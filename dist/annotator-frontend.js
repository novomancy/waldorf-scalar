(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
module.exports={
    "client_id": "scalar",
    "client_ver": "2.6",
    "native": "true",
    "id": "",
    "api_key": ""
}
},{}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AnnotationManager = void 0;

var _annotation = require("./annotation.js");

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var AnnotationManager = /*#__PURE__*/function () {
  function AnnotationManager() {
    _classCallCheck(this, AnnotationManager);

    this.annotations = [];
    this.onomyVocabulary = [];
  }

  _createClass(AnnotationManager, [{
    key: "PopulateFromJSON",
    value: function PopulateFromJSON(json) {
      if (json.length == 0) {
        console.warn("JSON contains no annotations.");
      }

      if ('undefined' == typeof json.items) {
        // Version 1
        var _iterator = _createForOfIteratorHelper(json),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var object = _step.value;
            this.RegisterAnnotation(object);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      } else {
        // Version 2
        var _iterator2 = _createForOfIteratorHelper(json.items[0].items),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _object = _step2.value;
            this.RegisterAnnotation(_object, JSON.parse(JSON.stringify(json.items[0])));
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
    }
  }, {
    key: "RegisterAnnotation",
    value: function RegisterAnnotation(jsonObject, canvasObject) {
      //console.log("Registering new annotation with ID " + jsonObject.id);
      var anno = new _annotation.Annotation(jsonObject, canvasObject);
      this.annotations.push(anno);
    }
  }, {
    key: "RemoveAnnotation",
    value: function RemoveAnnotation(id) {
      this.annotations = this.annotations.filter(function (obj) {
        if ('undefined' == typeof obj.items) {
          // Version 1
          return id !== obj.id;
        } else {
          // Version 2
          return id !== obj.items[0].items[0].items[0].id;
        }
      });
    }
    /**
     * Update the given annotation in the stored array
     */

  }, {
    key: "UpdateAnnotation",
    value: function UpdateAnnotation(annotation, oldID) {
      //console.log("Updating annotation ID " + oldID + " to " + annotation.metadata.id);
      this.RemoveAnnotation(oldID); //this.RegisterAnnotation(annotation);

      this.PopulateFromJSON(annotation);
    }
  }, {
    key: "AnnotationsAtTime",
    value: function AnnotationsAtTime(time) {
      // TODO: Reenable with some kind of force parameter
      // // If the last time requested is asked for again, just give back the cached result
      // if(timeMS == this.lastTimeRequested){
      //     //console.log("Using cache");
      //     return this.cached;
      // }
      // this.lastTimeRequested = timeMS;
      // Filter all loaded annotations that fit within the range query.
      var filtered = this.annotations.filter(function (item) {
        return item.beginTime <= time && time <= item.endTime;
      });
      this.cached = filtered;
      return filtered;
    }
  }, {
    key: "GetOnomyVocabulary",
    value: function GetOnomyVocabulary() {
      return this.onomyVocabulary;
    }
  }, {
    key: "UpdateOnomyVocabulary",
    value: function UpdateOnomyVocabulary(vocabulary) {
      this.onomyVocabulary = vocabulary;
    }
  }]);

  return AnnotationManager;
}();

exports.AnnotationManager = AnnotationManager;

},{"./annotation.js":3}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Annotation = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/// A wrapper for JSON objects.
var Annotation = /*#__PURE__*/function () {
  function Annotation() {
    var json = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var canvas = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck(this, Annotation);

    var version = "v2";

    if (json) {
      if ('undefined' == typeof json.items) {
        version = "v1";
      } else {
        version = "v2";
      }
    } // ver1


    if (version == "v1") {
      this["@context"] = "http://www.w3.org/ns/anno.jsonld";
      this["request"] = {
        "client_id": "scalar",
        "client_ver": "2.5.12",
        "items": {
          "native": false,
          "id": "__CHECK_CONFIG_FILE__ID__",
          "api_key": "__CHECK_CONFIG_FILE__API_KEY__",
          "action": "TOBEFILLED",
          "format": "json"
        }
      };
      this["type"] = "Annotation";
      this["motivation"] = "highlighting";
      this["body"] = [];
      this["target"] = {};
      this["annotation_version"] = "v1";
      this.readConfig(version);

      if (json) {
        Object.assign(this, json);
      }
    } else {
      // ver2 docs/webannotation_spec/sample_2.0.json
      this["@context"] = ["http://www.w3.org/ns/anno.jsonld", "http://iiif.io/api/presentation/3/context.json"];
      this["service"] = [{
        "client_id": "scalar",
        "client_ver": "2.5.12",
        "items": {
          "native": false,
          "id": "__CHECK_CONFIG_FILE__ID__",
          "api_key": "__CHECK_CONFIG_FILE__API_KEY__",
          "action": "TOBEFILLED",
          "format": "json"
        }
      }];
      this["type"] = "Manifest";
      this["items"] = [];

      if (canvas) {
        this["items"].push(canvas); // The "Canvas"

        this["items"][0].items = [json]; // The "AnnotationPage" + "Annotation"
      }

      this["annotation_version"] = "v2";
      this.readConfig(version);
    }

    if (json) {
      // Compute read only easy access properties
      this.recalculate();
    }
  }

  _createClass(Annotation, [{
    key: "readConfig",
    value: function readConfig(version) {
      var config = require("../annotator-config.json");

      if (version == "v1") {
        // ver1
        this["request"]["client_id"] = config.client_id;
        this["request"]["client_ver"] = config.client_ver;
        this["request"]["items"]["native"] = config["native"];
        this["request"]["items"]["id"] = config.id;
        this["request"]["items"]["api_key"] = config.api_key;
      } else {
        // ver2
        this["service"][0]["client_id"] = config.client_id;
        this["service"][0]["client_ver"] = config.client_ver;
        this["service"][0]["items"]["native"] = config["native"];
        this["service"][0]["items"]["id"] = config.id;
        this["service"][0]["items"]["api_key"] = config.api_key;
      }
    } /// Compute read only easy access properties

  }, {
    key: "recalculate",
    value: function recalculate() {
      console.log(this);

      if ('undefined' == typeof this.items) {
        // Version 1
        var timeSlice = this.target.selector.filter(function (item) {
          return item.type === "FragmentSelector";
        })[0].value;
      } else {
        // Version 2
        var timeSlice = this.items[0].items[0].items[0].target.selector.value;
      }

      timeSlice = timeSlice.replace('#t=npt:', 't=');
      timeSlice = timeSlice.replace("t=", ""); /// Start time in seconds

      this.beginTime = parseFloat(timeSlice.split(",")[0]); /// End time in seconds

      this.endTime = parseFloat(timeSlice.split(",")[1]);
      console.log('beginTime: ' + this.beginTime + ' endTime: ' + this.endTime); /// Extract tags from annotation

      if ('undefined' == typeof this.items) {
        // Version 1
        this.tags = this.body.filter(function (item) {
          return item.purpose === "tagging";
        }).map(function (item) {
          return item.value;
        });
      } else {
        // Version 2
        this.tags = [];

        for (var j = 0; j < this.items[0].items[0].items[0].body.length; j++) {
          if (this.items[0].items[0].items[0].body[j].purpose != 'tagging') continue;

          if ('undefined' != typeof this.items[0].items[0].items[0].body[j].value) {
            // Basic tag
            this.tags.push(this.items[0].items[0].items[0].body[j].value);
          } else if ('undefined' != typeof this.items[0].items[0].items[0].body[j].source) {
            // Onomy tag
            this.tags.push(this.items[0].items[0].items[0].body[j].source.label['en']); // TODO: english hard-coded here
          }
        }
      }

      console.log('Tags: ' + this.tags); // Start and end poly points

      this.polyStart = null;
      this.polyEnd = null;
      var pointsSelector = [];

      if ('undefined' == typeof this.items) {
        // Version 1
        pointsSelector = this.target.selector.filter(function (item) {
          return item.type === "SvgSelector";
        });
      } else {
        // Version 2
        pointsSelector = 'undefined' != typeof this.items[0].items[0].items[0].target.selector.refinedBy ? [this.items[0].items[0].items[0].target.selector.refinedBy] : [];
      }

      if (pointsSelector.length > 0) {
        var pointsSvg = pointsSelector[0].value;
        var regExString = new RegExp("(?:points=')(.*?)(?:')", "ig");
        var pointsRE = regExString.exec(pointsSvg)[1];
        var pointsData = pointsRE.trim().split(" ").map(function (item) {
          return item.split(",");
        });
        this.polyStart = pointsData;
        var parser = new DOMParser();
        var xmlDoc = parser.parseFromString(pointsSvg, "text/xml");

        if (xmlDoc.getElementsByTagName("animate").length) {
          // If there is no animation element, create an "animation" from the static points
          pointsRE = xmlDoc.getElementsByTagName("animate")[0].getAttribute("to");
          pointsData = pointsRE.trim().split(" ").map(function (item) {
            return item.split(",");
          });
          this.polyEnd = pointsData;
        }
      }

      console.log('polyStart: ');
      console.log(this.polyStart);
      console.log('polyEnd: ');
      console.log(this.polyEnd);
    }
  }, {
    key: "getPoly",
    value: function getPoly() {
      var pointsSelector = [];

      if ('undefined' == typeof this.items) {
        // Version 1
        pointsSelector = this.target.selector.filter(function (item) {
          return item.type === "SvgSelector";
        });
      } else {
        // Version 2
        pointsSelector = 'undefined' != typeof this.items[0].items[0].items[0].target.selector.refinedBy ? [this.items[0].items[0].items[0].target.selector.refinedBy] : [];
      }

      if (pointsSelector.length == 0) return null; // Parse the points array from the annotation

      var pointsSvg = pointsSelector[0].value;
      var regExString = new RegExp("(?:points=')(.*?)(?:')", "ig"); //set ig flag for global search and case insensitive

      var pointsRE = regExString.exec(pointsSvg)[1];
      var pointsData = pointsRE.trim().split(" ").map(function (item) {
        return item.split(",");
      });
      return pointsData;
    }
  }, {
    key: "getSVGPolyPoints",
    value: function getSVGPolyPoints() {
      var pointsSelector = [];

      if ('undefined' == typeof this.items) {
        // Version 1
        pointsSelector = this.target.selector.filter(function (item) {
          return item.type === "SvgSelector";
        });
      } else {
        // Version 2
        pointsSelector = 'undefined' != typeof this.items[0].items[0].items[0].target.selector.refinedBy ? [this.items[0].items[0].items[0].target.selector.refinedBy] : [];
      }

      if (pointsSelector.length == 0) return null; // Parse the points array from the annotation

      var pointsSvg = pointsSelector[0].value;
      var parser = new DOMParser();
      var xmlDoc = parser.parseFromString(pointsSvg, "text/xml");

      if (!xmlDoc.getElementsByTagName("animate").length) {
        // If there is no animation element, create an "animation" from the static points
        var points = this.getPoly();
        return [points, points];
      } else {
        return [xmlDoc.getElementsByTagName("animate")[0].getAttribute("from"), xmlDoc.getElementsByTagName("animate")[0].getAttribute("to")];
      }
    }
  }]);

  return Annotation;
}();

exports.Annotation = Annotation;

},{"../annotator-config.json":1}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VideoAnnotator = void 0;

var _serverInterface = require("./server-interface.js");

var _annotationManager = require("./annotation-manager.js");

var _tickBar = require("./components/tick-bar.js");

var _polygonOverlay = require("./components/polygon-overlay.js");

var _preferenceManager = require("../utils/preference-manager.js");

var _annotationGui = require("./components/annotation-gui.js");

var _infoContainer = require("./components/info-container.js");

var _indexContainer = require("./components/index-container.js");

var _sessionManager = require("./session-manager.js");

var _messageOverlay = require("./components/message-overlay.js");

var _annotation2 = require("./annotation.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var sha1 = require('sha1');

var VideoAnnotator = /*#__PURE__*/function () {
  function VideoAnnotator(args) {
    var _this = this;

    _classCallCheck(this, VideoAnnotator);

    console.log("[VideoAnnotator] Creating VideoAnnotator..."); //Parse arguments
    //This is actually required

    if (typeof args.player === 'undefined') {
      console.log('Called for a new VideoAnnotator without passing a player!');
      return false;
    }

    this.player = args.player; // Bring in the argument from the constructor
    //These config options are required for saving annotations to a server

    this.serverURL = typeof args.serverURL === 'undefined' ? '' : args.serverURL;
    this.tagsURL = typeof args.tagsURL === 'undefined' ? '' : args.tagsURL;
    this.apiKey = typeof args.apiKey === 'undefined' ? '' : args.apiKey; //If apiKey is set and cmsUsername and cmsEmail are passed, we'll auto login later

    this.cmsUsername = typeof args.cmsUsername === 'undefined' ? '' : args.cmsUsername;
    this.cmsEmail = typeof args.cmsEmail === 'undefined' ? '' : args.cmsEmail; //This config option is required for using a static annotation file

    this.localURL = typeof args.localURL === 'undefined' ? '' : args.localURL; //Optional params
    //Removes the editing interface

    this.kioskMode = typeof args.kioskMode === 'undefined' ? '' : args.kioskMode; //Shows the 'open manifest' button if kioskMode is off

    this.showManifest = typeof args.showManifest === 'undefined' ? false : args.showManifest; //Allows passing in a function that overrides the default annotation renderer

    this.renderer = typeof args.renderer === 'undefined' ? false : args.renderer; //Allows passing in a function that overrides the default annotation renderer

    this.unrenderer = typeof args.unrenderer === 'undefined' ? false : args.unrenderer; //Determines whether or not the annotation container is cleared every time it updates

    this.clearContainer = typeof args.clearContainer === 'undefined' ? true : args.clearContainer; //Determines whether or not to create a navigable index of annotations

    this.displayIndex = typeof args.displayIndex === 'undefined' ? false : args.displayIndex; //Determine the language of the annotation

    this.onomyLanguage = typeof args.onomyLanguage === 'undefined' ? '' : args.onomyLanguage;
    this.onomyVocabulary = []; //localURL implies kiosk mode

    if (this.localURL != '') this.kioskMode = true; //additional data from annotations collected from scalar to be added in API 2.0 

    this.contentLabel = "";
    this.artURL = "";
    this.annotationPageURL = "";
    this.Wrap();
    this.PopulateControls(); //may need to move this below the this.server block later?

    this.messageOverlay = new _messageOverlay.MessageOverlay(this);
    this.annotationManager = new _annotationManager.AnnotationManager();
    this.sessionManager = new _sessionManager.SessionManager(this); //load onomy vocabulary

    $.ajax(this.gui.GetTagsQuery()).done(function (vocabulary) {
      //console.log("OnomyVocabulary is loaded");
      var parsedVocabulary = _this.gui.OnomyVocabularProcess(vocabulary, _this.onomyLanguage);

      _this.annotationManager.UpdateOnomyVocabulary(parsedVocabulary);

      _this.onomyVocabulary = parsedVocabulary;
    }); //localURL takes precendence - if it is anything but '' then do not load from server

    if (this.localURL == '') {
      this.server = new _serverInterface.ServerInterface(this);
      this.server.SetBaseURL(this.serverURL); // Load annotations from server based on the player's video URL

      this.server.FetchAnnotations('location', this.player.videoElement.currentSrc).done(function (json) {
        if ('undefined' == typeof json.items) {
          // Version 1
          //json.shift()  // Assume first node is a content node
          for (var j = json.length - 1; j >= 0; j--) {
            if (json[j].type != "Annotation") {
              var annotation_info = json[j];
              _this.contentLabel = annotation_info["dcterms:title"];
              _this.artURL = annotation_info["art:url"];
              console.log(annotation_info["dcterms:title"]);
              json.splice(j, 1);
            } else {
              for (var k = 0; k < json[j].target.selector.length; k++) {
                if ('FragmentSelector' != json[j].target.selector[k].type) continue;
                json[j].target.selector[k].value = json[j].target.selector[k].value.replace('#t=npt:', 't=');
              }
            }
          }
        } else {
          // Version 2
          _this.contentLabel = json.label.en[0];
          _this.artURL = json.items[0].content.id;
          _this.annotationPageURL = json.items[0].items[0].items[0].id;
        }

        _this.annotationManager.PopulateFromJSON(json);

        _this.AnnotationsLoaded();
      }); //auto-login if not in kiosk mode, and we have the cms variables and API key

      if (!this.kioskMode) {
        if (this.apiKey && this.cmsEmail && this.cmsUsername) {
          this.server.LogOut();
          this.server.LogIn(this.cmsUsername, sha1(this.cmsEmail)).done(function () {
            console.log("[Main] CMS login success");
          }).fail(function () {
            console.log("[Main] CMS login failed");
          });
        }
      }
    } else {
      console.log('Loading local cache file: ' + this.localURL);
      $.ajax({
        url: this.localURL,
        type: "GET",
        dataType: "json",
        async: true
      }).done(function (data) {
        console.log("Fetched ".concat(data.length, " annotations from local cache."));
        var json = data;

        if ('undefined' == typeof json.items) {
          // Version 1
          //json.shift()  // Assume first node is a content node
          for (var j = json.length - 1; j >= 0; j--) {
            if (json[j].type != "Annotation") {
              var annotation_info = json[j];
              _this.contentLabel = annotation_info["dcterms:title"];
              _this.artURL = annotation_info["art:url"];
              console.log(annotation_info["dcterms:title"]);
              json.splice(j, 1);
            } else {
              for (var k = 0; k < json[j].target.selector.length; k++) {
                if ('FragmentSelector' != json[j].target.selector[k].type) continue;
                json[j].target.selector[k].value = json[j].target.selector[k].value.replace('#t=npt:', 't=');
              }
            }
          }
        } else {
          // Version 2
          _this.contentLabel = json.label.en[0];
          _this.artURL = json.items[0].content.id;
        }

        _this.annotationManager.PopulateFromJSON(data);

        _this.AnnotationsLoaded();
      }).fail(function (response) {
        console.log(response);
        console.error("Error fetching annotations from local cache\"\n".concat(response.responseJSON.detail, "."));

        _this.annotator.messageOverlay.ShowError("Could not retrieve annotations!<br>(".concat(response.responseJSON.detail, ")"));
      });
    }

    this.player.$container.on("OnTimeUpdate", function (event, time) {
      _this.OnTimeUpdate(time);
    });
    this.$container.on("OnPolyClicked", function (event, annotation) {
      // Edit a poly when clicked, but only if the editor isn't already open
      if (!_this.gui.open) {
        _this.$addAnnotationButton.button("disable");

        _this.gui.BeginEditing(annotation);
      }
    });
    this.$container.on("OnPolygonClicked", function (event, annotation) {
      console.log("OnPolygonClicked event captured");
    });
    this.$container.on("OnAnimationClicked", function (event, annotation) {
      console.log("OnAnimationClicked event captured");
    });
    this.gui.$container.on("OnGUIClosed", function (event) {
      _this.$addAnnotationButton.button("enable");
    });
    this.url = this.player.videoElement.currentSrc;
    console.log("[VideoAnnotator] Annotator created for video.");
  }

  _createClass(VideoAnnotator, [{
    key: "readConfig",
    value: function readConfig() {
      var config = require("../annotator-config.json");

      this.apiKey = config.api_key;
    }
    /**
     * Creates the divs that surround the video player.
     */

  }, {
    key: "Wrap",
    value: function Wrap() {
      // Wrap the video player with this container. Can't use .wrap due to duplication issues    
      var videoContainer = $(this.player.$container).parent();
      var waldorfContainer = $("<div class='waldorf-container'></div>");
      waldorfContainer.insertBefore($(this.player.$container));
      waldorfContainer.append(this.player.$container);
      this.$container = videoContainer.parent(); // Set the container to the width of the video player

      this.$container.width(this.player.$container.width()); // Allow the video player container to grow
      //this.player.$container.width("100%");
      //this.player.$container.height("100%");
      // Copy the video styles to the container
      // console.log(this.player.originalStyles);

      this.$container.css(this.player.originalStyles);
    }
  }, {
    key: "PopulateControls",
    value: function PopulateControls() {
      var _this2 = this;

      // Create the tick bar
      this.tickBar = new _tickBar.TickBar(this); // Create the polygon overlay

      this.polyOverlay = new _polygonOverlay.PolygonOverlay(this);

      if (!this.kioskMode && this.showManifest) {
        this.$debugControls = $("<div class='waldorf-debug-controls'></div>").appendTo(this.$container);
        var $showAllAnnotationsButton = this.$debugControls.append('<button>Open Annotation Manifest in New Window</button>');
        $showAllAnnotationsButton.click(function () {
          var url = _this2.player.videoElement.currentSrc;

          _this2.server.FetchAnnotations("location", url).done(function (json) {
            var win = window.open();

            if (win === null) {
              console.error("Couldn't show annotation manifest; please allow pop-ups.");

              _this2.messageOverlay.ShowError("Couldn't show annotation manifest; please allow pop-ups.");
            } else {
              win.document.open();
              win.document.write("<title>Annotation Manifest for ".concat(url, "</title>"));
              win.document.write("<pre>");
              win.document.write(JSON.stringify(json, null, 2).escapeHTML());
              win.document.write("</pre>");
              win.document.close();
            }
          });
        });
      } // Wrap all the buttons with the list tag
      //this.$debugControls.wrapInner("<ul></ul>");
      // Wrap each button with the list element tag
      //this.$debugControls.find("button").wrap("<li></li>");
      // Create the info container


      this.infoContainer = new _infoContainer.InfoContainer(this);
      if (this.displayIndex) this.indexContainer = new _indexContainer.IndexContainer(this); // Inject the annotation edit button into the toolbar

      if (!this.kioskMode) {
        this.$addAnnotationButton = $("<button>Add New Annotation</button>").button({
          icon: "fa fa-plus",
          showLabel: false
        }).click(function () {
          _this2.$addAnnotationButton.button("disable");

          _this2.gui.BeginEditing();
        });
        this.player.controlBar.RegisterElement(this.$addAnnotationButton, 3, 'flex-end'); // Inject the annotation upload button into the toolbar

        this.$uploadAnnotationButton = $("<button type='file'>Import Annotation From File</button>").button({
          icon: "fa fa-upload",
          showLabel: false
        }).click(function () {
          _this2.LoadFromFile();
        });
        this.player.controlBar.RegisterElement(this.$uploadAnnotationButton, 2, 'flex-end');
      }

      this.gui = new _annotationGui.AnnotationGUI(this);
    }
  }, {
    key: "AnnotationsLoaded",
    value: function AnnotationsLoaded() {
      //Send annotation loaded event
      this.$container.trigger("OnAnnotationsLoaded", this.annotationManager);
    }
  }, {
    key: "OnTimeUpdate",
    value: function OnTimeUpdate(time) {
      this.annotationsNow = this.annotationManager.AnnotationsAtTime(time);

      if (this.annotationsNow.equals(this.lastAnnotationSet)) {
        this.SetAnnotationTimePosition(time);
        return;
      }

      this.lastAnnotationSet = this.annotationsNow;
      this.UpdateViews();
    }
  }, {
    key: "SetAnnotationTimePosition",
    value: function SetAnnotationTimePosition(time) {
      //console.log("time: " + time);
      //Check safari and multiple geometric annotation
      if (this.IsSafari() && this.annotationsNow.length > 1) {
        var msg = "Multiple geometric annotations are detected.<br>";
        msg += "Safari doesn't support multiple geometric annotations.<br>";
        msg += "Chrome or Firefox are recommended.";
        this.messageOverlay.ShowMessage(msg, 2.0);
        return; //no animation for safari browser with multiple geometric annotation
      }

      for (var i = 0; i < this.annotationsNow.length; i++) {
        var annotation_id = this.annotationsNow[i].id;

        if (this.polyOverlay.svgElementsHash[annotation_id]) {
          this.polyOverlay.svgElementsHash[annotation_id].animate.beginElement();
          var time_diff = time - this.annotationsNow[i].beginTime;
          var current_time = this.polyOverlay.svgElementsHash[annotation_id].svgElement.getCurrentTime(); //console.log("\t i:" + i + " (" + annotation_id + "), svg current_time:" + current_time + ", animate time_diff: " + time_diff);

          this.polyOverlay.svgElementsHash[annotation_id].svgElement.setCurrentTime(current_time + time_diff);
          this.polyOverlay.svgElementsHash[annotation_id].animate.endElement();
        }
      }
    }
  }, {
    key: "UpdateViews",
    value: function UpdateViews() {
      //console.log("annotator.js:267 UpdateViews");
      this.annotationsNow = this.annotationManager.AnnotationsAtTime(this.player.videoElement.currentTime); // Update the info container

      this.infoContainer.Rebuild(this.annotationsNow, this.clearContainer);
      this.$container.trigger("OnNewAnnotationSet", [this.annotationsNow]);
      this.SetAnnotationTimePosition(this.player.videoElement.currentTime);
    }
  }, {
    key: "GetAnnotations",
    value: function GetAnnotations() {
      var ordered = this.annotationManager.annotations.slice();

      var orderByStart = function orderByStart(a, b) {
        var aTime = a.beginTime;
        var bTime = b.beginTime;
        return aTime < bTime ? -1 : aTime > bTime ? 1 : 0;
      };

      ordered.sort(orderByStart);
      return ordered;
    }
  }, {
    key: "RegisterNewAnnotation",
    value: function RegisterNewAnnotation(annotation) {
      //console.log(annotation);
      //this.annotationManager.RegisterAnnotation(annotation);
      this.annotationManager.PopulateFromJSON(annotation); // Throw event for listening objects (e.g. tick-bar)

      this.$container.trigger("OnAnnotationRegistered", [annotation]); // Update dependent views

      this.UpdateViews();
    }
  }, {
    key: "UpdateAnnotation",
    value: function UpdateAnnotation(annotation, oldID) {
      this.annotationManager.UpdateAnnotation(annotation, oldID); // Throw event for listening objects (e.g. tick-bar)

      this.$container.trigger("OnAnnotationRemoved", [oldID]);
      this.$container.trigger("OnAnnotationRegistered", [annotation]); // Update dependent views

      this.UpdateViews();
    }
  }, {
    key: "DeregisterAnnotation",
    value: function DeregisterAnnotation(annotation) {
      var id = '';

      if ('undefined' == typeof annotation.items) {
        // Ver 1
        id = annotation.id;
      } else {
        // Ver 2
        id = annotation.items[0].items[0].items[0].id;
      }

      this.annotationManager.RemoveAnnotation(id); //this.annotationsNow = this.annotationManager.AnnotationsAtTime(this.player.videoElement.currentTime);
      // Throw event for listening objects (e.g. tick-bar)

      this.$container.trigger("OnAnnotationRemoved", [id]); // Update dependent views

      this.UpdateViews();
    }
  }, {
    key: "LoadFromFile",
    value: function LoadFromFile() {
      var _this3 = this;

      // Create the dialog
      var $container = $("<div class='waldorf-session-modal' title='Import Annotation'></div>"); // Outermost HTML

      var $headText = $("<p class='validateTips'>Annotations must be W3C OA compliant in JSON format.</p>").appendTo($container);
      var $errorText = $("<p class='validateTips modal-error-text'></p>").appendTo($container);
      $errorText.hide();
      var $form = $("<form></form>").appendTo($container);
      var $importField;
      $("<label for='importFile'>Select File</label>").appendTo($form);
      $importField = $("<input type='file' name='importFile' class='file ui-widget-content ui-corner-all'>").appendTo($form);
      $form.wrapInner("<fieldset />");

      var error = function error(message) {
        console.error(message);
        $errorText.html(message);
        $errorText.show();
      };

      var self = this;
      $importField.on('change', function () {
        var files = $importField.get(0).files;
        var fr = new FileReader();

        fr.onload = function (localFile) {
          // If the JSON is malformed, show an error and stop here.
          try {
            JSON.parse(localFile.target.result);
          } catch (e) {
            error("JSON file is malformed!");
            return;
          }

          var localJson = JSON.parse(localFile.target.result);

          if (typeof localJson.target != "undefined") {
            var annotation = new _annotation2.Annotation(localJson);

            if (_this3.ValidateAnnotation(annotation)) {
              // Open the GUI and populate it with this annotation's data.
              _this3.gui.BeginEditing(annotation, true);

              _this3.gui.CommitAnnotationToServer(function () {
                return;
              });
            } else {
              error("JSON is invalid!");
            }
          } else {
            for (var i = 0; i < localJson.length; i++) {
              var _annotation = new _annotation2.Annotation(localJson[i]);

              if (_this3.ValidateAnnotation(_annotation)) {
                // Open the GUI and populate it with this annotation's data.
                _this3.gui.BeginEditing(_annotation, true);

                _this3.gui.CommitAnnotationToServer(function (annotation) {
                  _this3.RegisterNewAnnotation(annotation);

                  _this3.gui.Close();
                });
              } else {
                error("JSON is invalid!");
              }
            }
          }

          $dialog.dialog("close");
        };

        fr.readAsText(files[0]);
      });
      var $dialog = $container.dialog({
        autoOpen: true,
        draggable: false,
        modal: true,
        buttons: {
          Cancel: function Cancel() {
            $dialog.dialog("close");
          }
        },
        close: function close() {
          $dialog.find("form")[0].reset();
          $dialog.find("input").removeClass("ui-state-error"); //this.OnModalClose();
        }
      });
    }
  }, {
    key: "ValidateAnnotation",
    value: function ValidateAnnotation(annotation) {
      // TODO: Validate annotation here. Return false if any
      // required properties are not present.
      return true;
    } // checking whether the browser is safari or not

  }, {
    key: "IsSafari",
    value: function IsSafari() {
      //ref: https://stackoverflow.com/questions/49872111/detect-safari-and-stop-script
      var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      return isSafari;
    }
  }]);

  return VideoAnnotator;
}();

exports.VideoAnnotator = VideoAnnotator;

},{"../annotator-config.json":1,"../utils/preference-manager.js":19,"./annotation-manager.js":2,"./annotation.js":3,"./components/annotation-gui.js":5,"./components/index-container.js":6,"./components/info-container.js":7,"./components/message-overlay.js":8,"./components/polygon-overlay.js":10,"./components/tick-bar.js":11,"./server-interface.js":12,"./session-manager.js":13,"sha1":227}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AnnotationGUI = void 0;

var _time = require("../../utils/time.js");

var _polygonEditor = require("./polygon-editor.js");

var _annotation = require("../annotation.js");

var _types = require("@babel/types");

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var AnnotationGUI = /*#__PURE__*/function () {
  function AnnotationGUI(annotator) {
    var _this = this;

    _classCallCheck(this, AnnotationGUI);

    this.annotator = annotator;
    this.Create();
    this.open = false; //Hide the container

    this.isVisible = false;
    this.$container.makeVisible(false);
    this.polyEditor = new _polygonEditor.PolygonEditor(this.annotator);
    this.annotator.$container.on("OnPolygonEditingEnded", function () {
      _this.SetVisible(true);

      _this.polyEditor.ShowJustPolygon();
    });
  }

  _createClass(AnnotationGUI, [{
    key: "Create",
    value: function Create() {
      var _this2 = this;

      /*
       * //new UI
       * 
       */
      this.$container = $("<div id='create-dialog' class='ui-widget-content center'>").appendTo(this.annotator.player.$container);
      this.$container.draggable();
      this.$title = $("<div class='dialog-title'>Create Annotation</div>").appendTo(this.$container); // Make cancel button

      var $exitButton = $("<button>Exit Annotation Editing</button>").button({
        icons: {
          primary: 'fa fa-remove'
        },
        showLabel: false
      });
      $exitButton.css("float", "right");
      $exitButton.attr('title', "Exit annotation editing");
      $exitButton.addClass("waldorf-cancel-button");
      $exitButton.click(function () {
        _this2.polyEditor.ResetPolygons();

        _this2.Close();
      });
      this.RegisterElement($exitButton, this.$title, -1);
      this.$tabs = $("<div id='tabs'></div>").appendTo(this.$container);
      var $tabUI = $("<ul></ul>");
      var $startUI = $("<li><a href='#start_tab'>Start </a></li>");
      var $bodyUI = $("<li><a href='#body_tab'>Body </a></li>");
      var $stopUI = $("<li><a href='#stop_tab'>Stop </a></li>");
      this.RegisterElement($tabUI, this.$tabs, -1);
      this.RegisterElement($startUI, $tabUI, -1);
      this.RegisterElement($bodyUI, $tabUI, -1);
      this.RegisterElement($stopUI, $tabUI, -1); //Create tabs

      var $startTab = $("<div id='start_tab' class='ui-field-contain'></div>");
      this.RegisterElement($startTab, this.$tabs, -1);
      var $bodyTab = $("<div id='body_tab'></div>");
      this.RegisterElement($bodyTab, this.$tabs, -1);
      var $stopTab = $("<div id='stop_tab'></div>");
      this.RegisterElement($stopTab, this.$tabs, -1); //Begin filling start tab
      // Make "Start time" label and field

      this.$timeStartField = $('<input type="text" name="time-start" id="time-start" value=""><br><br>');
      this.$timeStartField.width(72);
      this.$timeStartField.css("font-family", "Courier, monospace");
      this.$timeStartField.css("margin-right", "2px");
      this.$timeStartField.addClass("ui-widget ui-widget-content ui-corner-all");
      this.$timeStartField.attr('title', "Start time (hh:mm:ss.ss)");
      this.$timeStartField.on('keypress', function (event) {
        if (event.keyCode == 46 || event.keyCode >= 48 && event.keyCode <= 58) {
          //0-9, period, and colon
          return true;
        }

        return false;
      }); //add start marker button

      this.$startTimeMarker = $("<button style='padding:0; line-height:1.4'>Set Start</button> ").button({
        icon: "fa fa-map-marker",
        showLabel: false
      }).click(function () {
        _this2.$timeStartField[0].value = (0, _time.GetFormattedTime)(_this2.annotator.player.videoElement.currentTime);
      });
      this.RegisterElement(this.$startTimeMarker, $startTab, -2);
      $("<label for='time-start'>Start Time: </label> ").appendTo($startTab);
      this.$timeStartField.appendTo($startTab); //Make "Edit polygon" button

      var $editPolyButton = $("<button style='padding:0; line-height:1.4'>Edit Polygon</button>").button({
        icon: "fa fa-pencil",
        showLabel: false
      }).click(function () {
        _this2.SetVisible(false); //console.log("annotation-gui:353 Create");


        _this2.polyEditor.BeginEditing('start');
      });
      $editPolyButton.attr('title', "Edit polygon");
      this.RegisterElement($editPolyButton, $startTab, -1);
      var $startTargetLabel = $("<label>Start Target</label> ");
      $startTargetLabel.css("color", "white");
      this.RegisterElement($startTargetLabel, $startTab, -1); //start point polygon is added (This seems to be unused? JPB 2021-09-16)
      // this.$startPolygonSet = $("<button style='padding:0; line-height:1.4'>Start Polygon Set</button>").button({
      //     icon: "fa fa-check-square-o",
      //     showLabel: false
      // });
      // //this.$startPolygonSet.css("visibility", "inherit");
      // this.$startPolygonSet.css("visibility", "hidden");
      // this.$startPolygonSet.addClass("waldorf-confirm-button");
      //this.RegisterElement(this.$startPolygonSet, $startTab, -2); 
      // Add tags input field

      this.$tagsField = $('<select class="form-control" multiple="multiple"></select>');
      this.$tagsField.width("100%");
      this.$tagsField.css("margin-top", "-8px");
      this.RegisterElement(this.$tagsField, $bodyTab, -1);
      this.$tagsField.select2({
        tags: true,
        placeholder: "Tags",
        ajax: this.GetTagsQuery(),
        selectOnBlur: true,
        // Allow manually entered text in drop down.
        createTag: function createTag(params) {
          return {
            id: params.term,
            text: params.term,
            newOption: true
          };
        }
      }); // Add custom class for bringing the dropdown to the front (fullscreen fix)

      this.$tagsField.data('select2').$dropdown.addClass("select2-dropdown-annotator"); // Make notes text field

      this.$textField = $('<textarea type="text" name="anno-text" id="anno-text" value="" placeholder="Notes">');
      this.$textField.css("margin-top", "2px");
      this.$textField.width("98.5%");
      this.$textField.addClass("ui-widget ui-widget-content ui-corner-all");
      this.$textField.attr('title', 'Annotation text');
      this.$textField.css("flex-grow", 2);
      this.RegisterElement(this.$textField, $bodyTab, -1); // Make "Stop time" label and field

      this.$timeEndField = $('<input type="text" name="time-stop" id="time-stop" value=""><br><br>');
      this.$timeEndField.width(72);
      this.$timeEndField.css("font-family", "Courier, monospace");
      this.$timeEndField.css("margin-right", "2px");
      this.$timeEndField.addClass("ui-widget ui-widget-content ui-corner-all");
      this.$timeEndField.attr('title', "Start time (hh:mm:ss.ss)");
      this.$timeEndField.on('keypress', function (event) {
        if (event.keyCode == 46 || event.keyCode >= 48 && event.keyCode <= 58) {
          //0-9, period, and colon
          return true;
        }

        return false;
      }); //add end marker button

      this.$endTimeMarker = $("<button style='padding:0; line-height:1.4'>Set End</button>").button({
        icon: "fa fa-map-marker",
        showLabel: false
      }).click(function () {
        _this2.$timeEndField[0].value = (0, _time.GetFormattedTime)(_this2.annotator.player.videoElement.currentTime);
      });
      this.RegisterElement(this.$endTimeMarker, $stopTab, -2);
      $("<label for='stop_time'>Stop Time: </label> ").appendTo($stopTab);
      this.$timeEndField.appendTo($stopTab); //Make "Edit polygon" button

      var $editStopPolyButton = $("<button style='padding:0; line-height:1.4'>Edit Polygon</button>").button({
        icon: "fa fa-pencil",
        showLabel: false
      }).click(function () {
        _this2.SetVisible(false); //console.log("annotation-gui:353 Create");


        _this2.polyEditor.BeginEditing('stop');
      });
      $editStopPolyButton.attr('title', "Edit polygon");
      this.RegisterElement($editStopPolyButton, $stopTab, -1);
      var $stopTargetLabel = $("<label>Stop Target</label> ");
      $stopTargetLabel.css("color", "white");
      this.RegisterElement($stopTargetLabel, $stopTab, -1); //stop point polygon is added

      this.$endPolygonSet = $("<button style='padding:0; line-height:1.4'>End Polygon Set</button>").button({
        icon: "fa fa-check-square-o",
        showLabel: false
      }); //this.$endPolygonSet.css("visibility", "inherit");

      this.$endPolygonSet.css("visibility", "hidden"); //this.$endPolygonSet.addClass("waldorf-confirm-button");
      //Add some error checking...

      this.$timeEndField.blur(function () {
        var e = $(_this2.$timeEndField).val();
        var s = $(_this2.$timeStartField).val();

        if ((0, _time.GetSecondsFromHMS)(s + 1) > (0, _time.GetSecondsFromHMS)(e)) {
          $(_this2.$timeEndField).val((0, _time.GetFormattedTime)((0, _time.GetSecondsFromHMS)(s) + .01));
        }
      });
      this.$timeStartField.blur(function () {
        var e = $(_this2.$timeEndField).val();
        var s = $(_this2.$timeStartField).val();

        if ((0, _time.GetSecondsFromHMS)(s + 1) > (0, _time.GetSecondsFromHMS)(e)) {
          $(_this2.$timeEndField).val((0, _time.GetFormattedTime)((0, _time.GetSecondsFromHMS)(s) + .01));
        }
      });
      this.RegisterElement(this.$endPolygonSet, $stopTab, -2);
      var $buttonPanel = $("<div class='button_panel'></div>").appendTo(this.$container); // Make delete button. This should only appear if we're editing, not if it's a new annotation

      this.$deleteButton = $("<button>Delete Annotation</button>").button({
        // icon: "fa fa-bomb",
        showLabel: true
      });
      this.$deleteButton.hide();
      this.$deleteButton.attr('title', "Delete annotation");
      this.$deleteButton.click(function () {
        _this2.annotator.server.DeleteAnnotation(_this2.originalAnnotation, function () {
          _this2.annotator.DeregisterAnnotation(_this2.originalAnnotation);

          _this2.Close();
        });
      });
      this.RegisterElement(this.$deleteButton, $buttonPanel, -1); // Make cancel button

      var $cancelButton = $("<br><br><button>Cancel</button>").button({
        showLabel: true
      }).click(function () {
        _this2.polyEditor.ResetPolygons();

        _this2.Close();
      });
      $cancelButton.css("float", "right");
      $cancelButton.attr('title', "Exit annotation editing"); //$cancel_button.addClass("waldorf-cancel-button");

      this.RegisterElement($cancelButton, $buttonPanel, -1); // Make save button

      var $saveButton = $("<button>Save</button>").button({
        showLabel: true
      }).click(function () {
        _this2.CommitAnnotationToServer(function (annotation, oldID) {
          if (_this2.editMode) {
            _this2.annotator.UpdateAnnotation(annotation, oldID);
          } else {
            _this2.annotator.RegisterNewAnnotation(annotation);
          }

          _this2.polyEditor.ResetPolygons();

          _this2.Close();
        });
      });
      $saveButton.css("float", "left");
      this.RegisterElement($saveButton, $buttonPanel, -1); //https://stackoverflow.com/questions/13837304/jquery-ui-non-ajax-tab-loading-whole-website-into-itself

      $('base').remove();
      this.$tabs.tabs().addClass('ui-tabs-vertical'); //let $script_section = $
      //this.$container.hide();
    }
  }, {
    key: "RegisterElement",
    value: function RegisterElement($element, $container, order) {
      var justification = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'flex-start';
      $element.css('order', order);
      $element.css('align-self', justification); // Sets grow [shrink] [basis]
      //$element.css('flex', '0 0 auto');

      $container.append($element);
    }
  }, {
    key: "SetVisible",
    value: function SetVisible(isVisible) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      //console.log(isVisible + " " + duration);
      if (isVisible) {
        this.$container.fadeTo(duration, 1.0);
        this.$container.makeVisible(true);
      } else {
        this.$container.stop(true, true);
        this.$container.fadeTo(duration, 0.0);
        this.$container.makeVisible(false);
      }

      this.isVisible = isVisible;
    }
  }, {
    key: "ToggleOpen",
    value: function ToggleOpen() {
      if (this.open) {
        this.Close();
      } else {
        this.Open();
      }
    }
  }, {
    key: "Open",
    value: function Open() {
      this.SetVisible(true);
      this.open = true;
      this.polyEditor.Done(); // Disable autofading when the gui is visible

      this.annotator.player.SetAutoFade(false);
    }
  }, {
    key: "Close",
    value: function Close() {
      this.SetVisible(false);
      this.open = false;
      this.polyEditor.Done(); // Re-enable autofading when the gui is hidden

      this.annotator.player.SetAutoFade(true);
      this.$container.trigger("OnGUIClosed");
    }
  }, {
    key: "ToggleVisible",
    value: function ToggleVisible() {
      this.SetVisible(!this.isVisible, 0);
    }
  }, {
    key: "BeginEditing",
    value: function BeginEditing() {
      var annotation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var forceNew = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      // Open the GUI if it isn't already
      this.Open(); // Populate data from the passed in annotation

      if (annotation || forceNew) {
        // Populate the fields from the annotation
        this.editMode = true; // Flip edit mode back to false if forceNew. We want to
        // populate from the entire passed in annotation, but treat
        // it as new.

        if (forceNew) this.editMode = false;
        this.originalAnnotation = annotation;
        console.log("Populated from an existing annotation");
        console.log(annotation);
        this.$timeStartField.val((0, _time.GetFormattedTime)(annotation.beginTime));
        this.$timeEndField.val((0, _time.GetFormattedTime)(annotation.endTime));

        if ('undefined' == typeof annotation.items) {
          // Version 1
          this.$textField.val(annotation.body.filter(function (item) {
            return item.purpose == "describing";
          })[0].value); // Version 1 doesn't have a this.id context
        } else {
          // Version 2
          this.$textField.val(annotation.items[0].items[0].items[0].body.filter(function (item) {
            return item.purpose == "describing";
          })[0].value);
          this.id = annotation.items[0].items[0].items[0].id;
        } // Reset the tags field


        this.$tagsField.val("").trigger("change");
        this.$tagsField.find("option").remove();

        var _iterator = _createForOfIteratorHelper(annotation.tags),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var tag = _step.value;
            this.$tagsField.append("<option value='" + tag + "' selected>" + tag + "</option>");
            this.$tagsField.trigger("change");
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        this.polyEditor.InitPoly(annotation.getPoly());
        this.polyEditor.ShowJustPolygon(); // Propagate the polygon editor's polygons array with polygons from the annotation

        this.polyEditor.$polygons = [];

        if (annotation.polyStart != null) {
          this.polyEditor.$polygons.push(annotation.polyStart);

          if (annotation.polyEnd != null) {
            this.polyEditor.$polygons.push(annotation.polyEnd);
          }
        }
      } // Insert template data if no annotation is given
      else {
          // Populate fields if no annotation is given
          this.editMode = false;
          this.originalAnnotation = null;
          console.log("Populated with template data");
          this.$timeStartField.val((0, _time.GetFormattedTime)(this.annotator.player.videoElement.currentTime));
          this.$timeEndField.val((0, _time.GetFormattedTime)(this.annotator.player.videoElement.duration));
          this.$textField.val(""); // Reset the tags field

          this.$tagsField.val("").trigger("change");
          this.$tagsField.find("option").remove();
          this.polyEditor.InitPoly();
        } // Modify GUI based on edit mode


      if (this.editMode) {
        this.$title.text("Edit Annotation");
        this.$deleteButton.button("enable");
      } else {
        this.$title.text("Create Annotation");
        this.$deleteButton.button("disable");
      }
    }
  }, {
    key: "CommitAnnotationToServer",
    value: function CommitAnnotationToServer(callback) {
      if (this.editMode) {
        console.log("Sending edited annotation to server...");
        this.annotator.server.EditAnnotation(callback);
      } else {
        console.log("Sending new annotation to server...");
        this.annotator.server.PostAnnotation(callback);
      }
    } // Build an object from the data.

  }, {
    key: "GetAnnotationObject",
    value: function GetAnnotationObject() {
      var annotation = new _annotation.Annotation();

      if ('undefined' == typeof annotation.items) {
        // Version 1
        annotation["body"] = this.BuildAnnotationBodyV1();
        annotation["target"] = this.BuildAnnotationTarget(true);
      } else {
        // Version 2
        annotation["label"] = {
          "en": [this.annotator.contentLabel]
        };
        annotation["items"] = this.BuildAnnotationItems();
      } // Recompute read-only access properties after all other properties have been set


      annotation.recalculate(); // Clone the object so we don't modify anything by changing this object

      var clone = JSON.parse(JSON.stringify(annotation));
      return clone;
    }
  }, {
    key: "BuildAnnotationItems",
    value: function BuildAnnotationItems() {
      var buildTime = new Date().toISOString(); //"2020-08-16T12:00:00Z"

      var videoDuration = this.annotator.player.videoElement.duration;
      var videoWidth = this.annotator.player.videoElement.videoWidth;
      var videoHeight = this.annotator.player.videoElement.videoHeight; // let videoDimension = this.annotator.player.GetVideoDimensions()
      // videoWidth = videoDimension.width;
      // videoHeight = videoDimension.height;

      var items = [{
        "id": this.annotator.url,
        //TODO: scalar specific url - should be supplied to plugin 
        "type": "Canvas",
        "height": videoHeight,
        "width": videoWidth,
        "duration": videoDuration,
        "content": {
          "id": this.annotator.url,
          "type": "Video",
          "height": videoHeight,
          "width": videoWidth,
          "duration": videoDuration,
          "label": {
            "en": this.annotator.contentLabel //"dcterms:title" from the annotation json file from scalar

          },
          "description": {
            "en": ""
          }
        },
        "items": [{
          "id": this.annotator.url,
          "type": "AnnotationPage",
          "generator": "http://github.com/anvc/scalar",
          "generated": buildTime,
          "items": [{
            "id": this.id,
            // URL to the annotation-page
            "type": "Annotation",
            "generator": "http://github.com/novomancy/waldorf-scalar",
            "motivation": "highlighting",
            "creator": this.BuildCreatorTemplate(),
            "created": buildTime,
            "rights": "https://creativecommons.org/licenses/by/4.0/",
            "body": this.BuildAnnotationBodyV2(),
            "target": this.BuildAnnotationTarget(false)
          }]
        }]
      }];
      return items;
    }
  }, {
    key: "BuildCreatorTemplate",
    value: function BuildCreatorTemplate() {
      return {
        "type": "Person",
        "nickname": localStorage.getItem('waldorf_user_name'),
        "email_sha1": localStorage.getItem('waldorf_user_email')
      };
    } //Build with tags entries from onomy

  }, {
    key: "BuildAnnotationBodyV2",
    value: function BuildAnnotationBodyV2() {
      var body = []; // Build text descriptor

      var bodyText = {
        "type": "TextualBody",
        "value": this.$textField.val(),
        "format": "text/plain",
        "language": "en",
        "purpose": "describing"
      };
      body.push(bodyText); // Build tag descriptors
      //let tags = this.$tagsField.select2("data").map((item) => { return item.text; });

      var selected_tags = this.$tagsField.select2("data").map(function (item) {
        return {
          id: item.id,
          text: item.text
        };
      });
      var onomy_map = this.annotator.annotationManager.onomyVocabulary.results.reduce(function (acc, curr) {
        acc[curr['id']] = curr;
        return acc;
      }, {});

      var _iterator2 = _createForOfIteratorHelper(selected_tags),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var tag = _step2.value;
          var onomy_ref = onomy_map[tag.id];
          var bodyTag = {};

          if (onomy_ref) {
            bodyTag = {
              "type": "SpecificResource",
              "purpose": "tagging",
              "source": {
                "id": onomy_ref.terms_id,
                "format": "application/json",
                "label": {
                  "en": onomy_ref.text
                },
                "description": {
                  "en": onomy_ref.comment
                }
              }
            };
          } else {
            bodyTag = {
              "type": "TextualBody",
              "purpose": "tagging",
              "value": tag.text
            };
          }

          body.push(bodyTag);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return body;
    }
  }, {
    key: "BuildAnnotationBodyV1",
    value: function BuildAnnotationBodyV1() {
      var body = []; // Build text descriptor

      var bodyText = {
        "type": "TextualBody",
        "value": this.$textField.val(),
        "format": "text/plain",
        "language": "en",
        "purpose": "describing"
      };
      body.push(bodyText); // Build tag descriptors

      var tags = this.$tagsField.select2("data").map(function (item) {
        return item.text;
      });

      var _iterator3 = _createForOfIteratorHelper(tags),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var tagStr = _step3.value;
          var bodyTag = {
            "type": "TextualBody",
            "purpose": "tagging",
            "value": tagStr
          };
          body.push(bodyTag);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      return body;
    } //used both v1 and v2

  }, {
    key: "BuildAnnotationTarget",
    value: function BuildAnnotationTarget(selectorsInArray) {
      if ('undefined' == typeof selectorsInArray) selectorsInArray = false;
      var target = {
        "id": this.annotator.url,
        // URL of the video
        "type": "Video"
      };
      var selectors = [];
      var safeEndTime = (0, _time.GetSecondsFromHMS)(this.$timeStartField.val());

      if ((0, _time.GetSecondsFromHMS)(this.$timeEndField.val()) > (0, _time.GetSecondsFromHMS)(this.$timeStartField.val())) {
        safeEndTime = (0, _time.GetSecondsFromHMS)(this.$timeEndField.val());
      }

      var startTime = (0, _time.GetSecondsFromHMS)(this.$timeStartField.val()); // Build time selector

      var timeSelector = {
        "type": "FragmentSelector",
        "conformsTo": "http://www.w3.org/TR/media-frags/",
        // See media fragment specification
        "value": "t=".concat(startTime, ",").concat(safeEndTime) // Time interval in seconds

      }; //Build SvgSelector

      if (typeof this.polyEditor.$vertices.start != 'undefined' && this.polyEditor.$vertices.start.length > 0) {
        var pointsStr = this.polyEditor.$vertices.start.map(function (item) {
          return "".concat(item[0], ",").concat(item[1]);
        }).join(" ");
        var value = "<svg viewBox='0 0 100 100' preserveAspectRatio='none'>";
        value += "<polygon points='" + pointsStr + "' />";

        if (this.polyEditor.IsAnimated()) {
          var animeStr = this.polyEditor.$vertices.stop.map(function (item) {
            return "".concat(item[0], ",").concat(item[1]);
          }).join(" ");
          value += "<animate attributeName='points' from='" + pointsStr + "' to='" + animeStr + "'";
          value += " start='" + startTime + "' end='" + safeEndTime + "' />";
        }

        value += "</svg>";
        var polygonSelector = {
          "type": "SvgSelector",
          "conformsTo": "http://www.w3.org/TR/SVG/",
          //added for v2
          "value": "".concat(value) // http://stackoverflow.com/a/24898728

        };

        if (selectorsInArray) {
          selectors.push(polygonSelector);
        } else {
          timeSelector["refinedBy"] = polygonSelector;
        }
      }

      if (selectorsInArray) {
        selectors.push(timeSelector);
        target["selector"] = selectors;
      } else {
        target["selector"] = timeSelector;
      }

      return target;
    }
  }, {
    key: "GetTagsQuery",
    value: function GetTagsQuery() {
      if (this.annotator.annotationManager != undefined && this.annotator.annotationManager.onomyVocabulary.length > 0) {
        return this.annotator.annotationManager.onomyVocabulary;
      }

      return {
        url: this.annotator.tagsURL,
        dataType: 'json',
        delay: 250,
        cache: true,
        onomyLanguage: this.annotator.onomyLanguage,
        annotationManager: this.annotator.annotationManager,
        parseFunction: this.OnomyVocabularProcess,
        processResults: function processResults(data) {
          return this.ajaxOptions.parseFunction(data, this.ajaxOptions.onomyLanguage);
        }
      };
    }
  }, {
    key: "OnomyVocabularProcess",
    value: function OnomyVocabularProcess(data, onomyLanguage) {
      // Parse the labels into the format expected by Select2
      // multilingual tags
      var multilingual_tags = [];
      var m_comments = {};
      var comments = {};
      var m_index = 1;
      var tags = [];
      var index = 1;

      var _iterator4 = _createForOfIteratorHelper(data["terms"]),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var term = _step4.value;
          //if onomyLanguage is defined collect multilingual tags
          var terms_id = term["rdfs:about"];
          var terms_comment = term["rdfs:comment"];

          if (onomyLanguage != '' && term['labels'] != undefined) {
            var t_label = "";
            var t_comment = ""; //get labels

            var _iterator5 = _createForOfIteratorHelper(term["labels"]),
                _step5;

            try {
              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                var label = _step5.value;
                var xml_lang = label["xml:lang"];
                var m_label = label["rdfs:label"];

                if (xml_lang == onomyLanguage && m_label && m_label.trim != "") {
                  t_label = m_label;
                }
              } //get comments

            } catch (err) {
              _iterator5.e(err);
            } finally {
              _iterator5.f();
            }

            var _iterator6 = _createForOfIteratorHelper(term['comments']),
                _step6;

            try {
              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                var _label = _step6.value;
                var _xml_lang = _label["xml:lang"];
                var m_comment = _label["rdfs:comments"]; //TODO: change to comment after fixing Onomy

                if (_xml_lang == onomyLanguage && m_comment) {
                  t_comment = m_comment;
                }
              } // use the term comment value if comment is blank

            } catch (err) {
              _iterator6.e(err);
            } finally {
              _iterator6.f();
            }

            if (t_comment == undefined || t_comment.trim == "") {
              t_comment = terms_comment;
            }

            multilingual_tags.push({
              id: m_index,
              text: t_label,
              terms_id: terms_id,
              comment: t_comment
            });
            m_index++;
          }

          tags.push({
            id: index,
            text: term["rdfs:label"],
            terms_id: term["rdfs:about"],
            comment: term["rdfs:comment"]
          });
          index++;
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      var return_tags = multilingual_tags;

      if (return_tags.length == 0) {
        return_tags = tags;
      } //console.log("return_tags");
      //console.log(return_tags);


      return {
        results: return_tags
      };
    }
  }]);

  return AnnotationGUI;
}();

exports.AnnotationGUI = AnnotationGUI;

},{"../../utils/time.js":22,"../annotation.js":3,"./polygon-editor.js":9,"@babel/types":72}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IndexContainer = void 0;

var _time = require("../../utils/time.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var sha1 = require('sha1');

var IndexContainer = /*#__PURE__*/function () {
  function IndexContainer(annotator) {
    var _this = this;

    _classCallCheck(this, IndexContainer);

    console.log("[Index Container] Creating annotation index");
    this.annotator = annotator;
    var container = $(".waldorf-index");

    if (container.length > 0) {
      this.$container = container.first();
    } else {
      this.$container = $("<div class='waldorf-index' aria-live='polite' role='navigation'></div>").appendTo(this.annotator.$container);
    }

    this.annotationList = $("<ul class='waldorf-annotation-list' role='menubar'></ul>").appendTo(this.$container); // Attach event handlers

    this.annotator.$container.on("OnAnnotationsLoaded", function (event, annotationManager) {
      return _this.Rebuild();
    });
    this.annotator.$container.on("OnAnnotationRegistered", function (event, annotation) {
      return _this.Rebuild();
    });
    this.annotator.$container.on("OnAnnotationRemoved", function (event, id) {
      return _this.Rebuild();
    });
  }

  _createClass(IndexContainer, [{
    key: "Rebuild",
    value: function Rebuild() {
      this.annotationList.empty(); // if(this.annotator.unrenderer) this.annotator.unrenderer(this.annotator);
      // let plural = annotations.length == 1 ? "" : "s";
      // let totalAnnotations = this.annotator.annotationManager.annotations.length;
      // this.$container.html(`<p>Showing ${annotations.length} annotation${plural} (${totalAnnotations} total).</p>`);
      // Add each annotation to the readout

      var ordered = this.annotator.GetAnnotations();

      for (var i = 0; i < ordered.length; i++) {
        this.annotationList.append(this.MakeContainer(this.annotator, ordered[i], i));
      }
    }
  }, {
    key: "MakeContainer",
    value: function MakeContainer(annotator, annotation) {
      //TODO: ARIA and general screen reader compatibility
      var $panel = $("<li role='presentation' data-creator=" + annotation.creator.email + " data-tags='" + annotation.tags.join(", ").replace("'", "%27") + "'></li>"); //let text = JSON.stringify(annotation.AsOpenAnnotation(), null, 2);

      var headerText = (0, _time.GetFormattedTime)(annotation.beginTime) + " - " + (0, _time.GetFormattedTime)(annotation.endTime); // Add clickable header that brings up the edit interface.

      var $header = $("<a href='' title='Go to Annotation' role='menuitem'>" + headerText + "</a><br>");
      $header.click(function (event) {
        event.preventDefault();
        annotator.player.videoElement.currentTime = annotation.beginTime; // if(annotator.player.videoElement.annotationTimeout) clearTimeout(annotator.player.videoElement.annotationTimeout);
        // annotator.player.videoElement.annotationTimeout = setTimeout(function(){
        //     annotator.player.videoElement.pause()}, (annotation.endTime-annotation.beginTime) * 1000
        // );
        //annotator.player.videoElement.src=annotator.url + "#t=" + annotation.beginTime +","+annotation.endTime;
        //annotator.player.videoElement.play();

        annotator.player.Play();
        annotator.player.endTime = annotation.endTime;

        if (annotation.beginTime + 1 > annotation.endTime) {
          annotator.player.Pause();
        }
      });
      $panel.append($header);
      var $content = $("<p></p>");
      $content.append("<b>Text: </b> " + annotation.body.filter(function (item) {
        return item.purpose === "describing";
      })[0].value);
      $content.append("<br>");
      $content.append("<b>Tags: </b> " + annotation.tags.join(", "));
      $content.append("<br>");
      $panel.append($content);
      $panel.appendTo(annotator.$annotationList); // console.log($panel);

      return $panel;
    }
  }]);

  return IndexContainer;
}();

exports.IndexContainer = IndexContainer;

},{"../../utils/time.js":22,"sha1":227}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InfoContainer = void 0;

var _time = require("../../utils/time.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var sha1 = require('sha1');

var InfoContainer = /*#__PURE__*/function () {
  function InfoContainer(annotator) {
    _classCallCheck(this, InfoContainer);

    this.annotator = annotator;
    var container = $(".waldorf-info");

    if (container.length > 0) {
      this.$container = container.first();
    } else {
      this.$container = $("<div class='waldorf-info' aria-live='polite' aria-atomic='true'></div>").appendTo(this.annotator.$container);
    }
  }

  _createClass(InfoContainer, [{
    key: "Rebuild",
    value: function Rebuild(annotations, clearContainer) {
      if (clearContainer) this.$container.empty();
      if (this.annotator.unrenderer) this.annotator.unrenderer(this.annotator); // let plural = annotations.length == 1 ? "" : "s";
      // let totalAnnotations = this.annotator.annotationManager.annotations.length;
      // this.$container.html(`<p>Showing ${annotations.length} annotation${plural} (${totalAnnotations} total).</p>`);
      // Add each annotation to the readout

      var renderer = this.annotator.renderer === false ? this.MakeContainer : this.annotator.renderer;

      for (var i = 0; i < annotations.length; i++) {
        this.$container.append(renderer(this.annotator, annotations[i], i));
      }
    }
  }, {
    key: "MakeContainer",
    value: function MakeContainer(annotator, annotation, index) {
      var $panel = $("<p></p>").appendTo($("<div></div>").appendTo(annotator.$container)); //let text = JSON.stringify(annotation.AsOpenAnnotation(), null, 2);
      // Add clickable header that brings up the edit interface.

      var $header = $("<b>Annotation ".concat(index + 1, ":</b><br>"));

      if (annotator.kioskMode == false) {
        $header = $("<a href='' title='Edit Annotation'><b>Annotation ".concat(index + 1, ":</b><br></a>"));
        $header.click(function (event) {
          event.preventDefault();
          annotator.gui.BeginEditing(annotation);
        });
      }

      $panel.append($header);
      var $content = $("<p></p>");

      if ('undefined' == typeof annotation.items) {
        // Version 1
        var annotation_body = annotation.body.filter(function (item) {
          return item.purpose === "describing";
        })[0];
        var annotation_creator = annotation.creator != null ? annotation.creator : {};
      } else {
        // Version 2
        var annotation_body = annotation.items[0].items[0].items[0].body.filter(function (item) {
          return item.purpose === "describing";
        })[0];
        var annotation_creator = annotation.items[0].items[0].items[0].creator;
      }

      $content.append("<b>Text: </b> " + annotation_body.value);
      $content.append("<br>");
      $content.append("<b>Tags: </b> " + annotation.tags.join(", "));
      $content.append("<br>");
      $content.append("<b>Time: </b> " + (0, _time.GetFormattedTime)(annotation.beginTime) + " - " + (0, _time.GetFormattedTime)(annotation.endTime));
      $content.append("<br>");
      $content.append("<b>Submitter:</b> " + ('undefined' != typeof annotation_creator.nickname && annotation_creator.nickname.length ? annotation_creator.nickname : "<i>Not available</i>")); //$paragraph.append("<strong>Annotation " + (index + 1) + ":</strong><br><pre>" + text.escapeHTML() + "</pre>");

      $panel.append($content);
      return $panel;
    }
  }]);

  return InfoContainer;
}();

exports.InfoContainer = InfoContainer;

},{"../../utils/time.js":22,"sha1":227}],8:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MessageOverlay = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var MessageOverlay = /*#__PURE__*/function () {
  function MessageOverlay(annotator) {
    _classCallCheck(this, MessageOverlay);

    this.annotator = annotator;
    this.$container = $("<div class='waldorf-message-overlay'></div>");
    this.$container.appendTo(this.annotator.player.$container);
    this.$text = $("<p role='alert' aria-live='assertive' aria-atomic='true'></p>").appendTo(this.$container);
    this.$container.fadeOut(0);
  }

  _createClass(MessageOverlay, [{
    key: "ShowError",
    value: function ShowError(message) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3.0;
      this.$container.addClass("waldorf-message-overlay-error");

      this._ShowText(message, duration);
    }
  }, {
    key: "ShowMessage",
    value: function ShowMessage(message) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5.0;
      this.$container.removeClass("waldorf-message-overlay-error");

      this._ShowText(message, duration);
    }
  }, {
    key: "_ShowText",
    value: function _ShowText(message) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5.0;
      this.$text.html(message); //this.$container.stop(true, true);

      this.$container.finish();
      this.$container.fadeIn(0).delay(duration * 1000).fadeOut(400);
    }
  }]);

  return MessageOverlay;
}();

exports.MessageOverlay = MessageOverlay;

},{}],9:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PolygonEditor = void 0;

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Manages the creating or editing of a single polygon on the video.
 * Consists of a toolbar, an overlay, and the polygon inside the overlay.
 *
 * Click to place or remove a draggable point. Points should be
 * put down in clockwise order.
 */
var PolygonEditor = /*#__PURE__*/function () {
  function PolygonEditor(annotator) {
    var _this = this;

    _classCallCheck(this, PolygonEditor);

    this.annotator = annotator;
    this.baseZ = 2147483649;
    this.$breadcrumbs = [];
    this.$vertices = {
      'start': [],
      'stop': []
    }; //arrays of vertices for start/stop polys

    this.$polygons = {
      'start': null,
      'stop': null
    }; //DOM nodes for the actual polygons
    // this.$tempBreadCrumbs = [];

    this.$startStop = null; // Create the video overlay

    this.$clickSurface = $("<div class='waldorf-edit-overlay waldorf-vp-click-surface'></div>").appendTo(this.annotator.player.$container); //this.$clickSurface.css("z-index", this.baseZ);

    this.$clickSurface.click(function (event) {
      _this.OnSurfaceClick(event);
    }); // Initialize the polygon DOM nodes

    this.$polygons.start = $("<div class='waldorf-start-poly'></div>").appendTo(this.$clickSurface);
    this.$polygons.start.css("z-index", this.baseZ + 1);
    this.$polygons.stop = $("<div class='waldorf-stop-poly'></div>").appendTo(this.$clickSurface);
    this.$polygons.stop.css("z-index", this.baseZ + 1);
    this.ResizeOverlay();
    this.annotator.player.$container.on("OnFullscreenChange", function (event, setFullscreen) {
      return _this.ResizeOverlay();
    }); // Create the toolbar up top
    // this.$bar = $("<div class='waldorf-vp-post'></div>").appendTo(this.annotator.player.$container);
    // this.$postToolbar = $("<div class='flex-toolbar'></div>").appendTo(this.$bar);
    // Invisible expanding divider
    //-3//this.$postToolbar.append($("<div><p style='color:white'>Edit Polygon</p></div>").css("flex-grow", 1).css("order", 0));
    // Make "Collect Polygon state" button
    // this.$capPolyButton = $("<button>Capture Polygon</button>").button({
    //     icon: "fa fa-camera-retro",
    //     showLabel: false
    // }).click(() => {
    //     //this.SetVisible(false);
    //     //this.GetPoints();
    //     // Build polygon selector
    //     // let points = this.GetPoints();
    //     // if(points.length > 0) {
    //     //     let pointsStr = points.map(item => { return `${item[0]},${item[1]}` }).join(" ");
    //     //     let polygonSelector = {
    //     //         "type": "SvgSelector",
    //     //         "value": `<svg:svg viewBox='0 0 100 100' preserveAspectRatio='none'><polygon points='${pointsStr}' /></svg:svg>` // http://stackoverflow.com/a/24898728
    //     //     }
    //     //     tmpSelectors.push(polygonSelector);
    //     // }
    //     // console.log("tmpSelectors");
    //     // console.log(tmpSelectors);
    //     this.annotator.AddPolygonSet(this.annotator.annotation.getPoly());
    // });
    // this.$capPolyButton.css("margin-right", "15px");
    // this.$capPolyButton.attr('title', "Capture polygon");
    //-3//this.RegisterElement(this.$capPolyButton, this.$postToolbar, 1, 'flex-end');
    // Create undo button
    // this.$undoButton = $("<button>Remove Last Point</button>").button({
    //     icon: "fa fa-undo",
    //     showLabel: false
    // });
    // this.$undoButton.css("margin-right", "15px");
    // this.$undoButton.attr('title', "Remove last point");
    // this.$undoButton.click(() => {
    //     this.RemoveLastBreadcrumb();
    // });
    //-3//this.RegisterElement(this.$undoButton, this.$postToolbar, 1, 'flex-end');
    // Create the confirm button
    // this.$confirmButton = $("<button>Finish polygon</button>").button({
    //     icon: "fa fa-check",
    //     showLabel: false
    // });
    // this.$confirmButton.attr('title', "Finish polygon");
    // this.$confirmButton.addClass("waldorf-confirm-button");
    // this.$confirmButton.click(() => {
    //     this.originalJSON = this.GetJSON();
    //     this.Done();
    //     this.annotator.$container.trigger("OnPolygonEditingEnded");
    // });
    // //-3//this.RegisterElement(this.$confirmButton, this.$postToolbar, 3, 'flex-end');
    // // Create the cancel button
    // this.$cancelButton = $("<button>Stop polygon editing</button>").button({
    //     icon: "fa fa-remove",
    //     showLabel: false
    // });
    // this.$cancelButton.addClass("waldorf-cancel-button");
    // this.$cancelButton.attr('title', "Stop polygon editing");
    // this.$cancelButton.click(() => {
    //     //Restore the original state
    //     this.Restore();
    //     this.Done();
    //     this.annotator.$container.trigger("OnPolygonEditingEnded");
    // });
    // //-3//this.RegisterElement(this.$cancelButton, this.$postToolbar, 2, 'flex-end');
    // $(window).resize(() => this.ResizeOverlay());

    /* 
    * new UI
    */

    this.$editDialog = $("<div id='edit-dialog' class='waldorf-edit-overlay waldorf-vp-click-surface'></div>").appendTo(this.annotator.player.$container);
    this.$editDialog.draggable();
    this.$editDialog.css('z-index', this.baseZ + 100);
    this.$editDialog.click(function (event) {
      _this.OnSurfaceClick(event);
    });
    this.$space = $("<div>&nbsp;</div><hr>");
    this.RegisterElement(this.$space, this.$editDialog, 1, 'flex-end'); // Create undo button

    this.$undoButton = $("<button>Remove Last Point</button>").button({
      icon: "fa fa-undo",
      showLabel: false
    });
    this.$undoButton.css("margin", "0px 5px 4px 5px");
    this.$undoButton.attr('title', "Remove last point");
    this.$undoButton.css('z-index', this.baseZ + 105);
    this.$undoButton.click(function () {
      _this.RemoveLastBreadcrumb();
    });
    this.RegisterElement(this.$undoButton, this.$editDialog, 1, 'flex-end'); // Make "Collect Polygon state" button

    this.$capPolyButton = $("<button>Capture Polygon</button>").button({
      icon: "fa fa-camera-retro",
      showLabel: false
    }).click(function () {
      _this.AddPolygonSet();
    });
    this.$capPolyButton.css("margin", "0px 5px 4px 5px");
    this.$capPolyButton.attr('title', "Capture Polygon");
    this.$capPolyButton.css('z-index', this.baseZ + 105);
    this.RegisterElement(this.$capPolyButton, this.$editDialog, 1, 'flex-end'); // Create the cancel button

    this.$cancelButton = $("<button>Stop polygon editing</button>").button({
      icon: "fa fa-remove",
      showLabel: false
    });
    this.$cancelButton.css("margin", "0px 5px 4px 5px");
    this.$cancelButton.addClass("waldorf-cancel-button");
    this.$cancelButton.attr('title', "Stop Polygon Editing");
    this.$cancelButton.click(function () {
      //Restore the original state
      //this.Restore();
      _this.RemoveAllBreadcrumbs();

      _this.annotator.$container.trigger("OnPolygonEditingEnded");

      _this.Done();
    });
    this.RegisterElement(this.$cancelButton, this.$editDialog, 2, 'flex-end');
    $(window).resize(function () {
      return _this.ResizeOverlay();
    });
    this.Done();
  }

  _createClass(PolygonEditor, [{
    key: "OnSurfaceClick",
    value: function OnSurfaceClick(event) {
      if ($(event.currentTarget).attr("id") == "edit-dialog" || this.$startStop != "start") {
        return;
      } // Add a breadcrumb on click, but only for the start polygon. End vertices can only be dragged


      var target = $(event.currentTarget);
      var x = event.pageX - target.offset().left;
      var y = event.pageY - target.offset().top;
      var xPercent = x / target.width() * 100;
      var yPercent = y / target.height() * 100;
      this.AddBreadcrumb(xPercent, yPercent); //this.newPolyPoints.push([xPercent.toFixed(3), yPercent.toFixed(3)]);

      this.UpdatePolyClipping();
    }
    /**
     * Creates a new breadcrumb at the given (x, y) point on the
     * clickSurface, where x and y are percentages from 0 to 100.
     */

  }, {
    key: "AddBreadcrumb",
    value: function AddBreadcrumb(xPercent, yPercent) {
      var _this2 = this;

      var $breadcrumb = $("<div class='breadcrumb'></div>");
      $breadcrumb.appendTo(this.$clickSurface);
      $breadcrumb.css("position", "absolute"); // Percentage representations of breadcrumb width and height

      var offPercentX = $breadcrumb.outerWidth() / this.$clickSurface.width() * 100;
      var offPercentY = $breadcrumb.outerHeight() / this.$clickSurface.height() * 100; // Percentage representations of breadcrumb width and height

      $breadcrumb.css("left", (xPercent - offPercentX / 2).toString() + "%");
      $breadcrumb.css("top", (yPercent - offPercentY / 2).toString() + "%"); //$breadcrumb.css("z-index", this.baseZ - 50);

      $breadcrumb.draggable({
        //containment: "parent",
        drag: function drag() {
          // Recalculate percentages (mangled by jQuery UI draggable code)
          // See http://stackoverflow.com/a/23673462
          var l = 100 * parseFloat($breadcrumb.css("left")) / parseFloat($breadcrumb.parent().css("width")) + "%";
          var t = 100 * parseFloat($breadcrumb.css("top")) / parseFloat($breadcrumb.parent().css("height")) + "%";
          $breadcrumb.css("left", l);
          $breadcrumb.css("top", t);

          _this2.UpdatePolyClipping();
        }
      });

      if (this.$startStop == "start") {
        //breadcrumbs can only be added or removed in the first polygon
        $breadcrumb.click(function (event) {
          // Remove the breadcrumb on click
          event.stopPropagation();
          $breadcrumb.remove();

          _this2.$breadcrumbs.splice(_this2.$breadcrumbs.indexOf($breadcrumb), 1);

          _this2.UpdatePolyClipping();

          _this2.UpdateBreadcrumbColoring();
        });
      }

      this.$breadcrumbs.push($breadcrumb); //this.UpdatePolyClipping();

      this.UpdateBreadcrumbColoring();
    }
    /**
     * Removes the last-placed breadcrumb from the list
     * and updates the view.
     */

  }, {
    key: "RemoveLastBreadcrumb",
    value: function RemoveLastBreadcrumb() {
      var $removed = this.$breadcrumbs.pop();
      $removed.remove();
      this.UpdatePolyClipping();
      this.UpdateBreadcrumbColoring();
    }
  }, {
    key: "RemoveAllBreadcrumbs",
    value: function RemoveAllBreadcrumbs() {
      console.log("Removing all breadcrumbs");

      while (this.$breadcrumbs.length > 0) {
        this.RemoveLastBreadcrumb();
      }
    }
    /**
     * Gets the center of the breadcrumb as an (x, y) pair
     * representing the percentage distance from the top and left
     * of the click surface (0% - 100%).
     */

  }, {
    key: "GetCenterPercentage",
    value: function GetCenterPercentage($breadcrumb) {
      var topPercent = $breadcrumb.position().top / $breadcrumb.parent().height() * 100;
      var leftPercent = $breadcrumb.position().left / $breadcrumb.parent().width() * 100; // Percentage values for the dimensions of the breadcrumb relative to the click surface

      var offPercentX = $breadcrumb.outerWidth() / $breadcrumb.parent().width() * 100;
      var offPercentY = $breadcrumb.outerHeight() / $breadcrumb.parent().height() * 100;
      return {
        x: leftPercent + offPercentX / 2.0,
        y: topPercent + offPercentY / 2.0
      };
    }
  }, {
    key: "Reset",
    value: function Reset() {
      // Remove all breadcrumbs
      var _iterator = _createForOfIteratorHelper(this.$breadcrumbs),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var $breadcrumb = _step.value;
          $breadcrumb.remove();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      this.$breadcrumbs = []; // Remove the poly if it already exists
      // if(this.$poly != null){
      //     this.$poly.remove();
      // }
    }
  }, {
    key: "ResetPolygons",
    value: function ResetPolygons() {
      console.log("resetting polygons");

      if (this.$polygons.start) {
        console.log("reset start poly");
        this.$polygons.start.makeVisible(false);
        this.$polygons.start.css("clip-path", "");
      }

      if (this.$polygons.stop) {
        this.$polygons.stop.makeVisible(false);
        this.$polygons.stop.css("clip-path", "");
      }

      this.$vertices = {
        'start': [],
        'stop': []
      };
      this.UpdatePolyClipping();
      this.RemoveAllBreadcrumbs();
    }
  }, {
    key: "Restore",
    value: function Restore() {
      this.InitPoly(this.originalJSON);
    }
  }, {
    key: "InitPoly",
    value: function InitPoly() {
      var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      this.Reset(); // If JSON was specified, generate breadcrumbs from it.

      if (points != null) {
        // Put down the breadcrumbs
        var _iterator2 = _createForOfIteratorHelper(points),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var point = _step2.value;
            this.AddBreadcrumb(point[0], point[1]);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }

      this.UpdatePolyClipping();
      this.originalJSON = points;
    }
  }, {
    key: "DrawPolygons",
    value: function DrawPolygons() {
      var _this3 = this;

      this.RemoveAllBreadcrumbs();

      if (this.$vertices.start != []) {
        //let startPolygon = this.$vertices.start; //.map(item => { return `${item[0]},${item[1]}` }).join(" ");;
        // Create the poly objects
        // this.$polygons.start = $("<div class='waldorf-start-poly'></div>").appendTo(this.$clickSurface);
        // this.$polygons.start.css("z-index", this.baseZ + 1000);
        if (this.$vertices.start.length < 3) {
          this.$polygons.start.makeVisible(false);
          this.$polygons.start.clipPath([], {
            svgDefId: 'annotatorStartPolySvg'
          });
        } else {
          this.$polygons.start.makeVisible(true);
          this.$polygons.start.clipPath(this.$vertices.start, {
            isPercentage: true,
            svgDefId: 'annotatorStartPolySvg'
          });

          if (this.$startStop == "start") {
            this.$vertices.start.map(function (point) {
              _this3.AddBreadcrumb(point[0], point[1]);
            });
          }
        }
      }

      if (this.$vertices.stop != []) {
        // this.$stopPoly.remove();
        // this.$stopPoly = $("<div class='waldorf-stop-poly'></div>").appendTo(this.$clickSurface);
        // this.$stopPoly.css("z-index", this.baseZ + 1000);
        if (this.$vertices.stop.length < 3) {
          this.$polygons.stop.clipPath([], {
            svgDefId: 'annotatorStopPolySvg'
          });
        } else {
          this.$polygons.stop.clipPath(this.$vertices.stop, {
            isPercentage: true,
            svgDefId: 'annotatorStopPolySvg'
          });

          if (this.$startStop == "stop") {
            this.$vertices.stop.map(function (point) {
              _this3.AddBreadcrumb(point[0], point[1]);
            });
          }
        }
      }
    }
  }, {
    key: "UpdatePolyClipping",
    value: function UpdatePolyClipping() {
      var _this4 = this;

      if (this.$startStop == null) return;
      var svgId = this.$startStop == "start" ? "annotatorStartPolySvg" : "annotatorStopPolySvg";

      if (this.$breadcrumbs.length < 3) {
        this.$polygons[this.$startStop].makeVisible(false);
        this.$polygons[this.$startStop].clipPath([], {
          svgDefId: svgId
        });
      } else {
        var points = this.$breadcrumbs.map(function ($crumb) {
          var pos = _this4.GetCenterPercentage($crumb);

          return [pos.x, pos.y];
        });
        this.$polygons[this.$startStop].makeVisible(true);
        this.$polygons[this.$startStop].clipPath(points, {
          isPercentage: true,
          svgDefId: svgId
        });
      }
    }
  }, {
    key: "UpdateBreadcrumbColoring",
    value: function UpdateBreadcrumbColoring() {
      for (var i = 0; i < this.$breadcrumbs.length; i++) {
        var $crumb = this.$breadcrumbs[i]; // Recolor each breadcrumb

        var color = "#000000";

        if (i == this.$breadcrumbs.length - 1) {
          color = "#FF0000";
        } else if (i == 0) {
          color = "#00FF00";
        }

        this.$breadcrumbs[i].css("border-color", color);
      }
    }
    /**
     * Gets an array of percentages representing the x and y percentages of each
     * point in the polygon.
     */

  }, {
    key: "GetJSON",
    value: function GetJSON() {
      // Extract the coordinates from the crumbs and put them in the array
      var points = [];

      var _iterator3 = _createForOfIteratorHelper(this.$breadcrumbs),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var crumb = _step3.value;
          var point = this.GetCenterPercentage(crumb);
          points.push([point.x.toString(), point.y.toString()]);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      return JSON.stringify(points);
    }
    /**
     * Gets an array of percentages representing the x and y percentages of each
     * point in the polygon.
     */

  }, {
    key: "GetPoints",
    value: function GetPoints() {
      var points = [];

      var _iterator4 = _createForOfIteratorHelper(this.$breadcrumbs),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var crumb = _step4.value;
          var point = this.GetCenterPercentage(crumb);
          points.push([point.x, point.y]);
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      return points;
    }
    /**
     * Determines if all start vertices match stop vertices
     * returns true if the vertices don't match exactly
     */

  }, {
    key: "IsAnimated",
    value: function IsAnimated() {
      var comp = this.$vertices.start;
      var startString = JSON.stringify(comp);
      comp = this.$vertices.stop;
      var stopString = JSON.stringify(comp);
      return JSON.stringify(startString) != JSON.stringify(stopString);
    }
  }, {
    key: "BeginEditing",
    value: function BeginEditing(startStop) {
      this.$startStop = startStop; //startStop is either 'start' or 'stop', depending on which polygon is being edited

      this.$clickSurface.makeVisible(true);
      this.$editDialog.makeVisible(true);
      this.$polygons.start.makeVisible(true);
      this.$polygons.stop.makeVisible(true); //-3//this.$bar.makeVisible(true);

      this.DrawPolygons();
      this.UpdatePolyClipping();
    }
  }, {
    key: "Done",
    value: function Done() {
      this.$clickSurface.makeVisible(false);
      this.$editDialog.makeVisible(false);
      this.$polygons.start.makeVisible(false);
      this.$polygons.stop.makeVisible(false); //-3//this.$bar.makeVisible(false);
    }
  }, {
    key: "ResizeOverlay",
    value: function ResizeOverlay() {
      // Resize video overlay to fit actual video dimensions
      var videoDims = this.annotator.player.GetVideoDimensions();
      this.$clickSurface.css('width', videoDims.width);
      this.$clickSurface.css('height', videoDims.height);
      var heightDiff = (this.annotator.player.$video.height() - videoDims.height) / 2;
      this.$clickSurface.css('top', heightDiff);
      var widthDiff = (this.annotator.player.$video.width() - videoDims.width) / 2;
      this.$clickSurface.css('left', widthDiff);
      this.$polygons.start.width(videoDims.width);
      this.$polygons.start.height(videoDims.height);
      this.$polygons.start.css("top", heightDiff);
      this.$polygons.start.css("left", widthDiff);
      this.$polygons.start.css("position", "absolute");
      this.$polygons.start.makeVisible(false);
      this.$polygons.stop.width(videoDims.width);
      this.$polygons.stop.height(videoDims.height);
      this.$polygons.stop.css("top", heightDiff);
      this.$polygons.stop.css("left", widthDiff);
      this.$polygons.stop.css("position", "absolute");
      this.$polygons.stop.makeVisible(false);
    }
  }, {
    key: "RegisterElement",
    value: function RegisterElement($element, $container, order) {
      var justification = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'flex-start';
      $element.css('order', order);
      $element.css('align-self', justification); // Sets grow [shrink] [basis]
      //$element.css('flex', '0 0 auto');

      $container.append($element);
    }
  }, {
    key: "ShowJustPolygon",
    value: function ShowJustPolygon() {
      this.$polygons.start.makeVisible(true);
      this.$polygons.stop.makeVisible(true);
    }
  }, {
    key: "AddPolygonSet",
    value: function AddPolygonSet() {
      //This is saving a set of breadcrumbs into the vertices for a polygon
      this.$vertices[this.$startStop] = this.GetPoints();

      if (this.$startStop == "start" && this.$vertices.stop.length != this.$vertices.start.length) {
        this.$vertices.stop = this.GetPoints();
      }

      this.RemoveAllBreadcrumbs();
      this.annotator.messageOverlay.ShowMessage("Captured " + this.$startStop + " polygon."); // if (this.$vertices.length > 1) {
      //     this.$polygons = [];
      //     this.$tempBreadCrumbs = [];
      // }
      // if (!this.$polygons.length) {
      //     this.$polygons.start = this.GetPoints();
      //     this.$tempBreadCrumbs[0] = [this.$breadcrumbs];
      //     var msg = "Successfully captured first polygon.";
      // } else {
      //     this.$polygons.stop = this.GetPoints();
      //     this.$tempBreadCrumbs[1] = [this.$breadcrumbs];
      //     var msg = "Successfully captured second polygon.";
      // } 

      this.annotator.$container.trigger("OnPolygonEditingEnded");
      this.Done();
    }
  }]);

  return PolygonEditor;
}();

exports.PolygonEditor = PolygonEditor;

},{}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PolygonOverlay = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var PolygonOverlay = /*#__PURE__*/function () {
  function PolygonOverlay(annotator) {
    var _this = this;

    _classCallCheck(this, PolygonOverlay);

    this.annotator = annotator;
    this.polyElements = [];
    this.svgElements = [];
    this.animateElements = [];
    this.baseZ = 2147483649;
    this.lastAnnotations = [];
    this.svgElementsHash = {}; // Create the video overlay

    this.$videoOverlay = $("<div class='waldorf-video-overlay'></div>").appendTo(this.annotator.player.$container);
    this.ResizeOverlay();
    this.annotator.player.$container.on("OnFullscreenChange", function (event, setFullscreen) {
      return _this.ResizeOverlay();
    });
    this.annotator.$container.on("OnNewAnnotationSet", function (event, annotations) {
      return _this.Update(annotations);
    });
    this.videoDims = this.annotator.player.GetVideoDimensions();
    $(window).resize(function () {
      return _this.ResizeOverlay();
    });
  }

  _createClass(PolygonOverlay, [{
    key: "Update",
    value: function Update(annotations) {
      this.Clear(); // let prevSet = new Set(this.lastAnnotations);
      // let newSet = new Set(annotations);
      // // in newSet and not in prevSet
      // let toAdd = new Set(
      //     [...newSet].filter(x => !prevSet.has(x)));
      // // in prevAnnotations and not in annotations
      // let toDestroy = new Set(
      //     [...prevSet].filter(x => !newSet.has(x)));
      // console.log(Array.from(toAdd));
      // console.log(Array.from(toDestroy));
      //Sort polygon order by size (ascending)
      // polygons.sort(function(a, b) {
      //     return this.GetArea(a) > this.GetArea(b);
      // })

      for (var i = 0; i < annotations.length; i++) {
        var annotationPolyPoints = annotations[i].getPoly();

        if (annotationPolyPoints == null) {
          // Ignore this annotation if it has no polygon
          continue;
        }

        var svgPolyPoints = annotations[i].getSVGPolyPoints();
        var duration = annotations[i].endTime - annotations[i].beginTime; // Create the poly object

        var $svg = void 0;

        if (this.svgElements.length == 0) {
          $svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
          $svg.setAttribute('width', '100%');
          $svg.setAttribute('height', '100%');
          $svg.setAttribute('viewBox', '0 0 100 100');
          $svg.setAttribute('preserveAspectRatio', 'none'); //$svg.addEventListener("click", this.ClickEvent);

          this.$videoOverlay.append($svg);
          this.svgElements.push($svg);
        } else {
          $svg = this.svgElements[0];
        }

        var $polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        $polygon.setAttribute('points', svgPolyPoints[0]);
        $polygon.setAttribute('fill', 'rgba(0, 118, 255, 0.55)');
        $svg.appendChild($polygon);
        var $animate = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
        $animate.setAttribute('attributeName', 'points');
        $animate.setAttribute('fill', 'freeze');
        $animate.setAttribute('from', svgPolyPoints[0]);
        $animate.setAttribute('to', svgPolyPoints[1]);
        $animate.setAttribute('begin', 'indefinite');
        $animate.setAttribute('dur', duration + "s");
        $polygon.appendChild($animate);
        var $svgHash = {
          svgElement: $svg,
          polygon: $polygon,
          animate: $animate,
          beginTime: annotations[i].beginTime
        };
        this.svgElementsHash[annotations[i].id] = $svgHash; // Create the poly object
        // let $poly = $("<div class='waldorf-overlay-poly'></div>").appendTo(this.$videoOverlay);
        // $poly.clipPath(annotationPolyPoints, {
        //     isPercentage: true,
        //     svgDefId: 'annotatorPolySvg'
        // });
        // $poly.click(() => {
        //     this.annotator.$container.trigger("OnPolyClicked", annotations[i]);
        // });
        // this.AddTooltip($poly, annotations[i]);
        // this.polyElements.push($poly);

        this.polyElements.push($polygon);
        this.animateElements.push($animate);
      } //this.lastAnnotations = annotations;

    }
  }, {
    key: "ClickEvent",
    value: function ClickEvent(event) {
      console.log("animate is clicked");
    }
  }, {
    key: "AddTooltip",
    value: function AddTooltip($poly, annotation) {
      $.fn.qtip.zindex = this.baseZ + 1;
      $poly.qtip({
        content: {
          title: annotation.id,
          text: annotation.body.filter(function (item) {
            return item.purpose === "describing";
          })[0].value
        },
        position: {
          my: 'bottom right',
          at: 'top left',
          target: 'mouse',
          // Follow the mouse
          adjust: {
            mouse: true,
            method: "shift shift" // horizontal, vertical

          },
          viewport: this.annotator.player.$container
        },
        hide: {
          delay: 0 // No hide delay by default

        },
        style: {
          classes: 'qtip-dark qtip-rounded annotator-qtip'
        }
      });
    }
  }, {
    key: "Clear",
    value: function Clear() {
      // Clear all  animate element from the DOM
      for (var ai = 0; ai < this.animateElements.length; ai++) {
        //this.polyElements[i].data("qtip").destroy(true);
        this.animateElements[ai].remove();
      } // Clear all polygons 


      for (var pi = 0; pi < this.polyElements.length; pi++) {
        this.polyElements[pi].remove();
      } // Clear all  svg elements from the DOM


      for (var si = 0; si < this.svgElements.length; si++) {
        this.svgElements[si].remove();
      } // Mark the array as empty


      this.animateElements = [];
      this.polyElements = [];
      this.svgElements = [];
      this.svgElementsHash = {};
    }
  }, {
    key: "ResizeOverlay",
    value: function ResizeOverlay() {
      // Resize video overlay to fit actual video dimensions
      var videoDims = this.annotator.player.GetVideoDimensions();
      this.$videoOverlay.css('width', videoDims.width);
      this.$videoOverlay.css('height', videoDims.height);
      var heightDiff = (this.annotator.player.$video.height() - videoDims.height) / 2;
      this.$videoOverlay.css('top', heightDiff);
      var widthDiff = (this.annotator.player.$video.width() - videoDims.width) / 2;
      this.$videoOverlay.css('left', widthDiff);
    }
  }, {
    key: "getPlayerSize",
    value: function getPlayerSize() {
      return this.annotator.player.GetVideoDimensions();
    }
  }]);

  return PolygonOverlay;
}();

exports.PolygonOverlay = PolygonOverlay;

},{}],11:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TickBar = void 0;

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var TickBar = /*#__PURE__*/function () {
  function TickBar(annotator) {
    var _this = this;

    _classCallCheck(this, TickBar);

    this.annotator = annotator;
    this.ticks = []; // Create the element

    this.$tickBar = $("<div class='waldorf-tickbar'></div>");
    this.annotator.player.controlBar.$container.append(this.$tickBar); // Attach event handlers

    this.annotator.$container.on("OnAnnotationsLoaded", function (event, annotationManager) {
      return _this.LoadAnnotations(annotationManager);
    });
    this.annotator.$container.on("OnAnnotationRegistered", function (event, annotation) {
      return _this.LoadAnnotation(annotation);
    });
    this.annotator.$container.on("OnAnnotationRemoved", function (event, id) {
      return _this.RemoveAnnotation(id);
    });
  }

  _createClass(TickBar, [{
    key: "LoadAnnotations",
    value: function LoadAnnotations(annotationManager) {
      this.Clear();

      var _iterator = _createForOfIteratorHelper(annotationManager.annotations),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var annotation = _step.value;
          this.LoadAnnotation(annotation);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "LoadAnnotation",
    value: function LoadAnnotation(annotation) {
      var $tick = $("<div class='waldorf-tickbar-tick'></div>").appendTo(this.$tickBar); // Add the ID of the annotation to its corresponding tick so we can reference it later

      if ('undefined' == typeof annotation.items) {
        // Ver 1
        $tick.data("annotation-id", annotation.id);
      } else {
        // Ver 2
        $tick.data("annotation-id", annotation.items[0].items[0].items[0].id);
      }

      var beginTime = annotation.beginTime;
      var beginPercent = beginTime / this.annotator.player.videoElement.duration;
      $tick.css('left', (beginPercent * 100).toString() + "%");
      var endTime = annotation.endTime;
      var endPercent = endTime / this.annotator.player.videoElement.duration;
      $tick.css('width', ((endPercent - beginPercent) * 100).toString() + "%");
      this.ticks.push($tick);
    }
  }, {
    key: "RemoveAnnotation",
    value: function RemoveAnnotation(id) {
      //console.log("Removing tick " + id);
      // Remove the object from the document, and the array
      var newTicks = [];

      var _iterator2 = _createForOfIteratorHelper(this.ticks),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var $tick = _step2.value;
          console.log('Tick: ' + $tick.data("annotation-id"));

          if ($tick.data("annotation-id") == id) {
            console.log("Removed tick ".concat(id));
            $tick.remove();
          } else {
            newTicks.push($tick);
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      this.ticks = newTicks;
    }
  }, {
    key: "Clear",
    value: function Clear() {
      var _iterator3 = _createForOfIteratorHelper(this.ticks),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var $tick = _step3.value;
          $tick.remove();
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      this.ticks = [];
    }
  }]);

  return TickBar;
}();

exports.TickBar = TickBar;

},{}],12:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ServerInterface = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var sha1 = require('sha1');

var ServerInterface = /*#__PURE__*/function () {
  function ServerInterface(annotator) {
    _classCallCheck(this, ServerInterface);

    this.annotator = annotator; //localStorage.removeItem('waldorf_auth_token');
  }

  _createClass(ServerInterface, [{
    key: "SetBaseURL",
    value: function SetBaseURL(url) {
      this.baseURL = url;
    }
  }, {
    key: "make_base_auth",
    value: function make_base_auth(user, password) {
      var tok = user + ':' + password;
      var hash = btoa(tok);
      return 'Basic ' + hash;
    }
  }, {
    key: "make_write_auth",
    value: function make_write_auth(text) {
      if (this.annotator.apiKey) {
        return 'ApiKey ' + text;
      } else {
        return 'Token ' + text;
      }
    }
  }, {
    key: "LoggedIn",
    value: function LoggedIn() {
      if (this.annotator.apiKey) {
        // Return true if an email has been entered
        var user_email = localStorage.getItem('waldorf_user_email');
        return user_email !== null;
      } else {
        // Return true if a token has been registered
        var auth_token = localStorage.getItem('waldorf_auth_token');
        return auth_token !== null;
      }
    }
  }, {
    key: "LogIn",
    value: function LogIn(username, password) {
      var _this = this;

      // If API key is used, just store the email address
      if (this.annotator.apiKey) {
        console.log("[Server Interface] Successfully logged in.");
        localStorage.setItem('waldorf_user_email', password);
        localStorage.setItem('waldorf_user_name', username);
        this.annotator.messageOverlay.ShowMessage("Logged in as " + username);
        return $.Deferred().resolve();
      }

      return $.ajax({
        url: this.baseURL + "/api/login",
        type: "POST",
        async: true,
        context: this,
        beforeSend: function beforeSend(xhr) {
          xhr.setRequestHeader('Authorization', this.make_base_auth(username, password));
        }
      }).done(function (data) {
        console.log("[Server Interface] Successfully logged in.");
        localStorage.setItem('waldorf_auth_token', data.auth_token);
      }).fail(function (response) {
        console.error("[Server Interface] Could not log in.");

        _this.annotator.messageOverlay.ShowError("Could not log in!");
      });
    }
  }, {
    key: "LogOut",
    value: function LogOut() {
      // If API key is used, just remove the email from local storage.
      if (this.annotator.apiKey) {
        console.log("[Server Interface] Successfully logged out.");
        localStorage.removeItem('waldorf_user_email');
        localStorage.removeItem('waldorf_user_name');
        return $.Deferred().resolve();
      }

      return $.ajax({
        url: this.baseURL + "/api/logout",
        type: "DELETE",
        async: true,
        context: this,
        beforeSend: function beforeSend(xhr) {
          var auth_token = localStorage.getItem('waldorf_auth_token') || "";
          console.log("[Server Interface] token: ".concat(auth_token));
          xhr.setRequestHeader('Authorization', this.make_write_auth(auth_token));
        }
      }).done(function (data) {
        console.log("[Server Interface] Successfully logged out.");
        localStorage.removeItem('waldorf_auth_token');
      }).fail(function (response) {
        console.error("[Server Interface] Could not log out.");
        localStorage.removeItem('waldorf_auth_token');
      });
    }
  }, {
    key: "FetchAnnotations",
    value: function FetchAnnotations(searchKey, searchParam) {
      //This is replaced by this.baseURL, which is defined in config
      //var book_url = 'http://scalar.usc.edu/dev/semantic-annotation-tool/';  // This will be defined in the Book's JS
      //https://scalar.usc.edu/dev/semantic-annotation-tool/rdf/file/media/Inception%20Corgi%20Flop.mp4?format=oac&prov=1&rec=2
      // var ajax_url = this.baseURL + 'rdf/file/' + searchParam.replace(this.baseURL, '') + '?format=oac&prov=1&rec=2';
      var ajax_url = this.baseURL + 'rdf/file/' + searchParam.replace(this.baseURL, '') + '?format=iiif&prov=1&rec=2'; //console.log("ajax_url: " + ajax_url);

      return $.ajax({
        url: ajax_url,
        type: "GET",
        jsonp: "callback",
        dataType: "jsonp",
        async: true
      }).done(function (data) {
        console.log('[Server Interface] Fetched ' + ('undefined' == typeof data.items ? data.length - 1 : data.items[0].items.length) + ' annotations for ' + searchKey + ': "' + searchParam + '".');
      }).fail(function (response) {
        var returned_response = response.responseJSON.error.code[0].value + " : " + response.responseJSON.error.message[0].value;
        console.error('[Server Interface] Error fetching annotations for ' + searchKey + ': "' + searchParam + '"\n ' + returned_response);

        _this2.annotator.messageOverlay.ShowError('Could not retrieve annotations!<br>(' + returned_response + ')');
      });
    }
  }, {
    key: "PostAnnotation",
    value: function PostAnnotation(callback) {
      var _this3 = this;

      console.log("Posting annotation...");
      var annotation = this.annotator.gui.GetAnnotationObject();
      console.log(annotation);
      var key;

      if (this.annotator.apiKey) {
        key = this.annotator.apiKey;
        var email_storage = localStorage.getItem('waldorf_user_email');
        var name_storage = localStorage.getItem('waldorf_user_name');
        if (name_storage == null) name_storage = email_storage;
      } else {
        key = localStorage.getItem('waldorf_auth_token');
      }

      if (this.annotator.apiKey) {
        if (annotation["creator"] == null) annotation["creator"] = {};
        annotation["creator"]["email"] = localStorage.getItem('waldorf_user_email');
        annotation["creator"]["nickname"] = localStorage.getItem('waldorf_user_name');
      }

      if (annotation["annotation_version"] == "v1") {
        annotation["request"]["items"]["action"] = "add";
        delete annotation["items"];
      } else {
        annotation["service"][0]["items"]["action"] = "add";
        delete annotation["target"];
        delete annotation["body"];
      }

      delete annotation["annotation_version"];
      annotation["id"] = this.baseURL + "api/add";
      console.log("PostAnnotation payload: " + JSON.stringify(annotation));
      $.ajax({
        //url: this.baseURL + "/api/addAnnotation",
        url: this.baseURL + "api/add",
        type: "POST",
        dataType: 'json',
        // Necessary for Rails to see this data type correctly
        contentType: 'application/json',
        // Necessary for Rails to see this data type correctly
        data: JSON.stringify(annotation),
        // Stringify necessary for Rails to see this data type correctly
        async: true,
        context: this,
        beforeSend: function beforeSend(xhr) {
          xhr.setRequestHeader('Authorization', this.make_write_auth(key));
        },
        success: function success(data) {
          console.log("Successfully posted new annotation.");

          _this3.annotator.messageOverlay.ShowMessage("Successfully created new annotation.");

          annotation.id = data.id; // Append the ID given by the response

          if (callback) callback(annotation);
        },
        error: function error(response) {
          var returned_response = "undefined error while editing the annotation";

          if (response.responseJSON) {
            returned_response = response.responseJSON.error.code[0].value + " : " + response.responseJSON.error.message[0].value;
          }

          console.error("Could not edit the annotation! Message:\n ".concat(returned_response));

          _this3.annotator.messageOverlay.ShowError("Could not edit the annotation!<br>(".concat(returned_response, ")"));
        }
      });
    }
  }, {
    key: "EditAnnotation",
    value: function EditAnnotation(callback) {
      var _this4 = this;

      console.log("Editing annotation...");
      var annotation = this.annotator.gui.GetAnnotationObject();
      console.log(annotation);
      var key;

      if (this.annotator.apiKey) {
        key = this.annotator.apiKey;
        var email_storage = localStorage.getItem('waldorf_user_email');
        var name_storage = localStorage.getItem('waldorf_user_name');
        if (name_storage == null) name_storage = email_storage;
      } else {
        key = localStorage.getItem('waldorf_auth_token');
      }

      if (this.annotator.apiKey) {
        if (annotation["creator"] == null) annotation["creator"] = {};
        annotation["creator"]["email"] = localStorage.getItem('waldorf_user_email');
        annotation["creator"]["nickname"] = localStorage.getItem('waldorf_user_name');
      }

      if (annotation["annotation_version"] == "v1") {
        annotation["request"]["items"]["action"] = "update";
        delete annotation["items"];
      } else {
        annotation["service"][0]["items"]["action"] = "update";
        delete annotation["target"];
        delete annotation["body"];
      }

      delete annotation["annotation_version"];
      var oldID = '';

      if ('undefined' == typeof annotation.items) {
        // Version 1
        oldID = annotation.id;
      } else {
        // Version 2
        oldID = annotation.items[0].items[0].items[0].id;
      }

      console.log("Modifying annotation: " + oldID);
      $.ajax({
        url: this.baseURL + "api/update",
        type: "POST",
        dataType: 'json',
        contentType: 'application/json',
        data: JSON.stringify(annotation),
        async: true,
        context: this,
        beforeSend: function beforeSend(xhr) {
          xhr.setRequestHeader('Authorization', this.make_write_auth(key));
        },
        success: function success(data) {
          //console.log(annotation);
          annotation.id = data.id; // Append the ID given by the response
          //console.log("Successfully edited the annotation. (ID is now " + data.id + ")");

          _this4.annotator.messageOverlay.ShowMessage("Successfully edited the anotation.");

          if (callback) callback(annotation, oldID);
        },
        error: function error(response) {
          //console.error(`Could not edit the annotation! Message:\n ${response.responseJSON.detail}`);
          //this.annotator.messageOverlay.ShowError(`Could not edit the annotation!<br>(${response.responseJSON.detail})`);
          var returned_response = "undefined error while editing the annotation";

          if (response.responseJSON) {
            returned_response = response.responseJSON.error.code[0].value + " : " + response.responseJSON.error.message[0].value;
          }

          console.error("Could not edit the annotation! Message:\n ".concat(returned_response));

          _this4.annotator.messageOverlay.ShowError("Could not edit the annotation!<br>(".concat(returned_response, ")"));
        }
      });
    }
  }, {
    key: "DeleteAnnotation",
    value: function DeleteAnnotation(annotation, callback) {
      var _this5 = this;

      if (!confirm('Are you sure you wish to delete this annotation?')) {
        return;
      }

      var key;

      if (this.annotator.apiKey) {
        key = this.annotator.apiKey;
        var email_storage = localStorage.getItem('waldorf_user_email');
        var name_storage = localStorage.getItem('waldorf_user_name');
        if (name_storage == null) name_storage = email_storage;
      } else {
        key = localStorage.getItem('waldorf_auth_token');
      }

      if (this.annotator.apiKey) {
        if (annotation["creator"] == null) annotation["creator"] = {};
        annotation["creator"]["email"] = localStorage.getItem('waldorf_user_email');
        annotation["creator"]["nickname"] = localStorage.getItem('waldorf_user_name');
      }

      if (annotation["annotation_version"] == "v1") {
        annotation["request"]["items"]["action"] = "update";
        delete annotation["items"];
      } else {
        annotation["service"][0]["items"]["action"] = "update";
        delete annotation["target"];
        delete annotation["body"];
      }

      delete annotation["annotation_version"];
      var oldID = '';

      if ('undefined' == typeof annotation.items) {
        // Version 1
        oldID = annotation.id;
      } else {
        // Version 2
        oldID = annotation.items[0].items[0].items[0].id;
      }

      console.log("Deleting annotation: " + oldID);

      if ('undefined' == typeof annotation.items) {
        // Version 1
        var del_data = {
          "scalar:urn": "urn:scalar:version:" + annotation.id,
          "native": annotation.request.items["native"],
          "action": "DELETE",
          "api_key": annotation.request.items.api_key,
          "id": annotation.request.items.id
        };
        return $.post(this.baseURL + "api/delete", del_data, function (response) {
          {
            console.log("Delete error response");
            console.log(response);
            console.log(response.responseText);
          }
        }).done(function (response) {
          console.log("Successfully deleted the annotation.");

          _this5.annotator.messageOverlay.ShowMessage("Successfully deleted the annotation.");

          if (callback) callback(annotation, oldID);
        }).fail(function (response) {
          var returned_response = "undefined failure while deleting the annotation";

          if (response.responseJSON) {
            response.responseJSON.error.code[0].value + " : " + response.responseJSON.error.message[0].value;
          }

          console.error("Could not delete the annotation. Message:\n ".concat(returned_response));

          _this5.annotator.messageOverlay.ShowError("Could not delete the annotation!<br>(".concat(returned_response, ")"));
        });
      } else {
        // Version 2
        annotation["service"][0]["items"]["action"] = "delete";
        delete annotation["target"];
        delete annotation["body"];
        delete annotation["annotation_version"];
        $.ajax({
          url: this.baseURL + "api/delete",
          type: "POST",
          dataType: 'json',
          contentType: 'application/json',
          data: JSON.stringify(annotation),
          async: true,
          context: this,
          beforeSend: function beforeSend(xhr) {
            xhr.setRequestHeader('Authorization', this.make_write_auth(key));
          },
          success: function success(data) {
            _this5.annotator.messageOverlay.ShowMessage("Successfully deleted the anotation.");

            if (callback) callback(annotation, oldID);
          },
          error: function error(response) {
            var returned_response = "undefined error while deleting the annotation";

            if (response.responseJSON) {
              returned_response = response.responseJSON.error.code[0].value + " : " + response.responseJSON.error.message[0].value;
            }

            console.error("Could not delete the annotation! Message:\n ".concat(returned_response));

            _this5.annotator.messageOverlay.ShowError("Could not delete the annotation!<br>(".concat(returned_response, ")"));
          }
        });
      }
    }
  }]);

  return ServerInterface;
}();

exports.ServerInterface = ServerInterface;

},{"sha1":227}],13:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SessionManager = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var sha1 = require('sha1');
/**
 * Manages the user session for communicating with the backend.
 */


var SessionManager = /*#__PURE__*/function () {
  function SessionManager(annotator) {
    var _this = this;

    _classCallCheck(this, SessionManager);

    console.log("[Session Manager] Creating SessionManager...");
    this.annotator = annotator;
    this.modalOpen = false; // Inject the button for logging in/out into the toolbar

    if (!annotator.kioskMode && annotator.cmsEmail == '') {
      this.$userButton = $("<button>Session</button>").button({
        icon: "fa fa-user",
        showLabel: false
      }).click(function () {
        _this.PresentModal();
      });
      this.annotator.player.controlBar.RegisterElement(this.$userButton, 1, 'flex-end');
    } //this.$dialog.dialog("open");


    console.log("[Session Manager] SessionManager created.");
  }

  _createClass(SessionManager, [{
    key: "ShowLoginModal",
    value: function ShowLoginModal() {
      var _this2 = this;

      // Create the dialog
      var $container = $("<div class='waldorf-session-modal' title='Log In'></div>"); // Outermost HTML

      var $headText = $("<p class='validateTips'>All fields are required.</p>").appendTo($container);
      var $form = $("<form></form>").appendTo($container);
      var $nicknameField;
      var $usernameField;
      var $passwordField;

      if (this.annotator.apiKey) {
        $("<label for='username'>Name</label>").appendTo($form);
        $nicknameField = $("<input type='text' name='username' value='' class='text ui-widget-content ui-corner-all'>").appendTo($form);
        $("<label for='username'>Email Address</label>").appendTo($form);
        $usernameField = $("<input type='text' name='email' value='' class='text ui-widget-content ui-corner-all'>").appendTo($form);
      } else {
        $("<label for='username'>Username</label>").appendTo($form);
        $usernameField = $("<input type='text' name='username' value='' class='text ui-widget-content ui-corner-all'>").appendTo($form);
        $("<label for='password'>Password</label>").appendTo($form);
        $passwordField = $("<input type='password' name='password' value='' class='text ui-widget-content ui-corner-all'>").appendTo($form);
      }

      $form.wrapInner("<fieldset />");

      var login = function login() {
        if (_this2.annotator.apiKey) {
          var nickName = $nicknameField.val();
          var userName = sha1($usernameField.val());

          _this2.annotator.server.LogIn(nickName, userName).done(function () {
            console.log("API key login success");
            $dialog.dialog("close");
          }).fail(function () {
            $headText.html("<p>Invalid email address.</p>");
            $headText.css("color", "red");
          });
        } else {
          var userPass = sha1($passwordField.val());

          _this2.annotator.server.LogIn($usernameField.val(), userPass).done(function () {
            $dialog.dialog("close");
          }).fail(function () {
            $headText.html("<p>Invalid username or password.</p>");
            $headText.css("color", "red");
          });
        }
      };

      var $dialog = $container.dialog({
        autoOpen: true,
        draggable: false,
        modal: true,
        buttons: {
          "Log In": login,
          Cancel: function Cancel() {
            $dialog.dialog("close");
          }
        },
        close: function close() {
          $dialog.find("form")[0].reset();
          $dialog.find("input").removeClass("ui-state-error");

          _this2.OnModalClose();
        }
      });
    }
  }, {
    key: "ShowLogoutModal",
    value: function ShowLogoutModal() {
      var _this3 = this;

      var $container = $("<div title='Log Out'></div>");
      var $headText = $container.html("<p class='validateTips'>Are you sure you want to log out?</p>");
      var $dialog = $container.dialog({
        autoOpen: true,
        draggable: false,
        modal: true,
        buttons: {
          "Log Out": function LogOut() {
            _this3.annotator.server.LogOut().done(function () {
              $dialog.dialog("close");
            });
          },
          Cancel: function Cancel() {
            $dialog.dialog("close");
          }
        },
        close: function close() {
          _this3.OnModalClose();
        }
      });
    }
  }, {
    key: "PresentModal",
    value: function PresentModal() {
      // Early out if the modal is already open
      if (this.modalOpen) return; // Turn off fullscreen if it's on

      this.annotator.player.SetFullscreen(false);

      if (this.annotator.server.LoggedIn()) {
        this.ShowLogoutModal();
      } else {
        this.ShowLoginModal();
      }

      this.OnModalOpen();
    }
  }, {
    key: "OnModalOpen",
    value: function OnModalOpen() {
      this.$userButton.button("disable");
      this.modalOpen = true;
    }
  }, {
    key: "OnModalClose",
    value: function OnModalClose() {
      this.$userButton.button("enable");
      this.modalOpen = false;
    }
  }]);

  return SessionManager;
}();

exports.SessionManager = SessionManager;

},{"sha1":227}],14:[function(require,module,exports){
module.exports={
    "configFile": "annotator-config.json"
}
},{}],15:[function(require,module,exports){
"use strict";

require("./vendor.js");

require("./utils/array-extensions.js");

require("./utils/jquery-extensions.js");

require("./utils/string-extensions.js");

var _preferenceManager = require("./utils/preference-manager.js");

var _requirements = require("./utils/requirements.js");

var _videoPlayer = require("./video-player/video-player.js");

/*
Entry point for the whole project. Any jQuery extensions should
be registered here.
*/
// Import npm module dependencies
$.fn.annotate = function (args) {
  // let serverURL = args.serverURL || '';
  // let tagsURL = args.tagsURL || '';
  // let apiKey = args.apiKey || '';
  // let kioskMode = args.kioskMode || false;
  // let localURL = args.localURL || '';
  // let renderer = function(...) || false;
  // Error out early if "this" is not a video
  if ($(this).prop('tagName').toLowerCase() != "video") {
    console.error("Cannot wrap a non-video element!");
    return;
  }

  if (!(0, _requirements.VerifyRequirements)()) {
    return;
  } // preferences.GetJSON((data) => {
  //     //console.log(data);
  // });


  new _videoPlayer.AnnotatorVideoPlayer($(this), args);
};

},{"./utils/array-extensions.js":16,"./utils/jquery-extensions.js":18,"./utils/preference-manager.js":19,"./utils/requirements.js":20,"./utils/string-extensions.js":21,"./vendor.js":23,"./video-player/video-player.js":26}],16:[function(require,module,exports){
"use strict";

// From http://stackoverflow.com/a/14853974/7138792
// Warn if overriding existing method
if (Array.prototype.equals) console.warn("Overriding existing Array.prototype.equals. Possible causes: New API defines the method, \
    there's a framework conflict or you've got double inclusions in your code."); // attach the .equals method to Array's prototype to call it on any array

Array.prototype.equals = function (array) {
  // if the other array is a falsy value, return
  if (!array) return false; // compare lengths - can save a lot of time 

  if (this.length != array.length) return false;

  for (var i = 0, l = this.length; i < l; i++) {
    // Check if we have nested arrays
    if (this[i] instanceof Array && array[i] instanceof Array) {
      // recurse into the nested arrays
      if (!this[i].equals(array[i])) return false;
    } else if (this[i] != array[i]) {
      // Warning - two different object instances will never be equal: {x:20} != {x:20}
      return false;
    }
  }

  return true;
}; // Hide method from for-in loops


Object.defineProperty(Array.prototype, "equals", {
  enumerable: false
});

},{}],17:[function(require,module,exports){
(function (global){
"use strict";

/*!
 * jQuery clip-path-polygon Plugin v0.1.15 (2020-06-24)
 * jQuery plugin that makes easy to use clip-path on whatever tag under different browsers
 * https://github.com/andrusieczko/clip-path-polygon
 * 
 * Copyright 2020 Karol Andrusieczko
 * Released under MIT license
 */
var globalVariable = window || root;

var jQuery = jQuery || globalVariable.jQuery || (typeof window !== "undefined" ? window['$'] : typeof global !== "undefined" ? global['$'] : null);

(function ($) {
  var id = 0;

  var ClipPath = function ClipPath(jQuery, $el, points, options) {
    this.$ = jQuery;
    this.$el = $el;
    this.points = points;
    this.svgDefId = 'clipPathPolygonGenId' + id++;
    this.processOptions(options);
  };

  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = ClipPath;
    }

    exports.ClipPath = ClipPath;
  } else {
    globalVariable.ClipPath = ClipPath;
  }

  ClipPath.prototype = {
    $: null,
    $el: null,
    points: null,
    isForWebkit: true,
    isForSvg: true,
    svgDefId: null,
    isPercentage: false,
    create: function create() {
      this._createClipPath(this.points);
    },
    _createClipPath: function _createClipPath(points) {
      this._createSvgDefs();

      if (this.isForSvg) {
        this._createSvgBasedClipPath(points);
      }

      if (this.isForWebkit) {
        this._createWebkitClipPath(points);
      }
    },
    _createWebkitClipPath: function _createWebkitClipPath(points) {
      var clipPath = "polygon(" + this._translatePoints(points, true, this.isPercentage) + ")";
      this.$el.css('-webkit-clip-path', clipPath);
    },
    _createSvgBasedClipPath: function _createSvgBasedClipPath(points) {
      var clipPath = "polygon(" + this._translatePoints(points, true, this.isPercentage) + ")";
      this.$el.css('clip-path', clipPath);
    },
    // Firefox no longer seems to work with this but does with the webkit version, so I copied it above.
    // _createSvgBasedClipPath: function(points) {
    //   this.$('#' + this.svgDefId + '').find('polygon').attr('points', this._translatePoints(points, false, this.isPercentage));
    //   this.$el.css('clip-path', 'url(#' + this.svgDefId + ')');
    // },
    _translatePoints: function _translatePoints(points, withUnit, isPercentage) {
      var result = [];

      for (var i in points) {
        var x = this._handlePxs(points[i][0], withUnit, isPercentage);

        var y = this._handlePxs(points[i][1], withUnit, isPercentage);

        result.push(x + ' ' + y);
      }

      return result.join(', ');
    },
    _handlePxs: function _handlePxs(number, withUnit, isPercentage) {
      if (number === 0) {
        return number;
      }

      if (!withUnit) {
        if (isPercentage) {
          return number / 100;
        }

        return number;
      }

      return number + (isPercentage ? "%" : "px");
    },
    _createSvgElement: function _createSvgElement(elementName) {
      return this.$(document.createElementNS('http://www.w3.org/2000/svg', elementName));
    },
    _createSvgDefs: function _createSvgDefs() {
      if (this.$('#' + this.svgDefId + '').length === 0) {
        var $svg = this._createSvgElement('svg').attr('width', 0).attr('height', 0).css({
          'position': 'absolute',
          'visibility': 'hidden',
          'width': 0,
          'height': 0
        });

        var $defs = this._createSvgElement('defs');

        $svg.append($defs);

        var $clippath = this._createSvgElement('clipPath').attr('id', this.svgDefId);

        if (this.isPercentage) {
          $clippath.get(0).setAttribute('clipPathUnits', 'objectBoundingBox');
        }

        $defs.append($clippath);

        var $polygon = this._createSvgElement('polygon');

        $clippath.append($polygon);
        this.$('body').append($svg);
      }
    },
    processOptions: function processOptions(options) {
      this.isForWebkit = options && typeof options.isForWebkit !== "undefined" ? options.isForWebkit : this.isForWebkit;
      this.isForSvg = options && typeof options.isForSvg !== "undefined" ? options.isForSvg : this.isForSvg;
      this.isPercentage = options && options.isPercentage || this.isPercentage;
      this.svgDefId = options && options.svgDefId || this.svgDefId;
    }
  };

  $.fn.clipPath = function (points, options) {
    return this.each(function () {
      var $el = $(this);
      var clipPath = new ClipPath($, $el, points, options);
      clipPath.create();
    });
  };
}).call(void 0, jQuery);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],18:[function(require,module,exports){
"use strict";

/**
 * Sets the visibility of the element while disabling interaction.
 * Doesn't mess with jQuery's positioning calculations like show()
 * and hide().
 */
$.fn.makeVisible = function (show) {
  if (show) {
    $(this).css({
      "visibility": "visible",
      "pointer-events": ""
    });
  } else {
    $(this).css({
      "visibility": "hidden",
      "pointer-events": "none"
    });
  }
};
/*
Copyright 2014 Mike Dunn
http://upshots.org/
Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:
The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

https://github.com/moagrius/copycss

*/


$.fn.getStyles = function (only, except) {
  // the map to return with requested styles and values as KVP
  var product = {}; // the style object from the DOM element we need to iterate through

  var style; // recycle the name of the style attribute

  var name; // if it's a limited list, no need to run through the entire style object

  if (only && only instanceof Array) {
    for (var i = 0, l = only.length; i < l; i++) {
      // since we have the name already, just return via built-in .css method
      name = only[i];
      product[name] = this.css(name);
    }
  } else {
    // prevent from empty selector
    if (this.length) {
      // otherwise, we need to get everything
      var dom = this.get(0); // standards

      if (window.getComputedStyle) {
        // convenience methods to turn css case ('background-image') to camel ('backgroundImage')
        var pattern = /\-([a-z])/g;

        var uc = function uc(a, b) {
          return b.toUpperCase();
        };

        var camelize = function camelize(string) {
          return string.replace(pattern, uc);
        }; // make sure we're getting a good reference


        if (style = window.getComputedStyle(dom, null)) {
          var camel, value; // opera doesn't give back style.length - use truthy since a 0 length may as well be skipped anyways

          if (style.length) {
            for (var i = 0, l = style.length; i < l; i++) {
              name = style[i];
              camel = camelize(name);
              value = style.getPropertyValue(name);
              product[camel] = value;
            }
          } else {
            // opera
            for (name in style) {
              camel = camelize(name);
              value = style.getPropertyValue(name) || style[name];
              product[camel] = value;
            }
          }
        }
      } // IE - first try currentStyle, then normal style object - don't bother with runtimeStyle
      else if (style = dom.currentStyle) {
          for (name in style) {
            product[name] = style[name];
          }
        } else if (style = dom.style) {
          for (name in style) {
            if (typeof style[name] != 'function') {
              product[name] = style[name];
            }
          }
        }
    }
  } // remove any styles specified...
  // be careful on blacklist - sometimes vendor-specific values aren't obvious but will be visible...  e.g., excepting 'color' will still let '-webkit-text-fill-color' through, which will in fact color the text


  if (except && except instanceof Array) {
    for (var i = 0, l = except.length; i < l; i++) {
      name = except[i];
      delete product[name];
    }
  } // one way out so we can process blacklist in one spot


  return product;
}; // sugar - source is the selector, dom element or jQuery instance to copy from - only and except are optional


$.fn.copyCSS = function (source, only, except) {
  var styles = source.getStyles(only, except);
  this.css(styles);
  return this;
};

},{}],19:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.preferences = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// Bring in build config options
var metaconfig = require("../config.json");

var PreferenceManager = /*#__PURE__*/function () {
  function PreferenceManager() {
    _classCallCheck(this, PreferenceManager);
  }

  _createClass(PreferenceManager, [{
    key: "GetJSON",
    value: function GetJSON(callback) {
      var _this = this;

      //let loc = window.location.pathname;
      //let dir = loc.substring(0, loc.lastIndexOf('/'));
      var dir = "./dist/"; //console.log(dir + metaconfig.configFile);

      if (this.cachedJSON != null) {
        callback(this.cached);
      } else {
        $.ajax({
          dataType: "json",
          url: dir + metaconfig.configFile,
          success: function success(data) {
            _this.cachedJSON = data;
            callback(_this.cachedJSON);
          }
        });
      }
    }
  }]);

  return PreferenceManager;
}();

var preferences = new PreferenceManager();
exports.preferences = preferences;

},{"../config.json":14}],20:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VerifyRequirements = VerifyRequirements;

/**
 * Returns false if running on an unsupported platform or missing jQuery, otherwise true.
 * 
 */
function VerifyRequirements() {
  // Stop running if we're on an unsupported platform (mobile for now)
  // if( /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ) {
  //     console.error("Platform is unsupported!");
  //     //let unsupportedDiv = document.createElement("div");
  //     //unsupportedDiv.appendChild(document.createTextNode("Your platform is unsupported!"));
  //     //document.body.appendChild(unsupportedDiv);
  //     return false;
  // }
  // Check if we don't have jQuery loaded
  if (!window.jQuery) {
    console.error("JQuery must be present!"); //let unsupportedDiv = document.createElement("div");
    //unsupportedDiv.appendChild(document.createTextNode("Your platform is unsupported!"));
    //document.body.appendChild(unsupportedDiv);

    return false;
  }

  return true;
}

},{}],21:[function(require,module,exports){
"use strict";

/**
 * Escapes the string so it can embed directly in an HTML document.
 */
// http://stackoverflow.com/a/12034334
Object.defineProperty(String.prototype, 'escapeHTML', {
  value: function value() {
    var entityMap = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;',
      '/': '&#x2F;',
      '`': '&#x60;',
      '=': '&#x3D;'
    };
    return String(this).replace(/[&<>"'`=\/]/g, function (s) {
      return entityMap[s];
    });
  }
});

},{}],22:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GetFormattedTime = GetFormattedTime;
exports.GetSecondsFromHMS = GetSecondsFromHMS;

// http://stackoverflow.com/a/34841026
function GetFormattedTime(timeInSeconds) {
  if (isNaN(timeInSeconds)) return 0;
  var time = timeInSeconds | 0; //Truncate to integer

  var hours = Math.floor(time / 3600) % 24;
  var minutes = Math.floor(time / 60) % 60;
  var seconds = time % 60;
  var formatted = [hours, minutes, seconds].map(function (v) {
    return v < 10 ? "0" + v : v;
  }).filter(function (v, i) {
    return v !== "00" || i > 0;
  }).join(":");

  if (formatted.charAt(0) == "0") {
    formatted = formatted.substr(1);
  }

  var ms = (timeInSeconds % 1).toFixed(2);
  formatted += ms.toString().substr(1);
  return formatted;
} // From http://stackoverflow.com/a/9640417/7138792


function GetSecondsFromHMS(hms) {
  var parts = hms.split('.');
  var ms = "0";
  if (parts.length > 1) ms = '.' + parts[1];
  var p = parts[0].split(':'),
      s = 0,
      m = 1;

  while (p.length > 0) {
    s += m * parseInt(p.pop(), 10);
    m *= 60;
  }

  s += parseFloat(ms);
  return s;
}

},{}],23:[function(require,module,exports){
"use strict";

require("qtip2");

/**
 * Use this file to import what you need from the bundled npm modules.
 */
// Must import from node_modules folder or it won't see the shimmed jquery instance
// Removed from here because they weren't being loaded in the right order - JPB
// import '../node_modules/select2/dist/js/select2.js';
// import "../node_modules/select2/dist/css/select2.css";
//require("../node_modules/qtip2/dist/jquery.qtip.min.js");
//import "../node_modules/qtip2/dist/jquery.qtip.min.css";
require("./utils/clip-path-polygon-1.0.15.js"); //let screenfull = require('screenfull');
//import screenfull from "screenfull";
// CDN resources
// Font-Awesome
//$("head").append($("<script src='https://use.fontawesome.com/a703e2e5bf.js'></script>"));

},{"./utils/clip-path-polygon-1.0.15.js":17,"qtip2":225}],24:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SeekbarTooltip = void 0;

var _time = require("../utils/time.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var SeekbarTooltip = /*#__PURE__*/function () {
  function SeekbarTooltip($parent, player) {
    var _this = this;

    _classCallCheck(this, SeekbarTooltip);

    this.$parent = $parent;
    this.player = player;
    this.$tooltip = $("<div class='waldorf-seekbar-tooltip'></div>").appendTo($parent);
    this.text = "Test";
    this.$content = $("<p>" + this.text + "</p>").appendTo(this.$tooltip);
    this.hoverOffset = -10;
    this.padding = 5;
    this.Hide();
    this.$parent.mousemove(function (event) {
      _this.Show(); //Add and update tooltip on mouse movement to show where the mouse is hovering.


      var mouseX = event.pageX - player.$container.offset().left;

      var percent = mouseX / _this.$parent.width();

      var timeAtCursor = percent * player.videoElement.duration;

      _this.Move(mouseX, 0);

      _this.SetContent((0, _time.GetFormattedTime)(timeAtCursor));
    });
    this.$parent.mouseout(function () {
      _this.Hide();
    });
  }

  _createClass(SeekbarTooltip, [{
    key: "Move",
    value: function Move(x, y) {
      // Get initial positions
      var left = x - this.GetWidth() / 2;
      var top = y - this.GetHeight() + this.hoverOffset; // Offset if necessary (keep on-screen)

      if (left - this.padding < 0) {
        left = this.padding;
      }

      if (left + this.padding + this.GetWidth() > this.$parent.width()) {
        left = this.$parent.width() - this.GetWidth() - this.padding;
      } // Apply positions


      this.$tooltip.css({
        top: top,
        left: left
      });
    }
  }, {
    key: "GetWidth",
    value: function GetWidth() {
      return this.$tooltip.width();
    }
  }, {
    key: "GetHeight",
    value: function GetHeight() {
      return this.$tooltip.height();
    }
  }, {
    key: "Show",
    value: function Show() {
      this.$tooltip.makeVisible(true);
    }
  }, {
    key: "Hide",
    value: function Hide() {
      this.$tooltip.makeVisible(false);
    }
  }, {
    key: "SetContent",
    value: function SetContent(text) {
      //console.log(text);
      this.$content.text(text);
    }
  }]);

  return SeekbarTooltip;
}();

exports.SeekbarTooltip = SeekbarTooltip;

},{"../utils/time.js":22}],25:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VideoPlayerBar = void 0;

var _time = require("../utils/time.js");

var _seekbarTooltip = require("./seekbar-tooltip.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var VideoPlayerBar = /*#__PURE__*/function () {
  function VideoPlayerBar(player) {
    var _this = this;

    _classCallCheck(this, VideoPlayerBar);

    this.player = player;
    this.$container = $("<div class='waldorf-player-toolbar flex-toolbar'></div>").appendTo(player.$container);
    this.PopulateElements();
    this.scrubbingTimeSlider = false;
    this.videoPlayingBeforeTimeScrub = false; // Hook up to events from video player

    this.player.$container.on("OnVisibilityChange", function (event, isVisible, duration) {
      return _this.SetVisible(isVisible, duration);
    });
    this.player.$container.on("OnPlayStateChange", function (event, playing) {
      return _this.OnPlayStateChange(playing);
    });
    this.player.$container.on("OnTimeUpdate", function (event, time) {
      return _this.OnTimeUpdate(time);
    });
    this.player.$container.on("OnMuteStateChange", function (event, muted) {
      return _this.OnMuteStateChange(muted);
    });
    this.player.$container.on("OnVolumeChange", function (event, volume) {
      return _this.OnVolumeChange(volume);
    });
  }

  _createClass(VideoPlayerBar, [{
    key: "PopulateElements",
    value: function PopulateElements() {
      var _this2 = this;

      this.$seekBar = $("<div id='seek-bar'><div id='seek-handle' class='ui-slider-handle'></div></div>");
      var $seekSlider = this.$seekBar.slider({
        min: 0.0,
        max: 1.0,
        step: 0.001
      });
      $seekSlider.on("slide", function () {
        return _this2.UpdateVideoTime();
      });
      $seekSlider.on("slidestart", function () {
        return _this2.TimeDragStarted();
      });
      $seekSlider.on("slidestop", function () {
        _this2.TimeDragFinished();

        _this2.UpdateVideoTime();
      });
      this.$container.append(this.$seekBar);
      this.seekbarTooltip = new _seekbarTooltip.SeekbarTooltip(this.$seekBar, this.player);
      this.$seekProgress = $("<div id='seek-fill'></div>");
      this.$container.append(this.$seekProgress); //Jump Back button

      this.$jumpBackButton = $("<button>Jump Back</button>").button({
        icon: "fa fa-fast-backward",
        showLabel: false
      }).click(function () {
        return _this2.player.JumpBackward();
      });
      this.RegisterElement(this.$jumpBackButton, -8); //Nudge Back button

      this.$nudgeBackButton = $("<button>Nudge Back</button>").button({
        icon: "fa fa-step-backward",
        showLabel: false
      }).click(function () {
        return _this2.player.StepBackward();
      });
      this.RegisterElement(this.$nudgeBackButton, -7); // Play button

      this.$playButton = $("<button>Play</button>").button({
        icon: "fa fa-play",
        showLabel: false
      }).click(function () {
        return _this2.player.TogglePlayState();
      });
      this.RegisterElement(this.$playButton, -6); //Nudge button

      this.$nudgeButton = $("<button>Nudge</button>").button({
        icon: "fa fa-step-forward",
        showLabel: false
      }).click(function () {
        return _this2.player.StepForward();
      });
      this.RegisterElement(this.$nudgeButton, -5); //Jump button

      this.$jumpButton = $("<button>Nudge</button>").button({
        icon: "fa fa-fast-forward",
        showLabel: false
      }).click(function () {
        return _this2.player.JumpForward();
      });
      this.RegisterElement(this.$jumpButton, -4); // Time text

      var zero = (0, _time.GetFormattedTime)(0.000);
      this.$timeText = $("<p>${zero}/${zero}</p>");
      this.RegisterElement(this.$timeText, -3); // Mute button

      this.$muteButton = $("<button>Mute</button>").button({
        icon: "fa fa-volume-up",
        showLabel: false
      }).click(function () {
        return _this2.player.ToggleMuteState();
      });
      this.RegisterElement(this.$muteButton, -2); // Volume bar

      this.$volumeBar = $("<div id='volume-bar'><div id='volume-handle' class='ui-slider-handle'></div></div>");
      this.$volumeBar.slider({
        range: "min",
        max: 1.0,
        value: 1.0,
        step: 0.05
      }).on("slide", function (event, ui) {
        return _this2.player.SetVolume(ui.value);
      });
      this.RegisterElement(this.$volumeBar, -1); // Fullscreen button

      this.$fullScreenButton = $("<button>Fullscreen</button>").button({
        icon: "fa fa-arrows-alt",
        showLabel: false
      }).click(function () {
        return _this2.player.ToggleFullscreen();
      });
      this.RegisterElement(this.$fullScreenButton, 999, 'flex-end'); // Create empty element between left floating and right floating toolbar items to space them out properly

      this.$container.append($("<div></div>").css("flex-grow", 1).css("order", 0)); //Initialize controls

      this.OnTimeUpdate();
      this.$volumeBar.slider("value", this.player.videoElement.volume);
    }
  }, {
    key: "RegisterElement",
    value: function RegisterElement($element, order) {
      var justification = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'flex-start';
      $element.css('order', order);
      $element.css('align-self', justification); // Sets grow [shrink] [basis]
      //$element.css('flex', '0 0 auto');

      this.$container.append($element);
    }
  }, {
    key: "SetVisible",
    value: function SetVisible(isVisible, duration) {
      var _this3 = this;

      //console.log(isVisible + " " + duration);
      this.$container.stop(true, true);

      if (isVisible) {
        this.$container.fadeTo(duration, 1.0, function () {
          _this3.$container.makeVisible(true);
        });
      } else {
        this.$container.fadeTo(duration, 0.0, function () {
          _this3.$container.makeVisible(false);
        });
      }
    }
  }, {
    key: "UpdateVideoTime",
    value: function UpdateVideoTime() {
      // Calculate the new time
      var time = this.player.videoElement.duration * this.$seekBar.slider("value");
      this.player.endTime = false;
      this.player.videoElement.currentTime = time;
    }
  }, {
    key: "TimeDragStarted",
    value: function TimeDragStarted() {
      this.videoPlayingBeforeTimeScrub = !this.player.videoElement.paused;
      this.player.videoElement.pause();
    }
  }, {
    key: "TimeDragFinished",
    value: function TimeDragFinished() {
      // Start playing the video again if it was playing before the scrub started
      if (this.videoPlayingBeforeTimeScrub) {
        this.player.videoElement.play();
      }
    } ///
    /// ----- Event Listeners -----
    /// The following update the visual state of the bar
    /// upon changes to the video player. These are hooked
    /// up in the constructor.
    ///

  }, {
    key: "OnPlayStateChange",
    value: function OnPlayStateChange(playing) {
      this.$playButton.button("option", {
        icon: playing ? "fa fa-pause" : "fa fa-play"
      });
    }
  }, {
    key: "OnTimeUpdate",
    value: function OnTimeUpdate(time) {
      //console.log("video-player-bar.js:185 OnTimeUpdate is called");
      var duration = this.player.videoElement.duration; // Update the time text

      this.$timeText.text((0, _time.GetFormattedTime)(time) + "/" + (0, _time.GetFormattedTime)(duration));
      var progress = time / duration;
      this.$seekProgress.width((progress * 100).toString() + "%");
    }
  }, {
    key: "OnVolumeChange",
    value: function OnVolumeChange(volume) {
      this.$volumeBar.slider("value", volume);
    }
  }, {
    key: "OnMuteStateChange",
    value: function OnMuteStateChange(muted) {
      this.$muteButton.button("option", {
        icon: muted ? "fa fa-volume-up" : "fa fa-volume-off"
      });
    }
  }]);

  return VideoPlayerBar;
}();

exports.VideoPlayerBar = VideoPlayerBar;

},{"../utils/time.js":22,"./seekbar-tooltip.js":24}],26:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AnnotatorVideoPlayer = void 0;

var _videoPlayerBar = require("./video-player-bar.js");

var _annotator = require("../annotator/annotator.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

//import * as screenfull from "screenfull";
//import 'jquery-ui/dist/jquery-ui.js';
var screenfull = require('screenfull');

var AnnotatorVideoPlayer = /*#__PURE__*/function () {
  function AnnotatorVideoPlayer($video, annotatorArgs) {
    var _this = this;

    _classCallCheck(this, AnnotatorVideoPlayer);

    console.log("[AnnotatorVideoPlayer] Creating AnnotatorVideoPlayer for video...");
    this.$video = $video;
    this.videoElement = this.$video.get(0); // Store the original styling of the video element before we alter it

    this.originalStyles = this.$video.getStyles(null, ["height", "WebkitTextFillColor", "color"]); //["width", "top", "left", "margin", "padding"]

    this.Wrap();
    this.PopulateControls();
    this.SetVisible(true); // Hook up events

    this.HookUpEvents(); // Play / pause the video when clicked.

    this.$video.on("click", function () {
      return _this.TogglePlayState();
    });
    this.allowAutoFade = true; /// Inactivity timer for the mouse.

    this.mouseTimer = null; /// Set to true if the time slider is currently being dragged by the user.

    this.draggingTimeSlider = false; /// Seconds before the UI fades due to mouse inactivity.

    this.idleSecondsBeforeFade = 3;
    this.fadeDuration = 300;
    this.endTime = false;
    this.$container.mousemove(function () {
      return _this.OnMouseMove();
    });
    this.SetAutoFade(true); // If screenfull is enabled, create the event to handle it.

    if (screenfull !== 'undefined') {
      screenfull.onchange(function () {
        _this.OnFullscreenChange();

        _this.$container.trigger("OnFullscreenChange");
      });
    }

    this.videoElement.ontimeupdate = function () {
      _this.OnTimeUpdate(_this.videoElement.currentTime);
    };

    this.$container.on("OnVideoReady", function () {
      if (annotatorArgs.annotator == null) {
        console.log("[AnnotatorVideoPlayer] Player sent OnVideoReady, attempting to wrap with annotator..."); // Add annotator once video has loaded

        console.log("[AnnotatorVideoPlayer] Wrapping video with annotator...");
        annotatorArgs.player = _this;
        annotatorArgs.annotator = new _annotator.VideoAnnotator(annotatorArgs);
        if (typeof annotatorArgs.callback == "function") annotatorArgs.callback(annotatorArgs.annotator);
      }
    });

    this.videoElement.onloadedmetadata = function () {
      _this.$container.trigger("OnVideoReady");
    };

    if (this.videoElement.duration != null) {
      // If the metadata is already prepared, throw the event since
      // onloadedmetadata won't be fired
      this.$container.trigger("OnVideoReady");
    }

    console.log("[AnnotatorVideoPlayer] AnnotatorVideoPlayer created for video.");
  }

  _createClass(AnnotatorVideoPlayer, [{
    key: "Wrap",
    value: function Wrap() {
      // Remove the default controls from the video
      this.videoElement.removeAttribute("controls"); // Wrap the video element with the container

      this.$container = this.$video.wrap("<div class='waldorf-video-player'></div>").parent(); // Resize container to fit the dimensions of the video

      this.$container.width(this.$video.width());
      this.$container.height(this.$video.height());
    }
  }, {
    key: "PopulateControls",
    value: function PopulateControls() {
      this.controlBar = new _videoPlayerBar.VideoPlayerBar(this);
    }
  }, {
    key: "SetVisible",
    value: function SetVisible(isVisible) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this.$container.trigger("OnVisibilityChange", [isVisible, duration]);
    }
  }, {
    key: "HookUpEvents",
    value: function HookUpEvents() {}
  }, {
    key: "TogglePlayState",
    value: function TogglePlayState() {
      if (this.videoElement.paused) {
        this.Play();
      } else {
        this.Pause();
      }
    }
  }, {
    key: "StepForward",
    value: function StepForward() {
      var newTime = this.videoElement.currentTime + 0.1;
      this.videoElement.currentTime = newTime > this.videoElement.duration ? this.videoElement.duration : newTime;
    }
  }, {
    key: "JumpForward",
    value: function JumpForward() {
      var newTime = this.videoElement.currentTime + 1;
      this.videoElement.currentTime = newTime > this.videoElement.duration ? this.videoElement.duration : newTime;
    }
  }, {
    key: "StepBackward",
    value: function StepBackward() {
      var newTime = this.videoElement.currentTime - 0.1;
      this.videoElement.currentTime = newTime < 0 ? 0 : newTime;
    }
  }, {
    key: "JumpBackward",
    value: function JumpBackward() {
      var newTime = this.videoElement.currentTime - 1;
      this.videoElement.currentTime = newTime < 0 ? 0 : newTime;
    }
  }, {
    key: "Play",
    value: function Play() {
      this.videoElement.play();
      if (this.endTime) this.endTime = false;
      this.SetAutoFade(true);
      this.$container.trigger("OnPlayStateChange", !this.videoElement.paused);
    }
  }, {
    key: "Pause",
    value: function Pause() {
      if (this.endTime) this.endTime = false;
      this.videoElement.pause();
      this.SetAutoFade(false);
      this.$container.trigger("OnPlayStateChange", !this.videoElement.paused);
    }
  }, {
    key: "ToggleMuteState",
    value: function ToggleMuteState() {
      var muted = this.videoElement.muted;
      this.videoElement.muted = !muted;
      this.$container.trigger("OnMuteStateChange", muted);
    }
  }, {
    key: "SetVolume",
    value: function SetVolume(volume) {
      this.videoElement.volume = volume;
      this.$container.trigger("OnVolumeChange", volume);
    }
  }, {
    key: "ToggleFullscreen",
    value: function ToggleFullscreen() {
      if (screenfull === 'undefined') return;
      screenfull.toggle(this.$container[0]);
    }
  }, {
    key: "OnFullscreenChange",
    value: function OnFullscreenChange() {
      if (screenfull.isFullscreen) {
        this.$container.addClass("waldorf-fullscreen");
      } else {
        this.$container.removeClass("waldorf-fullscreen");
      }
    }
  }, {
    key: "SetFullscreen",
    value: function SetFullscreen(fullscreen) {
      if (screenfull === 'undefined' || !screenfull.enabled) {
        return;
      }

      if (fullscreen) {
        screenfull.request(this.$container[0]);
      } else {
        screenfull.exit();
      }
    }
    /**
     * Called when the mouse moves in the video container.
     */

  }, {
    key: "OnMouseMove",
    value: function OnMouseMove() {
      // Reset the timer
      clearTimeout(this.mouseTimer);
      this.mouseTimer = 0; // Restart fading if allowed to

      if (this.allowAutoFade) {
        this.RestartFading();
      }
    }
  }, {
    key: "OnTimeUpdate",
    value: function OnTimeUpdate(time) {
      if (this.endTime && this.endTime <= this.videoElement.currentTime) {
        this.Pause();
        this.endTime = false;
      }

      this.$container.trigger("OnTimeUpdate", time);
    }
  }, {
    key: "RestartFading",
    value: function RestartFading() {
      var _this2 = this;

      // Restore visibility
      this.SetVisible(true, this.fadeDuration); // Start the timer over again

      this.mouseTimer = setTimeout(function () {
        _this2.SetVisible(false, _this2.fadeDuration);
      }, this.idleSecondsBeforeFade * 1000);
    }
  }, {
    key: "SetAutoFade",
    value: function SetAutoFade(allow) {
      this.allowAutoFade = allow; // Reset the mouse timer

      clearTimeout(this.mouseTimer);
      this.mouseTimer = 0; // Make elements visible

      this.SetVisible(true); // Restart the fading behavior if desired

      if (allow) {
        this.RestartFading();
      }
    } // IsPlaying(){
    //     // http://stackoverflow.com/a/31133401
    //     return !!(this.videoElement.currentTime > 0 && !this.videoElement.paused && 
    //               !this.videoElement.ended && this.videoElement.readyState > 2);
    // }
    // From https://gist.github.com/Nateowami/7a947e93f09c45a1097e783dc00560e1

  }, {
    key: "GetVideoDimensions",
    value: function GetVideoDimensions() {
      var video = this.videoElement; // Ratio of the video's intrisic dimensions

      var videoRatio = video.videoWidth / video.videoHeight; // The width and height of the video element

      var width = video.offsetWidth;
      var height = video.offsetHeight; // The ratio of the element's width to its height

      var elementRatio = width / height; // If the video element is short and wide

      if (elementRatio > videoRatio) width = height * videoRatio; // It must be tall and thin, or exactly equal to the original ratio
      else height = width / videoRatio;
      return {
        width: width,
        height: height
      };
    }
  }]);

  return AnnotatorVideoPlayer;
}();

exports.AnnotatorVideoPlayer = AnnotatorVideoPlayer;

},{"../annotator/annotator.js":4,"./video-player-bar.js":25,"screenfull":226}],27:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isIdentifierStart = isIdentifierStart;
exports.isIdentifierChar = isIdentifierChar;
exports.isIdentifierName = isIdentifierName;
let nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08c7\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\u9ffc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7ca\ua7f5-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
let nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf\u1ac0\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
const nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
const nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
const astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
const astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];

function isInAstralSet(code, set) {
  let pos = 0x10000;

  for (let i = 0, length = set.length; i < length; i += 2) {
    pos += set[i];
    if (pos > code) return false;
    pos += set[i + 1];
    if (pos >= code) return true;
  }

  return false;
}

function isIdentifierStart(code) {
  if (code < 65) return code === 36;
  if (code <= 90) return true;
  if (code < 97) return code === 95;
  if (code <= 122) return true;

  if (code <= 0xffff) {
    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
  }

  return isInAstralSet(code, astralIdentifierStartCodes);
}

function isIdentifierChar(code) {
  if (code < 48) return code === 36;
  if (code < 58) return true;
  if (code < 65) return false;
  if (code <= 90) return true;
  if (code < 97) return code === 95;
  if (code <= 122) return true;

  if (code <= 0xffff) {
    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
  }

  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}

function isIdentifierName(name) {
  let isFirst = true;

  for (let _i = 0, _Array$from = Array.from(name); _i < _Array$from.length; _i++) {
    const char = _Array$from[_i];
    const cp = char.codePointAt(0);

    if (isFirst) {
      if (!isIdentifierStart(cp)) {
        return false;
      }

      isFirst = false;
    } else if (!isIdentifierChar(cp)) {
      return false;
    }
  }

  return !isFirst;
}
},{}],28:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "isIdentifierName", {
  enumerable: true,
  get: function () {
    return _identifier.isIdentifierName;
  }
});
Object.defineProperty(exports, "isIdentifierChar", {
  enumerable: true,
  get: function () {
    return _identifier.isIdentifierChar;
  }
});
Object.defineProperty(exports, "isIdentifierStart", {
  enumerable: true,
  get: function () {
    return _identifier.isIdentifierStart;
  }
});
Object.defineProperty(exports, "isReservedWord", {
  enumerable: true,
  get: function () {
    return _keyword.isReservedWord;
  }
});
Object.defineProperty(exports, "isStrictBindOnlyReservedWord", {
  enumerable: true,
  get: function () {
    return _keyword.isStrictBindOnlyReservedWord;
  }
});
Object.defineProperty(exports, "isStrictBindReservedWord", {
  enumerable: true,
  get: function () {
    return _keyword.isStrictBindReservedWord;
  }
});
Object.defineProperty(exports, "isStrictReservedWord", {
  enumerable: true,
  get: function () {
    return _keyword.isStrictReservedWord;
  }
});
Object.defineProperty(exports, "isKeyword", {
  enumerable: true,
  get: function () {
    return _keyword.isKeyword;
  }
});

var _identifier = require("./identifier");

var _keyword = require("./keyword");
},{"./identifier":27,"./keyword":29}],29:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isReservedWord = isReservedWord;
exports.isStrictReservedWord = isStrictReservedWord;
exports.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
exports.isStrictBindReservedWord = isStrictBindReservedWord;
exports.isKeyword = isKeyword;
const reservedWords = {
  keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
  strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
  strictBind: ["eval", "arguments"]
};
const keywords = new Set(reservedWords.keyword);
const reservedWordsStrictSet = new Set(reservedWords.strict);
const reservedWordsStrictBindSet = new Set(reservedWords.strictBind);

function isReservedWord(word, inModule) {
  return inModule && word === "await" || word === "enum";
}

function isStrictReservedWord(word, inModule) {
  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
}

function isStrictBindOnlyReservedWord(word) {
  return reservedWordsStrictBindSet.has(word);
}

function isStrictBindReservedWord(word, inModule) {
  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
}

function isKeyword(word) {
  return keywords.has(word);
}
},{}],30:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assertNode;

var _isNode = _interopRequireDefault(require("../validators/isNode"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function assertNode(node) {
  if (!(0, _isNode.default)(node)) {
    var _node$type;

    const type = (_node$type = node == null ? void 0 : node.type) != null ? _node$type : JSON.stringify(node);
    throw new TypeError(`Not a valid node of type "${type}"`);
  }
}
},{"../validators/isNode":94}],31:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assertArrayExpression = assertArrayExpression;
exports.assertAssignmentExpression = assertAssignmentExpression;
exports.assertBinaryExpression = assertBinaryExpression;
exports.assertInterpreterDirective = assertInterpreterDirective;
exports.assertDirective = assertDirective;
exports.assertDirectiveLiteral = assertDirectiveLiteral;
exports.assertBlockStatement = assertBlockStatement;
exports.assertBreakStatement = assertBreakStatement;
exports.assertCallExpression = assertCallExpression;
exports.assertCatchClause = assertCatchClause;
exports.assertConditionalExpression = assertConditionalExpression;
exports.assertContinueStatement = assertContinueStatement;
exports.assertDebuggerStatement = assertDebuggerStatement;
exports.assertDoWhileStatement = assertDoWhileStatement;
exports.assertEmptyStatement = assertEmptyStatement;
exports.assertExpressionStatement = assertExpressionStatement;
exports.assertFile = assertFile;
exports.assertForInStatement = assertForInStatement;
exports.assertForStatement = assertForStatement;
exports.assertFunctionDeclaration = assertFunctionDeclaration;
exports.assertFunctionExpression = assertFunctionExpression;
exports.assertIdentifier = assertIdentifier;
exports.assertIfStatement = assertIfStatement;
exports.assertLabeledStatement = assertLabeledStatement;
exports.assertStringLiteral = assertStringLiteral;
exports.assertNumericLiteral = assertNumericLiteral;
exports.assertNullLiteral = assertNullLiteral;
exports.assertBooleanLiteral = assertBooleanLiteral;
exports.assertRegExpLiteral = assertRegExpLiteral;
exports.assertLogicalExpression = assertLogicalExpression;
exports.assertMemberExpression = assertMemberExpression;
exports.assertNewExpression = assertNewExpression;
exports.assertProgram = assertProgram;
exports.assertObjectExpression = assertObjectExpression;
exports.assertObjectMethod = assertObjectMethod;
exports.assertObjectProperty = assertObjectProperty;
exports.assertRestElement = assertRestElement;
exports.assertReturnStatement = assertReturnStatement;
exports.assertSequenceExpression = assertSequenceExpression;
exports.assertParenthesizedExpression = assertParenthesizedExpression;
exports.assertSwitchCase = assertSwitchCase;
exports.assertSwitchStatement = assertSwitchStatement;
exports.assertThisExpression = assertThisExpression;
exports.assertThrowStatement = assertThrowStatement;
exports.assertTryStatement = assertTryStatement;
exports.assertUnaryExpression = assertUnaryExpression;
exports.assertUpdateExpression = assertUpdateExpression;
exports.assertVariableDeclaration = assertVariableDeclaration;
exports.assertVariableDeclarator = assertVariableDeclarator;
exports.assertWhileStatement = assertWhileStatement;
exports.assertWithStatement = assertWithStatement;
exports.assertAssignmentPattern = assertAssignmentPattern;
exports.assertArrayPattern = assertArrayPattern;
exports.assertArrowFunctionExpression = assertArrowFunctionExpression;
exports.assertClassBody = assertClassBody;
exports.assertClassExpression = assertClassExpression;
exports.assertClassDeclaration = assertClassDeclaration;
exports.assertExportAllDeclaration = assertExportAllDeclaration;
exports.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
exports.assertExportNamedDeclaration = assertExportNamedDeclaration;
exports.assertExportSpecifier = assertExportSpecifier;
exports.assertForOfStatement = assertForOfStatement;
exports.assertImportDeclaration = assertImportDeclaration;
exports.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
exports.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
exports.assertImportSpecifier = assertImportSpecifier;
exports.assertMetaProperty = assertMetaProperty;
exports.assertClassMethod = assertClassMethod;
exports.assertObjectPattern = assertObjectPattern;
exports.assertSpreadElement = assertSpreadElement;
exports.assertSuper = assertSuper;
exports.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
exports.assertTemplateElement = assertTemplateElement;
exports.assertTemplateLiteral = assertTemplateLiteral;
exports.assertYieldExpression = assertYieldExpression;
exports.assertAwaitExpression = assertAwaitExpression;
exports.assertImport = assertImport;
exports.assertBigIntLiteral = assertBigIntLiteral;
exports.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
exports.assertOptionalMemberExpression = assertOptionalMemberExpression;
exports.assertOptionalCallExpression = assertOptionalCallExpression;
exports.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
exports.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
exports.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
exports.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;
exports.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;
exports.assertClassImplements = assertClassImplements;
exports.assertDeclareClass = assertDeclareClass;
exports.assertDeclareFunction = assertDeclareFunction;
exports.assertDeclareInterface = assertDeclareInterface;
exports.assertDeclareModule = assertDeclareModule;
exports.assertDeclareModuleExports = assertDeclareModuleExports;
exports.assertDeclareTypeAlias = assertDeclareTypeAlias;
exports.assertDeclareOpaqueType = assertDeclareOpaqueType;
exports.assertDeclareVariable = assertDeclareVariable;
exports.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
exports.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;
exports.assertDeclaredPredicate = assertDeclaredPredicate;
exports.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
exports.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
exports.assertFunctionTypeParam = assertFunctionTypeParam;
exports.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
exports.assertInferredPredicate = assertInferredPredicate;
exports.assertInterfaceExtends = assertInterfaceExtends;
exports.assertInterfaceDeclaration = assertInterfaceDeclaration;
exports.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;
exports.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;
exports.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
exports.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
exports.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
exports.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;
exports.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
exports.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
exports.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;
exports.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
exports.assertObjectTypeIndexer = assertObjectTypeIndexer;
exports.assertObjectTypeProperty = assertObjectTypeProperty;
exports.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
exports.assertOpaqueType = assertOpaqueType;
exports.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
exports.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;
exports.assertStringTypeAnnotation = assertStringTypeAnnotation;
exports.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;
exports.assertThisTypeAnnotation = assertThisTypeAnnotation;
exports.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
exports.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
exports.assertTypeAlias = assertTypeAlias;
exports.assertTypeAnnotation = assertTypeAnnotation;
exports.assertTypeCastExpression = assertTypeCastExpression;
exports.assertTypeParameter = assertTypeParameter;
exports.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
exports.assertTypeParameterInstantiation = assertTypeParameterInstantiation;
exports.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
exports.assertVariance = assertVariance;
exports.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
exports.assertEnumDeclaration = assertEnumDeclaration;
exports.assertEnumBooleanBody = assertEnumBooleanBody;
exports.assertEnumNumberBody = assertEnumNumberBody;
exports.assertEnumStringBody = assertEnumStringBody;
exports.assertEnumSymbolBody = assertEnumSymbolBody;
exports.assertEnumBooleanMember = assertEnumBooleanMember;
exports.assertEnumNumberMember = assertEnumNumberMember;
exports.assertEnumStringMember = assertEnumStringMember;
exports.assertEnumDefaultedMember = assertEnumDefaultedMember;
exports.assertJSXAttribute = assertJSXAttribute;
exports.assertJSXClosingElement = assertJSXClosingElement;
exports.assertJSXElement = assertJSXElement;
exports.assertJSXEmptyExpression = assertJSXEmptyExpression;
exports.assertJSXExpressionContainer = assertJSXExpressionContainer;
exports.assertJSXSpreadChild = assertJSXSpreadChild;
exports.assertJSXIdentifier = assertJSXIdentifier;
exports.assertJSXMemberExpression = assertJSXMemberExpression;
exports.assertJSXNamespacedName = assertJSXNamespacedName;
exports.assertJSXOpeningElement = assertJSXOpeningElement;
exports.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
exports.assertJSXText = assertJSXText;
exports.assertJSXFragment = assertJSXFragment;
exports.assertJSXOpeningFragment = assertJSXOpeningFragment;
exports.assertJSXClosingFragment = assertJSXClosingFragment;
exports.assertNoop = assertNoop;
exports.assertPlaceholder = assertPlaceholder;
exports.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;
exports.assertArgumentPlaceholder = assertArgumentPlaceholder;
exports.assertBindExpression = assertBindExpression;
exports.assertClassProperty = assertClassProperty;
exports.assertPipelineTopicExpression = assertPipelineTopicExpression;
exports.assertPipelineBareFunction = assertPipelineBareFunction;
exports.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference;
exports.assertClassPrivateProperty = assertClassPrivateProperty;
exports.assertClassPrivateMethod = assertClassPrivateMethod;
exports.assertImportAttribute = assertImportAttribute;
exports.assertDecorator = assertDecorator;
exports.assertDoExpression = assertDoExpression;
exports.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
exports.assertPrivateName = assertPrivateName;
exports.assertRecordExpression = assertRecordExpression;
exports.assertTupleExpression = assertTupleExpression;
exports.assertDecimalLiteral = assertDecimalLiteral;
exports.assertTSParameterProperty = assertTSParameterProperty;
exports.assertTSDeclareFunction = assertTSDeclareFunction;
exports.assertTSDeclareMethod = assertTSDeclareMethod;
exports.assertTSQualifiedName = assertTSQualifiedName;
exports.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;
exports.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;
exports.assertTSPropertySignature = assertTSPropertySignature;
exports.assertTSMethodSignature = assertTSMethodSignature;
exports.assertTSIndexSignature = assertTSIndexSignature;
exports.assertTSAnyKeyword = assertTSAnyKeyword;
exports.assertTSBooleanKeyword = assertTSBooleanKeyword;
exports.assertTSBigIntKeyword = assertTSBigIntKeyword;
exports.assertTSNeverKeyword = assertTSNeverKeyword;
exports.assertTSNullKeyword = assertTSNullKeyword;
exports.assertTSNumberKeyword = assertTSNumberKeyword;
exports.assertTSObjectKeyword = assertTSObjectKeyword;
exports.assertTSStringKeyword = assertTSStringKeyword;
exports.assertTSSymbolKeyword = assertTSSymbolKeyword;
exports.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
exports.assertTSUnknownKeyword = assertTSUnknownKeyword;
exports.assertTSVoidKeyword = assertTSVoidKeyword;
exports.assertTSThisType = assertTSThisType;
exports.assertTSFunctionType = assertTSFunctionType;
exports.assertTSConstructorType = assertTSConstructorType;
exports.assertTSTypeReference = assertTSTypeReference;
exports.assertTSTypePredicate = assertTSTypePredicate;
exports.assertTSTypeQuery = assertTSTypeQuery;
exports.assertTSTypeLiteral = assertTSTypeLiteral;
exports.assertTSArrayType = assertTSArrayType;
exports.assertTSTupleType = assertTSTupleType;
exports.assertTSOptionalType = assertTSOptionalType;
exports.assertTSRestType = assertTSRestType;
exports.assertTSNamedTupleMember = assertTSNamedTupleMember;
exports.assertTSUnionType = assertTSUnionType;
exports.assertTSIntersectionType = assertTSIntersectionType;
exports.assertTSConditionalType = assertTSConditionalType;
exports.assertTSInferType = assertTSInferType;
exports.assertTSParenthesizedType = assertTSParenthesizedType;
exports.assertTSTypeOperator = assertTSTypeOperator;
exports.assertTSIndexedAccessType = assertTSIndexedAccessType;
exports.assertTSMappedType = assertTSMappedType;
exports.assertTSLiteralType = assertTSLiteralType;
exports.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;
exports.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
exports.assertTSInterfaceBody = assertTSInterfaceBody;
exports.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
exports.assertTSAsExpression = assertTSAsExpression;
exports.assertTSTypeAssertion = assertTSTypeAssertion;
exports.assertTSEnumDeclaration = assertTSEnumDeclaration;
exports.assertTSEnumMember = assertTSEnumMember;
exports.assertTSModuleDeclaration = assertTSModuleDeclaration;
exports.assertTSModuleBlock = assertTSModuleBlock;
exports.assertTSImportType = assertTSImportType;
exports.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;
exports.assertTSExternalModuleReference = assertTSExternalModuleReference;
exports.assertTSNonNullExpression = assertTSNonNullExpression;
exports.assertTSExportAssignment = assertTSExportAssignment;
exports.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;
exports.assertTSTypeAnnotation = assertTSTypeAnnotation;
exports.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;
exports.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;
exports.assertTSTypeParameter = assertTSTypeParameter;
exports.assertExpression = assertExpression;
exports.assertBinary = assertBinary;
exports.assertScopable = assertScopable;
exports.assertBlockParent = assertBlockParent;
exports.assertBlock = assertBlock;
exports.assertStatement = assertStatement;
exports.assertTerminatorless = assertTerminatorless;
exports.assertCompletionStatement = assertCompletionStatement;
exports.assertConditional = assertConditional;
exports.assertLoop = assertLoop;
exports.assertWhile = assertWhile;
exports.assertExpressionWrapper = assertExpressionWrapper;
exports.assertFor = assertFor;
exports.assertForXStatement = assertForXStatement;
exports.assertFunction = assertFunction;
exports.assertFunctionParent = assertFunctionParent;
exports.assertPureish = assertPureish;
exports.assertDeclaration = assertDeclaration;
exports.assertPatternLike = assertPatternLike;
exports.assertLVal = assertLVal;
exports.assertTSEntityName = assertTSEntityName;
exports.assertLiteral = assertLiteral;
exports.assertImmutable = assertImmutable;
exports.assertUserWhitespacable = assertUserWhitespacable;
exports.assertMethod = assertMethod;
exports.assertObjectMember = assertObjectMember;
exports.assertProperty = assertProperty;
exports.assertUnaryLike = assertUnaryLike;
exports.assertPattern = assertPattern;
exports.assertClass = assertClass;
exports.assertModuleDeclaration = assertModuleDeclaration;
exports.assertExportDeclaration = assertExportDeclaration;
exports.assertModuleSpecifier = assertModuleSpecifier;
exports.assertFlow = assertFlow;
exports.assertFlowType = assertFlowType;
exports.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
exports.assertFlowDeclaration = assertFlowDeclaration;
exports.assertFlowPredicate = assertFlowPredicate;
exports.assertEnumBody = assertEnumBody;
exports.assertEnumMember = assertEnumMember;
exports.assertJSX = assertJSX;
exports.assertPrivate = assertPrivate;
exports.assertTSTypeElement = assertTSTypeElement;
exports.assertTSType = assertTSType;
exports.assertTSBaseType = assertTSBaseType;
exports.assertNumberLiteral = assertNumberLiteral;
exports.assertRegexLiteral = assertRegexLiteral;
exports.assertRestProperty = assertRestProperty;
exports.assertSpreadProperty = assertSpreadProperty;

var _is = _interopRequireDefault(require("../../validators/is"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function assert(type, node, opts) {
  if (!(0, _is.default)(type, node, opts)) {
    throw new Error(`Expected type "${type}" with option ${JSON.stringify(opts)}, ` + `but instead got "${node.type}".`);
  }
}

function assertArrayExpression(node, opts = {}) {
  assert("ArrayExpression", node, opts);
}

function assertAssignmentExpression(node, opts = {}) {
  assert("AssignmentExpression", node, opts);
}

function assertBinaryExpression(node, opts = {}) {
  assert("BinaryExpression", node, opts);
}

function assertInterpreterDirective(node, opts = {}) {
  assert("InterpreterDirective", node, opts);
}

function assertDirective(node, opts = {}) {
  assert("Directive", node, opts);
}

function assertDirectiveLiteral(node, opts = {}) {
  assert("DirectiveLiteral", node, opts);
}

function assertBlockStatement(node, opts = {}) {
  assert("BlockStatement", node, opts);
}

function assertBreakStatement(node, opts = {}) {
  assert("BreakStatement", node, opts);
}

function assertCallExpression(node, opts = {}) {
  assert("CallExpression", node, opts);
}

function assertCatchClause(node, opts = {}) {
  assert("CatchClause", node, opts);
}

function assertConditionalExpression(node, opts = {}) {
  assert("ConditionalExpression", node, opts);
}

function assertContinueStatement(node, opts = {}) {
  assert("ContinueStatement", node, opts);
}

function assertDebuggerStatement(node, opts = {}) {
  assert("DebuggerStatement", node, opts);
}

function assertDoWhileStatement(node, opts = {}) {
  assert("DoWhileStatement", node, opts);
}

function assertEmptyStatement(node, opts = {}) {
  assert("EmptyStatement", node, opts);
}

function assertExpressionStatement(node, opts = {}) {
  assert("ExpressionStatement", node, opts);
}

function assertFile(node, opts = {}) {
  assert("File", node, opts);
}

function assertForInStatement(node, opts = {}) {
  assert("ForInStatement", node, opts);
}

function assertForStatement(node, opts = {}) {
  assert("ForStatement", node, opts);
}

function assertFunctionDeclaration(node, opts = {}) {
  assert("FunctionDeclaration", node, opts);
}

function assertFunctionExpression(node, opts = {}) {
  assert("FunctionExpression", node, opts);
}

function assertIdentifier(node, opts = {}) {
  assert("Identifier", node, opts);
}

function assertIfStatement(node, opts = {}) {
  assert("IfStatement", node, opts);
}

function assertLabeledStatement(node, opts = {}) {
  assert("LabeledStatement", node, opts);
}

function assertStringLiteral(node, opts = {}) {
  assert("StringLiteral", node, opts);
}

function assertNumericLiteral(node, opts = {}) {
  assert("NumericLiteral", node, opts);
}

function assertNullLiteral(node, opts = {}) {
  assert("NullLiteral", node, opts);
}

function assertBooleanLiteral(node, opts = {}) {
  assert("BooleanLiteral", node, opts);
}

function assertRegExpLiteral(node, opts = {}) {
  assert("RegExpLiteral", node, opts);
}

function assertLogicalExpression(node, opts = {}) {
  assert("LogicalExpression", node, opts);
}

function assertMemberExpression(node, opts = {}) {
  assert("MemberExpression", node, opts);
}

function assertNewExpression(node, opts = {}) {
  assert("NewExpression", node, opts);
}

function assertProgram(node, opts = {}) {
  assert("Program", node, opts);
}

function assertObjectExpression(node, opts = {}) {
  assert("ObjectExpression", node, opts);
}

function assertObjectMethod(node, opts = {}) {
  assert("ObjectMethod", node, opts);
}

function assertObjectProperty(node, opts = {}) {
  assert("ObjectProperty", node, opts);
}

function assertRestElement(node, opts = {}) {
  assert("RestElement", node, opts);
}

function assertReturnStatement(node, opts = {}) {
  assert("ReturnStatement", node, opts);
}

function assertSequenceExpression(node, opts = {}) {
  assert("SequenceExpression", node, opts);
}

function assertParenthesizedExpression(node, opts = {}) {
  assert("ParenthesizedExpression", node, opts);
}

function assertSwitchCase(node, opts = {}) {
  assert("SwitchCase", node, opts);
}

function assertSwitchStatement(node, opts = {}) {
  assert("SwitchStatement", node, opts);
}

function assertThisExpression(node, opts = {}) {
  assert("ThisExpression", node, opts);
}

function assertThrowStatement(node, opts = {}) {
  assert("ThrowStatement", node, opts);
}

function assertTryStatement(node, opts = {}) {
  assert("TryStatement", node, opts);
}

function assertUnaryExpression(node, opts = {}) {
  assert("UnaryExpression", node, opts);
}

function assertUpdateExpression(node, opts = {}) {
  assert("UpdateExpression", node, opts);
}

function assertVariableDeclaration(node, opts = {}) {
  assert("VariableDeclaration", node, opts);
}

function assertVariableDeclarator(node, opts = {}) {
  assert("VariableDeclarator", node, opts);
}

function assertWhileStatement(node, opts = {}) {
  assert("WhileStatement", node, opts);
}

function assertWithStatement(node, opts = {}) {
  assert("WithStatement", node, opts);
}

function assertAssignmentPattern(node, opts = {}) {
  assert("AssignmentPattern", node, opts);
}

function assertArrayPattern(node, opts = {}) {
  assert("ArrayPattern", node, opts);
}

function assertArrowFunctionExpression(node, opts = {}) {
  assert("ArrowFunctionExpression", node, opts);
}

function assertClassBody(node, opts = {}) {
  assert("ClassBody", node, opts);
}

function assertClassExpression(node, opts = {}) {
  assert("ClassExpression", node, opts);
}

function assertClassDeclaration(node, opts = {}) {
  assert("ClassDeclaration", node, opts);
}

function assertExportAllDeclaration(node, opts = {}) {
  assert("ExportAllDeclaration", node, opts);
}

function assertExportDefaultDeclaration(node, opts = {}) {
  assert("ExportDefaultDeclaration", node, opts);
}

function assertExportNamedDeclaration(node, opts = {}) {
  assert("ExportNamedDeclaration", node, opts);
}

function assertExportSpecifier(node, opts = {}) {
  assert("ExportSpecifier", node, opts);
}

function assertForOfStatement(node, opts = {}) {
  assert("ForOfStatement", node, opts);
}

function assertImportDeclaration(node, opts = {}) {
  assert("ImportDeclaration", node, opts);
}

function assertImportDefaultSpecifier(node, opts = {}) {
  assert("ImportDefaultSpecifier", node, opts);
}

function assertImportNamespaceSpecifier(node, opts = {}) {
  assert("ImportNamespaceSpecifier", node, opts);
}

function assertImportSpecifier(node, opts = {}) {
  assert("ImportSpecifier", node, opts);
}

function assertMetaProperty(node, opts = {}) {
  assert("MetaProperty", node, opts);
}

function assertClassMethod(node, opts = {}) {
  assert("ClassMethod", node, opts);
}

function assertObjectPattern(node, opts = {}) {
  assert("ObjectPattern", node, opts);
}

function assertSpreadElement(node, opts = {}) {
  assert("SpreadElement", node, opts);
}

function assertSuper(node, opts = {}) {
  assert("Super", node, opts);
}

function assertTaggedTemplateExpression(node, opts = {}) {
  assert("TaggedTemplateExpression", node, opts);
}

function assertTemplateElement(node, opts = {}) {
  assert("TemplateElement", node, opts);
}

function assertTemplateLiteral(node, opts = {}) {
  assert("TemplateLiteral", node, opts);
}

function assertYieldExpression(node, opts = {}) {
  assert("YieldExpression", node, opts);
}

function assertAwaitExpression(node, opts = {}) {
  assert("AwaitExpression", node, opts);
}

function assertImport(node, opts = {}) {
  assert("Import", node, opts);
}

function assertBigIntLiteral(node, opts = {}) {
  assert("BigIntLiteral", node, opts);
}

function assertExportNamespaceSpecifier(node, opts = {}) {
  assert("ExportNamespaceSpecifier", node, opts);
}

function assertOptionalMemberExpression(node, opts = {}) {
  assert("OptionalMemberExpression", node, opts);
}

function assertOptionalCallExpression(node, opts = {}) {
  assert("OptionalCallExpression", node, opts);
}

function assertAnyTypeAnnotation(node, opts = {}) {
  assert("AnyTypeAnnotation", node, opts);
}

function assertArrayTypeAnnotation(node, opts = {}) {
  assert("ArrayTypeAnnotation", node, opts);
}

function assertBooleanTypeAnnotation(node, opts = {}) {
  assert("BooleanTypeAnnotation", node, opts);
}

function assertBooleanLiteralTypeAnnotation(node, opts = {}) {
  assert("BooleanLiteralTypeAnnotation", node, opts);
}

function assertNullLiteralTypeAnnotation(node, opts = {}) {
  assert("NullLiteralTypeAnnotation", node, opts);
}

function assertClassImplements(node, opts = {}) {
  assert("ClassImplements", node, opts);
}

function assertDeclareClass(node, opts = {}) {
  assert("DeclareClass", node, opts);
}

function assertDeclareFunction(node, opts = {}) {
  assert("DeclareFunction", node, opts);
}

function assertDeclareInterface(node, opts = {}) {
  assert("DeclareInterface", node, opts);
}

function assertDeclareModule(node, opts = {}) {
  assert("DeclareModule", node, opts);
}

function assertDeclareModuleExports(node, opts = {}) {
  assert("DeclareModuleExports", node, opts);
}

function assertDeclareTypeAlias(node, opts = {}) {
  assert("DeclareTypeAlias", node, opts);
}

function assertDeclareOpaqueType(node, opts = {}) {
  assert("DeclareOpaqueType", node, opts);
}

function assertDeclareVariable(node, opts = {}) {
  assert("DeclareVariable", node, opts);
}

function assertDeclareExportDeclaration(node, opts = {}) {
  assert("DeclareExportDeclaration", node, opts);
}

function assertDeclareExportAllDeclaration(node, opts = {}) {
  assert("DeclareExportAllDeclaration", node, opts);
}

function assertDeclaredPredicate(node, opts = {}) {
  assert("DeclaredPredicate", node, opts);
}

function assertExistsTypeAnnotation(node, opts = {}) {
  assert("ExistsTypeAnnotation", node, opts);
}

function assertFunctionTypeAnnotation(node, opts = {}) {
  assert("FunctionTypeAnnotation", node, opts);
}

function assertFunctionTypeParam(node, opts = {}) {
  assert("FunctionTypeParam", node, opts);
}

function assertGenericTypeAnnotation(node, opts = {}) {
  assert("GenericTypeAnnotation", node, opts);
}

function assertInferredPredicate(node, opts = {}) {
  assert("InferredPredicate", node, opts);
}

function assertInterfaceExtends(node, opts = {}) {
  assert("InterfaceExtends", node, opts);
}

function assertInterfaceDeclaration(node, opts = {}) {
  assert("InterfaceDeclaration", node, opts);
}

function assertInterfaceTypeAnnotation(node, opts = {}) {
  assert("InterfaceTypeAnnotation", node, opts);
}

function assertIntersectionTypeAnnotation(node, opts = {}) {
  assert("IntersectionTypeAnnotation", node, opts);
}

function assertMixedTypeAnnotation(node, opts = {}) {
  assert("MixedTypeAnnotation", node, opts);
}

function assertEmptyTypeAnnotation(node, opts = {}) {
  assert("EmptyTypeAnnotation", node, opts);
}

function assertNullableTypeAnnotation(node, opts = {}) {
  assert("NullableTypeAnnotation", node, opts);
}

function assertNumberLiteralTypeAnnotation(node, opts = {}) {
  assert("NumberLiteralTypeAnnotation", node, opts);
}

function assertNumberTypeAnnotation(node, opts = {}) {
  assert("NumberTypeAnnotation", node, opts);
}

function assertObjectTypeAnnotation(node, opts = {}) {
  assert("ObjectTypeAnnotation", node, opts);
}

function assertObjectTypeInternalSlot(node, opts = {}) {
  assert("ObjectTypeInternalSlot", node, opts);
}

function assertObjectTypeCallProperty(node, opts = {}) {
  assert("ObjectTypeCallProperty", node, opts);
}

function assertObjectTypeIndexer(node, opts = {}) {
  assert("ObjectTypeIndexer", node, opts);
}

function assertObjectTypeProperty(node, opts = {}) {
  assert("ObjectTypeProperty", node, opts);
}

function assertObjectTypeSpreadProperty(node, opts = {}) {
  assert("ObjectTypeSpreadProperty", node, opts);
}

function assertOpaqueType(node, opts = {}) {
  assert("OpaqueType", node, opts);
}

function assertQualifiedTypeIdentifier(node, opts = {}) {
  assert("QualifiedTypeIdentifier", node, opts);
}

function assertStringLiteralTypeAnnotation(node, opts = {}) {
  assert("StringLiteralTypeAnnotation", node, opts);
}

function assertStringTypeAnnotation(node, opts = {}) {
  assert("StringTypeAnnotation", node, opts);
}

function assertSymbolTypeAnnotation(node, opts = {}) {
  assert("SymbolTypeAnnotation", node, opts);
}

function assertThisTypeAnnotation(node, opts = {}) {
  assert("ThisTypeAnnotation", node, opts);
}

function assertTupleTypeAnnotation(node, opts = {}) {
  assert("TupleTypeAnnotation", node, opts);
}

function assertTypeofTypeAnnotation(node, opts = {}) {
  assert("TypeofTypeAnnotation", node, opts);
}

function assertTypeAlias(node, opts = {}) {
  assert("TypeAlias", node, opts);
}

function assertTypeAnnotation(node, opts = {}) {
  assert("TypeAnnotation", node, opts);
}

function assertTypeCastExpression(node, opts = {}) {
  assert("TypeCastExpression", node, opts);
}

function assertTypeParameter(node, opts = {}) {
  assert("TypeParameter", node, opts);
}

function assertTypeParameterDeclaration(node, opts = {}) {
  assert("TypeParameterDeclaration", node, opts);
}

function assertTypeParameterInstantiation(node, opts = {}) {
  assert("TypeParameterInstantiation", node, opts);
}

function assertUnionTypeAnnotation(node, opts = {}) {
  assert("UnionTypeAnnotation", node, opts);
}

function assertVariance(node, opts = {}) {
  assert("Variance", node, opts);
}

function assertVoidTypeAnnotation(node, opts = {}) {
  assert("VoidTypeAnnotation", node, opts);
}

function assertEnumDeclaration(node, opts = {}) {
  assert("EnumDeclaration", node, opts);
}

function assertEnumBooleanBody(node, opts = {}) {
  assert("EnumBooleanBody", node, opts);
}

function assertEnumNumberBody(node, opts = {}) {
  assert("EnumNumberBody", node, opts);
}

function assertEnumStringBody(node, opts = {}) {
  assert("EnumStringBody", node, opts);
}

function assertEnumSymbolBody(node, opts = {}) {
  assert("EnumSymbolBody", node, opts);
}

function assertEnumBooleanMember(node, opts = {}) {
  assert("EnumBooleanMember", node, opts);
}

function assertEnumNumberMember(node, opts = {}) {
  assert("EnumNumberMember", node, opts);
}

function assertEnumStringMember(node, opts = {}) {
  assert("EnumStringMember", node, opts);
}

function assertEnumDefaultedMember(node, opts = {}) {
  assert("EnumDefaultedMember", node, opts);
}

function assertJSXAttribute(node, opts = {}) {
  assert("JSXAttribute", node, opts);
}

function assertJSXClosingElement(node, opts = {}) {
  assert("JSXClosingElement", node, opts);
}

function assertJSXElement(node, opts = {}) {
  assert("JSXElement", node, opts);
}

function assertJSXEmptyExpression(node, opts = {}) {
  assert("JSXEmptyExpression", node, opts);
}

function assertJSXExpressionContainer(node, opts = {}) {
  assert("JSXExpressionContainer", node, opts);
}

function assertJSXSpreadChild(node, opts = {}) {
  assert("JSXSpreadChild", node, opts);
}

function assertJSXIdentifier(node, opts = {}) {
  assert("JSXIdentifier", node, opts);
}

function assertJSXMemberExpression(node, opts = {}) {
  assert("JSXMemberExpression", node, opts);
}

function assertJSXNamespacedName(node, opts = {}) {
  assert("JSXNamespacedName", node, opts);
}

function assertJSXOpeningElement(node, opts = {}) {
  assert("JSXOpeningElement", node, opts);
}

function assertJSXSpreadAttribute(node, opts = {}) {
  assert("JSXSpreadAttribute", node, opts);
}

function assertJSXText(node, opts = {}) {
  assert("JSXText", node, opts);
}

function assertJSXFragment(node, opts = {}) {
  assert("JSXFragment", node, opts);
}

function assertJSXOpeningFragment(node, opts = {}) {
  assert("JSXOpeningFragment", node, opts);
}

function assertJSXClosingFragment(node, opts = {}) {
  assert("JSXClosingFragment", node, opts);
}

function assertNoop(node, opts = {}) {
  assert("Noop", node, opts);
}

function assertPlaceholder(node, opts = {}) {
  assert("Placeholder", node, opts);
}

function assertV8IntrinsicIdentifier(node, opts = {}) {
  assert("V8IntrinsicIdentifier", node, opts);
}

function assertArgumentPlaceholder(node, opts = {}) {
  assert("ArgumentPlaceholder", node, opts);
}

function assertBindExpression(node, opts = {}) {
  assert("BindExpression", node, opts);
}

function assertClassProperty(node, opts = {}) {
  assert("ClassProperty", node, opts);
}

function assertPipelineTopicExpression(node, opts = {}) {
  assert("PipelineTopicExpression", node, opts);
}

function assertPipelineBareFunction(node, opts = {}) {
  assert("PipelineBareFunction", node, opts);
}

function assertPipelinePrimaryTopicReference(node, opts = {}) {
  assert("PipelinePrimaryTopicReference", node, opts);
}

function assertClassPrivateProperty(node, opts = {}) {
  assert("ClassPrivateProperty", node, opts);
}

function assertClassPrivateMethod(node, opts = {}) {
  assert("ClassPrivateMethod", node, opts);
}

function assertImportAttribute(node, opts = {}) {
  assert("ImportAttribute", node, opts);
}

function assertDecorator(node, opts = {}) {
  assert("Decorator", node, opts);
}

function assertDoExpression(node, opts = {}) {
  assert("DoExpression", node, opts);
}

function assertExportDefaultSpecifier(node, opts = {}) {
  assert("ExportDefaultSpecifier", node, opts);
}

function assertPrivateName(node, opts = {}) {
  assert("PrivateName", node, opts);
}

function assertRecordExpression(node, opts = {}) {
  assert("RecordExpression", node, opts);
}

function assertTupleExpression(node, opts = {}) {
  assert("TupleExpression", node, opts);
}

function assertDecimalLiteral(node, opts = {}) {
  assert("DecimalLiteral", node, opts);
}

function assertTSParameterProperty(node, opts = {}) {
  assert("TSParameterProperty", node, opts);
}

function assertTSDeclareFunction(node, opts = {}) {
  assert("TSDeclareFunction", node, opts);
}

function assertTSDeclareMethod(node, opts = {}) {
  assert("TSDeclareMethod", node, opts);
}

function assertTSQualifiedName(node, opts = {}) {
  assert("TSQualifiedName", node, opts);
}

function assertTSCallSignatureDeclaration(node, opts = {}) {
  assert("TSCallSignatureDeclaration", node, opts);
}

function assertTSConstructSignatureDeclaration(node, opts = {}) {
  assert("TSConstructSignatureDeclaration", node, opts);
}

function assertTSPropertySignature(node, opts = {}) {
  assert("TSPropertySignature", node, opts);
}

function assertTSMethodSignature(node, opts = {}) {
  assert("TSMethodSignature", node, opts);
}

function assertTSIndexSignature(node, opts = {}) {
  assert("TSIndexSignature", node, opts);
}

function assertTSAnyKeyword(node, opts = {}) {
  assert("TSAnyKeyword", node, opts);
}

function assertTSBooleanKeyword(node, opts = {}) {
  assert("TSBooleanKeyword", node, opts);
}

function assertTSBigIntKeyword(node, opts = {}) {
  assert("TSBigIntKeyword", node, opts);
}

function assertTSNeverKeyword(node, opts = {}) {
  assert("TSNeverKeyword", node, opts);
}

function assertTSNullKeyword(node, opts = {}) {
  assert("TSNullKeyword", node, opts);
}

function assertTSNumberKeyword(node, opts = {}) {
  assert("TSNumberKeyword", node, opts);
}

function assertTSObjectKeyword(node, opts = {}) {
  assert("TSObjectKeyword", node, opts);
}

function assertTSStringKeyword(node, opts = {}) {
  assert("TSStringKeyword", node, opts);
}

function assertTSSymbolKeyword(node, opts = {}) {
  assert("TSSymbolKeyword", node, opts);
}

function assertTSUndefinedKeyword(node, opts = {}) {
  assert("TSUndefinedKeyword", node, opts);
}

function assertTSUnknownKeyword(node, opts = {}) {
  assert("TSUnknownKeyword", node, opts);
}

function assertTSVoidKeyword(node, opts = {}) {
  assert("TSVoidKeyword", node, opts);
}

function assertTSThisType(node, opts = {}) {
  assert("TSThisType", node, opts);
}

function assertTSFunctionType(node, opts = {}) {
  assert("TSFunctionType", node, opts);
}

function assertTSConstructorType(node, opts = {}) {
  assert("TSConstructorType", node, opts);
}

function assertTSTypeReference(node, opts = {}) {
  assert("TSTypeReference", node, opts);
}

function assertTSTypePredicate(node, opts = {}) {
  assert("TSTypePredicate", node, opts);
}

function assertTSTypeQuery(node, opts = {}) {
  assert("TSTypeQuery", node, opts);
}

function assertTSTypeLiteral(node, opts = {}) {
  assert("TSTypeLiteral", node, opts);
}

function assertTSArrayType(node, opts = {}) {
  assert("TSArrayType", node, opts);
}

function assertTSTupleType(node, opts = {}) {
  assert("TSTupleType", node, opts);
}

function assertTSOptionalType(node, opts = {}) {
  assert("TSOptionalType", node, opts);
}

function assertTSRestType(node, opts = {}) {
  assert("TSRestType", node, opts);
}

function assertTSNamedTupleMember(node, opts = {}) {
  assert("TSNamedTupleMember", node, opts);
}

function assertTSUnionType(node, opts = {}) {
  assert("TSUnionType", node, opts);
}

function assertTSIntersectionType(node, opts = {}) {
  assert("TSIntersectionType", node, opts);
}

function assertTSConditionalType(node, opts = {}) {
  assert("TSConditionalType", node, opts);
}

function assertTSInferType(node, opts = {}) {
  assert("TSInferType", node, opts);
}

function assertTSParenthesizedType(node, opts = {}) {
  assert("TSParenthesizedType", node, opts);
}

function assertTSTypeOperator(node, opts = {}) {
  assert("TSTypeOperator", node, opts);
}

function assertTSIndexedAccessType(node, opts = {}) {
  assert("TSIndexedAccessType", node, opts);
}

function assertTSMappedType(node, opts = {}) {
  assert("TSMappedType", node, opts);
}

function assertTSLiteralType(node, opts = {}) {
  assert("TSLiteralType", node, opts);
}

function assertTSExpressionWithTypeArguments(node, opts = {}) {
  assert("TSExpressionWithTypeArguments", node, opts);
}

function assertTSInterfaceDeclaration(node, opts = {}) {
  assert("TSInterfaceDeclaration", node, opts);
}

function assertTSInterfaceBody(node, opts = {}) {
  assert("TSInterfaceBody", node, opts);
}

function assertTSTypeAliasDeclaration(node, opts = {}) {
  assert("TSTypeAliasDeclaration", node, opts);
}

function assertTSAsExpression(node, opts = {}) {
  assert("TSAsExpression", node, opts);
}

function assertTSTypeAssertion(node, opts = {}) {
  assert("TSTypeAssertion", node, opts);
}

function assertTSEnumDeclaration(node, opts = {}) {
  assert("TSEnumDeclaration", node, opts);
}

function assertTSEnumMember(node, opts = {}) {
  assert("TSEnumMember", node, opts);
}

function assertTSModuleDeclaration(node, opts = {}) {
  assert("TSModuleDeclaration", node, opts);
}

function assertTSModuleBlock(node, opts = {}) {
  assert("TSModuleBlock", node, opts);
}

function assertTSImportType(node, opts = {}) {
  assert("TSImportType", node, opts);
}

function assertTSImportEqualsDeclaration(node, opts = {}) {
  assert("TSImportEqualsDeclaration", node, opts);
}

function assertTSExternalModuleReference(node, opts = {}) {
  assert("TSExternalModuleReference", node, opts);
}

function assertTSNonNullExpression(node, opts = {}) {
  assert("TSNonNullExpression", node, opts);
}

function assertTSExportAssignment(node, opts = {}) {
  assert("TSExportAssignment", node, opts);
}

function assertTSNamespaceExportDeclaration(node, opts = {}) {
  assert("TSNamespaceExportDeclaration", node, opts);
}

function assertTSTypeAnnotation(node, opts = {}) {
  assert("TSTypeAnnotation", node, opts);
}

function assertTSTypeParameterInstantiation(node, opts = {}) {
  assert("TSTypeParameterInstantiation", node, opts);
}

function assertTSTypeParameterDeclaration(node, opts = {}) {
  assert("TSTypeParameterDeclaration", node, opts);
}

function assertTSTypeParameter(node, opts = {}) {
  assert("TSTypeParameter", node, opts);
}

function assertExpression(node, opts = {}) {
  assert("Expression", node, opts);
}

function assertBinary(node, opts = {}) {
  assert("Binary", node, opts);
}

function assertScopable(node, opts = {}) {
  assert("Scopable", node, opts);
}

function assertBlockParent(node, opts = {}) {
  assert("BlockParent", node, opts);
}

function assertBlock(node, opts = {}) {
  assert("Block", node, opts);
}

function assertStatement(node, opts = {}) {
  assert("Statement", node, opts);
}

function assertTerminatorless(node, opts = {}) {
  assert("Terminatorless", node, opts);
}

function assertCompletionStatement(node, opts = {}) {
  assert("CompletionStatement", node, opts);
}

function assertConditional(node, opts = {}) {
  assert("Conditional", node, opts);
}

function assertLoop(node, opts = {}) {
  assert("Loop", node, opts);
}

function assertWhile(node, opts = {}) {
  assert("While", node, opts);
}

function assertExpressionWrapper(node, opts = {}) {
  assert("ExpressionWrapper", node, opts);
}

function assertFor(node, opts = {}) {
  assert("For", node, opts);
}

function assertForXStatement(node, opts = {}) {
  assert("ForXStatement", node, opts);
}

function assertFunction(node, opts = {}) {
  assert("Function", node, opts);
}

function assertFunctionParent(node, opts = {}) {
  assert("FunctionParent", node, opts);
}

function assertPureish(node, opts = {}) {
  assert("Pureish", node, opts);
}

function assertDeclaration(node, opts = {}) {
  assert("Declaration", node, opts);
}

function assertPatternLike(node, opts = {}) {
  assert("PatternLike", node, opts);
}

function assertLVal(node, opts = {}) {
  assert("LVal", node, opts);
}

function assertTSEntityName(node, opts = {}) {
  assert("TSEntityName", node, opts);
}

function assertLiteral(node, opts = {}) {
  assert("Literal", node, opts);
}

function assertImmutable(node, opts = {}) {
  assert("Immutable", node, opts);
}

function assertUserWhitespacable(node, opts = {}) {
  assert("UserWhitespacable", node, opts);
}

function assertMethod(node, opts = {}) {
  assert("Method", node, opts);
}

function assertObjectMember(node, opts = {}) {
  assert("ObjectMember", node, opts);
}

function assertProperty(node, opts = {}) {
  assert("Property", node, opts);
}

function assertUnaryLike(node, opts = {}) {
  assert("UnaryLike", node, opts);
}

function assertPattern(node, opts = {}) {
  assert("Pattern", node, opts);
}

function assertClass(node, opts = {}) {
  assert("Class", node, opts);
}

function assertModuleDeclaration(node, opts = {}) {
  assert("ModuleDeclaration", node, opts);
}

function assertExportDeclaration(node, opts = {}) {
  assert("ExportDeclaration", node, opts);
}

function assertModuleSpecifier(node, opts = {}) {
  assert("ModuleSpecifier", node, opts);
}

function assertFlow(node, opts = {}) {
  assert("Flow", node, opts);
}

function assertFlowType(node, opts = {}) {
  assert("FlowType", node, opts);
}

function assertFlowBaseAnnotation(node, opts = {}) {
  assert("FlowBaseAnnotation", node, opts);
}

function assertFlowDeclaration(node, opts = {}) {
  assert("FlowDeclaration", node, opts);
}

function assertFlowPredicate(node, opts = {}) {
  assert("FlowPredicate", node, opts);
}

function assertEnumBody(node, opts = {}) {
  assert("EnumBody", node, opts);
}

function assertEnumMember(node, opts = {}) {
  assert("EnumMember", node, opts);
}

function assertJSX(node, opts = {}) {
  assert("JSX", node, opts);
}

function assertPrivate(node, opts = {}) {
  assert("Private", node, opts);
}

function assertTSTypeElement(node, opts = {}) {
  assert("TSTypeElement", node, opts);
}

function assertTSType(node, opts = {}) {
  assert("TSType", node, opts);
}

function assertTSBaseType(node, opts = {}) {
  assert("TSBaseType", node, opts);
}

function assertNumberLiteral(node, opts) {
  console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
  assert("NumberLiteral", node, opts);
}

function assertRegexLiteral(node, opts) {
  console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
  assert("RegexLiteral", node, opts);
}

function assertRestProperty(node, opts) {
  console.trace("The node type RestProperty has been renamed to RestElement");
  assert("RestProperty", node, opts);
}

function assertSpreadProperty(node, opts) {
  console.trace("The node type SpreadProperty has been renamed to SpreadElement");
  assert("SpreadProperty", node, opts);
}
},{"../../validators/is":89}],32:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = builder;

var _clone = _interopRequireDefault(require("lodash/clone"));

var _definitions = require("../definitions");

var _validate = _interopRequireDefault(require("../validators/validate"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function builder(type, ...args) {
  const keys = _definitions.BUILDER_KEYS[type];
  const countArgs = args.length;

  if (countArgs > keys.length) {
    throw new Error(`${type}: Too many arguments passed. Received ${countArgs} but can receive no more than ${keys.length}`);
  }

  const node = {
    type
  };
  let i = 0;
  keys.forEach(key => {
    const field = _definitions.NODE_FIELDS[type][key];
    let arg;
    if (i < countArgs) arg = args[i];
    if (arg === undefined) arg = (0, _clone.default)(field.default);
    node[key] = arg;
    i++;
  });

  for (const key of Object.keys(node)) {
    (0, _validate.default)(node, key, node[key]);
  }

  return node;
}
},{"../definitions":66,"../validators/validate":107,"lodash/clone":205}],33:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createFlowUnionType;

var _generated = require("../generated");

var _removeTypeDuplicates = _interopRequireDefault(require("../../modifications/flow/removeTypeDuplicates"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createFlowUnionType(types) {
  const flattened = (0, _removeTypeDuplicates.default)(types);

  if (flattened.length === 1) {
    return flattened[0];
  } else {
    return (0, _generated.unionTypeAnnotation)(flattened);
  }
}
},{"../../modifications/flow/removeTypeDuplicates":74,"../generated":35}],34:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createTypeAnnotationBasedOnTypeof;

var _generated = require("../generated");

function createTypeAnnotationBasedOnTypeof(type) {
  if (type === "string") {
    return (0, _generated.stringTypeAnnotation)();
  } else if (type === "number") {
    return (0, _generated.numberTypeAnnotation)();
  } else if (type === "undefined") {
    return (0, _generated.voidTypeAnnotation)();
  } else if (type === "boolean") {
    return (0, _generated.booleanTypeAnnotation)();
  } else if (type === "function") {
    return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Function"));
  } else if (type === "object") {
    return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Object"));
  } else if (type === "symbol") {
    return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Symbol"));
  } else {
    throw new Error("Invalid typeof value");
  }
}
},{"../generated":35}],35:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ArrayExpression = exports.arrayExpression = arrayExpression;
exports.AssignmentExpression = exports.assignmentExpression = assignmentExpression;
exports.BinaryExpression = exports.binaryExpression = binaryExpression;
exports.InterpreterDirective = exports.interpreterDirective = interpreterDirective;
exports.Directive = exports.directive = directive;
exports.DirectiveLiteral = exports.directiveLiteral = directiveLiteral;
exports.BlockStatement = exports.blockStatement = blockStatement;
exports.BreakStatement = exports.breakStatement = breakStatement;
exports.CallExpression = exports.callExpression = callExpression;
exports.CatchClause = exports.catchClause = catchClause;
exports.ConditionalExpression = exports.conditionalExpression = conditionalExpression;
exports.ContinueStatement = exports.continueStatement = continueStatement;
exports.DebuggerStatement = exports.debuggerStatement = debuggerStatement;
exports.DoWhileStatement = exports.doWhileStatement = doWhileStatement;
exports.EmptyStatement = exports.emptyStatement = emptyStatement;
exports.ExpressionStatement = exports.expressionStatement = expressionStatement;
exports.File = exports.file = file;
exports.ForInStatement = exports.forInStatement = forInStatement;
exports.ForStatement = exports.forStatement = forStatement;
exports.FunctionDeclaration = exports.functionDeclaration = functionDeclaration;
exports.FunctionExpression = exports.functionExpression = functionExpression;
exports.Identifier = exports.identifier = identifier;
exports.IfStatement = exports.ifStatement = ifStatement;
exports.LabeledStatement = exports.labeledStatement = labeledStatement;
exports.StringLiteral = exports.stringLiteral = stringLiteral;
exports.NumericLiteral = exports.numericLiteral = numericLiteral;
exports.NullLiteral = exports.nullLiteral = nullLiteral;
exports.BooleanLiteral = exports.booleanLiteral = booleanLiteral;
exports.RegExpLiteral = exports.regExpLiteral = regExpLiteral;
exports.LogicalExpression = exports.logicalExpression = logicalExpression;
exports.MemberExpression = exports.memberExpression = memberExpression;
exports.NewExpression = exports.newExpression = newExpression;
exports.Program = exports.program = program;
exports.ObjectExpression = exports.objectExpression = objectExpression;
exports.ObjectMethod = exports.objectMethod = objectMethod;
exports.ObjectProperty = exports.objectProperty = objectProperty;
exports.RestElement = exports.restElement = restElement;
exports.ReturnStatement = exports.returnStatement = returnStatement;
exports.SequenceExpression = exports.sequenceExpression = sequenceExpression;
exports.ParenthesizedExpression = exports.parenthesizedExpression = parenthesizedExpression;
exports.SwitchCase = exports.switchCase = switchCase;
exports.SwitchStatement = exports.switchStatement = switchStatement;
exports.ThisExpression = exports.thisExpression = thisExpression;
exports.ThrowStatement = exports.throwStatement = throwStatement;
exports.TryStatement = exports.tryStatement = tryStatement;
exports.UnaryExpression = exports.unaryExpression = unaryExpression;
exports.UpdateExpression = exports.updateExpression = updateExpression;
exports.VariableDeclaration = exports.variableDeclaration = variableDeclaration;
exports.VariableDeclarator = exports.variableDeclarator = variableDeclarator;
exports.WhileStatement = exports.whileStatement = whileStatement;
exports.WithStatement = exports.withStatement = withStatement;
exports.AssignmentPattern = exports.assignmentPattern = assignmentPattern;
exports.ArrayPattern = exports.arrayPattern = arrayPattern;
exports.ArrowFunctionExpression = exports.arrowFunctionExpression = arrowFunctionExpression;
exports.ClassBody = exports.classBody = classBody;
exports.ClassExpression = exports.classExpression = classExpression;
exports.ClassDeclaration = exports.classDeclaration = classDeclaration;
exports.ExportAllDeclaration = exports.exportAllDeclaration = exportAllDeclaration;
exports.ExportDefaultDeclaration = exports.exportDefaultDeclaration = exportDefaultDeclaration;
exports.ExportNamedDeclaration = exports.exportNamedDeclaration = exportNamedDeclaration;
exports.ExportSpecifier = exports.exportSpecifier = exportSpecifier;
exports.ForOfStatement = exports.forOfStatement = forOfStatement;
exports.ImportDeclaration = exports.importDeclaration = importDeclaration;
exports.ImportDefaultSpecifier = exports.importDefaultSpecifier = importDefaultSpecifier;
exports.ImportNamespaceSpecifier = exports.importNamespaceSpecifier = importNamespaceSpecifier;
exports.ImportSpecifier = exports.importSpecifier = importSpecifier;
exports.MetaProperty = exports.metaProperty = metaProperty;
exports.ClassMethod = exports.classMethod = classMethod;
exports.ObjectPattern = exports.objectPattern = objectPattern;
exports.SpreadElement = exports.spreadElement = spreadElement;
exports.super = exports.Super = _super;
exports.TaggedTemplateExpression = exports.taggedTemplateExpression = taggedTemplateExpression;
exports.TemplateElement = exports.templateElement = templateElement;
exports.TemplateLiteral = exports.templateLiteral = templateLiteral;
exports.YieldExpression = exports.yieldExpression = yieldExpression;
exports.AwaitExpression = exports.awaitExpression = awaitExpression;
exports.import = exports.Import = _import;
exports.BigIntLiteral = exports.bigIntLiteral = bigIntLiteral;
exports.ExportNamespaceSpecifier = exports.exportNamespaceSpecifier = exportNamespaceSpecifier;
exports.OptionalMemberExpression = exports.optionalMemberExpression = optionalMemberExpression;
exports.OptionalCallExpression = exports.optionalCallExpression = optionalCallExpression;
exports.AnyTypeAnnotation = exports.anyTypeAnnotation = anyTypeAnnotation;
exports.ArrayTypeAnnotation = exports.arrayTypeAnnotation = arrayTypeAnnotation;
exports.BooleanTypeAnnotation = exports.booleanTypeAnnotation = booleanTypeAnnotation;
exports.BooleanLiteralTypeAnnotation = exports.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
exports.NullLiteralTypeAnnotation = exports.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
exports.ClassImplements = exports.classImplements = classImplements;
exports.DeclareClass = exports.declareClass = declareClass;
exports.DeclareFunction = exports.declareFunction = declareFunction;
exports.DeclareInterface = exports.declareInterface = declareInterface;
exports.DeclareModule = exports.declareModule = declareModule;
exports.DeclareModuleExports = exports.declareModuleExports = declareModuleExports;
exports.DeclareTypeAlias = exports.declareTypeAlias = declareTypeAlias;
exports.DeclareOpaqueType = exports.declareOpaqueType = declareOpaqueType;
exports.DeclareVariable = exports.declareVariable = declareVariable;
exports.DeclareExportDeclaration = exports.declareExportDeclaration = declareExportDeclaration;
exports.DeclareExportAllDeclaration = exports.declareExportAllDeclaration = declareExportAllDeclaration;
exports.DeclaredPredicate = exports.declaredPredicate = declaredPredicate;
exports.ExistsTypeAnnotation = exports.existsTypeAnnotation = existsTypeAnnotation;
exports.FunctionTypeAnnotation = exports.functionTypeAnnotation = functionTypeAnnotation;
exports.FunctionTypeParam = exports.functionTypeParam = functionTypeParam;
exports.GenericTypeAnnotation = exports.genericTypeAnnotation = genericTypeAnnotation;
exports.InferredPredicate = exports.inferredPredicate = inferredPredicate;
exports.InterfaceExtends = exports.interfaceExtends = interfaceExtends;
exports.InterfaceDeclaration = exports.interfaceDeclaration = interfaceDeclaration;
exports.InterfaceTypeAnnotation = exports.interfaceTypeAnnotation = interfaceTypeAnnotation;
exports.IntersectionTypeAnnotation = exports.intersectionTypeAnnotation = intersectionTypeAnnotation;
exports.MixedTypeAnnotation = exports.mixedTypeAnnotation = mixedTypeAnnotation;
exports.EmptyTypeAnnotation = exports.emptyTypeAnnotation = emptyTypeAnnotation;
exports.NullableTypeAnnotation = exports.nullableTypeAnnotation = nullableTypeAnnotation;
exports.NumberLiteralTypeAnnotation = exports.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
exports.NumberTypeAnnotation = exports.numberTypeAnnotation = numberTypeAnnotation;
exports.ObjectTypeAnnotation = exports.objectTypeAnnotation = objectTypeAnnotation;
exports.ObjectTypeInternalSlot = exports.objectTypeInternalSlot = objectTypeInternalSlot;
exports.ObjectTypeCallProperty = exports.objectTypeCallProperty = objectTypeCallProperty;
exports.ObjectTypeIndexer = exports.objectTypeIndexer = objectTypeIndexer;
exports.ObjectTypeProperty = exports.objectTypeProperty = objectTypeProperty;
exports.ObjectTypeSpreadProperty = exports.objectTypeSpreadProperty = objectTypeSpreadProperty;
exports.OpaqueType = exports.opaqueType = opaqueType;
exports.QualifiedTypeIdentifier = exports.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
exports.StringLiteralTypeAnnotation = exports.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
exports.StringTypeAnnotation = exports.stringTypeAnnotation = stringTypeAnnotation;
exports.SymbolTypeAnnotation = exports.symbolTypeAnnotation = symbolTypeAnnotation;
exports.ThisTypeAnnotation = exports.thisTypeAnnotation = thisTypeAnnotation;
exports.TupleTypeAnnotation = exports.tupleTypeAnnotation = tupleTypeAnnotation;
exports.TypeofTypeAnnotation = exports.typeofTypeAnnotation = typeofTypeAnnotation;
exports.TypeAlias = exports.typeAlias = typeAlias;
exports.TypeAnnotation = exports.typeAnnotation = typeAnnotation;
exports.TypeCastExpression = exports.typeCastExpression = typeCastExpression;
exports.TypeParameter = exports.typeParameter = typeParameter;
exports.TypeParameterDeclaration = exports.typeParameterDeclaration = typeParameterDeclaration;
exports.TypeParameterInstantiation = exports.typeParameterInstantiation = typeParameterInstantiation;
exports.UnionTypeAnnotation = exports.unionTypeAnnotation = unionTypeAnnotation;
exports.Variance = exports.variance = variance;
exports.VoidTypeAnnotation = exports.voidTypeAnnotation = voidTypeAnnotation;
exports.EnumDeclaration = exports.enumDeclaration = enumDeclaration;
exports.EnumBooleanBody = exports.enumBooleanBody = enumBooleanBody;
exports.EnumNumberBody = exports.enumNumberBody = enumNumberBody;
exports.EnumStringBody = exports.enumStringBody = enumStringBody;
exports.EnumSymbolBody = exports.enumSymbolBody = enumSymbolBody;
exports.EnumBooleanMember = exports.enumBooleanMember = enumBooleanMember;
exports.EnumNumberMember = exports.enumNumberMember = enumNumberMember;
exports.EnumStringMember = exports.enumStringMember = enumStringMember;
exports.EnumDefaultedMember = exports.enumDefaultedMember = enumDefaultedMember;
exports.jSXAttribute = exports.JSXAttribute = exports.jsxAttribute = jsxAttribute;
exports.jSXClosingElement = exports.JSXClosingElement = exports.jsxClosingElement = jsxClosingElement;
exports.jSXElement = exports.JSXElement = exports.jsxElement = jsxElement;
exports.jSXEmptyExpression = exports.JSXEmptyExpression = exports.jsxEmptyExpression = jsxEmptyExpression;
exports.jSXExpressionContainer = exports.JSXExpressionContainer = exports.jsxExpressionContainer = jsxExpressionContainer;
exports.jSXSpreadChild = exports.JSXSpreadChild = exports.jsxSpreadChild = jsxSpreadChild;
exports.jSXIdentifier = exports.JSXIdentifier = exports.jsxIdentifier = jsxIdentifier;
exports.jSXMemberExpression = exports.JSXMemberExpression = exports.jsxMemberExpression = jsxMemberExpression;
exports.jSXNamespacedName = exports.JSXNamespacedName = exports.jsxNamespacedName = jsxNamespacedName;
exports.jSXOpeningElement = exports.JSXOpeningElement = exports.jsxOpeningElement = jsxOpeningElement;
exports.jSXSpreadAttribute = exports.JSXSpreadAttribute = exports.jsxSpreadAttribute = jsxSpreadAttribute;
exports.jSXText = exports.JSXText = exports.jsxText = jsxText;
exports.jSXFragment = exports.JSXFragment = exports.jsxFragment = jsxFragment;
exports.jSXOpeningFragment = exports.JSXOpeningFragment = exports.jsxOpeningFragment = jsxOpeningFragment;
exports.jSXClosingFragment = exports.JSXClosingFragment = exports.jsxClosingFragment = jsxClosingFragment;
exports.Noop = exports.noop = noop;
exports.Placeholder = exports.placeholder = placeholder;
exports.V8IntrinsicIdentifier = exports.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
exports.ArgumentPlaceholder = exports.argumentPlaceholder = argumentPlaceholder;
exports.BindExpression = exports.bindExpression = bindExpression;
exports.ClassProperty = exports.classProperty = classProperty;
exports.PipelineTopicExpression = exports.pipelineTopicExpression = pipelineTopicExpression;
exports.PipelineBareFunction = exports.pipelineBareFunction = pipelineBareFunction;
exports.PipelinePrimaryTopicReference = exports.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
exports.ClassPrivateProperty = exports.classPrivateProperty = classPrivateProperty;
exports.ClassPrivateMethod = exports.classPrivateMethod = classPrivateMethod;
exports.ImportAttribute = exports.importAttribute = importAttribute;
exports.Decorator = exports.decorator = decorator;
exports.DoExpression = exports.doExpression = doExpression;
exports.ExportDefaultSpecifier = exports.exportDefaultSpecifier = exportDefaultSpecifier;
exports.PrivateName = exports.privateName = privateName;
exports.RecordExpression = exports.recordExpression = recordExpression;
exports.TupleExpression = exports.tupleExpression = tupleExpression;
exports.DecimalLiteral = exports.decimalLiteral = decimalLiteral;
exports.tSParameterProperty = exports.TSParameterProperty = exports.tsParameterProperty = tsParameterProperty;
exports.tSDeclareFunction = exports.TSDeclareFunction = exports.tsDeclareFunction = tsDeclareFunction;
exports.tSDeclareMethod = exports.TSDeclareMethod = exports.tsDeclareMethod = tsDeclareMethod;
exports.tSQualifiedName = exports.TSQualifiedName = exports.tsQualifiedName = tsQualifiedName;
exports.tSCallSignatureDeclaration = exports.TSCallSignatureDeclaration = exports.tsCallSignatureDeclaration = tsCallSignatureDeclaration;
exports.tSConstructSignatureDeclaration = exports.TSConstructSignatureDeclaration = exports.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;
exports.tSPropertySignature = exports.TSPropertySignature = exports.tsPropertySignature = tsPropertySignature;
exports.tSMethodSignature = exports.TSMethodSignature = exports.tsMethodSignature = tsMethodSignature;
exports.tSIndexSignature = exports.TSIndexSignature = exports.tsIndexSignature = tsIndexSignature;
exports.tSAnyKeyword = exports.TSAnyKeyword = exports.tsAnyKeyword = tsAnyKeyword;
exports.tSBooleanKeyword = exports.TSBooleanKeyword = exports.tsBooleanKeyword = tsBooleanKeyword;
exports.tSBigIntKeyword = exports.TSBigIntKeyword = exports.tsBigIntKeyword = tsBigIntKeyword;
exports.tSNeverKeyword = exports.TSNeverKeyword = exports.tsNeverKeyword = tsNeverKeyword;
exports.tSNullKeyword = exports.TSNullKeyword = exports.tsNullKeyword = tsNullKeyword;
exports.tSNumberKeyword = exports.TSNumberKeyword = exports.tsNumberKeyword = tsNumberKeyword;
exports.tSObjectKeyword = exports.TSObjectKeyword = exports.tsObjectKeyword = tsObjectKeyword;
exports.tSStringKeyword = exports.TSStringKeyword = exports.tsStringKeyword = tsStringKeyword;
exports.tSSymbolKeyword = exports.TSSymbolKeyword = exports.tsSymbolKeyword = tsSymbolKeyword;
exports.tSUndefinedKeyword = exports.TSUndefinedKeyword = exports.tsUndefinedKeyword = tsUndefinedKeyword;
exports.tSUnknownKeyword = exports.TSUnknownKeyword = exports.tsUnknownKeyword = tsUnknownKeyword;
exports.tSVoidKeyword = exports.TSVoidKeyword = exports.tsVoidKeyword = tsVoidKeyword;
exports.tSThisType = exports.TSThisType = exports.tsThisType = tsThisType;
exports.tSFunctionType = exports.TSFunctionType = exports.tsFunctionType = tsFunctionType;
exports.tSConstructorType = exports.TSConstructorType = exports.tsConstructorType = tsConstructorType;
exports.tSTypeReference = exports.TSTypeReference = exports.tsTypeReference = tsTypeReference;
exports.tSTypePredicate = exports.TSTypePredicate = exports.tsTypePredicate = tsTypePredicate;
exports.tSTypeQuery = exports.TSTypeQuery = exports.tsTypeQuery = tsTypeQuery;
exports.tSTypeLiteral = exports.TSTypeLiteral = exports.tsTypeLiteral = tsTypeLiteral;
exports.tSArrayType = exports.TSArrayType = exports.tsArrayType = tsArrayType;
exports.tSTupleType = exports.TSTupleType = exports.tsTupleType = tsTupleType;
exports.tSOptionalType = exports.TSOptionalType = exports.tsOptionalType = tsOptionalType;
exports.tSRestType = exports.TSRestType = exports.tsRestType = tsRestType;
exports.tSNamedTupleMember = exports.TSNamedTupleMember = exports.tsNamedTupleMember = tsNamedTupleMember;
exports.tSUnionType = exports.TSUnionType = exports.tsUnionType = tsUnionType;
exports.tSIntersectionType = exports.TSIntersectionType = exports.tsIntersectionType = tsIntersectionType;
exports.tSConditionalType = exports.TSConditionalType = exports.tsConditionalType = tsConditionalType;
exports.tSInferType = exports.TSInferType = exports.tsInferType = tsInferType;
exports.tSParenthesizedType = exports.TSParenthesizedType = exports.tsParenthesizedType = tsParenthesizedType;
exports.tSTypeOperator = exports.TSTypeOperator = exports.tsTypeOperator = tsTypeOperator;
exports.tSIndexedAccessType = exports.TSIndexedAccessType = exports.tsIndexedAccessType = tsIndexedAccessType;
exports.tSMappedType = exports.TSMappedType = exports.tsMappedType = tsMappedType;
exports.tSLiteralType = exports.TSLiteralType = exports.tsLiteralType = tsLiteralType;
exports.tSExpressionWithTypeArguments = exports.TSExpressionWithTypeArguments = exports.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;
exports.tSInterfaceDeclaration = exports.TSInterfaceDeclaration = exports.tsInterfaceDeclaration = tsInterfaceDeclaration;
exports.tSInterfaceBody = exports.TSInterfaceBody = exports.tsInterfaceBody = tsInterfaceBody;
exports.tSTypeAliasDeclaration = exports.TSTypeAliasDeclaration = exports.tsTypeAliasDeclaration = tsTypeAliasDeclaration;
exports.tSAsExpression = exports.TSAsExpression = exports.tsAsExpression = tsAsExpression;
exports.tSTypeAssertion = exports.TSTypeAssertion = exports.tsTypeAssertion = tsTypeAssertion;
exports.tSEnumDeclaration = exports.TSEnumDeclaration = exports.tsEnumDeclaration = tsEnumDeclaration;
exports.tSEnumMember = exports.TSEnumMember = exports.tsEnumMember = tsEnumMember;
exports.tSModuleDeclaration = exports.TSModuleDeclaration = exports.tsModuleDeclaration = tsModuleDeclaration;
exports.tSModuleBlock = exports.TSModuleBlock = exports.tsModuleBlock = tsModuleBlock;
exports.tSImportType = exports.TSImportType = exports.tsImportType = tsImportType;
exports.tSImportEqualsDeclaration = exports.TSImportEqualsDeclaration = exports.tsImportEqualsDeclaration = tsImportEqualsDeclaration;
exports.tSExternalModuleReference = exports.TSExternalModuleReference = exports.tsExternalModuleReference = tsExternalModuleReference;
exports.tSNonNullExpression = exports.TSNonNullExpression = exports.tsNonNullExpression = tsNonNullExpression;
exports.tSExportAssignment = exports.TSExportAssignment = exports.tsExportAssignment = tsExportAssignment;
exports.tSNamespaceExportDeclaration = exports.TSNamespaceExportDeclaration = exports.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;
exports.tSTypeAnnotation = exports.TSTypeAnnotation = exports.tsTypeAnnotation = tsTypeAnnotation;
exports.tSTypeParameterInstantiation = exports.TSTypeParameterInstantiation = exports.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
exports.tSTypeParameterDeclaration = exports.TSTypeParameterDeclaration = exports.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
exports.tSTypeParameter = exports.TSTypeParameter = exports.tsTypeParameter = tsTypeParameter;
exports.numberLiteral = exports.NumberLiteral = NumberLiteral;
exports.regexLiteral = exports.RegexLiteral = RegexLiteral;
exports.restProperty = exports.RestProperty = RestProperty;
exports.spreadProperty = exports.SpreadProperty = SpreadProperty;

var _builder = _interopRequireDefault(require("../builder"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function arrayExpression(...args) {
  return (0, _builder.default)("ArrayExpression", ...args);
}

function assignmentExpression(...args) {
  return (0, _builder.default)("AssignmentExpression", ...args);
}

function binaryExpression(...args) {
  return (0, _builder.default)("BinaryExpression", ...args);
}

function interpreterDirective(...args) {
  return (0, _builder.default)("InterpreterDirective", ...args);
}

function directive(...args) {
  return (0, _builder.default)("Directive", ...args);
}

function directiveLiteral(...args) {
  return (0, _builder.default)("DirectiveLiteral", ...args);
}

function blockStatement(...args) {
  return (0, _builder.default)("BlockStatement", ...args);
}

function breakStatement(...args) {
  return (0, _builder.default)("BreakStatement", ...args);
}

function callExpression(...args) {
  return (0, _builder.default)("CallExpression", ...args);
}

function catchClause(...args) {
  return (0, _builder.default)("CatchClause", ...args);
}

function conditionalExpression(...args) {
  return (0, _builder.default)("ConditionalExpression", ...args);
}

function continueStatement(...args) {
  return (0, _builder.default)("ContinueStatement", ...args);
}

function debuggerStatement(...args) {
  return (0, _builder.default)("DebuggerStatement", ...args);
}

function doWhileStatement(...args) {
  return (0, _builder.default)("DoWhileStatement", ...args);
}

function emptyStatement(...args) {
  return (0, _builder.default)("EmptyStatement", ...args);
}

function expressionStatement(...args) {
  return (0, _builder.default)("ExpressionStatement", ...args);
}

function file(...args) {
  return (0, _builder.default)("File", ...args);
}

function forInStatement(...args) {
  return (0, _builder.default)("ForInStatement", ...args);
}

function forStatement(...args) {
  return (0, _builder.default)("ForStatement", ...args);
}

function functionDeclaration(...args) {
  return (0, _builder.default)("FunctionDeclaration", ...args);
}

function functionExpression(...args) {
  return (0, _builder.default)("FunctionExpression", ...args);
}

function identifier(...args) {
  return (0, _builder.default)("Identifier", ...args);
}

function ifStatement(...args) {
  return (0, _builder.default)("IfStatement", ...args);
}

function labeledStatement(...args) {
  return (0, _builder.default)("LabeledStatement", ...args);
}

function stringLiteral(...args) {
  return (0, _builder.default)("StringLiteral", ...args);
}

function numericLiteral(...args) {
  return (0, _builder.default)("NumericLiteral", ...args);
}

function nullLiteral(...args) {
  return (0, _builder.default)("NullLiteral", ...args);
}

function booleanLiteral(...args) {
  return (0, _builder.default)("BooleanLiteral", ...args);
}

function regExpLiteral(...args) {
  return (0, _builder.default)("RegExpLiteral", ...args);
}

function logicalExpression(...args) {
  return (0, _builder.default)("LogicalExpression", ...args);
}

function memberExpression(...args) {
  return (0, _builder.default)("MemberExpression", ...args);
}

function newExpression(...args) {
  return (0, _builder.default)("NewExpression", ...args);
}

function program(...args) {
  return (0, _builder.default)("Program", ...args);
}

function objectExpression(...args) {
  return (0, _builder.default)("ObjectExpression", ...args);
}

function objectMethod(...args) {
  return (0, _builder.default)("ObjectMethod", ...args);
}

function objectProperty(...args) {
  return (0, _builder.default)("ObjectProperty", ...args);
}

function restElement(...args) {
  return (0, _builder.default)("RestElement", ...args);
}

function returnStatement(...args) {
  return (0, _builder.default)("ReturnStatement", ...args);
}

function sequenceExpression(...args) {
  return (0, _builder.default)("SequenceExpression", ...args);
}

function parenthesizedExpression(...args) {
  return (0, _builder.default)("ParenthesizedExpression", ...args);
}

function switchCase(...args) {
  return (0, _builder.default)("SwitchCase", ...args);
}

function switchStatement(...args) {
  return (0, _builder.default)("SwitchStatement", ...args);
}

function thisExpression(...args) {
  return (0, _builder.default)("ThisExpression", ...args);
}

function throwStatement(...args) {
  return (0, _builder.default)("ThrowStatement", ...args);
}

function tryStatement(...args) {
  return (0, _builder.default)("TryStatement", ...args);
}

function unaryExpression(...args) {
  return (0, _builder.default)("UnaryExpression", ...args);
}

function updateExpression(...args) {
  return (0, _builder.default)("UpdateExpression", ...args);
}

function variableDeclaration(...args) {
  return (0, _builder.default)("VariableDeclaration", ...args);
}

function variableDeclarator(...args) {
  return (0, _builder.default)("VariableDeclarator", ...args);
}

function whileStatement(...args) {
  return (0, _builder.default)("WhileStatement", ...args);
}

function withStatement(...args) {
  return (0, _builder.default)("WithStatement", ...args);
}

function assignmentPattern(...args) {
  return (0, _builder.default)("AssignmentPattern", ...args);
}

function arrayPattern(...args) {
  return (0, _builder.default)("ArrayPattern", ...args);
}

function arrowFunctionExpression(...args) {
  return (0, _builder.default)("ArrowFunctionExpression", ...args);
}

function classBody(...args) {
  return (0, _builder.default)("ClassBody", ...args);
}

function classExpression(...args) {
  return (0, _builder.default)("ClassExpression", ...args);
}

function classDeclaration(...args) {
  return (0, _builder.default)("ClassDeclaration", ...args);
}

function exportAllDeclaration(...args) {
  return (0, _builder.default)("ExportAllDeclaration", ...args);
}

function exportDefaultDeclaration(...args) {
  return (0, _builder.default)("ExportDefaultDeclaration", ...args);
}

function exportNamedDeclaration(...args) {
  return (0, _builder.default)("ExportNamedDeclaration", ...args);
}

function exportSpecifier(...args) {
  return (0, _builder.default)("ExportSpecifier", ...args);
}

function forOfStatement(...args) {
  return (0, _builder.default)("ForOfStatement", ...args);
}

function importDeclaration(...args) {
  return (0, _builder.default)("ImportDeclaration", ...args);
}

function importDefaultSpecifier(...args) {
  return (0, _builder.default)("ImportDefaultSpecifier", ...args);
}

function importNamespaceSpecifier(...args) {
  return (0, _builder.default)("ImportNamespaceSpecifier", ...args);
}

function importSpecifier(...args) {
  return (0, _builder.default)("ImportSpecifier", ...args);
}

function metaProperty(...args) {
  return (0, _builder.default)("MetaProperty", ...args);
}

function classMethod(...args) {
  return (0, _builder.default)("ClassMethod", ...args);
}

function objectPattern(...args) {
  return (0, _builder.default)("ObjectPattern", ...args);
}

function spreadElement(...args) {
  return (0, _builder.default)("SpreadElement", ...args);
}

function _super(...args) {
  return (0, _builder.default)("Super", ...args);
}

function taggedTemplateExpression(...args) {
  return (0, _builder.default)("TaggedTemplateExpression", ...args);
}

function templateElement(...args) {
  return (0, _builder.default)("TemplateElement", ...args);
}

function templateLiteral(...args) {
  return (0, _builder.default)("TemplateLiteral", ...args);
}

function yieldExpression(...args) {
  return (0, _builder.default)("YieldExpression", ...args);
}

function awaitExpression(...args) {
  return (0, _builder.default)("AwaitExpression", ...args);
}

function _import(...args) {
  return (0, _builder.default)("Import", ...args);
}

function bigIntLiteral(...args) {
  return (0, _builder.default)("BigIntLiteral", ...args);
}

function exportNamespaceSpecifier(...args) {
  return (0, _builder.default)("ExportNamespaceSpecifier", ...args);
}

function optionalMemberExpression(...args) {
  return (0, _builder.default)("OptionalMemberExpression", ...args);
}

function optionalCallExpression(...args) {
  return (0, _builder.default)("OptionalCallExpression", ...args);
}

function anyTypeAnnotation(...args) {
  return (0, _builder.default)("AnyTypeAnnotation", ...args);
}

function arrayTypeAnnotation(...args) {
  return (0, _builder.default)("ArrayTypeAnnotation", ...args);
}

function booleanTypeAnnotation(...args) {
  return (0, _builder.default)("BooleanTypeAnnotation", ...args);
}

function booleanLiteralTypeAnnotation(...args) {
  return (0, _builder.default)("BooleanLiteralTypeAnnotation", ...args);
}

function nullLiteralTypeAnnotation(...args) {
  return (0, _builder.default)("NullLiteralTypeAnnotation", ...args);
}

function classImplements(...args) {
  return (0, _builder.default)("ClassImplements", ...args);
}

function declareClass(...args) {
  return (0, _builder.default)("DeclareClass", ...args);
}

function declareFunction(...args) {
  return (0, _builder.default)("DeclareFunction", ...args);
}

function declareInterface(...args) {
  return (0, _builder.default)("DeclareInterface", ...args);
}

function declareModule(...args) {
  return (0, _builder.default)("DeclareModule", ...args);
}

function declareModuleExports(...args) {
  return (0, _builder.default)("DeclareModuleExports", ...args);
}

function declareTypeAlias(...args) {
  return (0, _builder.default)("DeclareTypeAlias", ...args);
}

function declareOpaqueType(...args) {
  return (0, _builder.default)("DeclareOpaqueType", ...args);
}

function declareVariable(...args) {
  return (0, _builder.default)("DeclareVariable", ...args);
}

function declareExportDeclaration(...args) {
  return (0, _builder.default)("DeclareExportDeclaration", ...args);
}

function declareExportAllDeclaration(...args) {
  return (0, _builder.default)("DeclareExportAllDeclaration", ...args);
}

function declaredPredicate(...args) {
  return (0, _builder.default)("DeclaredPredicate", ...args);
}

function existsTypeAnnotation(...args) {
  return (0, _builder.default)("ExistsTypeAnnotation", ...args);
}

function functionTypeAnnotation(...args) {
  return (0, _builder.default)("FunctionTypeAnnotation", ...args);
}

function functionTypeParam(...args) {
  return (0, _builder.default)("FunctionTypeParam", ...args);
}

function genericTypeAnnotation(...args) {
  return (0, _builder.default)("GenericTypeAnnotation", ...args);
}

function inferredPredicate(...args) {
  return (0, _builder.default)("InferredPredicate", ...args);
}

function interfaceExtends(...args) {
  return (0, _builder.default)("InterfaceExtends", ...args);
}

function interfaceDeclaration(...args) {
  return (0, _builder.default)("InterfaceDeclaration", ...args);
}

function interfaceTypeAnnotation(...args) {
  return (0, _builder.default)("InterfaceTypeAnnotation", ...args);
}

function intersectionTypeAnnotation(...args) {
  return (0, _builder.default)("IntersectionTypeAnnotation", ...args);
}

function mixedTypeAnnotation(...args) {
  return (0, _builder.default)("MixedTypeAnnotation", ...args);
}

function emptyTypeAnnotation(...args) {
  return (0, _builder.default)("EmptyTypeAnnotation", ...args);
}

function nullableTypeAnnotation(...args) {
  return (0, _builder.default)("NullableTypeAnnotation", ...args);
}

function numberLiteralTypeAnnotation(...args) {
  return (0, _builder.default)("NumberLiteralTypeAnnotation", ...args);
}

function numberTypeAnnotation(...args) {
  return (0, _builder.default)("NumberTypeAnnotation", ...args);
}

function objectTypeAnnotation(...args) {
  return (0, _builder.default)("ObjectTypeAnnotation", ...args);
}

function objectTypeInternalSlot(...args) {
  return (0, _builder.default)("ObjectTypeInternalSlot", ...args);
}

function objectTypeCallProperty(...args) {
  return (0, _builder.default)("ObjectTypeCallProperty", ...args);
}

function objectTypeIndexer(...args) {
  return (0, _builder.default)("ObjectTypeIndexer", ...args);
}

function objectTypeProperty(...args) {
  return (0, _builder.default)("ObjectTypeProperty", ...args);
}

function objectTypeSpreadProperty(...args) {
  return (0, _builder.default)("ObjectTypeSpreadProperty", ...args);
}

function opaqueType(...args) {
  return (0, _builder.default)("OpaqueType", ...args);
}

function qualifiedTypeIdentifier(...args) {
  return (0, _builder.default)("QualifiedTypeIdentifier", ...args);
}

function stringLiteralTypeAnnotation(...args) {
  return (0, _builder.default)("StringLiteralTypeAnnotation", ...args);
}

function stringTypeAnnotation(...args) {
  return (0, _builder.default)("StringTypeAnnotation", ...args);
}

function symbolTypeAnnotation(...args) {
  return (0, _builder.default)("SymbolTypeAnnotation", ...args);
}

function thisTypeAnnotation(...args) {
  return (0, _builder.default)("ThisTypeAnnotation", ...args);
}

function tupleTypeAnnotation(...args) {
  return (0, _builder.default)("TupleTypeAnnotation", ...args);
}

function typeofTypeAnnotation(...args) {
  return (0, _builder.default)("TypeofTypeAnnotation", ...args);
}

function typeAlias(...args) {
  return (0, _builder.default)("TypeAlias", ...args);
}

function typeAnnotation(...args) {
  return (0, _builder.default)("TypeAnnotation", ...args);
}

function typeCastExpression(...args) {
  return (0, _builder.default)("TypeCastExpression", ...args);
}

function typeParameter(...args) {
  return (0, _builder.default)("TypeParameter", ...args);
}

function typeParameterDeclaration(...args) {
  return (0, _builder.default)("TypeParameterDeclaration", ...args);
}

function typeParameterInstantiation(...args) {
  return (0, _builder.default)("TypeParameterInstantiation", ...args);
}

function unionTypeAnnotation(...args) {
  return (0, _builder.default)("UnionTypeAnnotation", ...args);
}

function variance(...args) {
  return (0, _builder.default)("Variance", ...args);
}

function voidTypeAnnotation(...args) {
  return (0, _builder.default)("VoidTypeAnnotation", ...args);
}

function enumDeclaration(...args) {
  return (0, _builder.default)("EnumDeclaration", ...args);
}

function enumBooleanBody(...args) {
  return (0, _builder.default)("EnumBooleanBody", ...args);
}

function enumNumberBody(...args) {
  return (0, _builder.default)("EnumNumberBody", ...args);
}

function enumStringBody(...args) {
  return (0, _builder.default)("EnumStringBody", ...args);
}

function enumSymbolBody(...args) {
  return (0, _builder.default)("EnumSymbolBody", ...args);
}

function enumBooleanMember(...args) {
  return (0, _builder.default)("EnumBooleanMember", ...args);
}

function enumNumberMember(...args) {
  return (0, _builder.default)("EnumNumberMember", ...args);
}

function enumStringMember(...args) {
  return (0, _builder.default)("EnumStringMember", ...args);
}

function enumDefaultedMember(...args) {
  return (0, _builder.default)("EnumDefaultedMember", ...args);
}

function jsxAttribute(...args) {
  return (0, _builder.default)("JSXAttribute", ...args);
}

function jsxClosingElement(...args) {
  return (0, _builder.default)("JSXClosingElement", ...args);
}

function jsxElement(...args) {
  return (0, _builder.default)("JSXElement", ...args);
}

function jsxEmptyExpression(...args) {
  return (0, _builder.default)("JSXEmptyExpression", ...args);
}

function jsxExpressionContainer(...args) {
  return (0, _builder.default)("JSXExpressionContainer", ...args);
}

function jsxSpreadChild(...args) {
  return (0, _builder.default)("JSXSpreadChild", ...args);
}

function jsxIdentifier(...args) {
  return (0, _builder.default)("JSXIdentifier", ...args);
}

function jsxMemberExpression(...args) {
  return (0, _builder.default)("JSXMemberExpression", ...args);
}

function jsxNamespacedName(...args) {
  return (0, _builder.default)("JSXNamespacedName", ...args);
}

function jsxOpeningElement(...args) {
  return (0, _builder.default)("JSXOpeningElement", ...args);
}

function jsxSpreadAttribute(...args) {
  return (0, _builder.default)("JSXSpreadAttribute", ...args);
}

function jsxText(...args) {
  return (0, _builder.default)("JSXText", ...args);
}

function jsxFragment(...args) {
  return (0, _builder.default)("JSXFragment", ...args);
}

function jsxOpeningFragment(...args) {
  return (0, _builder.default)("JSXOpeningFragment", ...args);
}

function jsxClosingFragment(...args) {
  return (0, _builder.default)("JSXClosingFragment", ...args);
}

function noop(...args) {
  return (0, _builder.default)("Noop", ...args);
}

function placeholder(...args) {
  return (0, _builder.default)("Placeholder", ...args);
}

function v8IntrinsicIdentifier(...args) {
  return (0, _builder.default)("V8IntrinsicIdentifier", ...args);
}

function argumentPlaceholder(...args) {
  return (0, _builder.default)("ArgumentPlaceholder", ...args);
}

function bindExpression(...args) {
  return (0, _builder.default)("BindExpression", ...args);
}

function classProperty(...args) {
  return (0, _builder.default)("ClassProperty", ...args);
}

function pipelineTopicExpression(...args) {
  return (0, _builder.default)("PipelineTopicExpression", ...args);
}

function pipelineBareFunction(...args) {
  return (0, _builder.default)("PipelineBareFunction", ...args);
}

function pipelinePrimaryTopicReference(...args) {
  return (0, _builder.default)("PipelinePrimaryTopicReference", ...args);
}

function classPrivateProperty(...args) {
  return (0, _builder.default)("ClassPrivateProperty", ...args);
}

function classPrivateMethod(...args) {
  return (0, _builder.default)("ClassPrivateMethod", ...args);
}

function importAttribute(...args) {
  return (0, _builder.default)("ImportAttribute", ...args);
}

function decorator(...args) {
  return (0, _builder.default)("Decorator", ...args);
}

function doExpression(...args) {
  return (0, _builder.default)("DoExpression", ...args);
}

function exportDefaultSpecifier(...args) {
  return (0, _builder.default)("ExportDefaultSpecifier", ...args);
}

function privateName(...args) {
  return (0, _builder.default)("PrivateName", ...args);
}

function recordExpression(...args) {
  return (0, _builder.default)("RecordExpression", ...args);
}

function tupleExpression(...args) {
  return (0, _builder.default)("TupleExpression", ...args);
}

function decimalLiteral(...args) {
  return (0, _builder.default)("DecimalLiteral", ...args);
}

function tsParameterProperty(...args) {
  return (0, _builder.default)("TSParameterProperty", ...args);
}

function tsDeclareFunction(...args) {
  return (0, _builder.default)("TSDeclareFunction", ...args);
}

function tsDeclareMethod(...args) {
  return (0, _builder.default)("TSDeclareMethod", ...args);
}

function tsQualifiedName(...args) {
  return (0, _builder.default)("TSQualifiedName", ...args);
}

function tsCallSignatureDeclaration(...args) {
  return (0, _builder.default)("TSCallSignatureDeclaration", ...args);
}

function tsConstructSignatureDeclaration(...args) {
  return (0, _builder.default)("TSConstructSignatureDeclaration", ...args);
}

function tsPropertySignature(...args) {
  return (0, _builder.default)("TSPropertySignature", ...args);
}

function tsMethodSignature(...args) {
  return (0, _builder.default)("TSMethodSignature", ...args);
}

function tsIndexSignature(...args) {
  return (0, _builder.default)("TSIndexSignature", ...args);
}

function tsAnyKeyword(...args) {
  return (0, _builder.default)("TSAnyKeyword", ...args);
}

function tsBooleanKeyword(...args) {
  return (0, _builder.default)("TSBooleanKeyword", ...args);
}

function tsBigIntKeyword(...args) {
  return (0, _builder.default)("TSBigIntKeyword", ...args);
}

function tsNeverKeyword(...args) {
  return (0, _builder.default)("TSNeverKeyword", ...args);
}

function tsNullKeyword(...args) {
  return (0, _builder.default)("TSNullKeyword", ...args);
}

function tsNumberKeyword(...args) {
  return (0, _builder.default)("TSNumberKeyword", ...args);
}

function tsObjectKeyword(...args) {
  return (0, _builder.default)("TSObjectKeyword", ...args);
}

function tsStringKeyword(...args) {
  return (0, _builder.default)("TSStringKeyword", ...args);
}

function tsSymbolKeyword(...args) {
  return (0, _builder.default)("TSSymbolKeyword", ...args);
}

function tsUndefinedKeyword(...args) {
  return (0, _builder.default)("TSUndefinedKeyword", ...args);
}

function tsUnknownKeyword(...args) {
  return (0, _builder.default)("TSUnknownKeyword", ...args);
}

function tsVoidKeyword(...args) {
  return (0, _builder.default)("TSVoidKeyword", ...args);
}

function tsThisType(...args) {
  return (0, _builder.default)("TSThisType", ...args);
}

function tsFunctionType(...args) {
  return (0, _builder.default)("TSFunctionType", ...args);
}

function tsConstructorType(...args) {
  return (0, _builder.default)("TSConstructorType", ...args);
}

function tsTypeReference(...args) {
  return (0, _builder.default)("TSTypeReference", ...args);
}

function tsTypePredicate(...args) {
  return (0, _builder.default)("TSTypePredicate", ...args);
}

function tsTypeQuery(...args) {
  return (0, _builder.default)("TSTypeQuery", ...args);
}

function tsTypeLiteral(...args) {
  return (0, _builder.default)("TSTypeLiteral", ...args);
}

function tsArrayType(...args) {
  return (0, _builder.default)("TSArrayType", ...args);
}

function tsTupleType(...args) {
  return (0, _builder.default)("TSTupleType", ...args);
}

function tsOptionalType(...args) {
  return (0, _builder.default)("TSOptionalType", ...args);
}

function tsRestType(...args) {
  return (0, _builder.default)("TSRestType", ...args);
}

function tsNamedTupleMember(...args) {
  return (0, _builder.default)("TSNamedTupleMember", ...args);
}

function tsUnionType(...args) {
  return (0, _builder.default)("TSUnionType", ...args);
}

function tsIntersectionType(...args) {
  return (0, _builder.default)("TSIntersectionType", ...args);
}

function tsConditionalType(...args) {
  return (0, _builder.default)("TSConditionalType", ...args);
}

function tsInferType(...args) {
  return (0, _builder.default)("TSInferType", ...args);
}

function tsParenthesizedType(...args) {
  return (0, _builder.default)("TSParenthesizedType", ...args);
}

function tsTypeOperator(...args) {
  return (0, _builder.default)("TSTypeOperator", ...args);
}

function tsIndexedAccessType(...args) {
  return (0, _builder.default)("TSIndexedAccessType", ...args);
}

function tsMappedType(...args) {
  return (0, _builder.default)("TSMappedType", ...args);
}

function tsLiteralType(...args) {
  return (0, _builder.default)("TSLiteralType", ...args);
}

function tsExpressionWithTypeArguments(...args) {
  return (0, _builder.default)("TSExpressionWithTypeArguments", ...args);
}

function tsInterfaceDeclaration(...args) {
  return (0, _builder.default)("TSInterfaceDeclaration", ...args);
}

function tsInterfaceBody(...args) {
  return (0, _builder.default)("TSInterfaceBody", ...args);
}

function tsTypeAliasDeclaration(...args) {
  return (0, _builder.default)("TSTypeAliasDeclaration", ...args);
}

function tsAsExpression(...args) {
  return (0, _builder.default)("TSAsExpression", ...args);
}

function tsTypeAssertion(...args) {
  return (0, _builder.default)("TSTypeAssertion", ...args);
}

function tsEnumDeclaration(...args) {
  return (0, _builder.default)("TSEnumDeclaration", ...args);
}

function tsEnumMember(...args) {
  return (0, _builder.default)("TSEnumMember", ...args);
}

function tsModuleDeclaration(...args) {
  return (0, _builder.default)("TSModuleDeclaration", ...args);
}

function tsModuleBlock(...args) {
  return (0, _builder.default)("TSModuleBlock", ...args);
}

function tsImportType(...args) {
  return (0, _builder.default)("TSImportType", ...args);
}

function tsImportEqualsDeclaration(...args) {
  return (0, _builder.default)("TSImportEqualsDeclaration", ...args);
}

function tsExternalModuleReference(...args) {
  return (0, _builder.default)("TSExternalModuleReference", ...args);
}

function tsNonNullExpression(...args) {
  return (0, _builder.default)("TSNonNullExpression", ...args);
}

function tsExportAssignment(...args) {
  return (0, _builder.default)("TSExportAssignment", ...args);
}

function tsNamespaceExportDeclaration(...args) {
  return (0, _builder.default)("TSNamespaceExportDeclaration", ...args);
}

function tsTypeAnnotation(...args) {
  return (0, _builder.default)("TSTypeAnnotation", ...args);
}

function tsTypeParameterInstantiation(...args) {
  return (0, _builder.default)("TSTypeParameterInstantiation", ...args);
}

function tsTypeParameterDeclaration(...args) {
  return (0, _builder.default)("TSTypeParameterDeclaration", ...args);
}

function tsTypeParameter(...args) {
  return (0, _builder.default)("TSTypeParameter", ...args);
}

function NumberLiteral(...args) {
  console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
  return (0, _builder.default)("NumberLiteral", ...args);
}

function RegexLiteral(...args) {
  console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
  return (0, _builder.default)("RegexLiteral", ...args);
}

function RestProperty(...args) {
  console.trace("The node type RestProperty has been renamed to RestElement");
  return (0, _builder.default)("RestProperty", ...args);
}

function SpreadProperty(...args) {
  console.trace("The node type SpreadProperty has been renamed to SpreadElement");
  return (0, _builder.default)("SpreadProperty", ...args);
}
},{"../builder":32}],36:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = buildChildren;

var _generated = require("../../validators/generated");

var _cleanJSXElementLiteralChild = _interopRequireDefault(require("../../utils/react/cleanJSXElementLiteralChild"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function buildChildren(node) {
  const elements = [];

  for (let i = 0; i < node.children.length; i++) {
    let child = node.children[i];

    if ((0, _generated.isJSXText)(child)) {
      (0, _cleanJSXElementLiteralChild.default)(child, elements);
      continue;
    }

    if ((0, _generated.isJSXExpressionContainer)(child)) child = child.expression;
    if ((0, _generated.isJSXEmptyExpression)(child)) continue;
    elements.push(child);
  }

  return elements;
}
},{"../../utils/react/cleanJSXElementLiteralChild":85,"../../validators/generated":88}],37:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createTSUnionType;

var _generated = require("../generated");

var _removeTypeDuplicates = _interopRequireDefault(require("../../modifications/typescript/removeTypeDuplicates"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createTSUnionType(typeAnnotations) {
  const types = typeAnnotations.map(type => type.typeAnnotations);
  const flattened = (0, _removeTypeDuplicates.default)(types);

  if (flattened.length === 1) {
    return flattened[0];
  } else {
    return (0, _generated.tsUnionType)(flattened);
  }
}
},{"../../modifications/typescript/removeTypeDuplicates":79,"../generated":35}],38:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = clone;

var _cloneNode = _interopRequireDefault(require("./cloneNode"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function clone(node) {
  return (0, _cloneNode.default)(node, false);
}
},{"./cloneNode":41}],39:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cloneDeep;

var _cloneNode = _interopRequireDefault(require("./cloneNode"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function cloneDeep(node) {
  return (0, _cloneNode.default)(node);
}
},{"./cloneNode":41}],40:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cloneDeepWithoutLoc;

var _cloneNode = _interopRequireDefault(require("./cloneNode"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function cloneDeepWithoutLoc(node) {
  return (0, _cloneNode.default)(node, true, true);
}
},{"./cloneNode":41}],41:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cloneNode;

var _definitions = require("../definitions");

const has = Function.call.bind(Object.prototype.hasOwnProperty);

function cloneIfNode(obj, deep, withoutLoc) {
  if (obj && typeof obj.type === "string") {
    return cloneNode(obj, deep, withoutLoc);
  }

  return obj;
}

function cloneIfNodeOrArray(obj, deep, withoutLoc) {
  if (Array.isArray(obj)) {
    return obj.map(node => cloneIfNode(node, deep, withoutLoc));
  }

  return cloneIfNode(obj, deep, withoutLoc);
}

function cloneNode(node, deep = true, withoutLoc = false) {
  if (!node) return node;
  const {
    type
  } = node;
  const newNode = {
    type
  };

  if (type === "Identifier") {
    newNode.name = node.name;

    if (has(node, "optional") && typeof node.optional === "boolean") {
      newNode.optional = node.optional;
    }

    if (has(node, "typeAnnotation")) {
      newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc) : node.typeAnnotation;
    }
  } else if (!has(_definitions.NODE_FIELDS, type)) {
    throw new Error(`Unknown node type: "${type}"`);
  } else {
    for (const field of Object.keys(_definitions.NODE_FIELDS[type])) {
      if (has(node, field)) {
        if (deep) {
          newNode[field] = type === "File" && field === "comments" ? maybeCloneComments(node.comments, deep, withoutLoc) : cloneIfNodeOrArray(node[field], true, withoutLoc);
        } else {
          newNode[field] = node[field];
        }
      }
    }
  }

  if (has(node, "loc")) {
    if (withoutLoc) {
      newNode.loc = null;
    } else {
      newNode.loc = node.loc;
    }
  }

  if (has(node, "leadingComments")) {
    newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc);
  }

  if (has(node, "innerComments")) {
    newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc);
  }

  if (has(node, "trailingComments")) {
    newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc);
  }

  if (has(node, "extra")) {
    newNode.extra = Object.assign({}, node.extra);
  }

  return newNode;
}

function cloneCommentsWithoutLoc(comments) {
  return comments.map(({
    type,
    value
  }) => ({
    type,
    value,
    loc: null
  }));
}

function maybeCloneComments(comments, deep, withoutLoc) {
  return deep && withoutLoc ? cloneCommentsWithoutLoc(comments) : comments;
}
},{"../definitions":66}],42:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cloneWithoutLoc;

var _cloneNode = _interopRequireDefault(require("./cloneNode"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function cloneWithoutLoc(node) {
  return (0, _cloneNode.default)(node, false, true);
}
},{"./cloneNode":41}],43:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = addComment;

var _addComments = _interopRequireDefault(require("./addComments"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function addComment(node, type, content, line) {
  return (0, _addComments.default)(node, type, [{
    type: line ? "CommentLine" : "CommentBlock",
    value: content
  }]);
}
},{"./addComments":44}],44:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = addComments;

function addComments(node, type, comments) {
  if (!comments || !node) return node;
  const key = `${type}Comments`;

  if (node[key]) {
    if (type === "leading") {
      node[key] = comments.concat(node[key]);
    } else {
      node[key] = node[key].concat(comments);
    }
  } else {
    node[key] = comments;
  }

  return node;
}
},{}],45:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = inheritInnerComments;

var _inherit = _interopRequireDefault(require("../utils/inherit"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function inheritInnerComments(child, parent) {
  (0, _inherit.default)("innerComments", child, parent);
}
},{"../utils/inherit":84}],46:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = inheritLeadingComments;

var _inherit = _interopRequireDefault(require("../utils/inherit"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function inheritLeadingComments(child, parent) {
  (0, _inherit.default)("leadingComments", child, parent);
}
},{"../utils/inherit":84}],47:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = inheritTrailingComments;

var _inherit = _interopRequireDefault(require("../utils/inherit"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function inheritTrailingComments(child, parent) {
  (0, _inherit.default)("trailingComments", child, parent);
}
},{"../utils/inherit":84}],48:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = inheritsComments;

var _inheritTrailingComments = _interopRequireDefault(require("./inheritTrailingComments"));

var _inheritLeadingComments = _interopRequireDefault(require("./inheritLeadingComments"));

var _inheritInnerComments = _interopRequireDefault(require("./inheritInnerComments"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function inheritsComments(child, parent) {
  (0, _inheritTrailingComments.default)(child, parent);
  (0, _inheritLeadingComments.default)(child, parent);
  (0, _inheritInnerComments.default)(child, parent);
  return child;
}
},{"./inheritInnerComments":45,"./inheritLeadingComments":46,"./inheritTrailingComments":47}],49:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = removeComments;

var _constants = require("../constants");

function removeComments(node) {
  _constants.COMMENT_KEYS.forEach(key => {
    node[key] = null;
  });

  return node;
}
},{"../constants":51}],50:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TSBASETYPE_TYPES = exports.TSTYPE_TYPES = exports.TSTYPEELEMENT_TYPES = exports.PRIVATE_TYPES = exports.JSX_TYPES = exports.ENUMMEMBER_TYPES = exports.ENUMBODY_TYPES = exports.FLOWPREDICATE_TYPES = exports.FLOWDECLARATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = exports.FLOWTYPE_TYPES = exports.FLOW_TYPES = exports.MODULESPECIFIER_TYPES = exports.EXPORTDECLARATION_TYPES = exports.MODULEDECLARATION_TYPES = exports.CLASS_TYPES = exports.PATTERN_TYPES = exports.UNARYLIKE_TYPES = exports.PROPERTY_TYPES = exports.OBJECTMEMBER_TYPES = exports.METHOD_TYPES = exports.USERWHITESPACABLE_TYPES = exports.IMMUTABLE_TYPES = exports.LITERAL_TYPES = exports.TSENTITYNAME_TYPES = exports.LVAL_TYPES = exports.PATTERNLIKE_TYPES = exports.DECLARATION_TYPES = exports.PUREISH_TYPES = exports.FUNCTIONPARENT_TYPES = exports.FUNCTION_TYPES = exports.FORXSTATEMENT_TYPES = exports.FOR_TYPES = exports.EXPRESSIONWRAPPER_TYPES = exports.WHILE_TYPES = exports.LOOP_TYPES = exports.CONDITIONAL_TYPES = exports.COMPLETIONSTATEMENT_TYPES = exports.TERMINATORLESS_TYPES = exports.STATEMENT_TYPES = exports.BLOCK_TYPES = exports.BLOCKPARENT_TYPES = exports.SCOPABLE_TYPES = exports.BINARY_TYPES = exports.EXPRESSION_TYPES = void 0;

var _definitions = require("../../definitions");

const EXPRESSION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Expression"];
exports.EXPRESSION_TYPES = EXPRESSION_TYPES;
const BINARY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Binary"];
exports.BINARY_TYPES = BINARY_TYPES;
const SCOPABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Scopable"];
exports.SCOPABLE_TYPES = SCOPABLE_TYPES;
const BLOCKPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["BlockParent"];
exports.BLOCKPARENT_TYPES = BLOCKPARENT_TYPES;
const BLOCK_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Block"];
exports.BLOCK_TYPES = BLOCK_TYPES;
const STATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Statement"];
exports.STATEMENT_TYPES = STATEMENT_TYPES;
const TERMINATORLESS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Terminatorless"];
exports.TERMINATORLESS_TYPES = TERMINATORLESS_TYPES;
const COMPLETIONSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["CompletionStatement"];
exports.COMPLETIONSTATEMENT_TYPES = COMPLETIONSTATEMENT_TYPES;
const CONDITIONAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Conditional"];
exports.CONDITIONAL_TYPES = CONDITIONAL_TYPES;
const LOOP_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Loop"];
exports.LOOP_TYPES = LOOP_TYPES;
const WHILE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["While"];
exports.WHILE_TYPES = WHILE_TYPES;
const EXPRESSIONWRAPPER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
exports.EXPRESSIONWRAPPER_TYPES = EXPRESSIONWRAPPER_TYPES;
const FOR_TYPES = _definitions.FLIPPED_ALIAS_KEYS["For"];
exports.FOR_TYPES = FOR_TYPES;
const FORXSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ForXStatement"];
exports.FORXSTATEMENT_TYPES = FORXSTATEMENT_TYPES;
const FUNCTION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Function"];
exports.FUNCTION_TYPES = FUNCTION_TYPES;
const FUNCTIONPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FunctionParent"];
exports.FUNCTIONPARENT_TYPES = FUNCTIONPARENT_TYPES;
const PUREISH_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Pureish"];
exports.PUREISH_TYPES = PUREISH_TYPES;
const DECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Declaration"];
exports.DECLARATION_TYPES = DECLARATION_TYPES;
const PATTERNLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["PatternLike"];
exports.PATTERNLIKE_TYPES = PATTERNLIKE_TYPES;
const LVAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["LVal"];
exports.LVAL_TYPES = LVAL_TYPES;
const TSENTITYNAME_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSEntityName"];
exports.TSENTITYNAME_TYPES = TSENTITYNAME_TYPES;
const LITERAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Literal"];
exports.LITERAL_TYPES = LITERAL_TYPES;
const IMMUTABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Immutable"];
exports.IMMUTABLE_TYPES = IMMUTABLE_TYPES;
const USERWHITESPACABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["UserWhitespacable"];
exports.USERWHITESPACABLE_TYPES = USERWHITESPACABLE_TYPES;
const METHOD_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Method"];
exports.METHOD_TYPES = METHOD_TYPES;
const OBJECTMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ObjectMember"];
exports.OBJECTMEMBER_TYPES = OBJECTMEMBER_TYPES;
const PROPERTY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Property"];
exports.PROPERTY_TYPES = PROPERTY_TYPES;
const UNARYLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["UnaryLike"];
exports.UNARYLIKE_TYPES = UNARYLIKE_TYPES;
const PATTERN_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Pattern"];
exports.PATTERN_TYPES = PATTERN_TYPES;
const CLASS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Class"];
exports.CLASS_TYPES = CLASS_TYPES;
const MODULEDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ModuleDeclaration"];
exports.MODULEDECLARATION_TYPES = MODULEDECLARATION_TYPES;
const EXPORTDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ExportDeclaration"];
exports.EXPORTDECLARATION_TYPES = EXPORTDECLARATION_TYPES;
const MODULESPECIFIER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
exports.MODULESPECIFIER_TYPES = MODULESPECIFIER_TYPES;
const FLOW_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Flow"];
exports.FLOW_TYPES = FLOW_TYPES;
const FLOWTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowType"];
exports.FLOWTYPE_TYPES = FLOWTYPE_TYPES;
const FLOWBASEANNOTATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
exports.FLOWBASEANNOTATION_TYPES = FLOWBASEANNOTATION_TYPES;
const FLOWDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowDeclaration"];
exports.FLOWDECLARATION_TYPES = FLOWDECLARATION_TYPES;
const FLOWPREDICATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowPredicate"];
exports.FLOWPREDICATE_TYPES = FLOWPREDICATE_TYPES;
const ENUMBODY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["EnumBody"];
exports.ENUMBODY_TYPES = ENUMBODY_TYPES;
const ENUMMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["EnumMember"];
exports.ENUMMEMBER_TYPES = ENUMMEMBER_TYPES;
const JSX_TYPES = _definitions.FLIPPED_ALIAS_KEYS["JSX"];
exports.JSX_TYPES = JSX_TYPES;
const PRIVATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Private"];
exports.PRIVATE_TYPES = PRIVATE_TYPES;
const TSTYPEELEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSTypeElement"];
exports.TSTYPEELEMENT_TYPES = TSTYPEELEMENT_TYPES;
const TSTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSType"];
exports.TSTYPE_TYPES = TSTYPE_TYPES;
const TSBASETYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSBaseType"];
exports.TSBASETYPE_TYPES = TSBASETYPE_TYPES;
},{"../../definitions":66}],51:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NOT_LOCAL_BINDING = exports.BLOCK_SCOPED_SYMBOL = exports.INHERIT_KEYS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.NUMBER_UNARY_OPERATORS = exports.BOOLEAN_UNARY_OPERATORS = exports.ASSIGNMENT_OPERATORS = exports.BINARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.EQUALITY_BINARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.UPDATE_OPERATORS = exports.LOGICAL_OPERATORS = exports.COMMENT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.STATEMENT_OR_BLOCK_KEYS = void 0;
const STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
exports.STATEMENT_OR_BLOCK_KEYS = STATEMENT_OR_BLOCK_KEYS;
const FLATTENABLE_KEYS = ["body", "expressions"];
exports.FLATTENABLE_KEYS = FLATTENABLE_KEYS;
const FOR_INIT_KEYS = ["left", "init"];
exports.FOR_INIT_KEYS = FOR_INIT_KEYS;
const COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
exports.COMMENT_KEYS = COMMENT_KEYS;
const LOGICAL_OPERATORS = ["||", "&&", "??"];
exports.LOGICAL_OPERATORS = LOGICAL_OPERATORS;
const UPDATE_OPERATORS = ["++", "--"];
exports.UPDATE_OPERATORS = UPDATE_OPERATORS;
const BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];
exports.BOOLEAN_NUMBER_BINARY_OPERATORS = BOOLEAN_NUMBER_BINARY_OPERATORS;
const EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
exports.EQUALITY_BINARY_OPERATORS = EQUALITY_BINARY_OPERATORS;
const COMPARISON_BINARY_OPERATORS = [...EQUALITY_BINARY_OPERATORS, "in", "instanceof"];
exports.COMPARISON_BINARY_OPERATORS = COMPARISON_BINARY_OPERATORS;
const BOOLEAN_BINARY_OPERATORS = [...COMPARISON_BINARY_OPERATORS, ...BOOLEAN_NUMBER_BINARY_OPERATORS];
exports.BOOLEAN_BINARY_OPERATORS = BOOLEAN_BINARY_OPERATORS;
const NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
exports.NUMBER_BINARY_OPERATORS = NUMBER_BINARY_OPERATORS;
const BINARY_OPERATORS = ["+", ...NUMBER_BINARY_OPERATORS, ...BOOLEAN_BINARY_OPERATORS];
exports.BINARY_OPERATORS = BINARY_OPERATORS;
const ASSIGNMENT_OPERATORS = ["=", "+=", ...NUMBER_BINARY_OPERATORS.map(op => op + "="), ...LOGICAL_OPERATORS.map(op => op + "=")];
exports.ASSIGNMENT_OPERATORS = ASSIGNMENT_OPERATORS;
const BOOLEAN_UNARY_OPERATORS = ["delete", "!"];
exports.BOOLEAN_UNARY_OPERATORS = BOOLEAN_UNARY_OPERATORS;
const NUMBER_UNARY_OPERATORS = ["+", "-", "~"];
exports.NUMBER_UNARY_OPERATORS = NUMBER_UNARY_OPERATORS;
const STRING_UNARY_OPERATORS = ["typeof"];
exports.STRING_UNARY_OPERATORS = STRING_UNARY_OPERATORS;
const UNARY_OPERATORS = ["void", "throw", ...BOOLEAN_UNARY_OPERATORS, ...NUMBER_UNARY_OPERATORS, ...STRING_UNARY_OPERATORS];
exports.UNARY_OPERATORS = UNARY_OPERATORS;
const INHERIT_KEYS = {
  optional: ["typeAnnotation", "typeParameters", "returnType"],
  force: ["start", "loc", "end"]
};
exports.INHERIT_KEYS = INHERIT_KEYS;
const BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
exports.BLOCK_SCOPED_SYMBOL = BLOCK_SCOPED_SYMBOL;
const NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
exports.NOT_LOCAL_BINDING = NOT_LOCAL_BINDING;
},{}],52:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ensureBlock;

var _toBlock = _interopRequireDefault(require("./toBlock"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ensureBlock(node, key = "body") {
  return node[key] = (0, _toBlock.default)(node[key], node);
}
},{"./toBlock":55}],53:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = gatherSequenceExpressions;

var _getBindingIdentifiers = _interopRequireDefault(require("../retrievers/getBindingIdentifiers"));

var _generated = require("../validators/generated");

var _generated2 = require("../builders/generated");

var _cloneNode = _interopRequireDefault(require("../clone/cloneNode"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function gatherSequenceExpressions(nodes, scope, declars) {
  const exprs = [];
  let ensureLastUndefined = true;

  for (const node of nodes) {
    if (!(0, _generated.isEmptyStatement)(node)) {
      ensureLastUndefined = false;
    }

    if ((0, _generated.isExpression)(node)) {
      exprs.push(node);
    } else if ((0, _generated.isExpressionStatement)(node)) {
      exprs.push(node.expression);
    } else if ((0, _generated.isVariableDeclaration)(node)) {
      if (node.kind !== "var") return;

      for (const declar of node.declarations) {
        const bindings = (0, _getBindingIdentifiers.default)(declar);

        for (const key of Object.keys(bindings)) {
          declars.push({
            kind: node.kind,
            id: (0, _cloneNode.default)(bindings[key])
          });
        }

        if (declar.init) {
          exprs.push((0, _generated2.assignmentExpression)("=", declar.id, declar.init));
        }
      }

      ensureLastUndefined = true;
    } else if ((0, _generated.isIfStatement)(node)) {
      const consequent = node.consequent ? gatherSequenceExpressions([node.consequent], scope, declars) : scope.buildUndefinedNode();
      const alternate = node.alternate ? gatherSequenceExpressions([node.alternate], scope, declars) : scope.buildUndefinedNode();
      if (!consequent || !alternate) return;
      exprs.push((0, _generated2.conditionalExpression)(node.test, consequent, alternate));
    } else if ((0, _generated.isBlockStatement)(node)) {
      const body = gatherSequenceExpressions(node.body, scope, declars);
      if (!body) return;
      exprs.push(body);
    } else if ((0, _generated.isEmptyStatement)(node)) {
      if (nodes.indexOf(node) === 0) {
        ensureLastUndefined = true;
      }
    } else {
      return;
    }
  }

  if (ensureLastUndefined) {
    exprs.push(scope.buildUndefinedNode());
  }

  if (exprs.length === 1) {
    return exprs[0];
  } else {
    return (0, _generated2.sequenceExpression)(exprs);
  }
}
},{"../builders/generated":35,"../clone/cloneNode":41,"../retrievers/getBindingIdentifiers":80,"../validators/generated":88}],54:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toBindingIdentifierName;

var _toIdentifier = _interopRequireDefault(require("./toIdentifier"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function toBindingIdentifierName(name) {
  name = (0, _toIdentifier.default)(name);
  if (name === "eval" || name === "arguments") name = "_" + name;
  return name;
}
},{"./toIdentifier":58}],55:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toBlock;

var _generated = require("../validators/generated");

var _generated2 = require("../builders/generated");

function toBlock(node, parent) {
  if ((0, _generated.isBlockStatement)(node)) {
    return node;
  }

  let blockNodes = [];

  if ((0, _generated.isEmptyStatement)(node)) {
    blockNodes = [];
  } else {
    if (!(0, _generated.isStatement)(node)) {
      if ((0, _generated.isFunction)(parent)) {
        node = (0, _generated2.returnStatement)(node);
      } else {
        node = (0, _generated2.expressionStatement)(node);
      }
    }

    blockNodes = [node];
  }

  return (0, _generated2.blockStatement)(blockNodes);
}
},{"../builders/generated":35,"../validators/generated":88}],56:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toComputedKey;

var _generated = require("../validators/generated");

var _generated2 = require("../builders/generated");

function toComputedKey(node, key = node.key || node.property) {
  if (!node.computed && (0, _generated.isIdentifier)(key)) key = (0, _generated2.stringLiteral)(key.name);
  return key;
}
},{"../builders/generated":35,"../validators/generated":88}],57:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toExpression;

var _generated = require("../validators/generated");

function toExpression(node) {
  if ((0, _generated.isExpressionStatement)(node)) {
    node = node.expression;
  }

  if ((0, _generated.isExpression)(node)) {
    return node;
  }

  if ((0, _generated.isClass)(node)) {
    node.type = "ClassExpression";
  } else if ((0, _generated.isFunction)(node)) {
    node.type = "FunctionExpression";
  }

  if (!(0, _generated.isExpression)(node)) {
    throw new Error(`cannot turn ${node.type} to an expression`);
  }

  return node;
}
},{"../validators/generated":88}],58:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toIdentifier;

var _isValidIdentifier = _interopRequireDefault(require("../validators/isValidIdentifier"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function toIdentifier(name) {
  name = name + "";
  name = name.replace(/[^a-zA-Z0-9$_]/g, "-");
  name = name.replace(/^[-0-9]+/, "");
  name = name.replace(/[-\s]+(.)?/g, function (match, c) {
    return c ? c.toUpperCase() : "";
  });

  if (!(0, _isValidIdentifier.default)(name)) {
    name = `_${name}`;
  }

  return name || "_";
}
},{"../validators/isValidIdentifier":102}],59:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toKeyAlias;

var _generated = require("../validators/generated");

var _cloneNode = _interopRequireDefault(require("../clone/cloneNode"));

var _removePropertiesDeep = _interopRequireDefault(require("../modifications/removePropertiesDeep"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function toKeyAlias(node, key = node.key) {
  let alias;

  if (node.kind === "method") {
    return toKeyAlias.increment() + "";
  } else if ((0, _generated.isIdentifier)(key)) {
    alias = key.name;
  } else if ((0, _generated.isStringLiteral)(key)) {
    alias = JSON.stringify(key.value);
  } else {
    alias = JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode.default)(key)));
  }

  if (node.computed) {
    alias = `[${alias}]`;
  }

  if (node.static) {
    alias = `static:${alias}`;
  }

  return alias;
}

toKeyAlias.uid = 0;

toKeyAlias.increment = function () {
  if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {
    return toKeyAlias.uid = 0;
  } else {
    return toKeyAlias.uid++;
  }
};
},{"../clone/cloneNode":41,"../modifications/removePropertiesDeep":78,"../validators/generated":88}],60:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toSequenceExpression;

var _gatherSequenceExpressions = _interopRequireDefault(require("./gatherSequenceExpressions"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function toSequenceExpression(nodes, scope) {
  if (!(nodes == null ? void 0 : nodes.length)) return;
  const declars = [];
  const result = (0, _gatherSequenceExpressions.default)(nodes, scope, declars);
  if (!result) return;

  for (const declar of declars) {
    scope.push(declar);
  }

  return result;
}
},{"./gatherSequenceExpressions":53}],61:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toStatement;

var _generated = require("../validators/generated");

var _generated2 = require("../builders/generated");

function toStatement(node, ignore) {
  if ((0, _generated.isStatement)(node)) {
    return node;
  }

  let mustHaveId = false;
  let newType;

  if ((0, _generated.isClass)(node)) {
    mustHaveId = true;
    newType = "ClassDeclaration";
  } else if ((0, _generated.isFunction)(node)) {
    mustHaveId = true;
    newType = "FunctionDeclaration";
  } else if ((0, _generated.isAssignmentExpression)(node)) {
    return (0, _generated2.expressionStatement)(node);
  }

  if (mustHaveId && !node.id) {
    newType = false;
  }

  if (!newType) {
    if (ignore) {
      return false;
    } else {
      throw new Error(`cannot turn ${node.type} to a statement`);
    }
  }

  node.type = newType;
  return node;
}
},{"../builders/generated":35,"../validators/generated":88}],62:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = valueToNode;

var _isPlainObject = _interopRequireDefault(require("lodash/isPlainObject"));

var _isRegExp = _interopRequireDefault(require("lodash/isRegExp"));

var _isValidIdentifier = _interopRequireDefault(require("../validators/isValidIdentifier"));

var _generated = require("../builders/generated");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function valueToNode(value) {
  if (value === undefined) {
    return (0, _generated.identifier)("undefined");
  }

  if (value === true || value === false) {
    return (0, _generated.booleanLiteral)(value);
  }

  if (value === null) {
    return (0, _generated.nullLiteral)();
  }

  if (typeof value === "string") {
    return (0, _generated.stringLiteral)(value);
  }

  if (typeof value === "number") {
    let result;

    if (Number.isFinite(value)) {
      result = (0, _generated.numericLiteral)(Math.abs(value));
    } else {
      let numerator;

      if (Number.isNaN(value)) {
        numerator = (0, _generated.numericLiteral)(0);
      } else {
        numerator = (0, _generated.numericLiteral)(1);
      }

      result = (0, _generated.binaryExpression)("/", numerator, (0, _generated.numericLiteral)(0));
    }

    if (value < 0 || Object.is(value, -0)) {
      result = (0, _generated.unaryExpression)("-", result);
    }

    return result;
  }

  if ((0, _isRegExp.default)(value)) {
    const pattern = value.source;
    const flags = value.toString().match(/\/([a-z]+|)$/)[1];
    return (0, _generated.regExpLiteral)(pattern, flags);
  }

  if (Array.isArray(value)) {
    return (0, _generated.arrayExpression)(value.map(valueToNode));
  }

  if ((0, _isPlainObject.default)(value)) {
    const props = [];

    for (const key of Object.keys(value)) {
      let nodeKey;

      if ((0, _isValidIdentifier.default)(key)) {
        nodeKey = (0, _generated.identifier)(key);
      } else {
        nodeKey = (0, _generated.stringLiteral)(key);
      }

      props.push((0, _generated.objectProperty)(nodeKey, valueToNode(value[key])));
    }

    return (0, _generated.objectExpression)(props);
  }

  throw new Error("don't know how to turn this value into a node");
}
},{"../builders/generated":35,"../validators/isValidIdentifier":102,"lodash/isPlainObject":216,"lodash/isRegExp":217}],63:[function(require,module,exports){
(function (process){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.classMethodOrDeclareMethodCommon = exports.classMethodOrPropertyCommon = exports.patternLikeCommon = exports.functionDeclarationCommon = exports.functionTypeAnnotationCommon = exports.functionCommon = void 0;

var _is = _interopRequireDefault(require("../validators/is"));

var _isValidIdentifier = _interopRequireDefault(require("../validators/isValidIdentifier"));

var _helperValidatorIdentifier = require("@babel/helper-validator-identifier");

var _constants = require("../constants");

var _utils = _interopRequireWildcard(require("./utils"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _utils.default)("ArrayExpression", {
  fields: {
    elements: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "Expression", "SpreadElement"))),
      default: !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined
    }
  },
  visitor: ["elements"],
  aliases: ["Expression"]
});
(0, _utils.default)("AssignmentExpression", {
  fields: {
    operator: {
      validate: function () {
        if (!process.env.BABEL_TYPES_8_BREAKING) {
          return (0, _utils.assertValueType)("string");
        }

        const identifier = (0, _utils.assertOneOf)(..._constants.ASSIGNMENT_OPERATORS);
        const pattern = (0, _utils.assertOneOf)("=");
        return function (node, key, val) {
          const validator = (0, _is.default)("Pattern", node.left) ? pattern : identifier;
          validator(node, key, val);
        };
      }()
    },
    left: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal") : (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern")
    },
    right: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  },
  builder: ["operator", "left", "right"],
  visitor: ["left", "right"],
  aliases: ["Expression"]
});
(0, _utils.default)("BinaryExpression", {
  builder: ["operator", "left", "right"],
  fields: {
    operator: {
      validate: (0, _utils.assertOneOf)(..._constants.BINARY_OPERATORS)
    },
    left: {
      validate: function () {
        const expression = (0, _utils.assertNodeType)("Expression");
        const inOp = (0, _utils.assertNodeType)("Expression", "PrivateName");

        const validator = function (node, key, val) {
          const validator = node.operator === "in" ? inOp : expression;
          validator(node, key, val);
        };

        validator.oneOfNodeTypes = ["Expression", "PrivateName"];
        return validator;
      }()
    },
    right: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  },
  visitor: ["left", "right"],
  aliases: ["Binary", "Expression"]
});
(0, _utils.default)("InterpreterDirective", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("string")
    }
  }
});
(0, _utils.default)("Directive", {
  visitor: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertNodeType)("DirectiveLiteral")
    }
  }
});
(0, _utils.default)("DirectiveLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("string")
    }
  }
});
(0, _utils.default)("BlockStatement", {
  builder: ["body", "directives"],
  visitor: ["directives", "body"],
  fields: {
    directives: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
      default: []
    },
    body: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
    }
  },
  aliases: ["Scopable", "BlockParent", "Block", "Statement"]
});
(0, _utils.default)("BreakStatement", {
  visitor: ["label"],
  fields: {
    label: {
      validate: (0, _utils.assertNodeType)("Identifier"),
      optional: true
    }
  },
  aliases: ["Statement", "Terminatorless", "CompletionStatement"]
});
(0, _utils.default)("CallExpression", {
  visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
  builder: ["callee", "arguments"],
  aliases: ["Expression"],
  fields: Object.assign({
    callee: {
      validate: (0, _utils.assertNodeType)("Expression", "V8IntrinsicIdentifier")
    },
    arguments: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
    }
  }, !process.env.BABEL_TYPES_8_BREAKING ? {
    optional: {
      validate: (0, _utils.assertOneOf)(true, false),
      optional: true
    }
  } : {}, {
    typeArguments: {
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
      optional: true
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
      optional: true
    }
  })
});
(0, _utils.default)("CatchClause", {
  visitor: ["param", "body"],
  fields: {
    param: {
      validate: (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
      optional: true
    },
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  },
  aliases: ["Scopable", "BlockParent"]
});
(0, _utils.default)("ConditionalExpression", {
  visitor: ["test", "consequent", "alternate"],
  fields: {
    test: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    consequent: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    alternate: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  },
  aliases: ["Expression", "Conditional"]
});
(0, _utils.default)("ContinueStatement", {
  visitor: ["label"],
  fields: {
    label: {
      validate: (0, _utils.assertNodeType)("Identifier"),
      optional: true
    }
  },
  aliases: ["Statement", "Terminatorless", "CompletionStatement"]
});
(0, _utils.default)("DebuggerStatement", {
  aliases: ["Statement"]
});
(0, _utils.default)("DoWhileStatement", {
  visitor: ["test", "body"],
  fields: {
    test: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    }
  },
  aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
});
(0, _utils.default)("EmptyStatement", {
  aliases: ["Statement"]
});
(0, _utils.default)("ExpressionStatement", {
  visitor: ["expression"],
  fields: {
    expression: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  },
  aliases: ["Statement", "ExpressionWrapper"]
});
(0, _utils.default)("File", {
  builder: ["program", "comments", "tokens"],
  visitor: ["program"],
  fields: {
    program: {
      validate: (0, _utils.assertNodeType)("Program")
    },
    comments: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(() => {}, {
        each: {
          oneOfNodeTypes: ["CommentBlock", "CommentLine"]
        }
      }) : (0, _utils.assertEach)((0, _utils.assertNodeType)("CommentBlock", "CommentLine")),
      optional: true
    },
    tokens: {
      validate: (0, _utils.assertEach)(Object.assign(() => {}, {
        type: "any"
      })),
      optional: true
    }
  }
});
(0, _utils.default)("ForInStatement", {
  visitor: ["left", "right", "body"],
  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
  fields: {
    left: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("VariableDeclaration", "LVal") : (0, _utils.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern")
    },
    right: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    }
  }
});
(0, _utils.default)("ForStatement", {
  visitor: ["init", "test", "update", "body"],
  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
  fields: {
    init: {
      validate: (0, _utils.assertNodeType)("VariableDeclaration", "Expression"),
      optional: true
    },
    test: {
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
    },
    update: {
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    }
  }
});
const functionCommon = {
  params: {
    validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty")))
  },
  generator: {
    default: false
  },
  async: {
    default: false
  }
};
exports.functionCommon = functionCommon;
const functionTypeAnnotationCommon = {
  returnType: {
    validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
    optional: true
  },
  typeParameters: {
    validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
    optional: true
  }
};
exports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
const functionDeclarationCommon = Object.assign({}, functionCommon, {
  declare: {
    validate: (0, _utils.assertValueType)("boolean"),
    optional: true
  },
  id: {
    validate: (0, _utils.assertNodeType)("Identifier"),
    optional: true
  }
});
exports.functionDeclarationCommon = functionDeclarationCommon;
(0, _utils.default)("FunctionDeclaration", {
  builder: ["id", "params", "body", "generator", "async"],
  visitor: ["id", "params", "body", "returnType", "typeParameters"],
  fields: Object.assign({}, functionDeclarationCommon, functionTypeAnnotationCommon, {
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  }),
  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
  validate: function () {
    if (!process.env.BABEL_TYPES_8_BREAKING) return () => {};
    const identifier = (0, _utils.assertNodeType)("Identifier");
    return function (parent, key, node) {
      if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
        identifier(node, "id", node.id);
      }
    };
  }()
});
(0, _utils.default)("FunctionExpression", {
  inherits: "FunctionDeclaration",
  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
    id: {
      validate: (0, _utils.assertNodeType)("Identifier"),
      optional: true
    },
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  })
});
const patternLikeCommon = {
  typeAnnotation: {
    validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
    optional: true
  },
  decorators: {
    validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator")))
  }
};
exports.patternLikeCommon = patternLikeCommon;
(0, _utils.default)("Identifier", {
  builder: ["name"],
  visitor: ["typeAnnotation", "decorators"],
  aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
  fields: Object.assign({}, patternLikeCommon, {
    name: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function (node, key, val) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;

        if (!(0, _isValidIdentifier.default)(val, false)) {
          throw new TypeError(`"${val}" is not a valid identifier name`);
        }
      }, {
        type: "string"
      }))
    },
    optional: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    }
  }),

  validate(parent, key, node) {
    if (!process.env.BABEL_TYPES_8_BREAKING) return;
    const match = /\.(\w+)$/.exec(key);
    if (!match) return;
    const [, parentKey] = match;
    const nonComp = {
      computed: false
    };

    if (parentKey === "property") {
      if ((0, _is.default)("MemberExpression", parent, nonComp)) return;
      if ((0, _is.default)("OptionalMemberExpression", parent, nonComp)) return;
    } else if (parentKey === "key") {
      if ((0, _is.default)("Property", parent, nonComp)) return;
      if ((0, _is.default)("Method", parent, nonComp)) return;
    } else if (parentKey === "exported") {
      if ((0, _is.default)("ExportSpecifier", parent)) return;
    } else if (parentKey === "imported") {
      if ((0, _is.default)("ImportSpecifier", parent, {
        imported: node
      })) return;
    } else if (parentKey === "meta") {
      if ((0, _is.default)("MetaProperty", parent, {
        meta: node
      })) return;
    }

    if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name)) && node.name !== "this") {
      throw new TypeError(`"${node.name}" is not a valid identifier`);
    }
  }

});
(0, _utils.default)("IfStatement", {
  visitor: ["test", "consequent", "alternate"],
  aliases: ["Statement", "Conditional"],
  fields: {
    test: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    consequent: {
      validate: (0, _utils.assertNodeType)("Statement")
    },
    alternate: {
      optional: true,
      validate: (0, _utils.assertNodeType)("Statement")
    }
  }
});
(0, _utils.default)("LabeledStatement", {
  visitor: ["label", "body"],
  aliases: ["Statement"],
  fields: {
    label: {
      validate: (0, _utils.assertNodeType)("Identifier")
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    }
  }
});
(0, _utils.default)("StringLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("string")
    }
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});
(0, _utils.default)("NumericLiteral", {
  builder: ["value"],
  deprecatedAlias: "NumberLiteral",
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("number")
    }
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});
(0, _utils.default)("NullLiteral", {
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});
(0, _utils.default)("BooleanLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("boolean")
    }
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});
(0, _utils.default)("RegExpLiteral", {
  builder: ["pattern", "flags"],
  deprecatedAlias: "RegexLiteral",
  aliases: ["Expression", "Pureish", "Literal"],
  fields: {
    pattern: {
      validate: (0, _utils.assertValueType)("string")
    },
    flags: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function (node, key, val) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        const invalid = /[^gimsuy]/.exec(val);

        if (invalid) {
          throw new TypeError(`"${invalid[0]}" is not a valid RegExp flag`);
        }
      }, {
        type: "string"
      })),
      default: ""
    }
  }
});
(0, _utils.default)("LogicalExpression", {
  builder: ["operator", "left", "right"],
  visitor: ["left", "right"],
  aliases: ["Binary", "Expression"],
  fields: {
    operator: {
      validate: (0, _utils.assertOneOf)(..._constants.LOGICAL_OPERATORS)
    },
    left: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    right: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("MemberExpression", {
  builder: ["object", "property", "computed", "optional"],
  visitor: ["object", "property"],
  aliases: ["Expression", "LVal"],
  fields: Object.assign({
    object: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    property: {
      validate: function () {
        const normal = (0, _utils.assertNodeType)("Identifier", "PrivateName");
        const computed = (0, _utils.assertNodeType)("Expression");

        const validator = function (node, key, val) {
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
        };

        validator.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"];
        return validator;
      }()
    },
    computed: {
      default: false
    }
  }, !process.env.BABEL_TYPES_8_BREAKING ? {
    optional: {
      validate: (0, _utils.assertOneOf)(true, false),
      optional: true
    }
  } : {})
});
(0, _utils.default)("NewExpression", {
  inherits: "CallExpression"
});
(0, _utils.default)("Program", {
  visitor: ["directives", "body"],
  builder: ["body", "directives", "sourceType", "interpreter"],
  fields: {
    sourceFile: {
      validate: (0, _utils.assertValueType)("string")
    },
    sourceType: {
      validate: (0, _utils.assertOneOf)("script", "module"),
      default: "script"
    },
    interpreter: {
      validate: (0, _utils.assertNodeType)("InterpreterDirective"),
      default: null,
      optional: true
    },
    directives: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
      default: []
    },
    body: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
    }
  },
  aliases: ["Scopable", "BlockParent", "Block"]
});
(0, _utils.default)("ObjectExpression", {
  visitor: ["properties"],
  aliases: ["Expression"],
  fields: {
    properties: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement")))
    }
  }
});
(0, _utils.default)("ObjectMethod", {
  builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
    kind: Object.assign({
      validate: (0, _utils.assertOneOf)("method", "get", "set")
    }, !process.env.BABEL_TYPES_8_BREAKING ? {
      default: "method"
    } : {}),
    computed: {
      default: false
    },
    key: {
      validate: function () {
        const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
        const computed = (0, _utils.assertNodeType)("Expression");

        const validator = function (node, key, val) {
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
        };

        validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral"];
        return validator;
      }()
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
    },
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  }),
  visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
  aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
});
(0, _utils.default)("ObjectProperty", {
  builder: ["key", "value", "computed", "shorthand", ...(!process.env.BABEL_TYPES_8_BREAKING ? ["decorators"] : [])],
  fields: {
    computed: {
      default: false
    },
    key: {
      validate: function () {
        const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
        const computed = (0, _utils.assertNodeType)("Expression");

        const validator = function (node, key, val) {
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
        };

        validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral"];
        return validator;
      }()
    },
    value: {
      validate: (0, _utils.assertNodeType)("Expression", "PatternLike")
    },
    shorthand: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function (node, key, val) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;

        if (val && node.computed) {
          throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
        }
      }, {
        type: "boolean"
      }), function (node, key, val) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;

        if (val && !(0, _is.default)("Identifier", node.key)) {
          throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
        }
      }),
      default: false
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
    }
  },
  visitor: ["key", "value", "decorators"],
  aliases: ["UserWhitespacable", "Property", "ObjectMember"],
  validate: function () {
    const pattern = (0, _utils.assertNodeType)("Identifier", "Pattern");
    const expression = (0, _utils.assertNodeType)("Expression");
    return function (parent, key, node) {
      if (!process.env.BABEL_TYPES_8_BREAKING) return;
      const validator = (0, _is.default)("ObjectPattern", parent) ? pattern : expression;
      validator(node, "value", node.value);
    };
  }()
});
(0, _utils.default)("RestElement", {
  visitor: ["argument", "typeAnnotation"],
  builder: ["argument"],
  aliases: ["LVal", "PatternLike"],
  deprecatedAlias: "RestProperty",
  fields: Object.assign({}, patternLikeCommon, {
    argument: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal") : (0, _utils.assertNodeType)("Identifier", "Pattern", "MemberExpression")
    }
  }),

  validate(parent, key) {
    if (!process.env.BABEL_TYPES_8_BREAKING) return;
    const match = /(\w+)\[(\d+)\]/.exec(key);
    if (!match) throw new Error("Internal Babel error: malformed key.");
    const [, listKey, index] = match;

    if (parent[listKey].length > index + 1) {
      throw new TypeError(`RestElement must be last element of ${listKey}`);
    }
  }

});
(0, _utils.default)("ReturnStatement", {
  visitor: ["argument"],
  aliases: ["Statement", "Terminatorless", "CompletionStatement"],
  fields: {
    argument: {
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
    }
  }
});
(0, _utils.default)("SequenceExpression", {
  visitor: ["expressions"],
  fields: {
    expressions: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression")))
    }
  },
  aliases: ["Expression"]
});
(0, _utils.default)("ParenthesizedExpression", {
  visitor: ["expression"],
  aliases: ["Expression", "ExpressionWrapper"],
  fields: {
    expression: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("SwitchCase", {
  visitor: ["test", "consequent"],
  fields: {
    test: {
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
    },
    consequent: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
    }
  }
});
(0, _utils.default)("SwitchStatement", {
  visitor: ["discriminant", "cases"],
  aliases: ["Statement", "BlockParent", "Scopable"],
  fields: {
    discriminant: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    cases: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("SwitchCase")))
    }
  }
});
(0, _utils.default)("ThisExpression", {
  aliases: ["Expression"]
});
(0, _utils.default)("ThrowStatement", {
  visitor: ["argument"],
  aliases: ["Statement", "Terminatorless", "CompletionStatement"],
  fields: {
    argument: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("TryStatement", {
  visitor: ["block", "handler", "finalizer"],
  aliases: ["Statement"],
  fields: {
    block: {
      validate: (0, _utils.chain)((0, _utils.assertNodeType)("BlockStatement"), Object.assign(function (node) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;

        if (!node.handler && !node.finalizer) {
          throw new TypeError("TryStatement expects either a handler or finalizer, or both");
        }
      }, {
        oneOfNodeTypes: ["BlockStatement"]
      }))
    },
    handler: {
      optional: true,
      validate: (0, _utils.assertNodeType)("CatchClause")
    },
    finalizer: {
      optional: true,
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  }
});
(0, _utils.default)("UnaryExpression", {
  builder: ["operator", "argument", "prefix"],
  fields: {
    prefix: {
      default: true
    },
    argument: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    operator: {
      validate: (0, _utils.assertOneOf)(..._constants.UNARY_OPERATORS)
    }
  },
  visitor: ["argument"],
  aliases: ["UnaryLike", "Expression"]
});
(0, _utils.default)("UpdateExpression", {
  builder: ["operator", "argument", "prefix"],
  fields: {
    prefix: {
      default: false
    },
    argument: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Expression") : (0, _utils.assertNodeType)("Identifier", "MemberExpression")
    },
    operator: {
      validate: (0, _utils.assertOneOf)(..._constants.UPDATE_OPERATORS)
    }
  },
  visitor: ["argument"],
  aliases: ["Expression"]
});
(0, _utils.default)("VariableDeclaration", {
  builder: ["kind", "declarations"],
  visitor: ["declarations"],
  aliases: ["Statement", "Declaration"],
  fields: {
    declare: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    kind: {
      validate: (0, _utils.assertOneOf)("var", "let", "const")
    },
    declarations: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("VariableDeclarator")))
    }
  },

  validate(parent, key, node) {
    if (!process.env.BABEL_TYPES_8_BREAKING) return;
    if (!(0, _is.default)("ForXStatement", parent, {
      left: node
    })) return;

    if (node.declarations.length !== 1) {
      throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);
    }
  }

});
(0, _utils.default)("VariableDeclarator", {
  visitor: ["id", "init"],
  fields: {
    id: {
      validate: function () {
        if (!process.env.BABEL_TYPES_8_BREAKING) {
          return (0, _utils.assertNodeType)("LVal");
        }

        const normal = (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern");
        const without = (0, _utils.assertNodeType)("Identifier");
        return function (node, key, val) {
          const validator = node.init ? normal : without;
          validator(node, key, val);
        };
      }()
    },
    definite: {
      optional: true,
      validate: (0, _utils.assertValueType)("boolean")
    },
    init: {
      optional: true,
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("WhileStatement", {
  visitor: ["test", "body"],
  aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
  fields: {
    test: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    }
  }
});
(0, _utils.default)("WithStatement", {
  visitor: ["object", "body"],
  aliases: ["Statement"],
  fields: {
    object: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    }
  }
});
(0, _utils.default)("AssignmentPattern", {
  visitor: ["left", "right", "decorators"],
  builder: ["left", "right"],
  aliases: ["Pattern", "PatternLike", "LVal"],
  fields: Object.assign({}, patternLikeCommon, {
    left: {
      validate: (0, _utils.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression")
    },
    right: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
    }
  })
});
(0, _utils.default)("ArrayPattern", {
  visitor: ["elements", "typeAnnotation"],
  builder: ["elements"],
  aliases: ["Pattern", "PatternLike", "LVal"],
  fields: Object.assign({}, patternLikeCommon, {
    elements: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "PatternLike")))
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
    }
  })
});
(0, _utils.default)("ArrowFunctionExpression", {
  builder: ["params", "body", "async"],
  visitor: ["params", "body", "returnType", "typeParameters"],
  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
    expression: {
      validate: (0, _utils.assertValueType)("boolean")
    },
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement", "Expression")
    }
  })
});
(0, _utils.default)("ClassBody", {
  visitor: ["body"],
  fields: {
    body: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "TSDeclareMethod", "TSIndexSignature")))
    }
  }
});
(0, _utils.default)("ClassExpression", {
  builder: ["id", "superClass", "body", "decorators"],
  visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
  aliases: ["Scopable", "Class", "Expression"],
  fields: {
    id: {
      validate: (0, _utils.assertNodeType)("Identifier"),
      optional: true
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
      optional: true
    },
    body: {
      validate: (0, _utils.assertNodeType)("ClassBody")
    },
    superClass: {
      optional: true,
      validate: (0, _utils.assertNodeType)("Expression")
    },
    superTypeParameters: {
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
      optional: true
    },
    implements: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
      optional: true
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
    },
    mixins: {
      validate: (0, _utils.assertNodeType)("InterfaceExtends"),
      optional: true
    }
  }
});
(0, _utils.default)("ClassDeclaration", {
  inherits: "ClassExpression",
  aliases: ["Scopable", "Class", "Statement", "Declaration"],
  fields: {
    id: {
      validate: (0, _utils.assertNodeType)("Identifier")
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
      optional: true
    },
    body: {
      validate: (0, _utils.assertNodeType)("ClassBody")
    },
    superClass: {
      optional: true,
      validate: (0, _utils.assertNodeType)("Expression")
    },
    superTypeParameters: {
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
      optional: true
    },
    implements: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
      optional: true
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
    },
    mixins: {
      validate: (0, _utils.assertNodeType)("InterfaceExtends"),
      optional: true
    },
    declare: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    abstract: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    }
  },
  validate: function () {
    const identifier = (0, _utils.assertNodeType)("Identifier");
    return function (parent, key, node) {
      if (!process.env.BABEL_TYPES_8_BREAKING) return;

      if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
        identifier(node, "id", node.id);
      }
    };
  }()
});
(0, _utils.default)("ExportAllDeclaration", {
  visitor: ["source"],
  aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
  fields: {
    source: {
      validate: (0, _utils.assertNodeType)("StringLiteral")
    }
  }
});
(0, _utils.default)("ExportDefaultDeclaration", {
  visitor: ["declaration"],
  aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
  fields: {
    declaration: {
      validate: (0, _utils.assertNodeType)("FunctionDeclaration", "TSDeclareFunction", "ClassDeclaration", "Expression")
    }
  }
});
(0, _utils.default)("ExportNamedDeclaration", {
  visitor: ["declaration", "specifiers", "source"],
  aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
  fields: {
    declaration: {
      optional: true,
      validate: (0, _utils.chain)((0, _utils.assertNodeType)("Declaration"), Object.assign(function (node, key, val) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;

        if (val && node.specifiers.length) {
          throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
        }
      }, {
        oneOfNodeTypes: ["Declaration"]
      }), function (node, key, val) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;

        if (val && node.source) {
          throw new TypeError("Cannot export a declaration from a source");
        }
      })
    },
    specifiers: {
      default: [],
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)(function () {
        const sourced = (0, _utils.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");
        const sourceless = (0, _utils.assertNodeType)("ExportSpecifier");
        if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;
        return function (node, key, val) {
          const validator = node.source ? sourced : sourceless;
          validator(node, key, val);
        };
      }()))
    },
    source: {
      validate: (0, _utils.assertNodeType)("StringLiteral"),
      optional: true
    },
    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
  }
});
(0, _utils.default)("ExportSpecifier", {
  visitor: ["local", "exported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, _utils.assertNodeType)("Identifier")
    },
    exported: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
(0, _utils.default)("ForOfStatement", {
  visitor: ["left", "right", "body"],
  builder: ["left", "right", "body", "await"],
  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
  fields: {
    left: {
      validate: function () {
        if (!process.env.BABEL_TYPES_8_BREAKING) {
          return (0, _utils.assertNodeType)("VariableDeclaration", "LVal");
        }

        const declaration = (0, _utils.assertNodeType)("VariableDeclaration");
        const lval = (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern");
        return function (node, key, val) {
          if ((0, _is.default)("VariableDeclaration", val)) {
            declaration(node, key, val);
          } else {
            lval(node, key, val);
          }
        };
      }()
    },
    right: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    },
    await: {
      default: false
    }
  }
});
(0, _utils.default)("ImportDeclaration", {
  visitor: ["specifiers", "source"],
  aliases: ["Statement", "Declaration", "ModuleDeclaration"],
  fields: {
    specifiers: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
    },
    source: {
      validate: (0, _utils.assertNodeType)("StringLiteral")
    },
    importKind: {
      validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
      optional: true
    }
  }
});
(0, _utils.default)("ImportDefaultSpecifier", {
  visitor: ["local"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
(0, _utils.default)("ImportNamespaceSpecifier", {
  visitor: ["local"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
(0, _utils.default)("ImportSpecifier", {
  visitor: ["local", "imported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, _utils.assertNodeType)("Identifier")
    },
    imported: {
      validate: (0, _utils.assertNodeType)("Identifier")
    },
    importKind: {
      validate: (0, _utils.assertOneOf)("type", "typeof"),
      optional: true
    }
  }
});
(0, _utils.default)("MetaProperty", {
  visitor: ["meta", "property"],
  aliases: ["Expression"],
  fields: {
    meta: {
      validate: (0, _utils.chain)((0, _utils.assertNodeType)("Identifier"), Object.assign(function (node, key, val) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        let property;

        switch (val.name) {
          case "function":
            property = "sent";
            break;

          case "new":
            property = "target";
            break;

          case "import":
            property = "meta";
            break;
        }

        if (!(0, _is.default)("Identifier", node.property, {
          name: property
        })) {
          throw new TypeError("Unrecognised MetaProperty");
        }
      }, {
        oneOfNodeTypes: ["Identifier"]
      }))
    },
    property: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
const classMethodOrPropertyCommon = {
  abstract: {
    validate: (0, _utils.assertValueType)("boolean"),
    optional: true
  },
  accessibility: {
    validate: (0, _utils.assertOneOf)("public", "private", "protected"),
    optional: true
  },
  static: {
    default: false
  },
  computed: {
    default: false
  },
  optional: {
    validate: (0, _utils.assertValueType)("boolean"),
    optional: true
  },
  key: {
    validate: (0, _utils.chain)(function () {
      const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
      const computed = (0, _utils.assertNodeType)("Expression");
      return function (node, key, val) {
        const validator = node.computed ? computed : normal;
        validator(node, key, val);
      };
    }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "Expression"))
  }
};
exports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
const classMethodOrDeclareMethodCommon = Object.assign({}, functionCommon, classMethodOrPropertyCommon, {
  kind: {
    validate: (0, _utils.assertOneOf)("get", "set", "method", "constructor"),
    default: "method"
  },
  access: {
    validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),
    optional: true
  },
  decorators: {
    validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
    optional: true
  }
});
exports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
(0, _utils.default)("ClassMethod", {
  aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
  builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
  visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
  fields: Object.assign({}, classMethodOrDeclareMethodCommon, functionTypeAnnotationCommon, {
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  })
});
(0, _utils.default)("ObjectPattern", {
  visitor: ["properties", "typeAnnotation", "decorators"],
  builder: ["properties"],
  aliases: ["Pattern", "PatternLike", "LVal"],
  fields: Object.assign({}, patternLikeCommon, {
    properties: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("RestElement", "ObjectProperty")))
    }
  })
});
(0, _utils.default)("SpreadElement", {
  visitor: ["argument"],
  aliases: ["UnaryLike"],
  deprecatedAlias: "SpreadProperty",
  fields: {
    argument: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("Super", {
  aliases: ["Expression"]
});
(0, _utils.default)("TaggedTemplateExpression", {
  visitor: ["tag", "quasi"],
  aliases: ["Expression"],
  fields: {
    tag: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    quasi: {
      validate: (0, _utils.assertNodeType)("TemplateLiteral")
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
      optional: true
    }
  }
});
(0, _utils.default)("TemplateElement", {
  builder: ["value", "tail"],
  fields: {
    value: {
      validate: (0, _utils.assertShape)({
        raw: {
          validate: (0, _utils.assertValueType)("string")
        },
        cooked: {
          validate: (0, _utils.assertValueType)("string"),
          optional: true
        }
      })
    },
    tail: {
      default: false
    }
  }
});
(0, _utils.default)("TemplateLiteral", {
  visitor: ["quasis", "expressions"],
  aliases: ["Expression", "Literal"],
  fields: {
    quasis: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TemplateElement")))
    },
    expressions: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression")), function (node, key, val) {
        if (node.quasis.length !== val.length + 1) {
          throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.\nExpected ${val.length + 1} quasis but got ${node.quasis.length}`);
        }
      })
    }
  }
});
(0, _utils.default)("YieldExpression", {
  builder: ["argument", "delegate"],
  visitor: ["argument"],
  aliases: ["Expression", "Terminatorless"],
  fields: {
    delegate: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function (node, key, val) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;

        if (val && !node.argument) {
          throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
        }
      }, {
        type: "boolean"
      })),
      default: false
    },
    argument: {
      optional: true,
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("AwaitExpression", {
  builder: ["argument"],
  visitor: ["argument"],
  aliases: ["Expression", "Terminatorless"],
  fields: {
    argument: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("Import", {
  aliases: ["Expression"]
});
(0, _utils.default)("BigIntLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("string")
    }
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});
(0, _utils.default)("ExportNamespaceSpecifier", {
  visitor: ["exported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    exported: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
(0, _utils.default)("OptionalMemberExpression", {
  builder: ["object", "property", "computed", "optional"],
  visitor: ["object", "property"],
  aliases: ["Expression"],
  fields: {
    object: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    property: {
      validate: function () {
        const normal = (0, _utils.assertNodeType)("Identifier");
        const computed = (0, _utils.assertNodeType)("Expression");

        const validator = function (node, key, val) {
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
        };

        validator.oneOfNodeTypes = ["Expression", "Identifier"];
        return validator;
      }()
    },
    computed: {
      default: false
    },
    optional: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
    }
  }
});
(0, _utils.default)("OptionalCallExpression", {
  visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
  builder: ["callee", "arguments", "optional"],
  aliases: ["Expression"],
  fields: {
    callee: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    arguments: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName")))
    },
    optional: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
    },
    typeArguments: {
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
      optional: true
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
      optional: true
    }
  }
});
}).call(this,require('_process'))

},{"../constants":51,"../validators/is":89,"../validators/isValidIdentifier":102,"./utils":71,"@babel/helper-validator-identifier":28,"_process":224}],64:[function(require,module,exports){
(function (process){
"use strict";

var _utils = _interopRequireWildcard(require("./utils"));

var _core = require("./core");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

(0, _utils.default)("ArgumentPlaceholder", {});
(0, _utils.default)("BindExpression", {
  visitor: ["object", "callee"],
  aliases: ["Expression"],
  fields: !process.env.BABEL_TYPES_8_BREAKING ? {
    object: {
      validate: Object.assign(() => {}, {
        oneOfNodeTypes: ["Expression"]
      })
    },
    callee: {
      validate: Object.assign(() => {}, {
        oneOfNodeTypes: ["Expression"]
      })
    }
  } : {
    object: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    callee: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("ClassProperty", {
  visitor: ["key", "value", "typeAnnotation", "decorators"],
  builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
  aliases: ["Property"],
  fields: Object.assign({}, _core.classMethodOrPropertyCommon, {
    value: {
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
    },
    definite: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    typeAnnotation: {
      validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: true
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
    },
    readonly: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    declare: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    }
  })
});
(0, _utils.default)("PipelineTopicExpression", {
  builder: ["expression"],
  visitor: ["expression"],
  fields: {
    expression: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("PipelineBareFunction", {
  builder: ["callee"],
  visitor: ["callee"],
  fields: {
    callee: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("PipelinePrimaryTopicReference", {
  aliases: ["Expression"]
});
(0, _utils.default)("ClassPrivateProperty", {
  visitor: ["key", "value", "decorators"],
  builder: ["key", "value", "decorators"],
  aliases: ["Property", "Private"],
  fields: {
    key: {
      validate: (0, _utils.assertNodeType)("PrivateName")
    },
    value: {
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
    }
  }
});
(0, _utils.default)("ClassPrivateMethod", {
  builder: ["kind", "key", "params", "body", "static"],
  visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
  aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
  fields: Object.assign({}, _core.classMethodOrDeclareMethodCommon, _core.functionTypeAnnotationCommon, {
    key: {
      validate: (0, _utils.assertNodeType)("PrivateName")
    },
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  })
});
(0, _utils.default)("ImportAttribute", {
  visitor: ["key", "value"],
  fields: {
    key: {
      validate: (0, _utils.assertNodeType)("Identifier")
    },
    value: {
      validate: (0, _utils.assertNodeType)("StringLiteral")
    }
  }
});
(0, _utils.default)("Decorator", {
  visitor: ["expression"],
  fields: {
    expression: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("DoExpression", {
  visitor: ["body"],
  aliases: ["Expression"],
  fields: {
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  }
});
(0, _utils.default)("ExportDefaultSpecifier", {
  visitor: ["exported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    exported: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
(0, _utils.default)("PrivateName", {
  visitor: ["id"],
  aliases: ["Private"],
  fields: {
    id: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
(0, _utils.default)("RecordExpression", {
  visitor: ["properties"],
  aliases: ["Expression"],
  fields: {
    properties: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectProperty", "SpreadElement")))
    }
  }
});
(0, _utils.default)("TupleExpression", {
  fields: {
    elements: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement"))),
      default: []
    }
  },
  visitor: ["elements"],
  aliases: ["Expression"]
});
(0, _utils.default)("DecimalLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("string")
    }
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});
}).call(this,require('_process'))

},{"./core":63,"./utils":71,"_process":224}],65:[function(require,module,exports){
"use strict";

var _utils = _interopRequireWildcard(require("./utils"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const defineInterfaceishType = (name, typeParameterType = "TypeParameterDeclaration") => {
  (0, _utils.default)(name, {
    builder: ["id", "typeParameters", "extends", "body"],
    visitor: ["id", "typeParameters", "extends", "mixins", "implements", "body"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)(typeParameterType),
      extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
      mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
      implements: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ClassImplements")),
      body: (0, _utils.validateType)("ObjectTypeAnnotation")
    }
  });
};

(0, _utils.default)("AnyTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("ArrayTypeAnnotation", {
  visitor: ["elementType"],
  aliases: ["Flow", "FlowType"],
  fields: {
    elementType: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("BooleanTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("BooleanLiteralTypeAnnotation", {
  builder: ["value"],
  aliases: ["Flow", "FlowType"],
  fields: {
    value: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
  }
});
(0, _utils.default)("NullLiteralTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("ClassImplements", {
  visitor: ["id", "typeParameters"],
  aliases: ["Flow"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
  }
});
defineInterfaceishType("DeclareClass");
(0, _utils.default)("DeclareFunction", {
  visitor: ["id"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    predicate: (0, _utils.validateOptionalType)("DeclaredPredicate")
  }
});
defineInterfaceishType("DeclareInterface");
(0, _utils.default)("DeclareModule", {
  builder: ["id", "body", "kind"],
  visitor: ["id", "body"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
    body: (0, _utils.validateType)("BlockStatement"),
    kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("CommonJS", "ES"))
  }
});
(0, _utils.default)("DeclareModuleExports", {
  visitor: ["typeAnnotation"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
  }
});
(0, _utils.default)("DeclareTypeAlias", {
  visitor: ["id", "typeParameters", "right"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
    right: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("DeclareOpaqueType", {
  visitor: ["id", "typeParameters", "supertype"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
    supertype: (0, _utils.validateOptionalType)("FlowType")
  }
});
(0, _utils.default)("DeclareVariable", {
  visitor: ["id"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, _utils.validateType)("Identifier")
  }
});
(0, _utils.default)("DeclareExportDeclaration", {
  visitor: ["declaration", "specifiers", "source"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    declaration: (0, _utils.validateOptionalType)("Flow"),
    specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])),
    source: (0, _utils.validateOptionalType)("StringLiteral"),
    default: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
  }
});
(0, _utils.default)("DeclareExportAllDeclaration", {
  visitor: ["source"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    source: (0, _utils.validateType)("StringLiteral"),
    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
  }
});
(0, _utils.default)("DeclaredPredicate", {
  visitor: ["value"],
  aliases: ["Flow", "FlowPredicate"],
  fields: {
    value: (0, _utils.validateType)("Flow")
  }
});
(0, _utils.default)("ExistsTypeAnnotation", {
  aliases: ["Flow", "FlowType"]
});
(0, _utils.default)("FunctionTypeAnnotation", {
  visitor: ["typeParameters", "params", "rest", "returnType"],
  aliases: ["Flow", "FlowType"],
  fields: {
    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
    params: (0, _utils.validate)((0, _utils.arrayOfType)("FunctionTypeParam")),
    rest: (0, _utils.validateOptionalType)("FunctionTypeParam"),
    returnType: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("FunctionTypeParam", {
  visitor: ["name", "typeAnnotation"],
  aliases: ["Flow"],
  fields: {
    name: (0, _utils.validateOptionalType)("Identifier"),
    typeAnnotation: (0, _utils.validateType)("FlowType"),
    optional: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
  }
});
(0, _utils.default)("GenericTypeAnnotation", {
  visitor: ["id", "typeParameters"],
  aliases: ["Flow", "FlowType"],
  fields: {
    id: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
    typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
  }
});
(0, _utils.default)("InferredPredicate", {
  aliases: ["Flow", "FlowPredicate"]
});
(0, _utils.default)("InterfaceExtends", {
  visitor: ["id", "typeParameters"],
  aliases: ["Flow"],
  fields: {
    id: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
    typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
  }
});
defineInterfaceishType("InterfaceDeclaration");
(0, _utils.default)("InterfaceTypeAnnotation", {
  visitor: ["extends", "body"],
  aliases: ["Flow", "FlowType"],
  fields: {
    extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
    body: (0, _utils.validateType)("ObjectTypeAnnotation")
  }
});
(0, _utils.default)("IntersectionTypeAnnotation", {
  visitor: ["types"],
  aliases: ["Flow", "FlowType"],
  fields: {
    types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
  }
});
(0, _utils.default)("MixedTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("EmptyTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("NullableTypeAnnotation", {
  visitor: ["typeAnnotation"],
  aliases: ["Flow", "FlowType"],
  fields: {
    typeAnnotation: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("NumberLiteralTypeAnnotation", {
  builder: ["value"],
  aliases: ["Flow", "FlowType"],
  fields: {
    value: (0, _utils.validate)((0, _utils.assertValueType)("number"))
  }
});
(0, _utils.default)("NumberTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("ObjectTypeAnnotation", {
  visitor: ["properties", "indexers", "callProperties", "internalSlots"],
  aliases: ["Flow", "FlowType"],
  builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
  fields: {
    properties: (0, _utils.validate)((0, _utils.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])),
    indexers: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeIndexer")),
    callProperties: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeCallProperty")),
    internalSlots: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeInternalSlot")),
    exact: {
      validate: (0, _utils.assertValueType)("boolean"),
      default: false
    },
    inexact: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
  }
});
(0, _utils.default)("ObjectTypeInternalSlot", {
  visitor: ["id", "value", "optional", "static", "method"],
  aliases: ["Flow", "UserWhitespacable"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    value: (0, _utils.validateType)("FlowType"),
    optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
  }
});
(0, _utils.default)("ObjectTypeCallProperty", {
  visitor: ["value"],
  aliases: ["Flow", "UserWhitespacable"],
  fields: {
    value: (0, _utils.validateType)("FlowType"),
    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
  }
});
(0, _utils.default)("ObjectTypeIndexer", {
  visitor: ["id", "key", "value", "variance"],
  aliases: ["Flow", "UserWhitespacable"],
  fields: {
    id: (0, _utils.validateOptionalType)("Identifier"),
    key: (0, _utils.validateType)("FlowType"),
    value: (0, _utils.validateType)("FlowType"),
    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    variance: (0, _utils.validateOptionalType)("Variance")
  }
});
(0, _utils.default)("ObjectTypeProperty", {
  visitor: ["key", "value", "variance"],
  aliases: ["Flow", "UserWhitespacable"],
  fields: {
    key: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
    value: (0, _utils.validateType)("FlowType"),
    kind: (0, _utils.validate)((0, _utils.assertOneOf)("init", "get", "set")),
    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    proto: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    variance: (0, _utils.validateOptionalType)("Variance")
  }
});
(0, _utils.default)("ObjectTypeSpreadProperty", {
  visitor: ["argument"],
  aliases: ["Flow", "UserWhitespacable"],
  fields: {
    argument: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("OpaqueType", {
  visitor: ["id", "typeParameters", "supertype", "impltype"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
    supertype: (0, _utils.validateOptionalType)("FlowType"),
    impltype: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("QualifiedTypeIdentifier", {
  visitor: ["id", "qualification"],
  aliases: ["Flow"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    qualification: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"])
  }
});
(0, _utils.default)("StringLiteralTypeAnnotation", {
  builder: ["value"],
  aliases: ["Flow", "FlowType"],
  fields: {
    value: (0, _utils.validate)((0, _utils.assertValueType)("string"))
  }
});
(0, _utils.default)("StringTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("SymbolTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("ThisTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("TupleTypeAnnotation", {
  visitor: ["types"],
  aliases: ["Flow", "FlowType"],
  fields: {
    types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
  }
});
(0, _utils.default)("TypeofTypeAnnotation", {
  visitor: ["argument"],
  aliases: ["Flow", "FlowType"],
  fields: {
    argument: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("TypeAlias", {
  visitor: ["id", "typeParameters", "right"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
    right: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("TypeAnnotation", {
  aliases: ["Flow"],
  visitor: ["typeAnnotation"],
  fields: {
    typeAnnotation: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("TypeCastExpression", {
  visitor: ["expression", "typeAnnotation"],
  aliases: ["Flow", "ExpressionWrapper", "Expression"],
  fields: {
    expression: (0, _utils.validateType)("Expression"),
    typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
  }
});
(0, _utils.default)("TypeParameter", {
  aliases: ["Flow"],
  visitor: ["bound", "default", "variance"],
  fields: {
    name: (0, _utils.validate)((0, _utils.assertValueType)("string")),
    bound: (0, _utils.validateOptionalType)("TypeAnnotation"),
    default: (0, _utils.validateOptionalType)("FlowType"),
    variance: (0, _utils.validateOptionalType)("Variance")
  }
});
(0, _utils.default)("TypeParameterDeclaration", {
  aliases: ["Flow"],
  visitor: ["params"],
  fields: {
    params: (0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter"))
  }
});
(0, _utils.default)("TypeParameterInstantiation", {
  aliases: ["Flow"],
  visitor: ["params"],
  fields: {
    params: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
  }
});
(0, _utils.default)("UnionTypeAnnotation", {
  visitor: ["types"],
  aliases: ["Flow", "FlowType"],
  fields: {
    types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
  }
});
(0, _utils.default)("Variance", {
  aliases: ["Flow"],
  builder: ["kind"],
  fields: {
    kind: (0, _utils.validate)((0, _utils.assertOneOf)("minus", "plus"))
  }
});
(0, _utils.default)("VoidTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("EnumDeclaration", {
  aliases: ["Statement", "Declaration"],
  visitor: ["id", "body"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    body: (0, _utils.validateType)(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"])
  }
});
(0, _utils.default)("EnumBooleanBody", {
  aliases: ["EnumBody"],
  visitor: ["members"],
  fields: {
    explicit: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    members: (0, _utils.validateArrayOfType)("EnumBooleanMember")
  }
});
(0, _utils.default)("EnumNumberBody", {
  aliases: ["EnumBody"],
  visitor: ["members"],
  fields: {
    explicit: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    members: (0, _utils.validateArrayOfType)("EnumNumberMember")
  }
});
(0, _utils.default)("EnumStringBody", {
  aliases: ["EnumBody"],
  visitor: ["members"],
  fields: {
    explicit: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    members: (0, _utils.validateArrayOfType)(["EnumStringMember", "EnumDefaultedMember"])
  }
});
(0, _utils.default)("EnumSymbolBody", {
  aliases: ["EnumBody"],
  visitor: ["members"],
  fields: {
    members: (0, _utils.validateArrayOfType)("EnumDefaultedMember")
  }
});
(0, _utils.default)("EnumBooleanMember", {
  aliases: ["EnumMember"],
  visitor: ["id"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    init: (0, _utils.validateType)("BooleanLiteral")
  }
});
(0, _utils.default)("EnumNumberMember", {
  aliases: ["EnumMember"],
  visitor: ["id", "init"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    init: (0, _utils.validateType)("NumericLiteral")
  }
});
(0, _utils.default)("EnumStringMember", {
  aliases: ["EnumMember"],
  visitor: ["id", "init"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    init: (0, _utils.validateType)("StringLiteral")
  }
});
(0, _utils.default)("EnumDefaultedMember", {
  aliases: ["EnumMember"],
  visitor: ["id"],
  fields: {
    id: (0, _utils.validateType)("Identifier")
  }
});
},{"./utils":71}],66:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "VISITOR_KEYS", {
  enumerable: true,
  get: function () {
    return _utils.VISITOR_KEYS;
  }
});
Object.defineProperty(exports, "ALIAS_KEYS", {
  enumerable: true,
  get: function () {
    return _utils.ALIAS_KEYS;
  }
});
Object.defineProperty(exports, "FLIPPED_ALIAS_KEYS", {
  enumerable: true,
  get: function () {
    return _utils.FLIPPED_ALIAS_KEYS;
  }
});
Object.defineProperty(exports, "NODE_FIELDS", {
  enumerable: true,
  get: function () {
    return _utils.NODE_FIELDS;
  }
});
Object.defineProperty(exports, "BUILDER_KEYS", {
  enumerable: true,
  get: function () {
    return _utils.BUILDER_KEYS;
  }
});
Object.defineProperty(exports, "DEPRECATED_KEYS", {
  enumerable: true,
  get: function () {
    return _utils.DEPRECATED_KEYS;
  }
});
Object.defineProperty(exports, "NODE_PARENT_VALIDATIONS", {
  enumerable: true,
  get: function () {
    return _utils.NODE_PARENT_VALIDATIONS;
  }
});
Object.defineProperty(exports, "PLACEHOLDERS", {
  enumerable: true,
  get: function () {
    return _placeholders.PLACEHOLDERS;
  }
});
Object.defineProperty(exports, "PLACEHOLDERS_ALIAS", {
  enumerable: true,
  get: function () {
    return _placeholders.PLACEHOLDERS_ALIAS;
  }
});
Object.defineProperty(exports, "PLACEHOLDERS_FLIPPED_ALIAS", {
  enumerable: true,
  get: function () {
    return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;
  }
});
exports.TYPES = void 0;

var _toFastProperties = _interopRequireDefault(require("to-fast-properties"));

require("./core");

require("./flow");

require("./jsx");

require("./misc");

require("./experimental");

require("./typescript");

var _utils = require("./utils");

var _placeholders = require("./placeholders");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _toFastProperties.default)(_utils.VISITOR_KEYS);
(0, _toFastProperties.default)(_utils.ALIAS_KEYS);
(0, _toFastProperties.default)(_utils.FLIPPED_ALIAS_KEYS);
(0, _toFastProperties.default)(_utils.NODE_FIELDS);
(0, _toFastProperties.default)(_utils.BUILDER_KEYS);
(0, _toFastProperties.default)(_utils.DEPRECATED_KEYS);
(0, _toFastProperties.default)(_placeholders.PLACEHOLDERS_ALIAS);
(0, _toFastProperties.default)(_placeholders.PLACEHOLDERS_FLIPPED_ALIAS);
const TYPES = Object.keys(_utils.VISITOR_KEYS).concat(Object.keys(_utils.FLIPPED_ALIAS_KEYS)).concat(Object.keys(_utils.DEPRECATED_KEYS));
exports.TYPES = TYPES;
},{"./core":63,"./experimental":64,"./flow":65,"./jsx":67,"./misc":68,"./placeholders":69,"./typescript":70,"./utils":71,"to-fast-properties":228}],67:[function(require,module,exports){
"use strict";

var _utils = _interopRequireWildcard(require("./utils"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

(0, _utils.default)("JSXAttribute", {
  visitor: ["name", "value"],
  aliases: ["JSX", "Immutable"],
  fields: {
    name: {
      validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
    },
    value: {
      optional: true,
      validate: (0, _utils.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
    }
  }
});
(0, _utils.default)("JSXClosingElement", {
  visitor: ["name"],
  aliases: ["JSX", "Immutable"],
  fields: {
    name: {
      validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
    }
  }
});
(0, _utils.default)("JSXElement", {
  builder: ["openingElement", "closingElement", "children", "selfClosing"],
  visitor: ["openingElement", "children", "closingElement"],
  aliases: ["JSX", "Immutable", "Expression"],
  fields: {
    openingElement: {
      validate: (0, _utils.assertNodeType)("JSXOpeningElement")
    },
    closingElement: {
      optional: true,
      validate: (0, _utils.assertNodeType)("JSXClosingElement")
    },
    children: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
    },
    selfClosing: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    }
  }
});
(0, _utils.default)("JSXEmptyExpression", {
  aliases: ["JSX"]
});
(0, _utils.default)("JSXExpressionContainer", {
  visitor: ["expression"],
  aliases: ["JSX", "Immutable"],
  fields: {
    expression: {
      validate: (0, _utils.assertNodeType)("Expression", "JSXEmptyExpression")
    }
  }
});
(0, _utils.default)("JSXSpreadChild", {
  visitor: ["expression"],
  aliases: ["JSX", "Immutable"],
  fields: {
    expression: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("JSXIdentifier", {
  builder: ["name"],
  aliases: ["JSX"],
  fields: {
    name: {
      validate: (0, _utils.assertValueType)("string")
    }
  }
});
(0, _utils.default)("JSXMemberExpression", {
  visitor: ["object", "property"],
  aliases: ["JSX"],
  fields: {
    object: {
      validate: (0, _utils.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
    },
    property: {
      validate: (0, _utils.assertNodeType)("JSXIdentifier")
    }
  }
});
(0, _utils.default)("JSXNamespacedName", {
  visitor: ["namespace", "name"],
  aliases: ["JSX"],
  fields: {
    namespace: {
      validate: (0, _utils.assertNodeType)("JSXIdentifier")
    },
    name: {
      validate: (0, _utils.assertNodeType)("JSXIdentifier")
    }
  }
});
(0, _utils.default)("JSXOpeningElement", {
  builder: ["name", "attributes", "selfClosing"],
  visitor: ["name", "attributes"],
  aliases: ["JSX", "Immutable"],
  fields: {
    name: {
      validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
    },
    selfClosing: {
      default: false
    },
    attributes: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXAttribute", "JSXSpreadAttribute")))
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
      optional: true
    }
  }
});
(0, _utils.default)("JSXSpreadAttribute", {
  visitor: ["argument"],
  aliases: ["JSX"],
  fields: {
    argument: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("JSXText", {
  aliases: ["JSX", "Immutable"],
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("string")
    }
  }
});
(0, _utils.default)("JSXFragment", {
  builder: ["openingFragment", "closingFragment", "children"],
  visitor: ["openingFragment", "children", "closingFragment"],
  aliases: ["JSX", "Immutable", "Expression"],
  fields: {
    openingFragment: {
      validate: (0, _utils.assertNodeType)("JSXOpeningFragment")
    },
    closingFragment: {
      validate: (0, _utils.assertNodeType)("JSXClosingFragment")
    },
    children: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
    }
  }
});
(0, _utils.default)("JSXOpeningFragment", {
  aliases: ["JSX", "Immutable"]
});
(0, _utils.default)("JSXClosingFragment", {
  aliases: ["JSX", "Immutable"]
});
},{"./utils":71}],68:[function(require,module,exports){
"use strict";

var _utils = _interopRequireWildcard(require("./utils"));

var _placeholders = require("./placeholders");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

(0, _utils.default)("Noop", {
  visitor: []
});
(0, _utils.default)("Placeholder", {
  visitor: [],
  builder: ["expectedNode", "name"],
  fields: {
    name: {
      validate: (0, _utils.assertNodeType)("Identifier")
    },
    expectedNode: {
      validate: (0, _utils.assertOneOf)(..._placeholders.PLACEHOLDERS)
    }
  }
});
(0, _utils.default)("V8IntrinsicIdentifier", {
  builder: ["name"],
  fields: {
    name: {
      validate: (0, _utils.assertValueType)("string")
    }
  }
});
},{"./placeholders":69,"./utils":71}],69:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PLACEHOLDERS_FLIPPED_ALIAS = exports.PLACEHOLDERS_ALIAS = exports.PLACEHOLDERS = void 0;

var _utils = require("./utils");

const PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"];
exports.PLACEHOLDERS = PLACEHOLDERS;
const PLACEHOLDERS_ALIAS = {
  Declaration: ["Statement"],
  Pattern: ["PatternLike", "LVal"]
};
exports.PLACEHOLDERS_ALIAS = PLACEHOLDERS_ALIAS;

for (const type of PLACEHOLDERS) {
  const alias = _utils.ALIAS_KEYS[type];
  if (alias == null ? void 0 : alias.length) PLACEHOLDERS_ALIAS[type] = alias;
}

const PLACEHOLDERS_FLIPPED_ALIAS = {};
exports.PLACEHOLDERS_FLIPPED_ALIAS = PLACEHOLDERS_FLIPPED_ALIAS;
Object.keys(PLACEHOLDERS_ALIAS).forEach(type => {
  PLACEHOLDERS_ALIAS[type].forEach(alias => {
    if (!Object.hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {
      PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];
    }

    PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);
  });
});
},{"./utils":71}],70:[function(require,module,exports){
"use strict";

var _utils = _interopRequireWildcard(require("./utils"));

var _core = require("./core");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const bool = (0, _utils.assertValueType)("boolean");
const tSFunctionTypeAnnotationCommon = {
  returnType: {
    validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"),
    optional: true
  },
  typeParameters: {
    validate: (0, _utils.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
    optional: true
  }
};
(0, _utils.default)("TSParameterProperty", {
  aliases: ["LVal"],
  visitor: ["parameter"],
  fields: {
    accessibility: {
      validate: (0, _utils.assertOneOf)("public", "private", "protected"),
      optional: true
    },
    readonly: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    parameter: {
      validate: (0, _utils.assertNodeType)("Identifier", "AssignmentPattern")
    }
  }
});
(0, _utils.default)("TSDeclareFunction", {
  aliases: ["Statement", "Declaration"],
  visitor: ["id", "typeParameters", "params", "returnType"],
  fields: Object.assign({}, _core.functionDeclarationCommon, tSFunctionTypeAnnotationCommon)
});
(0, _utils.default)("TSDeclareMethod", {
  visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
  fields: Object.assign({}, _core.classMethodOrDeclareMethodCommon, tSFunctionTypeAnnotationCommon)
});
(0, _utils.default)("TSQualifiedName", {
  aliases: ["TSEntityName"],
  visitor: ["left", "right"],
  fields: {
    left: (0, _utils.validateType)("TSEntityName"),
    right: (0, _utils.validateType)("Identifier")
  }
});
const signatureDeclarationCommon = {
  typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
  parameters: (0, _utils.validateArrayOfType)(["Identifier", "RestElement"]),
  typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
};
const callConstructSignatureDeclaration = {
  aliases: ["TSTypeElement"],
  visitor: ["typeParameters", "parameters", "typeAnnotation"],
  fields: signatureDeclarationCommon
};
(0, _utils.default)("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
(0, _utils.default)("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
const namedTypeElementCommon = {
  key: (0, _utils.validateType)("Expression"),
  computed: (0, _utils.validate)(bool),
  optional: (0, _utils.validateOptional)(bool)
};
(0, _utils.default)("TSPropertySignature", {
  aliases: ["TSTypeElement"],
  visitor: ["key", "typeAnnotation", "initializer"],
  fields: Object.assign({}, namedTypeElementCommon, {
    readonly: (0, _utils.validateOptional)(bool),
    typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
    initializer: (0, _utils.validateOptionalType)("Expression")
  })
});
(0, _utils.default)("TSMethodSignature", {
  aliases: ["TSTypeElement"],
  visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
  fields: Object.assign({}, signatureDeclarationCommon, namedTypeElementCommon)
});
(0, _utils.default)("TSIndexSignature", {
  aliases: ["TSTypeElement"],
  visitor: ["parameters", "typeAnnotation"],
  fields: {
    readonly: (0, _utils.validateOptional)(bool),
    parameters: (0, _utils.validateArrayOfType)("Identifier"),
    typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
  }
});
const tsKeywordTypes = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];

for (const type of tsKeywordTypes) {
  (0, _utils.default)(type, {
    aliases: ["TSType", "TSBaseType"],
    visitor: [],
    fields: {}
  });
}

(0, _utils.default)("TSThisType", {
  aliases: ["TSType", "TSBaseType"],
  visitor: [],
  fields: {}
});
const fnOrCtr = {
  aliases: ["TSType"],
  visitor: ["typeParameters", "parameters", "typeAnnotation"],
  fields: signatureDeclarationCommon
};
(0, _utils.default)("TSFunctionType", fnOrCtr);
(0, _utils.default)("TSConstructorType", fnOrCtr);
(0, _utils.default)("TSTypeReference", {
  aliases: ["TSType"],
  visitor: ["typeName", "typeParameters"],
  fields: {
    typeName: (0, _utils.validateType)("TSEntityName"),
    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
  }
});
(0, _utils.default)("TSTypePredicate", {
  aliases: ["TSType"],
  visitor: ["parameterName", "typeAnnotation"],
  builder: ["parameterName", "typeAnnotation", "asserts"],
  fields: {
    parameterName: (0, _utils.validateType)(["Identifier", "TSThisType"]),
    typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
    asserts: (0, _utils.validateOptional)(bool)
  }
});
(0, _utils.default)("TSTypeQuery", {
  aliases: ["TSType"],
  visitor: ["exprName"],
  fields: {
    exprName: (0, _utils.validateType)(["TSEntityName", "TSImportType"])
  }
});
(0, _utils.default)("TSTypeLiteral", {
  aliases: ["TSType"],
  visitor: ["members"],
  fields: {
    members: (0, _utils.validateArrayOfType)("TSTypeElement")
  }
});
(0, _utils.default)("TSArrayType", {
  aliases: ["TSType"],
  visitor: ["elementType"],
  fields: {
    elementType: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSTupleType", {
  aliases: ["TSType"],
  visitor: ["elementTypes"],
  fields: {
    elementTypes: (0, _utils.validateArrayOfType)(["TSType", "TSNamedTupleMember"])
  }
});
(0, _utils.default)("TSOptionalType", {
  aliases: ["TSType"],
  visitor: ["typeAnnotation"],
  fields: {
    typeAnnotation: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSRestType", {
  aliases: ["TSType"],
  visitor: ["typeAnnotation"],
  fields: {
    typeAnnotation: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSNamedTupleMember", {
  visitor: ["label", "elementType"],
  builder: ["label", "elementType", "optional"],
  fields: {
    label: (0, _utils.validateType)("Identifier"),
    optional: {
      validate: bool,
      default: false
    },
    elementType: (0, _utils.validateType)("TSType")
  }
});
const unionOrIntersection = {
  aliases: ["TSType"],
  visitor: ["types"],
  fields: {
    types: (0, _utils.validateArrayOfType)("TSType")
  }
};
(0, _utils.default)("TSUnionType", unionOrIntersection);
(0, _utils.default)("TSIntersectionType", unionOrIntersection);
(0, _utils.default)("TSConditionalType", {
  aliases: ["TSType"],
  visitor: ["checkType", "extendsType", "trueType", "falseType"],
  fields: {
    checkType: (0, _utils.validateType)("TSType"),
    extendsType: (0, _utils.validateType)("TSType"),
    trueType: (0, _utils.validateType)("TSType"),
    falseType: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSInferType", {
  aliases: ["TSType"],
  visitor: ["typeParameter"],
  fields: {
    typeParameter: (0, _utils.validateType)("TSTypeParameter")
  }
});
(0, _utils.default)("TSParenthesizedType", {
  aliases: ["TSType"],
  visitor: ["typeAnnotation"],
  fields: {
    typeAnnotation: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSTypeOperator", {
  aliases: ["TSType"],
  visitor: ["typeAnnotation"],
  fields: {
    operator: (0, _utils.validate)((0, _utils.assertValueType)("string")),
    typeAnnotation: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSIndexedAccessType", {
  aliases: ["TSType"],
  visitor: ["objectType", "indexType"],
  fields: {
    objectType: (0, _utils.validateType)("TSType"),
    indexType: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSMappedType", {
  aliases: ["TSType"],
  visitor: ["typeParameter", "typeAnnotation"],
  fields: {
    readonly: (0, _utils.validateOptional)(bool),
    typeParameter: (0, _utils.validateType)("TSTypeParameter"),
    optional: (0, _utils.validateOptional)(bool),
    typeAnnotation: (0, _utils.validateOptionalType)("TSType")
  }
});
(0, _utils.default)("TSLiteralType", {
  aliases: ["TSType", "TSBaseType"],
  visitor: ["literal"],
  fields: {
    literal: (0, _utils.validateType)(["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral"])
  }
});
(0, _utils.default)("TSExpressionWithTypeArguments", {
  aliases: ["TSType"],
  visitor: ["expression", "typeParameters"],
  fields: {
    expression: (0, _utils.validateType)("TSEntityName"),
    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
  }
});
(0, _utils.default)("TSInterfaceDeclaration", {
  aliases: ["Statement", "Declaration"],
  visitor: ["id", "typeParameters", "extends", "body"],
  fields: {
    declare: (0, _utils.validateOptional)(bool),
    id: (0, _utils.validateType)("Identifier"),
    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
    extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("TSExpressionWithTypeArguments")),
    body: (0, _utils.validateType)("TSInterfaceBody")
  }
});
(0, _utils.default)("TSInterfaceBody", {
  visitor: ["body"],
  fields: {
    body: (0, _utils.validateArrayOfType)("TSTypeElement")
  }
});
(0, _utils.default)("TSTypeAliasDeclaration", {
  aliases: ["Statement", "Declaration"],
  visitor: ["id", "typeParameters", "typeAnnotation"],
  fields: {
    declare: (0, _utils.validateOptional)(bool),
    id: (0, _utils.validateType)("Identifier"),
    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
    typeAnnotation: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSAsExpression", {
  aliases: ["Expression"],
  visitor: ["expression", "typeAnnotation"],
  fields: {
    expression: (0, _utils.validateType)("Expression"),
    typeAnnotation: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSTypeAssertion", {
  aliases: ["Expression"],
  visitor: ["typeAnnotation", "expression"],
  fields: {
    typeAnnotation: (0, _utils.validateType)("TSType"),
    expression: (0, _utils.validateType)("Expression")
  }
});
(0, _utils.default)("TSEnumDeclaration", {
  aliases: ["Statement", "Declaration"],
  visitor: ["id", "members"],
  fields: {
    declare: (0, _utils.validateOptional)(bool),
    const: (0, _utils.validateOptional)(bool),
    id: (0, _utils.validateType)("Identifier"),
    members: (0, _utils.validateArrayOfType)("TSEnumMember"),
    initializer: (0, _utils.validateOptionalType)("Expression")
  }
});
(0, _utils.default)("TSEnumMember", {
  visitor: ["id", "initializer"],
  fields: {
    id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
    initializer: (0, _utils.validateOptionalType)("Expression")
  }
});
(0, _utils.default)("TSModuleDeclaration", {
  aliases: ["Statement", "Declaration"],
  visitor: ["id", "body"],
  fields: {
    declare: (0, _utils.validateOptional)(bool),
    global: (0, _utils.validateOptional)(bool),
    id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
    body: (0, _utils.validateType)(["TSModuleBlock", "TSModuleDeclaration"])
  }
});
(0, _utils.default)("TSModuleBlock", {
  aliases: ["Scopable", "Block", "BlockParent"],
  visitor: ["body"],
  fields: {
    body: (0, _utils.validateArrayOfType)("Statement")
  }
});
(0, _utils.default)("TSImportType", {
  aliases: ["TSType"],
  visitor: ["argument", "qualifier", "typeParameters"],
  fields: {
    argument: (0, _utils.validateType)("StringLiteral"),
    qualifier: (0, _utils.validateOptionalType)("TSEntityName"),
    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
  }
});
(0, _utils.default)("TSImportEqualsDeclaration", {
  aliases: ["Statement"],
  visitor: ["id", "moduleReference"],
  fields: {
    isExport: (0, _utils.validate)(bool),
    id: (0, _utils.validateType)("Identifier"),
    moduleReference: (0, _utils.validateType)(["TSEntityName", "TSExternalModuleReference"])
  }
});
(0, _utils.default)("TSExternalModuleReference", {
  visitor: ["expression"],
  fields: {
    expression: (0, _utils.validateType)("StringLiteral")
  }
});
(0, _utils.default)("TSNonNullExpression", {
  aliases: ["Expression"],
  visitor: ["expression"],
  fields: {
    expression: (0, _utils.validateType)("Expression")
  }
});
(0, _utils.default)("TSExportAssignment", {
  aliases: ["Statement"],
  visitor: ["expression"],
  fields: {
    expression: (0, _utils.validateType)("Expression")
  }
});
(0, _utils.default)("TSNamespaceExportDeclaration", {
  aliases: ["Statement"],
  visitor: ["id"],
  fields: {
    id: (0, _utils.validateType)("Identifier")
  }
});
(0, _utils.default)("TSTypeAnnotation", {
  visitor: ["typeAnnotation"],
  fields: {
    typeAnnotation: {
      validate: (0, _utils.assertNodeType)("TSType")
    }
  }
});
(0, _utils.default)("TSTypeParameterInstantiation", {
  visitor: ["params"],
  fields: {
    params: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSType")))
    }
  }
});
(0, _utils.default)("TSTypeParameterDeclaration", {
  visitor: ["params"],
  fields: {
    params: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSTypeParameter")))
    }
  }
});
(0, _utils.default)("TSTypeParameter", {
  builder: ["constraint", "default", "name"],
  visitor: ["constraint", "default"],
  fields: {
    name: {
      validate: (0, _utils.assertValueType)("string")
    },
    constraint: {
      validate: (0, _utils.assertNodeType)("TSType"),
      optional: true
    },
    default: {
      validate: (0, _utils.assertNodeType)("TSType"),
      optional: true
    }
  }
});
},{"./core":63,"./utils":71}],71:[function(require,module,exports){
(function (process){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validate = validate;
exports.typeIs = typeIs;
exports.validateType = validateType;
exports.validateOptional = validateOptional;
exports.validateOptionalType = validateOptionalType;
exports.arrayOf = arrayOf;
exports.arrayOfType = arrayOfType;
exports.validateArrayOfType = validateArrayOfType;
exports.assertEach = assertEach;
exports.assertOneOf = assertOneOf;
exports.assertNodeType = assertNodeType;
exports.assertNodeOrValueType = assertNodeOrValueType;
exports.assertValueType = assertValueType;
exports.assertShape = assertShape;
exports.assertOptionalChainStart = assertOptionalChainStart;
exports.chain = chain;
exports.default = defineType;
exports.NODE_PARENT_VALIDATIONS = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.NODE_FIELDS = exports.FLIPPED_ALIAS_KEYS = exports.ALIAS_KEYS = exports.VISITOR_KEYS = void 0;

var _is = _interopRequireDefault(require("../validators/is"));

var _validate = require("../validators/validate");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const VISITOR_KEYS = {};
exports.VISITOR_KEYS = VISITOR_KEYS;
const ALIAS_KEYS = {};
exports.ALIAS_KEYS = ALIAS_KEYS;
const FLIPPED_ALIAS_KEYS = {};
exports.FLIPPED_ALIAS_KEYS = FLIPPED_ALIAS_KEYS;
const NODE_FIELDS = {};
exports.NODE_FIELDS = NODE_FIELDS;
const BUILDER_KEYS = {};
exports.BUILDER_KEYS = BUILDER_KEYS;
const DEPRECATED_KEYS = {};
exports.DEPRECATED_KEYS = DEPRECATED_KEYS;
const NODE_PARENT_VALIDATIONS = {};
exports.NODE_PARENT_VALIDATIONS = NODE_PARENT_VALIDATIONS;

function getType(val) {
  if (Array.isArray(val)) {
    return "array";
  } else if (val === null) {
    return "null";
  } else {
    return typeof val;
  }
}

function validate(validate) {
  return {
    validate
  };
}

function typeIs(typeName) {
  return typeof typeName === "string" ? assertNodeType(typeName) : assertNodeType(...typeName);
}

function validateType(typeName) {
  return validate(typeIs(typeName));
}

function validateOptional(validate) {
  return {
    validate,
    optional: true
  };
}

function validateOptionalType(typeName) {
  return {
    validate: typeIs(typeName),
    optional: true
  };
}

function arrayOf(elementType) {
  return chain(assertValueType("array"), assertEach(elementType));
}

function arrayOfType(typeName) {
  return arrayOf(typeIs(typeName));
}

function validateArrayOfType(typeName) {
  return validate(arrayOfType(typeName));
}

function assertEach(callback) {
  function validator(node, key, val) {
    if (!Array.isArray(val)) return;

    for (let i = 0; i < val.length; i++) {
      const subkey = `${key}[${i}]`;
      const v = val[i];
      callback(node, subkey, v);
      if (process.env.BABEL_TYPES_8_BREAKING) (0, _validate.validateChild)(node, subkey, v);
    }
  }

  validator.each = callback;
  return validator;
}

function assertOneOf(...values) {
  function validate(node, key, val) {
    if (values.indexOf(val) < 0) {
      throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
    }
  }

  validate.oneOf = values;
  return validate;
}

function assertNodeType(...types) {
  function validate(node, key, val) {
    for (const type of types) {
      if ((0, _is.default)(type, val)) {
        (0, _validate.validateChild)(node, key, val);
        return;
      }
    }

    throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
  }

  validate.oneOfNodeTypes = types;
  return validate;
}

function assertNodeOrValueType(...types) {
  function validate(node, key, val) {
    for (const type of types) {
      if (getType(val) === type || (0, _is.default)(type, val)) {
        (0, _validate.validateChild)(node, key, val);
        return;
      }
    }

    throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
  }

  validate.oneOfNodeOrValueTypes = types;
  return validate;
}

function assertValueType(type) {
  function validate(node, key, val) {
    const valid = getType(val) === type;

    if (!valid) {
      throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
    }
  }

  validate.type = type;
  return validate;
}

function assertShape(shape) {
  function validate(node, key, val) {
    const errors = [];

    for (const property of Object.keys(shape)) {
      try {
        (0, _validate.validateField)(node, property, val[property], shape[property]);
      } catch (error) {
        if (error instanceof TypeError) {
          errors.push(error.message);
          continue;
        }

        throw error;
      }
    }

    if (errors.length) {
      throw new TypeError(`Property ${key} of ${node.type} expected to have the following:\n${errors.join("\n")}`);
    }
  }

  validate.shapeOf = shape;
  return validate;
}

function assertOptionalChainStart() {
  function validate(node) {
    var _current;

    let current = node;

    while (node) {
      const {
        type
      } = current;

      if (type === "OptionalCallExpression") {
        if (current.optional) return;
        current = current.callee;
        continue;
      }

      if (type === "OptionalMemberExpression") {
        if (current.optional) return;
        current = current.object;
        continue;
      }

      break;
    }

    throw new TypeError(`Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(_current = current) == null ? void 0 : _current.type}`);
  }

  return validate;
}

function chain(...fns) {
  function validate(...args) {
    for (const fn of fns) {
      fn(...args);
    }
  }

  validate.chainOf = fns;
  return validate;
}

const validTypeOpts = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"];
const validFieldKeys = ["default", "optional", "validate"];

function defineType(type, opts = {}) {
  const inherits = opts.inherits && store[opts.inherits] || {};
  let fields = opts.fields;

  if (!fields) {
    fields = {};

    if (inherits.fields) {
      const keys = Object.getOwnPropertyNames(inherits.fields);

      for (const key of keys) {
        const field = inherits.fields[key];
        fields[key] = {
          default: field.default,
          optional: field.optional,
          validate: field.validate
        };
      }
    }
  }

  const visitor = opts.visitor || inherits.visitor || [];
  const aliases = opts.aliases || inherits.aliases || [];
  const builder = opts.builder || inherits.builder || opts.visitor || [];

  for (const k of Object.keys(opts)) {
    if (validTypeOpts.indexOf(k) === -1) {
      throw new Error(`Unknown type option "${k}" on ${type}`);
    }
  }

  if (opts.deprecatedAlias) {
    DEPRECATED_KEYS[opts.deprecatedAlias] = type;
  }

  for (const key of visitor.concat(builder)) {
    fields[key] = fields[key] || {};
  }

  for (const key of Object.keys(fields)) {
    const field = fields[key];

    if (field.default !== undefined && builder.indexOf(key) === -1) {
      field.optional = true;
    }

    if (field.default === undefined) {
      field.default = null;
    } else if (!field.validate && field.default != null) {
      field.validate = assertValueType(getType(field.default));
    }

    for (const k of Object.keys(field)) {
      if (validFieldKeys.indexOf(k) === -1) {
        throw new Error(`Unknown field key "${k}" on ${type}.${key}`);
      }
    }
  }

  VISITOR_KEYS[type] = opts.visitor = visitor;
  BUILDER_KEYS[type] = opts.builder = builder;
  NODE_FIELDS[type] = opts.fields = fields;
  ALIAS_KEYS[type] = opts.aliases = aliases;
  aliases.forEach(alias => {
    FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
    FLIPPED_ALIAS_KEYS[alias].push(type);
  });

  if (opts.validate) {
    NODE_PARENT_VALIDATIONS[type] = opts.validate;
  }

  store[type] = opts;
}

const store = {};
}).call(this,require('_process'))

},{"../validators/is":89,"../validators/validate":107,"_process":224}],72:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  react: true,
  assertNode: true,
  createTypeAnnotationBasedOnTypeof: true,
  createUnionTypeAnnotation: true,
  createFlowUnionType: true,
  createTSUnionType: true,
  cloneNode: true,
  clone: true,
  cloneDeep: true,
  cloneDeepWithoutLoc: true,
  cloneWithoutLoc: true,
  addComment: true,
  addComments: true,
  inheritInnerComments: true,
  inheritLeadingComments: true,
  inheritsComments: true,
  inheritTrailingComments: true,
  removeComments: true,
  ensureBlock: true,
  toBindingIdentifierName: true,
  toBlock: true,
  toComputedKey: true,
  toExpression: true,
  toIdentifier: true,
  toKeyAlias: true,
  toSequenceExpression: true,
  toStatement: true,
  valueToNode: true,
  appendToMemberExpression: true,
  inherits: true,
  prependToMemberExpression: true,
  removeProperties: true,
  removePropertiesDeep: true,
  removeTypeDuplicates: true,
  getBindingIdentifiers: true,
  getOuterBindingIdentifiers: true,
  traverse: true,
  traverseFast: true,
  shallowEqual: true,
  is: true,
  isBinding: true,
  isBlockScoped: true,
  isImmutable: true,
  isLet: true,
  isNode: true,
  isNodesEquivalent: true,
  isPlaceholderType: true,
  isReferenced: true,
  isScope: true,
  isSpecifierDefault: true,
  isType: true,
  isValidES3Identifier: true,
  isValidIdentifier: true,
  isVar: true,
  matchesPattern: true,
  validate: true,
  buildMatchMemberExpression: true
};
Object.defineProperty(exports, "assertNode", {
  enumerable: true,
  get: function () {
    return _assertNode.default;
  }
});
Object.defineProperty(exports, "createTypeAnnotationBasedOnTypeof", {
  enumerable: true,
  get: function () {
    return _createTypeAnnotationBasedOnTypeof.default;
  }
});
Object.defineProperty(exports, "createUnionTypeAnnotation", {
  enumerable: true,
  get: function () {
    return _createFlowUnionType.default;
  }
});
Object.defineProperty(exports, "createFlowUnionType", {
  enumerable: true,
  get: function () {
    return _createFlowUnionType.default;
  }
});
Object.defineProperty(exports, "createTSUnionType", {
  enumerable: true,
  get: function () {
    return _createTSUnionType.default;
  }
});
Object.defineProperty(exports, "cloneNode", {
  enumerable: true,
  get: function () {
    return _cloneNode.default;
  }
});
Object.defineProperty(exports, "clone", {
  enumerable: true,
  get: function () {
    return _clone.default;
  }
});
Object.defineProperty(exports, "cloneDeep", {
  enumerable: true,
  get: function () {
    return _cloneDeep.default;
  }
});
Object.defineProperty(exports, "cloneDeepWithoutLoc", {
  enumerable: true,
  get: function () {
    return _cloneDeepWithoutLoc.default;
  }
});
Object.defineProperty(exports, "cloneWithoutLoc", {
  enumerable: true,
  get: function () {
    return _cloneWithoutLoc.default;
  }
});
Object.defineProperty(exports, "addComment", {
  enumerable: true,
  get: function () {
    return _addComment.default;
  }
});
Object.defineProperty(exports, "addComments", {
  enumerable: true,
  get: function () {
    return _addComments.default;
  }
});
Object.defineProperty(exports, "inheritInnerComments", {
  enumerable: true,
  get: function () {
    return _inheritInnerComments.default;
  }
});
Object.defineProperty(exports, "inheritLeadingComments", {
  enumerable: true,
  get: function () {
    return _inheritLeadingComments.default;
  }
});
Object.defineProperty(exports, "inheritsComments", {
  enumerable: true,
  get: function () {
    return _inheritsComments.default;
  }
});
Object.defineProperty(exports, "inheritTrailingComments", {
  enumerable: true,
  get: function () {
    return _inheritTrailingComments.default;
  }
});
Object.defineProperty(exports, "removeComments", {
  enumerable: true,
  get: function () {
    return _removeComments.default;
  }
});
Object.defineProperty(exports, "ensureBlock", {
  enumerable: true,
  get: function () {
    return _ensureBlock.default;
  }
});
Object.defineProperty(exports, "toBindingIdentifierName", {
  enumerable: true,
  get: function () {
    return _toBindingIdentifierName.default;
  }
});
Object.defineProperty(exports, "toBlock", {
  enumerable: true,
  get: function () {
    return _toBlock.default;
  }
});
Object.defineProperty(exports, "toComputedKey", {
  enumerable: true,
  get: function () {
    return _toComputedKey.default;
  }
});
Object.defineProperty(exports, "toExpression", {
  enumerable: true,
  get: function () {
    return _toExpression.default;
  }
});
Object.defineProperty(exports, "toIdentifier", {
  enumerable: true,
  get: function () {
    return _toIdentifier.default;
  }
});
Object.defineProperty(exports, "toKeyAlias", {
  enumerable: true,
  get: function () {
    return _toKeyAlias.default;
  }
});
Object.defineProperty(exports, "toSequenceExpression", {
  enumerable: true,
  get: function () {
    return _toSequenceExpression.default;
  }
});
Object.defineProperty(exports, "toStatement", {
  enumerable: true,
  get: function () {
    return _toStatement.default;
  }
});
Object.defineProperty(exports, "valueToNode", {
  enumerable: true,
  get: function () {
    return _valueToNode.default;
  }
});
Object.defineProperty(exports, "appendToMemberExpression", {
  enumerable: true,
  get: function () {
    return _appendToMemberExpression.default;
  }
});
Object.defineProperty(exports, "inherits", {
  enumerable: true,
  get: function () {
    return _inherits.default;
  }
});
Object.defineProperty(exports, "prependToMemberExpression", {
  enumerable: true,
  get: function () {
    return _prependToMemberExpression.default;
  }
});
Object.defineProperty(exports, "removeProperties", {
  enumerable: true,
  get: function () {
    return _removeProperties.default;
  }
});
Object.defineProperty(exports, "removePropertiesDeep", {
  enumerable: true,
  get: function () {
    return _removePropertiesDeep.default;
  }
});
Object.defineProperty(exports, "removeTypeDuplicates", {
  enumerable: true,
  get: function () {
    return _removeTypeDuplicates.default;
  }
});
Object.defineProperty(exports, "getBindingIdentifiers", {
  enumerable: true,
  get: function () {
    return _getBindingIdentifiers.default;
  }
});
Object.defineProperty(exports, "getOuterBindingIdentifiers", {
  enumerable: true,
  get: function () {
    return _getOuterBindingIdentifiers.default;
  }
});
Object.defineProperty(exports, "traverse", {
  enumerable: true,
  get: function () {
    return _traverse.default;
  }
});
Object.defineProperty(exports, "traverseFast", {
  enumerable: true,
  get: function () {
    return _traverseFast.default;
  }
});
Object.defineProperty(exports, "shallowEqual", {
  enumerable: true,
  get: function () {
    return _shallowEqual.default;
  }
});
Object.defineProperty(exports, "is", {
  enumerable: true,
  get: function () {
    return _is.default;
  }
});
Object.defineProperty(exports, "isBinding", {
  enumerable: true,
  get: function () {
    return _isBinding.default;
  }
});
Object.defineProperty(exports, "isBlockScoped", {
  enumerable: true,
  get: function () {
    return _isBlockScoped.default;
  }
});
Object.defineProperty(exports, "isImmutable", {
  enumerable: true,
  get: function () {
    return _isImmutable.default;
  }
});
Object.defineProperty(exports, "isLet", {
  enumerable: true,
  get: function () {
    return _isLet.default;
  }
});
Object.defineProperty(exports, "isNode", {
  enumerable: true,
  get: function () {
    return _isNode.default;
  }
});
Object.defineProperty(exports, "isNodesEquivalent", {
  enumerable: true,
  get: function () {
    return _isNodesEquivalent.default;
  }
});
Object.defineProperty(exports, "isPlaceholderType", {
  enumerable: true,
  get: function () {
    return _isPlaceholderType.default;
  }
});
Object.defineProperty(exports, "isReferenced", {
  enumerable: true,
  get: function () {
    return _isReferenced.default;
  }
});
Object.defineProperty(exports, "isScope", {
  enumerable: true,
  get: function () {
    return _isScope.default;
  }
});
Object.defineProperty(exports, "isSpecifierDefault", {
  enumerable: true,
  get: function () {
    return _isSpecifierDefault.default;
  }
});
Object.defineProperty(exports, "isType", {
  enumerable: true,
  get: function () {
    return _isType.default;
  }
});
Object.defineProperty(exports, "isValidES3Identifier", {
  enumerable: true,
  get: function () {
    return _isValidES3Identifier.default;
  }
});
Object.defineProperty(exports, "isValidIdentifier", {
  enumerable: true,
  get: function () {
    return _isValidIdentifier.default;
  }
});
Object.defineProperty(exports, "isVar", {
  enumerable: true,
  get: function () {
    return _isVar.default;
  }
});
Object.defineProperty(exports, "matchesPattern", {
  enumerable: true,
  get: function () {
    return _matchesPattern.default;
  }
});
Object.defineProperty(exports, "validate", {
  enumerable: true,
  get: function () {
    return _validate.default;
  }
});
Object.defineProperty(exports, "buildMatchMemberExpression", {
  enumerable: true,
  get: function () {
    return _buildMatchMemberExpression.default;
  }
});
exports.react = void 0;

var _isReactComponent = _interopRequireDefault(require("./validators/react/isReactComponent"));

var _isCompatTag = _interopRequireDefault(require("./validators/react/isCompatTag"));

var _buildChildren = _interopRequireDefault(require("./builders/react/buildChildren"));

var _assertNode = _interopRequireDefault(require("./asserts/assertNode"));

var _generated = require("./asserts/generated");

Object.keys(_generated).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _generated[key];
    }
  });
});

var _createTypeAnnotationBasedOnTypeof = _interopRequireDefault(require("./builders/flow/createTypeAnnotationBasedOnTypeof"));

var _createFlowUnionType = _interopRequireDefault(require("./builders/flow/createFlowUnionType"));

var _createTSUnionType = _interopRequireDefault(require("./builders/typescript/createTSUnionType"));

var _generated2 = require("./builders/generated");

Object.keys(_generated2).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _generated2[key];
    }
  });
});

var _cloneNode = _interopRequireDefault(require("./clone/cloneNode"));

var _clone = _interopRequireDefault(require("./clone/clone"));

var _cloneDeep = _interopRequireDefault(require("./clone/cloneDeep"));

var _cloneDeepWithoutLoc = _interopRequireDefault(require("./clone/cloneDeepWithoutLoc"));

var _cloneWithoutLoc = _interopRequireDefault(require("./clone/cloneWithoutLoc"));

var _addComment = _interopRequireDefault(require("./comments/addComment"));

var _addComments = _interopRequireDefault(require("./comments/addComments"));

var _inheritInnerComments = _interopRequireDefault(require("./comments/inheritInnerComments"));

var _inheritLeadingComments = _interopRequireDefault(require("./comments/inheritLeadingComments"));

var _inheritsComments = _interopRequireDefault(require("./comments/inheritsComments"));

var _inheritTrailingComments = _interopRequireDefault(require("./comments/inheritTrailingComments"));

var _removeComments = _interopRequireDefault(require("./comments/removeComments"));

var _generated3 = require("./constants/generated");

Object.keys(_generated3).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _generated3[key];
    }
  });
});

var _constants = require("./constants");

Object.keys(_constants).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _constants[key];
    }
  });
});

var _ensureBlock = _interopRequireDefault(require("./converters/ensureBlock"));

var _toBindingIdentifierName = _interopRequireDefault(require("./converters/toBindingIdentifierName"));

var _toBlock = _interopRequireDefault(require("./converters/toBlock"));

var _toComputedKey = _interopRequireDefault(require("./converters/toComputedKey"));

var _toExpression = _interopRequireDefault(require("./converters/toExpression"));

var _toIdentifier = _interopRequireDefault(require("./converters/toIdentifier"));

var _toKeyAlias = _interopRequireDefault(require("./converters/toKeyAlias"));

var _toSequenceExpression = _interopRequireDefault(require("./converters/toSequenceExpression"));

var _toStatement = _interopRequireDefault(require("./converters/toStatement"));

var _valueToNode = _interopRequireDefault(require("./converters/valueToNode"));

var _definitions = require("./definitions");

Object.keys(_definitions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _definitions[key];
    }
  });
});

var _appendToMemberExpression = _interopRequireDefault(require("./modifications/appendToMemberExpression"));

var _inherits = _interopRequireDefault(require("./modifications/inherits"));

var _prependToMemberExpression = _interopRequireDefault(require("./modifications/prependToMemberExpression"));

var _removeProperties = _interopRequireDefault(require("./modifications/removeProperties"));

var _removePropertiesDeep = _interopRequireDefault(require("./modifications/removePropertiesDeep"));

var _removeTypeDuplicates = _interopRequireDefault(require("./modifications/flow/removeTypeDuplicates"));

var _getBindingIdentifiers = _interopRequireDefault(require("./retrievers/getBindingIdentifiers"));

var _getOuterBindingIdentifiers = _interopRequireDefault(require("./retrievers/getOuterBindingIdentifiers"));

var _traverse = _interopRequireDefault(require("./traverse/traverse"));

var _traverseFast = _interopRequireDefault(require("./traverse/traverseFast"));

var _shallowEqual = _interopRequireDefault(require("./utils/shallowEqual"));

var _is = _interopRequireDefault(require("./validators/is"));

var _isBinding = _interopRequireDefault(require("./validators/isBinding"));

var _isBlockScoped = _interopRequireDefault(require("./validators/isBlockScoped"));

var _isImmutable = _interopRequireDefault(require("./validators/isImmutable"));

var _isLet = _interopRequireDefault(require("./validators/isLet"));

var _isNode = _interopRequireDefault(require("./validators/isNode"));

var _isNodesEquivalent = _interopRequireDefault(require("./validators/isNodesEquivalent"));

var _isPlaceholderType = _interopRequireDefault(require("./validators/isPlaceholderType"));

var _isReferenced = _interopRequireDefault(require("./validators/isReferenced"));

var _isScope = _interopRequireDefault(require("./validators/isScope"));

var _isSpecifierDefault = _interopRequireDefault(require("./validators/isSpecifierDefault"));

var _isType = _interopRequireDefault(require("./validators/isType"));

var _isValidES3Identifier = _interopRequireDefault(require("./validators/isValidES3Identifier"));

var _isValidIdentifier = _interopRequireDefault(require("./validators/isValidIdentifier"));

var _isVar = _interopRequireDefault(require("./validators/isVar"));

var _matchesPattern = _interopRequireDefault(require("./validators/matchesPattern"));

var _validate = _interopRequireDefault(require("./validators/validate"));

var _buildMatchMemberExpression = _interopRequireDefault(require("./validators/buildMatchMemberExpression"));

var _generated4 = require("./validators/generated");

Object.keys(_generated4).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _generated4[key];
    }
  });
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const react = {
  isReactComponent: _isReactComponent.default,
  isCompatTag: _isCompatTag.default,
  buildChildren: _buildChildren.default
};
exports.react = react;
},{"./asserts/assertNode":30,"./asserts/generated":31,"./builders/flow/createFlowUnionType":33,"./builders/flow/createTypeAnnotationBasedOnTypeof":34,"./builders/generated":35,"./builders/react/buildChildren":36,"./builders/typescript/createTSUnionType":37,"./clone/clone":38,"./clone/cloneDeep":39,"./clone/cloneDeepWithoutLoc":40,"./clone/cloneNode":41,"./clone/cloneWithoutLoc":42,"./comments/addComment":43,"./comments/addComments":44,"./comments/inheritInnerComments":45,"./comments/inheritLeadingComments":46,"./comments/inheritTrailingComments":47,"./comments/inheritsComments":48,"./comments/removeComments":49,"./constants":51,"./constants/generated":50,"./converters/ensureBlock":52,"./converters/toBindingIdentifierName":54,"./converters/toBlock":55,"./converters/toComputedKey":56,"./converters/toExpression":57,"./converters/toIdentifier":58,"./converters/toKeyAlias":59,"./converters/toSequenceExpression":60,"./converters/toStatement":61,"./converters/valueToNode":62,"./definitions":66,"./modifications/appendToMemberExpression":73,"./modifications/flow/removeTypeDuplicates":74,"./modifications/inherits":75,"./modifications/prependToMemberExpression":76,"./modifications/removeProperties":77,"./modifications/removePropertiesDeep":78,"./retrievers/getBindingIdentifiers":80,"./retrievers/getOuterBindingIdentifiers":81,"./traverse/traverse":82,"./traverse/traverseFast":83,"./utils/shallowEqual":86,"./validators/buildMatchMemberExpression":87,"./validators/generated":88,"./validators/is":89,"./validators/isBinding":90,"./validators/isBlockScoped":91,"./validators/isImmutable":92,"./validators/isLet":93,"./validators/isNode":94,"./validators/isNodesEquivalent":95,"./validators/isPlaceholderType":96,"./validators/isReferenced":97,"./validators/isScope":98,"./validators/isSpecifierDefault":99,"./validators/isType":100,"./validators/isValidES3Identifier":101,"./validators/isValidIdentifier":102,"./validators/isVar":103,"./validators/matchesPattern":104,"./validators/react/isCompatTag":105,"./validators/react/isReactComponent":106,"./validators/validate":107}],73:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = appendToMemberExpression;

var _generated = require("../builders/generated");

function appendToMemberExpression(member, append, computed = false) {
  member.object = (0, _generated.memberExpression)(member.object, member.property, member.computed);
  member.property = append;
  member.computed = !!computed;
  return member;
}
},{"../builders/generated":35}],74:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = removeTypeDuplicates;

var _generated = require("../../validators/generated");

function removeTypeDuplicates(nodes) {
  const generics = {};
  const bases = {};
  const typeGroups = [];
  const types = [];

  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (!node) continue;

    if (types.indexOf(node) >= 0) {
      continue;
    }

    if ((0, _generated.isAnyTypeAnnotation)(node)) {
      return [node];
    }

    if ((0, _generated.isFlowBaseAnnotation)(node)) {
      bases[node.type] = node;
      continue;
    }

    if ((0, _generated.isUnionTypeAnnotation)(node)) {
      if (typeGroups.indexOf(node.types) < 0) {
        nodes = nodes.concat(node.types);
        typeGroups.push(node.types);
      }

      continue;
    }

    if ((0, _generated.isGenericTypeAnnotation)(node)) {
      const name = node.id.name;

      if (generics[name]) {
        let existing = generics[name];

        if (existing.typeParameters) {
          if (node.typeParameters) {
            existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));
          }
        } else {
          existing = node.typeParameters;
        }
      } else {
        generics[name] = node;
      }

      continue;
    }

    types.push(node);
  }

  for (const type of Object.keys(bases)) {
    types.push(bases[type]);
  }

  for (const name of Object.keys(generics)) {
    types.push(generics[name]);
  }

  return types;
}
},{"../../validators/generated":88}],75:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = inherits;

var _constants = require("../constants");

var _inheritsComments = _interopRequireDefault(require("../comments/inheritsComments"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function inherits(child, parent) {
  if (!child || !parent) return child;

  for (const key of _constants.INHERIT_KEYS.optional) {
    if (child[key] == null) {
      child[key] = parent[key];
    }
  }

  for (const key of Object.keys(parent)) {
    if (key[0] === "_" && key !== "__clone") child[key] = parent[key];
  }

  for (const key of _constants.INHERIT_KEYS.force) {
    child[key] = parent[key];
  }

  (0, _inheritsComments.default)(child, parent);
  return child;
}
},{"../comments/inheritsComments":48,"../constants":51}],76:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = prependToMemberExpression;

var _generated = require("../builders/generated");

function prependToMemberExpression(member, prepend) {
  member.object = (0, _generated.memberExpression)(prepend, member.object);
  return member;
}
},{"../builders/generated":35}],77:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = removeProperties;

var _constants = require("../constants");

const CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"];

const CLEAR_KEYS_PLUS_COMMENTS = _constants.COMMENT_KEYS.concat(["comments"]).concat(CLEAR_KEYS);

function removeProperties(node, opts = {}) {
  const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;

  for (const key of map) {
    if (node[key] != null) node[key] = undefined;
  }

  for (const key of Object.keys(node)) {
    if (key[0] === "_" && node[key] != null) node[key] = undefined;
  }

  const symbols = Object.getOwnPropertySymbols(node);

  for (const sym of symbols) {
    node[sym] = null;
  }
}
},{"../constants":51}],78:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = removePropertiesDeep;

var _traverseFast = _interopRequireDefault(require("../traverse/traverseFast"));

var _removeProperties = _interopRequireDefault(require("./removeProperties"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function removePropertiesDeep(tree, opts) {
  (0, _traverseFast.default)(tree, _removeProperties.default, opts);
  return tree;
}
},{"../traverse/traverseFast":83,"./removeProperties":77}],79:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = removeTypeDuplicates;

var _generated = require("../../validators/generated");

function removeTypeDuplicates(nodes) {
  const generics = {};
  const bases = {};
  const typeGroups = [];
  const types = [];

  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (!node) continue;

    if (types.indexOf(node) >= 0) {
      continue;
    }

    if ((0, _generated.isTSAnyKeyword)(node.type)) {
      return [node];
    }

    if ((0, _generated.isTSBaseType)(node)) {
      bases[node.type] = node;
      continue;
    }

    if ((0, _generated.isTSUnionType)(node)) {
      if (typeGroups.indexOf(node.types) < 0) {
        nodes = nodes.concat(node.types);
        typeGroups.push(node.types);
      }

      continue;
    }

    types.push(node);
  }

  for (const type of Object.keys(bases)) {
    types.push(bases[type]);
  }

  for (const name of Object.keys(generics)) {
    types.push(generics[name]);
  }

  return types;
}
},{"../../validators/generated":88}],80:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getBindingIdentifiers;

var _generated = require("../validators/generated");

function getBindingIdentifiers(node, duplicates, outerOnly) {
  let search = [].concat(node);
  const ids = Object.create(null);

  while (search.length) {
    const id = search.shift();
    if (!id) continue;
    const keys = getBindingIdentifiers.keys[id.type];

    if ((0, _generated.isIdentifier)(id)) {
      if (duplicates) {
        const _ids = ids[id.name] = ids[id.name] || [];

        _ids.push(id);
      } else {
        ids[id.name] = id;
      }

      continue;
    }

    if ((0, _generated.isExportDeclaration)(id)) {
      if ((0, _generated.isDeclaration)(id.declaration)) {
        search.push(id.declaration);
      }

      continue;
    }

    if (outerOnly) {
      if ((0, _generated.isFunctionDeclaration)(id)) {
        search.push(id.id);
        continue;
      }

      if ((0, _generated.isFunctionExpression)(id)) {
        continue;
      }
    }

    if (keys) {
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];

        if (id[key]) {
          search = search.concat(id[key]);
        }
      }
    }
  }

  return ids;
}

getBindingIdentifiers.keys = {
  DeclareClass: ["id"],
  DeclareFunction: ["id"],
  DeclareModule: ["id"],
  DeclareVariable: ["id"],
  DeclareInterface: ["id"],
  DeclareTypeAlias: ["id"],
  DeclareOpaqueType: ["id"],
  InterfaceDeclaration: ["id"],
  TypeAlias: ["id"],
  OpaqueType: ["id"],
  CatchClause: ["param"],
  LabeledStatement: ["label"],
  UnaryExpression: ["argument"],
  AssignmentExpression: ["left"],
  ImportSpecifier: ["local"],
  ImportNamespaceSpecifier: ["local"],
  ImportDefaultSpecifier: ["local"],
  ImportDeclaration: ["specifiers"],
  ExportSpecifier: ["exported"],
  ExportNamespaceSpecifier: ["exported"],
  ExportDefaultSpecifier: ["exported"],
  FunctionDeclaration: ["id", "params"],
  FunctionExpression: ["id", "params"],
  ArrowFunctionExpression: ["params"],
  ObjectMethod: ["params"],
  ClassMethod: ["params"],
  ForInStatement: ["left"],
  ForOfStatement: ["left"],
  ClassDeclaration: ["id"],
  ClassExpression: ["id"],
  RestElement: ["argument"],
  UpdateExpression: ["argument"],
  ObjectProperty: ["value"],
  AssignmentPattern: ["left"],
  ArrayPattern: ["elements"],
  ObjectPattern: ["properties"],
  VariableDeclaration: ["declarations"],
  VariableDeclarator: ["id"]
};
},{"../validators/generated":88}],81:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getOuterBindingIdentifiers;

var _getBindingIdentifiers = _interopRequireDefault(require("./getBindingIdentifiers"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getOuterBindingIdentifiers(node, duplicates) {
  return (0, _getBindingIdentifiers.default)(node, duplicates, true);
}
},{"./getBindingIdentifiers":80}],82:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = traverse;

var _definitions = require("../definitions");

function traverse(node, handlers, state) {
  if (typeof handlers === "function") {
    handlers = {
      enter: handlers
    };
  }

  const {
    enter,
    exit
  } = handlers;
  traverseSimpleImpl(node, enter, exit, state, []);
}

function traverseSimpleImpl(node, enter, exit, state, ancestors) {
  const keys = _definitions.VISITOR_KEYS[node.type];
  if (!keys) return;
  if (enter) enter(node, ancestors, state);

  for (const key of keys) {
    const subNode = node[key];

    if (Array.isArray(subNode)) {
      for (let i = 0; i < subNode.length; i++) {
        const child = subNode[i];
        if (!child) continue;
        ancestors.push({
          node,
          key,
          index: i
        });
        traverseSimpleImpl(child, enter, exit, state, ancestors);
        ancestors.pop();
      }
    } else if (subNode) {
      ancestors.push({
        node,
        key
      });
      traverseSimpleImpl(subNode, enter, exit, state, ancestors);
      ancestors.pop();
    }
  }

  if (exit) exit(node, ancestors, state);
}
},{"../definitions":66}],83:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = traverseFast;

var _definitions = require("../definitions");

function traverseFast(node, enter, opts) {
  if (!node) return;
  const keys = _definitions.VISITOR_KEYS[node.type];
  if (!keys) return;
  opts = opts || {};
  enter(node, opts);

  for (const key of keys) {
    const subNode = node[key];

    if (Array.isArray(subNode)) {
      for (const node of subNode) {
        traverseFast(node, enter, opts);
      }
    } else {
      traverseFast(subNode, enter, opts);
    }
  }
}
},{"../definitions":66}],84:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = inherit;

function inherit(key, child, parent) {
  if (child && parent) {
    child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean)));
  }
}
},{}],85:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cleanJSXElementLiteralChild;

var _generated = require("../../builders/generated");

function cleanJSXElementLiteralChild(child, args) {
  const lines = child.value.split(/\r\n|\n|\r/);
  let lastNonEmptyLine = 0;

  for (let i = 0; i < lines.length; i++) {
    if (lines[i].match(/[^ \t]/)) {
      lastNonEmptyLine = i;
    }
  }

  let str = "";

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const isFirstLine = i === 0;
    const isLastLine = i === lines.length - 1;
    const isLastNonEmptyLine = i === lastNonEmptyLine;
    let trimmedLine = line.replace(/\t/g, " ");

    if (!isFirstLine) {
      trimmedLine = trimmedLine.replace(/^[ ]+/, "");
    }

    if (!isLastLine) {
      trimmedLine = trimmedLine.replace(/[ ]+$/, "");
    }

    if (trimmedLine) {
      if (!isLastNonEmptyLine) {
        trimmedLine += " ";
      }

      str += trimmedLine;
    }
  }

  if (str) args.push((0, _generated.stringLiteral)(str));
}
},{"../../builders/generated":35}],86:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = shallowEqual;

function shallowEqual(actual, expected) {
  const keys = Object.keys(expected);

  for (const key of keys) {
    if (actual[key] !== expected[key]) {
      return false;
    }
  }

  return true;
}
},{}],87:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = buildMatchMemberExpression;

var _matchesPattern = _interopRequireDefault(require("./matchesPattern"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function buildMatchMemberExpression(match, allowPartial) {
  const parts = match.split(".");
  return member => (0, _matchesPattern.default)(member, parts, allowPartial);
}
},{"./matchesPattern":104}],88:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isArrayExpression = isArrayExpression;
exports.isAssignmentExpression = isAssignmentExpression;
exports.isBinaryExpression = isBinaryExpression;
exports.isInterpreterDirective = isInterpreterDirective;
exports.isDirective = isDirective;
exports.isDirectiveLiteral = isDirectiveLiteral;
exports.isBlockStatement = isBlockStatement;
exports.isBreakStatement = isBreakStatement;
exports.isCallExpression = isCallExpression;
exports.isCatchClause = isCatchClause;
exports.isConditionalExpression = isConditionalExpression;
exports.isContinueStatement = isContinueStatement;
exports.isDebuggerStatement = isDebuggerStatement;
exports.isDoWhileStatement = isDoWhileStatement;
exports.isEmptyStatement = isEmptyStatement;
exports.isExpressionStatement = isExpressionStatement;
exports.isFile = isFile;
exports.isForInStatement = isForInStatement;
exports.isForStatement = isForStatement;
exports.isFunctionDeclaration = isFunctionDeclaration;
exports.isFunctionExpression = isFunctionExpression;
exports.isIdentifier = isIdentifier;
exports.isIfStatement = isIfStatement;
exports.isLabeledStatement = isLabeledStatement;
exports.isStringLiteral = isStringLiteral;
exports.isNumericLiteral = isNumericLiteral;
exports.isNullLiteral = isNullLiteral;
exports.isBooleanLiteral = isBooleanLiteral;
exports.isRegExpLiteral = isRegExpLiteral;
exports.isLogicalExpression = isLogicalExpression;
exports.isMemberExpression = isMemberExpression;
exports.isNewExpression = isNewExpression;
exports.isProgram = isProgram;
exports.isObjectExpression = isObjectExpression;
exports.isObjectMethod = isObjectMethod;
exports.isObjectProperty = isObjectProperty;
exports.isRestElement = isRestElement;
exports.isReturnStatement = isReturnStatement;
exports.isSequenceExpression = isSequenceExpression;
exports.isParenthesizedExpression = isParenthesizedExpression;
exports.isSwitchCase = isSwitchCase;
exports.isSwitchStatement = isSwitchStatement;
exports.isThisExpression = isThisExpression;
exports.isThrowStatement = isThrowStatement;
exports.isTryStatement = isTryStatement;
exports.isUnaryExpression = isUnaryExpression;
exports.isUpdateExpression = isUpdateExpression;
exports.isVariableDeclaration = isVariableDeclaration;
exports.isVariableDeclarator = isVariableDeclarator;
exports.isWhileStatement = isWhileStatement;
exports.isWithStatement = isWithStatement;
exports.isAssignmentPattern = isAssignmentPattern;
exports.isArrayPattern = isArrayPattern;
exports.isArrowFunctionExpression = isArrowFunctionExpression;
exports.isClassBody = isClassBody;
exports.isClassExpression = isClassExpression;
exports.isClassDeclaration = isClassDeclaration;
exports.isExportAllDeclaration = isExportAllDeclaration;
exports.isExportDefaultDeclaration = isExportDefaultDeclaration;
exports.isExportNamedDeclaration = isExportNamedDeclaration;
exports.isExportSpecifier = isExportSpecifier;
exports.isForOfStatement = isForOfStatement;
exports.isImportDeclaration = isImportDeclaration;
exports.isImportDefaultSpecifier = isImportDefaultSpecifier;
exports.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
exports.isImportSpecifier = isImportSpecifier;
exports.isMetaProperty = isMetaProperty;
exports.isClassMethod = isClassMethod;
exports.isObjectPattern = isObjectPattern;
exports.isSpreadElement = isSpreadElement;
exports.isSuper = isSuper;
exports.isTaggedTemplateExpression = isTaggedTemplateExpression;
exports.isTemplateElement = isTemplateElement;
exports.isTemplateLiteral = isTemplateLiteral;
exports.isYieldExpression = isYieldExpression;
exports.isAwaitExpression = isAwaitExpression;
exports.isImport = isImport;
exports.isBigIntLiteral = isBigIntLiteral;
exports.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
exports.isOptionalMemberExpression = isOptionalMemberExpression;
exports.isOptionalCallExpression = isOptionalCallExpression;
exports.isAnyTypeAnnotation = isAnyTypeAnnotation;
exports.isArrayTypeAnnotation = isArrayTypeAnnotation;
exports.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
exports.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
exports.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
exports.isClassImplements = isClassImplements;
exports.isDeclareClass = isDeclareClass;
exports.isDeclareFunction = isDeclareFunction;
exports.isDeclareInterface = isDeclareInterface;
exports.isDeclareModule = isDeclareModule;
exports.isDeclareModuleExports = isDeclareModuleExports;
exports.isDeclareTypeAlias = isDeclareTypeAlias;
exports.isDeclareOpaqueType = isDeclareOpaqueType;
exports.isDeclareVariable = isDeclareVariable;
exports.isDeclareExportDeclaration = isDeclareExportDeclaration;
exports.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
exports.isDeclaredPredicate = isDeclaredPredicate;
exports.isExistsTypeAnnotation = isExistsTypeAnnotation;
exports.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
exports.isFunctionTypeParam = isFunctionTypeParam;
exports.isGenericTypeAnnotation = isGenericTypeAnnotation;
exports.isInferredPredicate = isInferredPredicate;
exports.isInterfaceExtends = isInterfaceExtends;
exports.isInterfaceDeclaration = isInterfaceDeclaration;
exports.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
exports.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
exports.isMixedTypeAnnotation = isMixedTypeAnnotation;
exports.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
exports.isNullableTypeAnnotation = isNullableTypeAnnotation;
exports.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
exports.isNumberTypeAnnotation = isNumberTypeAnnotation;
exports.isObjectTypeAnnotation = isObjectTypeAnnotation;
exports.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
exports.isObjectTypeCallProperty = isObjectTypeCallProperty;
exports.isObjectTypeIndexer = isObjectTypeIndexer;
exports.isObjectTypeProperty = isObjectTypeProperty;
exports.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
exports.isOpaqueType = isOpaqueType;
exports.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
exports.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
exports.isStringTypeAnnotation = isStringTypeAnnotation;
exports.isSymbolTypeAnnotation = isSymbolTypeAnnotation;
exports.isThisTypeAnnotation = isThisTypeAnnotation;
exports.isTupleTypeAnnotation = isTupleTypeAnnotation;
exports.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
exports.isTypeAlias = isTypeAlias;
exports.isTypeAnnotation = isTypeAnnotation;
exports.isTypeCastExpression = isTypeCastExpression;
exports.isTypeParameter = isTypeParameter;
exports.isTypeParameterDeclaration = isTypeParameterDeclaration;
exports.isTypeParameterInstantiation = isTypeParameterInstantiation;
exports.isUnionTypeAnnotation = isUnionTypeAnnotation;
exports.isVariance = isVariance;
exports.isVoidTypeAnnotation = isVoidTypeAnnotation;
exports.isEnumDeclaration = isEnumDeclaration;
exports.isEnumBooleanBody = isEnumBooleanBody;
exports.isEnumNumberBody = isEnumNumberBody;
exports.isEnumStringBody = isEnumStringBody;
exports.isEnumSymbolBody = isEnumSymbolBody;
exports.isEnumBooleanMember = isEnumBooleanMember;
exports.isEnumNumberMember = isEnumNumberMember;
exports.isEnumStringMember = isEnumStringMember;
exports.isEnumDefaultedMember = isEnumDefaultedMember;
exports.isJSXAttribute = isJSXAttribute;
exports.isJSXClosingElement = isJSXClosingElement;
exports.isJSXElement = isJSXElement;
exports.isJSXEmptyExpression = isJSXEmptyExpression;
exports.isJSXExpressionContainer = isJSXExpressionContainer;
exports.isJSXSpreadChild = isJSXSpreadChild;
exports.isJSXIdentifier = isJSXIdentifier;
exports.isJSXMemberExpression = isJSXMemberExpression;
exports.isJSXNamespacedName = isJSXNamespacedName;
exports.isJSXOpeningElement = isJSXOpeningElement;
exports.isJSXSpreadAttribute = isJSXSpreadAttribute;
exports.isJSXText = isJSXText;
exports.isJSXFragment = isJSXFragment;
exports.isJSXOpeningFragment = isJSXOpeningFragment;
exports.isJSXClosingFragment = isJSXClosingFragment;
exports.isNoop = isNoop;
exports.isPlaceholder = isPlaceholder;
exports.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;
exports.isArgumentPlaceholder = isArgumentPlaceholder;
exports.isBindExpression = isBindExpression;
exports.isClassProperty = isClassProperty;
exports.isPipelineTopicExpression = isPipelineTopicExpression;
exports.isPipelineBareFunction = isPipelineBareFunction;
exports.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;
exports.isClassPrivateProperty = isClassPrivateProperty;
exports.isClassPrivateMethod = isClassPrivateMethod;
exports.isImportAttribute = isImportAttribute;
exports.isDecorator = isDecorator;
exports.isDoExpression = isDoExpression;
exports.isExportDefaultSpecifier = isExportDefaultSpecifier;
exports.isPrivateName = isPrivateName;
exports.isRecordExpression = isRecordExpression;
exports.isTupleExpression = isTupleExpression;
exports.isDecimalLiteral = isDecimalLiteral;
exports.isTSParameterProperty = isTSParameterProperty;
exports.isTSDeclareFunction = isTSDeclareFunction;
exports.isTSDeclareMethod = isTSDeclareMethod;
exports.isTSQualifiedName = isTSQualifiedName;
exports.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
exports.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
exports.isTSPropertySignature = isTSPropertySignature;
exports.isTSMethodSignature = isTSMethodSignature;
exports.isTSIndexSignature = isTSIndexSignature;
exports.isTSAnyKeyword = isTSAnyKeyword;
exports.isTSBooleanKeyword = isTSBooleanKeyword;
exports.isTSBigIntKeyword = isTSBigIntKeyword;
exports.isTSNeverKeyword = isTSNeverKeyword;
exports.isTSNullKeyword = isTSNullKeyword;
exports.isTSNumberKeyword = isTSNumberKeyword;
exports.isTSObjectKeyword = isTSObjectKeyword;
exports.isTSStringKeyword = isTSStringKeyword;
exports.isTSSymbolKeyword = isTSSymbolKeyword;
exports.isTSUndefinedKeyword = isTSUndefinedKeyword;
exports.isTSUnknownKeyword = isTSUnknownKeyword;
exports.isTSVoidKeyword = isTSVoidKeyword;
exports.isTSThisType = isTSThisType;
exports.isTSFunctionType = isTSFunctionType;
exports.isTSConstructorType = isTSConstructorType;
exports.isTSTypeReference = isTSTypeReference;
exports.isTSTypePredicate = isTSTypePredicate;
exports.isTSTypeQuery = isTSTypeQuery;
exports.isTSTypeLiteral = isTSTypeLiteral;
exports.isTSArrayType = isTSArrayType;
exports.isTSTupleType = isTSTupleType;
exports.isTSOptionalType = isTSOptionalType;
exports.isTSRestType = isTSRestType;
exports.isTSNamedTupleMember = isTSNamedTupleMember;
exports.isTSUnionType = isTSUnionType;
exports.isTSIntersectionType = isTSIntersectionType;
exports.isTSConditionalType = isTSConditionalType;
exports.isTSInferType = isTSInferType;
exports.isTSParenthesizedType = isTSParenthesizedType;
exports.isTSTypeOperator = isTSTypeOperator;
exports.isTSIndexedAccessType = isTSIndexedAccessType;
exports.isTSMappedType = isTSMappedType;
exports.isTSLiteralType = isTSLiteralType;
exports.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
exports.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
exports.isTSInterfaceBody = isTSInterfaceBody;
exports.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
exports.isTSAsExpression = isTSAsExpression;
exports.isTSTypeAssertion = isTSTypeAssertion;
exports.isTSEnumDeclaration = isTSEnumDeclaration;
exports.isTSEnumMember = isTSEnumMember;
exports.isTSModuleDeclaration = isTSModuleDeclaration;
exports.isTSModuleBlock = isTSModuleBlock;
exports.isTSImportType = isTSImportType;
exports.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
exports.isTSExternalModuleReference = isTSExternalModuleReference;
exports.isTSNonNullExpression = isTSNonNullExpression;
exports.isTSExportAssignment = isTSExportAssignment;
exports.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
exports.isTSTypeAnnotation = isTSTypeAnnotation;
exports.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
exports.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
exports.isTSTypeParameter = isTSTypeParameter;
exports.isExpression = isExpression;
exports.isBinary = isBinary;
exports.isScopable = isScopable;
exports.isBlockParent = isBlockParent;
exports.isBlock = isBlock;
exports.isStatement = isStatement;
exports.isTerminatorless = isTerminatorless;
exports.isCompletionStatement = isCompletionStatement;
exports.isConditional = isConditional;
exports.isLoop = isLoop;
exports.isWhile = isWhile;
exports.isExpressionWrapper = isExpressionWrapper;
exports.isFor = isFor;
exports.isForXStatement = isForXStatement;
exports.isFunction = isFunction;
exports.isFunctionParent = isFunctionParent;
exports.isPureish = isPureish;
exports.isDeclaration = isDeclaration;
exports.isPatternLike = isPatternLike;
exports.isLVal = isLVal;
exports.isTSEntityName = isTSEntityName;
exports.isLiteral = isLiteral;
exports.isImmutable = isImmutable;
exports.isUserWhitespacable = isUserWhitespacable;
exports.isMethod = isMethod;
exports.isObjectMember = isObjectMember;
exports.isProperty = isProperty;
exports.isUnaryLike = isUnaryLike;
exports.isPattern = isPattern;
exports.isClass = isClass;
exports.isModuleDeclaration = isModuleDeclaration;
exports.isExportDeclaration = isExportDeclaration;
exports.isModuleSpecifier = isModuleSpecifier;
exports.isFlow = isFlow;
exports.isFlowType = isFlowType;
exports.isFlowBaseAnnotation = isFlowBaseAnnotation;
exports.isFlowDeclaration = isFlowDeclaration;
exports.isFlowPredicate = isFlowPredicate;
exports.isEnumBody = isEnumBody;
exports.isEnumMember = isEnumMember;
exports.isJSX = isJSX;
exports.isPrivate = isPrivate;
exports.isTSTypeElement = isTSTypeElement;
exports.isTSType = isTSType;
exports.isTSBaseType = isTSBaseType;
exports.isNumberLiteral = isNumberLiteral;
exports.isRegexLiteral = isRegexLiteral;
exports.isRestProperty = isRestProperty;
exports.isSpreadProperty = isSpreadProperty;

var _shallowEqual = _interopRequireDefault(require("../../utils/shallowEqual"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isArrayExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ArrayExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isAssignmentExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "AssignmentExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBinaryExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "BinaryExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isInterpreterDirective(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "InterpreterDirective") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDirective(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Directive") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDirectiveLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DirectiveLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBlockStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "BlockStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBreakStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "BreakStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isCallExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "CallExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isCatchClause(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "CatchClause") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isConditionalExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ConditionalExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isContinueStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ContinueStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDebuggerStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DebuggerStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDoWhileStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DoWhileStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEmptyStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "EmptyStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExpressionStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ExpressionStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFile(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "File") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isForInStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ForInStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isForStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ForStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFunctionDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "FunctionDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFunctionExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "FunctionExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isIdentifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Identifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isIfStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "IfStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isLabeledStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "LabeledStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isStringLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "StringLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNumericLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "NumericLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNullLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "NullLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBooleanLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "BooleanLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isRegExpLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "RegExpLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isLogicalExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "LogicalExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isMemberExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "MemberExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNewExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "NewExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isProgram(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Program") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectMethod(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectMethod") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isRestElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "RestElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isReturnStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ReturnStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isSequenceExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "SequenceExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isParenthesizedExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ParenthesizedExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isSwitchCase(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "SwitchCase") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isSwitchStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "SwitchStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isThisExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ThisExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isThrowStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ThrowStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTryStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TryStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isUnaryExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "UnaryExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isUpdateExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "UpdateExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isVariableDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "VariableDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isVariableDeclarator(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "VariableDeclarator") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isWhileStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "WhileStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isWithStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "WithStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isAssignmentPattern(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "AssignmentPattern") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isArrayPattern(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ArrayPattern") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isArrowFunctionExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ArrowFunctionExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClassBody(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ClassBody") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClassExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ClassExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClassDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ClassDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExportAllDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ExportAllDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExportDefaultDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ExportDefaultDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExportNamedDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ExportNamedDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExportSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ExportSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isForOfStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ForOfStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isImportDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ImportDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isImportDefaultSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ImportDefaultSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isImportNamespaceSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ImportNamespaceSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isImportSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ImportSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isMetaProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "MetaProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClassMethod(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ClassMethod") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectPattern(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectPattern") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isSpreadElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "SpreadElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isSuper(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Super") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTaggedTemplateExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TaggedTemplateExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTemplateElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TemplateElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTemplateLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TemplateLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isYieldExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "YieldExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isAwaitExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "AwaitExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isImport(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Import") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBigIntLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "BigIntLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExportNamespaceSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ExportNamespaceSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isOptionalMemberExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "OptionalMemberExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isOptionalCallExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "OptionalCallExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isAnyTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "AnyTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isArrayTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ArrayTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBooleanTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "BooleanTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBooleanLiteralTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "BooleanLiteralTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNullLiteralTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "NullLiteralTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClassImplements(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ClassImplements") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareClass(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclareClass") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareFunction(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclareFunction") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareInterface(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclareInterface") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareModule(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclareModule") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareModuleExports(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclareModuleExports") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareTypeAlias(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclareTypeAlias") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareOpaqueType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclareOpaqueType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareVariable(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclareVariable") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareExportDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclareExportDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareExportAllDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclareExportAllDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclaredPredicate(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclaredPredicate") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExistsTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ExistsTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFunctionTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "FunctionTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFunctionTypeParam(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "FunctionTypeParam") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isGenericTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "GenericTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isInferredPredicate(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "InferredPredicate") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isInterfaceExtends(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "InterfaceExtends") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isInterfaceDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "InterfaceDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isInterfaceTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "InterfaceTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isIntersectionTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "IntersectionTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isMixedTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "MixedTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEmptyTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "EmptyTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNullableTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "NullableTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNumberLiteralTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "NumberLiteralTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNumberTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "NumberTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectTypeInternalSlot(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectTypeInternalSlot") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectTypeCallProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectTypeCallProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectTypeIndexer(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectTypeIndexer") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectTypeProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectTypeProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectTypeSpreadProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectTypeSpreadProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isOpaqueType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "OpaqueType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isQualifiedTypeIdentifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "QualifiedTypeIdentifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isStringLiteralTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "StringLiteralTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isStringTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "StringTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isSymbolTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "SymbolTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isThisTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ThisTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTupleTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TupleTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTypeofTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TypeofTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTypeAlias(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TypeAlias") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTypeCastExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TypeCastExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTypeParameter(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TypeParameter") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTypeParameterDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TypeParameterDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTypeParameterInstantiation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TypeParameterInstantiation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isUnionTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "UnionTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isVariance(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Variance") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isVoidTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "VoidTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "EnumDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumBooleanBody(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "EnumBooleanBody") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumNumberBody(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "EnumNumberBody") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumStringBody(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "EnumStringBody") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumSymbolBody(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "EnumSymbolBody") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumBooleanMember(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "EnumBooleanMember") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumNumberMember(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "EnumNumberMember") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumStringMember(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "EnumStringMember") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumDefaultedMember(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "EnumDefaultedMember") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXAttribute(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXAttribute") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXClosingElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXClosingElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXEmptyExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXEmptyExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXExpressionContainer(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXExpressionContainer") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXSpreadChild(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXSpreadChild") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXIdentifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXIdentifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXMemberExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXMemberExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXNamespacedName(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXNamespacedName") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXOpeningElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXOpeningElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXSpreadAttribute(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXSpreadAttribute") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXText(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXText") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXFragment(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXFragment") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXOpeningFragment(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXOpeningFragment") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXClosingFragment(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXClosingFragment") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNoop(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Noop") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPlaceholder(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Placeholder") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isV8IntrinsicIdentifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "V8IntrinsicIdentifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isArgumentPlaceholder(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ArgumentPlaceholder") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBindExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "BindExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClassProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ClassProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPipelineTopicExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "PipelineTopicExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPipelineBareFunction(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "PipelineBareFunction") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPipelinePrimaryTopicReference(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "PipelinePrimaryTopicReference") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClassPrivateProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ClassPrivateProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClassPrivateMethod(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ClassPrivateMethod") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isImportAttribute(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ImportAttribute") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDecorator(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Decorator") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDoExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DoExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExportDefaultSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ExportDefaultSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPrivateName(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "PrivateName") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isRecordExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "RecordExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTupleExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TupleExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDecimalLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DecimalLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSParameterProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSParameterProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSDeclareFunction(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSDeclareFunction") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSDeclareMethod(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSDeclareMethod") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSQualifiedName(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSQualifiedName") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSCallSignatureDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSCallSignatureDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSConstructSignatureDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSConstructSignatureDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSPropertySignature(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSPropertySignature") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSMethodSignature(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSMethodSignature") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSIndexSignature(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSIndexSignature") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSAnyKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSAnyKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSBooleanKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSBooleanKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSBigIntKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSBigIntKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSNeverKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSNeverKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSNullKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSNullKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSNumberKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSNumberKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSObjectKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSObjectKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSStringKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSStringKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSSymbolKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSSymbolKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSUndefinedKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSUndefinedKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSUnknownKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSUnknownKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSVoidKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSVoidKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSThisType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSThisType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSFunctionType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSFunctionType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSConstructorType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSConstructorType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeReference(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeReference") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypePredicate(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypePredicate") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeQuery(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeQuery") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSArrayType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSArrayType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTupleType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTupleType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSOptionalType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSOptionalType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSRestType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSRestType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSNamedTupleMember(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSNamedTupleMember") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSUnionType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSUnionType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSIntersectionType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSIntersectionType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSConditionalType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSConditionalType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSInferType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSInferType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSParenthesizedType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSParenthesizedType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeOperator(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeOperator") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSIndexedAccessType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSIndexedAccessType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSMappedType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSMappedType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSLiteralType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSLiteralType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSExpressionWithTypeArguments(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSExpressionWithTypeArguments") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSInterfaceDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSInterfaceDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSInterfaceBody(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSInterfaceBody") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeAliasDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeAliasDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSAsExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSAsExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeAssertion(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeAssertion") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSEnumDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSEnumDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSEnumMember(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSEnumMember") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSModuleDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSModuleDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSModuleBlock(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSModuleBlock") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSImportType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSImportType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSImportEqualsDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSImportEqualsDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSExternalModuleReference(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSExternalModuleReference") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSNonNullExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSNonNullExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSExportAssignment(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSExportAssignment") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSNamespaceExportDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSNamespaceExportDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeParameterInstantiation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeParameterInstantiation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeParameterDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeParameterDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeParameter(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeParameter") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Expression" || "ArrayExpression" === nodeType || "AssignmentExpression" === nodeType || "BinaryExpression" === nodeType || "CallExpression" === nodeType || "ConditionalExpression" === nodeType || "FunctionExpression" === nodeType || "Identifier" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "LogicalExpression" === nodeType || "MemberExpression" === nodeType || "NewExpression" === nodeType || "ObjectExpression" === nodeType || "SequenceExpression" === nodeType || "ParenthesizedExpression" === nodeType || "ThisExpression" === nodeType || "UnaryExpression" === nodeType || "UpdateExpression" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassExpression" === nodeType || "MetaProperty" === nodeType || "Super" === nodeType || "TaggedTemplateExpression" === nodeType || "TemplateLiteral" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType || "Import" === nodeType || "BigIntLiteral" === nodeType || "OptionalMemberExpression" === nodeType || "OptionalCallExpression" === nodeType || "TypeCastExpression" === nodeType || "JSXElement" === nodeType || "JSXFragment" === nodeType || "BindExpression" === nodeType || "PipelinePrimaryTopicReference" === nodeType || "DoExpression" === nodeType || "RecordExpression" === nodeType || "TupleExpression" === nodeType || "DecimalLiteral" === nodeType || "TSAsExpression" === nodeType || "TSTypeAssertion" === nodeType || "TSNonNullExpression" === nodeType || nodeType === "Placeholder" && ("Expression" === node.expectedNode || "Identifier" === node.expectedNode || "StringLiteral" === node.expectedNode)) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBinary(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Binary" || "BinaryExpression" === nodeType || "LogicalExpression" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isScopable(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Scopable" || "BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassExpression" === nodeType || "ClassDeclaration" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBlockParent(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "BlockParent" || "BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBlock(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Block" || "BlockStatement" === nodeType || "Program" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Statement" || "BlockStatement" === nodeType || "BreakStatement" === nodeType || "ContinueStatement" === nodeType || "DebuggerStatement" === nodeType || "DoWhileStatement" === nodeType || "EmptyStatement" === nodeType || "ExpressionStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "IfStatement" === nodeType || "LabeledStatement" === nodeType || "ReturnStatement" === nodeType || "SwitchStatement" === nodeType || "ThrowStatement" === nodeType || "TryStatement" === nodeType || "VariableDeclaration" === nodeType || "WhileStatement" === nodeType || "WithStatement" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ForOfStatement" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "EnumDeclaration" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || "TSImportEqualsDeclaration" === nodeType || "TSExportAssignment" === nodeType || "TSNamespaceExportDeclaration" === nodeType || nodeType === "Placeholder" && ("Statement" === node.expectedNode || "Declaration" === node.expectedNode || "BlockStatement" === node.expectedNode)) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTerminatorless(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Terminatorless" || "BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isCompletionStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "CompletionStatement" || "BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isConditional(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Conditional" || "ConditionalExpression" === nodeType || "IfStatement" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isLoop(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Loop" || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "WhileStatement" === nodeType || "ForOfStatement" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isWhile(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "While" || "DoWhileStatement" === nodeType || "WhileStatement" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExpressionWrapper(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ExpressionWrapper" || "ExpressionStatement" === nodeType || "ParenthesizedExpression" === nodeType || "TypeCastExpression" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFor(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "For" || "ForInStatement" === nodeType || "ForStatement" === nodeType || "ForOfStatement" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isForXStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ForXStatement" || "ForInStatement" === nodeType || "ForOfStatement" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFunction(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Function" || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFunctionParent(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "FunctionParent" || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPureish(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Pureish" || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "ArrowFunctionExpression" === nodeType || "BigIntLiteral" === nodeType || "DecimalLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Declaration" || "FunctionDeclaration" === nodeType || "VariableDeclaration" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "EnumDeclaration" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || nodeType === "Placeholder" && "Declaration" === node.expectedNode) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPatternLike(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "PatternLike" || "Identifier" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || nodeType === "Placeholder" && ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode)) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isLVal(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "LVal" || "Identifier" === nodeType || "MemberExpression" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || "TSParameterProperty" === nodeType || nodeType === "Placeholder" && ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode)) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSEntityName(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSEntityName" || "Identifier" === nodeType || "TSQualifiedName" === nodeType || nodeType === "Placeholder" && "Identifier" === node.expectedNode) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Literal" || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "TemplateLiteral" === nodeType || "BigIntLiteral" === nodeType || "DecimalLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isImmutable(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Immutable" || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "BigIntLiteral" === nodeType || "JSXAttribute" === nodeType || "JSXClosingElement" === nodeType || "JSXElement" === nodeType || "JSXExpressionContainer" === nodeType || "JSXSpreadChild" === nodeType || "JSXOpeningElement" === nodeType || "JSXText" === nodeType || "JSXFragment" === nodeType || "JSXOpeningFragment" === nodeType || "JSXClosingFragment" === nodeType || "DecimalLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isUserWhitespacable(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "UserWhitespacable" || "ObjectMethod" === nodeType || "ObjectProperty" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isMethod(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Method" || "ObjectMethod" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectMember(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectMember" || "ObjectMethod" === nodeType || "ObjectProperty" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Property" || "ObjectProperty" === nodeType || "ClassProperty" === nodeType || "ClassPrivateProperty" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isUnaryLike(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "UnaryLike" || "UnaryExpression" === nodeType || "SpreadElement" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPattern(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Pattern" || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || nodeType === "Placeholder" && "Pattern" === node.expectedNode) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClass(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Class" || "ClassExpression" === nodeType || "ClassDeclaration" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isModuleDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ModuleDeclaration" || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExportDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ExportDeclaration" || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isModuleSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ModuleSpecifier" || "ExportSpecifier" === nodeType || "ImportDefaultSpecifier" === nodeType || "ImportNamespaceSpecifier" === nodeType || "ImportSpecifier" === nodeType || "ExportNamespaceSpecifier" === nodeType || "ExportDefaultSpecifier" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFlow(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Flow" || "AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ClassImplements" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "DeclaredPredicate" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "FunctionTypeParam" === nodeType || "GenericTypeAnnotation" === nodeType || "InferredPredicate" === nodeType || "InterfaceExtends" === nodeType || "InterfaceDeclaration" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType || "OpaqueType" === nodeType || "QualifiedTypeIdentifier" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "TypeAlias" === nodeType || "TypeAnnotation" === nodeType || "TypeCastExpression" === nodeType || "TypeParameter" === nodeType || "TypeParameterDeclaration" === nodeType || "TypeParameterInstantiation" === nodeType || "UnionTypeAnnotation" === nodeType || "Variance" === nodeType || "VoidTypeAnnotation" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFlowType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "FlowType" || "AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "GenericTypeAnnotation" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "UnionTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFlowBaseAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "FlowBaseAnnotation" || "AnyTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFlowDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "FlowDeclaration" || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFlowPredicate(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "FlowPredicate" || "DeclaredPredicate" === nodeType || "InferredPredicate" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumBody(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "EnumBody" || "EnumBooleanBody" === nodeType || "EnumNumberBody" === nodeType || "EnumStringBody" === nodeType || "EnumSymbolBody" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumMember(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "EnumMember" || "EnumBooleanMember" === nodeType || "EnumNumberMember" === nodeType || "EnumStringMember" === nodeType || "EnumDefaultedMember" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSX(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSX" || "JSXAttribute" === nodeType || "JSXClosingElement" === nodeType || "JSXElement" === nodeType || "JSXEmptyExpression" === nodeType || "JSXExpressionContainer" === nodeType || "JSXSpreadChild" === nodeType || "JSXIdentifier" === nodeType || "JSXMemberExpression" === nodeType || "JSXNamespacedName" === nodeType || "JSXOpeningElement" === nodeType || "JSXSpreadAttribute" === nodeType || "JSXText" === nodeType || "JSXFragment" === nodeType || "JSXOpeningFragment" === nodeType || "JSXClosingFragment" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPrivate(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Private" || "ClassPrivateProperty" === nodeType || "ClassPrivateMethod" === nodeType || "PrivateName" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeElement" || "TSCallSignatureDeclaration" === nodeType || "TSConstructSignatureDeclaration" === nodeType || "TSPropertySignature" === nodeType || "TSMethodSignature" === nodeType || "TSIndexSignature" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSType" || "TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSFunctionType" === nodeType || "TSConstructorType" === nodeType || "TSTypeReference" === nodeType || "TSTypePredicate" === nodeType || "TSTypeQuery" === nodeType || "TSTypeLiteral" === nodeType || "TSArrayType" === nodeType || "TSTupleType" === nodeType || "TSOptionalType" === nodeType || "TSRestType" === nodeType || "TSUnionType" === nodeType || "TSIntersectionType" === nodeType || "TSConditionalType" === nodeType || "TSInferType" === nodeType || "TSParenthesizedType" === nodeType || "TSTypeOperator" === nodeType || "TSIndexedAccessType" === nodeType || "TSMappedType" === nodeType || "TSLiteralType" === nodeType || "TSExpressionWithTypeArguments" === nodeType || "TSImportType" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSBaseType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSBaseType" || "TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSLiteralType" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNumberLiteral(node, opts) {
  console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "NumberLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isRegexLiteral(node, opts) {
  console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "RegexLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isRestProperty(node, opts) {
  console.trace("The node type RestProperty has been renamed to RestElement");
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "RestProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isSpreadProperty(node, opts) {
  console.trace("The node type SpreadProperty has been renamed to SpreadElement");
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "SpreadProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}
},{"../../utils/shallowEqual":86}],89:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = is;

var _shallowEqual = _interopRequireDefault(require("../utils/shallowEqual"));

var _isType = _interopRequireDefault(require("./isType"));

var _isPlaceholderType = _interopRequireDefault(require("./isPlaceholderType"));

var _definitions = require("../definitions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function is(type, node, opts) {
  if (!node) return false;
  const matches = (0, _isType.default)(node.type, type);

  if (!matches) {
    if (!opts && node.type === "Placeholder" && type in _definitions.FLIPPED_ALIAS_KEYS) {
      return (0, _isPlaceholderType.default)(node.expectedNode, type);
    }

    return false;
  }

  if (typeof opts === "undefined") {
    return true;
  } else {
    return (0, _shallowEqual.default)(node, opts);
  }
}
},{"../definitions":66,"../utils/shallowEqual":86,"./isPlaceholderType":96,"./isType":100}],90:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isBinding;

var _getBindingIdentifiers = _interopRequireDefault(require("../retrievers/getBindingIdentifiers"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isBinding(node, parent, grandparent) {
  if (grandparent && node.type === "Identifier" && parent.type === "ObjectProperty" && grandparent.type === "ObjectExpression") {
    return false;
  }

  const keys = _getBindingIdentifiers.default.keys[parent.type];

  if (keys) {
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const val = parent[key];

      if (Array.isArray(val)) {
        if (val.indexOf(node) >= 0) return true;
      } else {
        if (val === node) return true;
      }
    }
  }

  return false;
}
},{"../retrievers/getBindingIdentifiers":80}],91:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isBlockScoped;

var _generated = require("./generated");

var _isLet = _interopRequireDefault(require("./isLet"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isBlockScoped(node) {
  return (0, _generated.isFunctionDeclaration)(node) || (0, _generated.isClassDeclaration)(node) || (0, _isLet.default)(node);
}
},{"./generated":88,"./isLet":93}],92:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isImmutable;

var _isType = _interopRequireDefault(require("./isType"));

var _generated = require("./generated");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isImmutable(node) {
  if ((0, _isType.default)(node.type, "Immutable")) return true;

  if ((0, _generated.isIdentifier)(node)) {
    if (node.name === "undefined") {
      return true;
    } else {
      return false;
    }
  }

  return false;
}
},{"./generated":88,"./isType":100}],93:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isLet;

var _generated = require("./generated");

var _constants = require("../constants");

function isLet(node) {
  return (0, _generated.isVariableDeclaration)(node) && (node.kind !== "var" || node[_constants.BLOCK_SCOPED_SYMBOL]);
}
},{"../constants":51,"./generated":88}],94:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isNode;

var _definitions = require("../definitions");

function isNode(node) {
  return !!(node && _definitions.VISITOR_KEYS[node.type]);
}
},{"../definitions":66}],95:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isNodesEquivalent;

var _definitions = require("../definitions");

function isNodesEquivalent(a, b) {
  if (typeof a !== "object" || typeof b !== "object" || a == null || b == null) {
    return a === b;
  }

  if (a.type !== b.type) {
    return false;
  }

  const fields = Object.keys(_definitions.NODE_FIELDS[a.type] || a.type);
  const visitorKeys = _definitions.VISITOR_KEYS[a.type];

  for (const field of fields) {
    if (typeof a[field] !== typeof b[field]) {
      return false;
    }

    if (a[field] == null && b[field] == null) {
      continue;
    } else if (a[field] == null || b[field] == null) {
      return false;
    }

    if (Array.isArray(a[field])) {
      if (!Array.isArray(b[field])) {
        return false;
      }

      if (a[field].length !== b[field].length) {
        return false;
      }

      for (let i = 0; i < a[field].length; i++) {
        if (!isNodesEquivalent(a[field][i], b[field][i])) {
          return false;
        }
      }

      continue;
    }

    if (typeof a[field] === "object" && !(visitorKeys == null ? void 0 : visitorKeys.includes(field))) {
      for (const key of Object.keys(a[field])) {
        if (a[field][key] !== b[field][key]) {
          return false;
        }
      }

      continue;
    }

    if (!isNodesEquivalent(a[field], b[field])) {
      return false;
    }
  }

  return true;
}
},{"../definitions":66}],96:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isPlaceholderType;

var _definitions = require("../definitions");

function isPlaceholderType(placeholderType, targetType) {
  if (placeholderType === targetType) return true;
  const aliases = _definitions.PLACEHOLDERS_ALIAS[placeholderType];

  if (aliases) {
    for (const alias of aliases) {
      if (targetType === alias) return true;
    }
  }

  return false;
}
},{"../definitions":66}],97:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isReferenced;

function isReferenced(node, parent, grandparent) {
  switch (parent.type) {
    case "MemberExpression":
    case "JSXMemberExpression":
    case "OptionalMemberExpression":
      if (parent.property === node) {
        return !!parent.computed;
      }

      return parent.object === node;

    case "VariableDeclarator":
      return parent.init === node;

    case "ArrowFunctionExpression":
      return parent.body === node;

    case "ExportSpecifier":
      if (parent.source) {
        return false;
      }

      return parent.local === node;

    case "PrivateName":
      return false;

    case "ClassMethod":
    case "ClassPrivateMethod":
    case "ObjectMethod":
      if (parent.params.includes(node)) {
        return false;
      }

    case "ObjectProperty":
    case "ClassProperty":
    case "ClassPrivateProperty":
      if (parent.key === node) {
        return !!parent.computed;
      }

      if (parent.value === node) {
        return !grandparent || grandparent.type !== "ObjectPattern";
      }

      return true;

    case "ClassDeclaration":
    case "ClassExpression":
      return parent.superClass === node;

    case "AssignmentExpression":
      return parent.right === node;

    case "AssignmentPattern":
      return parent.right === node;

    case "LabeledStatement":
      return false;

    case "CatchClause":
      return false;

    case "RestElement":
      return false;

    case "BreakStatement":
    case "ContinueStatement":
      return false;

    case "FunctionDeclaration":
    case "FunctionExpression":
      return false;

    case "ExportNamespaceSpecifier":
    case "ExportDefaultSpecifier":
      return false;

    case "ImportDefaultSpecifier":
    case "ImportNamespaceSpecifier":
    case "ImportSpecifier":
      return false;

    case "JSXAttribute":
      return false;

    case "ObjectPattern":
    case "ArrayPattern":
      return false;

    case "MetaProperty":
      return false;

    case "ObjectTypeProperty":
      return parent.key !== node;

    case "TSEnumMember":
      return parent.id !== node;

    case "TSPropertySignature":
      if (parent.key === node) {
        return !!parent.computed;
      }

      return true;
  }

  return true;
}
},{}],98:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isScope;

var _generated = require("./generated");

function isScope(node, parent) {
  if ((0, _generated.isBlockStatement)(node) && (0, _generated.isFunction)(parent, {
    body: node
  })) {
    return false;
  }

  if ((0, _generated.isBlockStatement)(node) && (0, _generated.isCatchClause)(parent, {
    body: node
  })) {
    return false;
  }

  if ((0, _generated.isPattern)(node) && (0, _generated.isFunction)(parent)) {
    return true;
  }

  return (0, _generated.isScopable)(node);
}
},{"./generated":88}],99:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isSpecifierDefault;

var _generated = require("./generated");

function isSpecifierDefault(specifier) {
  return (0, _generated.isImportDefaultSpecifier)(specifier) || (0, _generated.isIdentifier)(specifier.imported || specifier.exported, {
    name: "default"
  });
}
},{"./generated":88}],100:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isType;

var _definitions = require("../definitions");

function isType(nodeType, targetType) {
  if (nodeType === targetType) return true;
  if (_definitions.ALIAS_KEYS[targetType]) return false;
  const aliases = _definitions.FLIPPED_ALIAS_KEYS[targetType];

  if (aliases) {
    if (aliases[0] === nodeType) return true;

    for (const alias of aliases) {
      if (nodeType === alias) return true;
    }
  }

  return false;
}
},{"../definitions":66}],101:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isValidES3Identifier;

var _isValidIdentifier = _interopRequireDefault(require("./isValidIdentifier"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const RESERVED_WORDS_ES3_ONLY = new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);

function isValidES3Identifier(name) {
  return (0, _isValidIdentifier.default)(name) && !RESERVED_WORDS_ES3_ONLY.has(name);
}
},{"./isValidIdentifier":102}],102:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isValidIdentifier;

var _helperValidatorIdentifier = require("@babel/helper-validator-identifier");

function isValidIdentifier(name, reserved = true) {
  if (typeof name !== "string") return false;

  if (reserved) {
    if ((0, _helperValidatorIdentifier.isKeyword)(name) || (0, _helperValidatorIdentifier.isStrictReservedWord)(name)) {
      return false;
    } else if (name === "await") {
      return false;
    }
  }

  return (0, _helperValidatorIdentifier.isIdentifierName)(name);
}
},{"@babel/helper-validator-identifier":28}],103:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isVar;

var _generated = require("./generated");

var _constants = require("../constants");

function isVar(node) {
  return (0, _generated.isVariableDeclaration)(node, {
    kind: "var"
  }) && !node[_constants.BLOCK_SCOPED_SYMBOL];
}
},{"../constants":51,"./generated":88}],104:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = matchesPattern;

var _generated = require("./generated");

function matchesPattern(member, match, allowPartial) {
  if (!(0, _generated.isMemberExpression)(member)) return false;
  const parts = Array.isArray(match) ? match : match.split(".");
  const nodes = [];
  let node;

  for (node = member; (0, _generated.isMemberExpression)(node); node = node.object) {
    nodes.push(node.property);
  }

  nodes.push(node);
  if (nodes.length < parts.length) return false;
  if (!allowPartial && nodes.length > parts.length) return false;

  for (let i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {
    const node = nodes[j];
    let value;

    if ((0, _generated.isIdentifier)(node)) {
      value = node.name;
    } else if ((0, _generated.isStringLiteral)(node)) {
      value = node.value;
    } else {
      return false;
    }

    if (parts[i] !== value) return false;
  }

  return true;
}
},{"./generated":88}],105:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isCompatTag;

function isCompatTag(tagName) {
  return !!tagName && /^[a-z]/.test(tagName);
}
},{}],106:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _buildMatchMemberExpression = _interopRequireDefault(require("../buildMatchMemberExpression"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const isReactComponent = (0, _buildMatchMemberExpression.default)("React.Component");
var _default = isReactComponent;
exports.default = _default;
},{"../buildMatchMemberExpression":87}],107:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = validate;
exports.validateField = validateField;
exports.validateChild = validateChild;

var _definitions = require("../definitions");

function validate(node, key, val) {
  if (!node) return;
  const fields = _definitions.NODE_FIELDS[node.type];
  if (!fields) return;
  const field = fields[key];
  validateField(node, key, val, field);
  validateChild(node, key, val);
}

function validateField(node, key, val, field) {
  if (!(field == null ? void 0 : field.validate)) return;
  if (field.optional && val == null) return;
  field.validate(node, key, val);
}

function validateChild(node, key, val) {
  if (val == null) return;
  const validate = _definitions.NODE_PARENT_VALIDATIONS[val.type];
  if (!validate) return;
  validate(node, key, val);
}
},{"../definitions":66}],108:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],109:[function(require,module,exports){
(function (Buffer){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this,require("buffer").Buffer)

},{"base64-js":108,"buffer":109,"ieee754":112}],110:[function(require,module,exports){
var charenc = {
  // UTF-8 encoding
  utf8: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
    }
  },

  // Binary encoding
  bin: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      for (var bytes = [], i = 0; i < str.length; i++)
        bytes.push(str.charCodeAt(i) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      for (var str = [], i = 0; i < bytes.length; i++)
        str.push(String.fromCharCode(bytes[i]));
      return str.join('');
    }
  }
};

module.exports = charenc;

},{}],111:[function(require,module,exports){
(function() {
  var base64map
      = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',

  crypt = {
    // Bit-wise rotation left
    rotl: function(n, b) {
      return (n << b) | (n >>> (32 - b));
    },

    // Bit-wise rotation right
    rotr: function(n, b) {
      return (n << (32 - b)) | (n >>> b);
    },

    // Swap big-endian to little-endian and vice versa
    endian: function(n) {
      // If number given, swap endian
      if (n.constructor == Number) {
        return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;
      }

      // Else, assume array and swap all items
      for (var i = 0; i < n.length; i++)
        n[i] = crypt.endian(n[i]);
      return n;
    },

    // Generate an array of any length of random bytes
    randomBytes: function(n) {
      for (var bytes = []; n > 0; n--)
        bytes.push(Math.floor(Math.random() * 256));
      return bytes;
    },

    // Convert a byte array to big-endian 32-bit words
    bytesToWords: function(bytes) {
      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
        words[b >>> 5] |= bytes[i] << (24 - b % 32);
      return words;
    },

    // Convert big-endian 32-bit words to a byte array
    wordsToBytes: function(words) {
      for (var bytes = [], b = 0; b < words.length * 32; b += 8)
        bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a hex string
    bytesToHex: function(bytes) {
      for (var hex = [], i = 0; i < bytes.length; i++) {
        hex.push((bytes[i] >>> 4).toString(16));
        hex.push((bytes[i] & 0xF).toString(16));
      }
      return hex.join('');
    },

    // Convert a hex string to a byte array
    hexToBytes: function(hex) {
      for (var bytes = [], c = 0; c < hex.length; c += 2)
        bytes.push(parseInt(hex.substr(c, 2), 16));
      return bytes;
    },

    // Convert a byte array to a base-64 string
    bytesToBase64: function(bytes) {
      for (var base64 = [], i = 0; i < bytes.length; i += 3) {
        var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
        for (var j = 0; j < 4; j++)
          if (i * 8 + j * 6 <= bytes.length * 8)
            base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));
          else
            base64.push('=');
      }
      return base64.join('');
    },

    // Convert a base-64 string to a byte array
    base64ToBytes: function(base64) {
      // Remove non-base-64 characters
      base64 = base64.replace(/[^A-Z0-9+\/]/ig, '');

      for (var bytes = [], i = 0, imod4 = 0; i < base64.length;
          imod4 = ++i % 4) {
        if (imod4 == 0) continue;
        bytes.push(((base64map.indexOf(base64.charAt(i - 1))
            & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2))
            | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));
      }
      return bytes;
    }
  };

  module.exports = crypt;
})();

},{}],112:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],113:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;

},{"./_getNative":163,"./_root":198}],114:[function(require,module,exports){
var hashClear = require('./_hashClear'),
    hashDelete = require('./_hashDelete'),
    hashGet = require('./_hashGet'),
    hashHas = require('./_hashHas'),
    hashSet = require('./_hashSet');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;

},{"./_hashClear":170,"./_hashDelete":171,"./_hashGet":172,"./_hashHas":173,"./_hashSet":174}],115:[function(require,module,exports){
var listCacheClear = require('./_listCacheClear'),
    listCacheDelete = require('./_listCacheDelete'),
    listCacheGet = require('./_listCacheGet'),
    listCacheHas = require('./_listCacheHas'),
    listCacheSet = require('./_listCacheSet');

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;

},{"./_listCacheClear":182,"./_listCacheDelete":183,"./_listCacheGet":184,"./_listCacheHas":185,"./_listCacheSet":186}],116:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;

},{"./_getNative":163,"./_root":198}],117:[function(require,module,exports){
var mapCacheClear = require('./_mapCacheClear'),
    mapCacheDelete = require('./_mapCacheDelete'),
    mapCacheGet = require('./_mapCacheGet'),
    mapCacheHas = require('./_mapCacheHas'),
    mapCacheSet = require('./_mapCacheSet');

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;

},{"./_mapCacheClear":187,"./_mapCacheDelete":188,"./_mapCacheGet":189,"./_mapCacheHas":190,"./_mapCacheSet":191}],118:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;

},{"./_getNative":163,"./_root":198}],119:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;

},{"./_getNative":163,"./_root":198}],120:[function(require,module,exports){
var ListCache = require('./_ListCache'),
    stackClear = require('./_stackClear'),
    stackDelete = require('./_stackDelete'),
    stackGet = require('./_stackGet'),
    stackHas = require('./_stackHas'),
    stackSet = require('./_stackSet');

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;

},{"./_ListCache":115,"./_stackClear":199,"./_stackDelete":200,"./_stackGet":201,"./_stackHas":202,"./_stackSet":203}],121:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;

},{"./_root":198}],122:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;

},{"./_root":198}],123:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;

},{"./_getNative":163,"./_root":198}],124:[function(require,module,exports){
/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;

},{}],125:[function(require,module,exports){
/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;

},{}],126:[function(require,module,exports){
var baseTimes = require('./_baseTimes'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isIndex = require('./_isIndex'),
    isTypedArray = require('./isTypedArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;

},{"./_baseTimes":145,"./_isIndex":178,"./isArguments":207,"./isArray":208,"./isBuffer":210,"./isTypedArray":219}],127:[function(require,module,exports){
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;

},{}],128:[function(require,module,exports){
var baseAssignValue = require('./_baseAssignValue'),
    eq = require('./eq');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;

},{"./_baseAssignValue":132,"./eq":206}],129:[function(require,module,exports){
var eq = require('./eq');

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;

},{"./eq":206}],130:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    keys = require('./keys');

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;

},{"./_copyObject":154,"./keys":220}],131:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    keysIn = require('./keysIn');

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;

},{"./_copyObject":154,"./keysIn":221}],132:[function(require,module,exports){
var defineProperty = require('./_defineProperty');

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;

},{"./_defineProperty":158}],133:[function(require,module,exports){
var Stack = require('./_Stack'),
    arrayEach = require('./_arrayEach'),
    assignValue = require('./_assignValue'),
    baseAssign = require('./_baseAssign'),
    baseAssignIn = require('./_baseAssignIn'),
    cloneBuffer = require('./_cloneBuffer'),
    copyArray = require('./_copyArray'),
    copySymbols = require('./_copySymbols'),
    copySymbolsIn = require('./_copySymbolsIn'),
    getAllKeys = require('./_getAllKeys'),
    getAllKeysIn = require('./_getAllKeysIn'),
    getTag = require('./_getTag'),
    initCloneArray = require('./_initCloneArray'),
    initCloneByTag = require('./_initCloneByTag'),
    initCloneObject = require('./_initCloneObject'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isMap = require('./isMap'),
    isObject = require('./isObject'),
    isSet = require('./isSet'),
    keys = require('./keys'),
    keysIn = require('./keysIn');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;

},{"./_Stack":120,"./_arrayEach":124,"./_assignValue":128,"./_baseAssign":130,"./_baseAssignIn":131,"./_cloneBuffer":148,"./_copyArray":153,"./_copySymbols":155,"./_copySymbolsIn":156,"./_getAllKeys":160,"./_getAllKeysIn":161,"./_getTag":168,"./_initCloneArray":175,"./_initCloneByTag":176,"./_initCloneObject":177,"./isArray":208,"./isBuffer":210,"./isMap":213,"./isObject":214,"./isSet":218,"./keys":220,"./keysIn":221}],134:[function(require,module,exports){
var isObject = require('./isObject');

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;

},{"./isObject":214}],135:[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    isArray = require('./isArray');

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;

},{"./_arrayPush":127,"./isArray":208}],136:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    getRawTag = require('./_getRawTag'),
    objectToString = require('./_objectToString');

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;

},{"./_Symbol":121,"./_getRawTag":165,"./_objectToString":196}],137:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

},{"./_baseGetTag":136,"./isObjectLike":215}],138:[function(require,module,exports){
var getTag = require('./_getTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var mapTag = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;

},{"./_getTag":168,"./isObjectLike":215}],139:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isMasked = require('./_isMasked'),
    isObject = require('./isObject'),
    toSource = require('./_toSource');

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

},{"./_isMasked":180,"./_toSource":204,"./isFunction":211,"./isObject":214}],140:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var regexpTag = '[object RegExp]';

/**
 * The base implementation of `_.isRegExp` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
 */
function baseIsRegExp(value) {
  return isObjectLike(value) && baseGetTag(value) == regexpTag;
}

module.exports = baseIsRegExp;

},{"./_baseGetTag":136,"./isObjectLike":215}],141:[function(require,module,exports){
var getTag = require('./_getTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var setTag = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;

},{"./_getTag":168,"./isObjectLike":215}],142:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isLength = require('./isLength'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

},{"./_baseGetTag":136,"./isLength":212,"./isObjectLike":215}],143:[function(require,module,exports){
var isPrototype = require('./_isPrototype'),
    nativeKeys = require('./_nativeKeys');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;

},{"./_isPrototype":181,"./_nativeKeys":193}],144:[function(require,module,exports){
var isObject = require('./isObject'),
    isPrototype = require('./_isPrototype'),
    nativeKeysIn = require('./_nativeKeysIn');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;

},{"./_isPrototype":181,"./_nativeKeysIn":194,"./isObject":214}],145:[function(require,module,exports){
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;

},{}],146:[function(require,module,exports){
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;

},{}],147:[function(require,module,exports){
var Uint8Array = require('./_Uint8Array');

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;

},{"./_Uint8Array":122}],148:[function(require,module,exports){
var root = require('./_root');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

},{"./_root":198}],149:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer');

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;

},{"./_cloneArrayBuffer":147}],150:[function(require,module,exports){
/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;

},{}],151:[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;

},{"./_Symbol":121}],152:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer');

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;

},{"./_cloneArrayBuffer":147}],153:[function(require,module,exports){
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;

},{}],154:[function(require,module,exports){
var assignValue = require('./_assignValue'),
    baseAssignValue = require('./_baseAssignValue');

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;

},{"./_assignValue":128,"./_baseAssignValue":132}],155:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    getSymbols = require('./_getSymbols');

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;

},{"./_copyObject":154,"./_getSymbols":166}],156:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    getSymbolsIn = require('./_getSymbolsIn');

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;

},{"./_copyObject":154,"./_getSymbolsIn":167}],157:[function(require,module,exports){
var root = require('./_root');

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;

},{"./_root":198}],158:[function(require,module,exports){
var getNative = require('./_getNative');

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;

},{"./_getNative":163}],159:[function(require,module,exports){
(function (global){
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],160:[function(require,module,exports){
var baseGetAllKeys = require('./_baseGetAllKeys'),
    getSymbols = require('./_getSymbols'),
    keys = require('./keys');

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;

},{"./_baseGetAllKeys":135,"./_getSymbols":166,"./keys":220}],161:[function(require,module,exports){
var baseGetAllKeys = require('./_baseGetAllKeys'),
    getSymbolsIn = require('./_getSymbolsIn'),
    keysIn = require('./keysIn');

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;

},{"./_baseGetAllKeys":135,"./_getSymbolsIn":167,"./keysIn":221}],162:[function(require,module,exports){
var isKeyable = require('./_isKeyable');

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;

},{"./_isKeyable":179}],163:[function(require,module,exports){
var baseIsNative = require('./_baseIsNative'),
    getValue = require('./_getValue');

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

},{"./_baseIsNative":139,"./_getValue":169}],164:[function(require,module,exports){
var overArg = require('./_overArg');

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;

},{"./_overArg":197}],165:[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;

},{"./_Symbol":121}],166:[function(require,module,exports){
var arrayFilter = require('./_arrayFilter'),
    stubArray = require('./stubArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;

},{"./_arrayFilter":125,"./stubArray":222}],167:[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    getPrototype = require('./_getPrototype'),
    getSymbols = require('./_getSymbols'),
    stubArray = require('./stubArray');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;

},{"./_arrayPush":127,"./_getPrototype":164,"./_getSymbols":166,"./stubArray":222}],168:[function(require,module,exports){
var DataView = require('./_DataView'),
    Map = require('./_Map'),
    Promise = require('./_Promise'),
    Set = require('./_Set'),
    WeakMap = require('./_WeakMap'),
    baseGetTag = require('./_baseGetTag'),
    toSource = require('./_toSource');

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;

},{"./_DataView":113,"./_Map":116,"./_Promise":118,"./_Set":119,"./_WeakMap":123,"./_baseGetTag":136,"./_toSource":204}],169:[function(require,module,exports){
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

},{}],170:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;

},{"./_nativeCreate":192}],171:[function(require,module,exports){
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;

},{}],172:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

},{"./_nativeCreate":192}],173:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

},{"./_nativeCreate":192}],174:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

},{"./_nativeCreate":192}],175:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;

},{}],176:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer'),
    cloneDataView = require('./_cloneDataView'),
    cloneRegExp = require('./_cloneRegExp'),
    cloneSymbol = require('./_cloneSymbol'),
    cloneTypedArray = require('./_cloneTypedArray');

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor;

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor;

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;

},{"./_cloneArrayBuffer":147,"./_cloneDataView":149,"./_cloneRegExp":150,"./_cloneSymbol":151,"./_cloneTypedArray":152}],177:[function(require,module,exports){
var baseCreate = require('./_baseCreate'),
    getPrototype = require('./_getPrototype'),
    isPrototype = require('./_isPrototype');

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;

},{"./_baseCreate":134,"./_getPrototype":164,"./_isPrototype":181}],178:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;

},{}],179:[function(require,module,exports){
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;

},{}],180:[function(require,module,exports){
var coreJsData = require('./_coreJsData');

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;

},{"./_coreJsData":157}],181:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;

},{}],182:[function(require,module,exports){
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;

},{}],183:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;

},{"./_assocIndexOf":129}],184:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

},{"./_assocIndexOf":129}],185:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

},{"./_assocIndexOf":129}],186:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;

},{"./_assocIndexOf":129}],187:[function(require,module,exports){
var Hash = require('./_Hash'),
    ListCache = require('./_ListCache'),
    Map = require('./_Map');

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;

},{"./_Hash":114,"./_ListCache":115,"./_Map":116}],188:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;

},{"./_getMapData":162}],189:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

},{"./_getMapData":162}],190:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

},{"./_getMapData":162}],191:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;

},{"./_getMapData":162}],192:[function(require,module,exports){
var getNative = require('./_getNative');

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;

},{"./_getNative":163}],193:[function(require,module,exports){
var overArg = require('./_overArg');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;

},{"./_overArg":197}],194:[function(require,module,exports){
/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;

},{}],195:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

},{"./_freeGlobal":159}],196:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

},{}],197:[function(require,module,exports){
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

},{}],198:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;

},{"./_freeGlobal":159}],199:[function(require,module,exports){
var ListCache = require('./_ListCache');

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;

},{"./_ListCache":115}],200:[function(require,module,exports){
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;

},{}],201:[function(require,module,exports){
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

},{}],202:[function(require,module,exports){
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

},{}],203:[function(require,module,exports){
var ListCache = require('./_ListCache'),
    Map = require('./_Map'),
    MapCache = require('./_MapCache');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;

},{"./_ListCache":115,"./_Map":116,"./_MapCache":117}],204:[function(require,module,exports){
/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;

},{}],205:[function(require,module,exports){
var baseClone = require('./_baseClone');

/** Used to compose bitmasks for cloning. */
var CLONE_SYMBOLS_FLAG = 4;

/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */
function clone(value) {
  return baseClone(value, CLONE_SYMBOLS_FLAG);
}

module.exports = clone;

},{"./_baseClone":133}],206:[function(require,module,exports){
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;

},{}],207:[function(require,module,exports){
var baseIsArguments = require('./_baseIsArguments'),
    isObjectLike = require('./isObjectLike');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;

},{"./_baseIsArguments":137,"./isObjectLike":215}],208:[function(require,module,exports){
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;

},{}],209:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isLength = require('./isLength');

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

},{"./isFunction":211,"./isLength":212}],210:[function(require,module,exports){
var root = require('./_root'),
    stubFalse = require('./stubFalse');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

},{"./_root":198,"./stubFalse":223}],211:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObject = require('./isObject');

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

},{"./_baseGetTag":136,"./isObject":214}],212:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

},{}],213:[function(require,module,exports){
var baseIsMap = require('./_baseIsMap'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');

/* Node.js helper references. */
var nodeIsMap = nodeUtil && nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

module.exports = isMap;

},{"./_baseIsMap":138,"./_baseUnary":146,"./_nodeUtil":195}],214:[function(require,module,exports){
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

},{}],215:[function(require,module,exports){
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;

},{}],216:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    getPrototype = require('./_getPrototype'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;

},{"./_baseGetTag":136,"./_getPrototype":164,"./isObjectLike":215}],217:[function(require,module,exports){
var baseIsRegExp = require('./_baseIsRegExp'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');

/* Node.js helper references. */
var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;

/**
 * Checks if `value` is classified as a `RegExp` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
 * @example
 *
 * _.isRegExp(/abc/);
 * // => true
 *
 * _.isRegExp('/abc/');
 * // => false
 */
var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

module.exports = isRegExp;

},{"./_baseIsRegExp":140,"./_baseUnary":146,"./_nodeUtil":195}],218:[function(require,module,exports){
var baseIsSet = require('./_baseIsSet'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');

/* Node.js helper references. */
var nodeIsSet = nodeUtil && nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

module.exports = isSet;

},{"./_baseIsSet":141,"./_baseUnary":146,"./_nodeUtil":195}],219:[function(require,module,exports){
var baseIsTypedArray = require('./_baseIsTypedArray'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;

},{"./_baseIsTypedArray":142,"./_baseUnary":146,"./_nodeUtil":195}],220:[function(require,module,exports){
var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeys = require('./_baseKeys'),
    isArrayLike = require('./isArrayLike');

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;

},{"./_arrayLikeKeys":126,"./_baseKeys":143,"./isArrayLike":209}],221:[function(require,module,exports){
var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeysIn = require('./_baseKeysIn'),
    isArrayLike = require('./isArrayLike');

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;

},{"./_arrayLikeKeys":126,"./_baseKeysIn":144,"./isArrayLike":209}],222:[function(require,module,exports){
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;

},{}],223:[function(require,module,exports){
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

},{}],224:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],225:[function(require,module,exports){
/*
 * qTip2 - Pretty powerful tooltips - v3.0.3
 * http://qtip2.com
 *
 * Copyright (c) 2016 
 * Released under the MIT licenses
 * http://jquery.org/license
 *
 * Date: Wed May 11 2016 10:31 GMT+0100+0100
 * Plugins: tips modal viewport svg imagemap ie6
 * Styles: core basic css3
 */
/*global window: false, jQuery: false, console: false, define: false */

/* Cache window, document, undefined */
(function( window, document, undefined ) {

// Uses AMD or browser globals to create a jQuery plugin.
(function( factory ) {
	"use strict";
	if(typeof define === 'function' && define.amd) {
		define(['jquery'], factory);
	}
	else if(jQuery && !jQuery.fn.qtip) {
		factory(jQuery);
	}
}
(function($) {
	"use strict"; // Enable ECMAScript "strict" operation for this function. See more: http://ejohn.org/blog/ecmascript-5-strict-mode-json-and-more/
;// Munge the primitives - Paul Irish tip
var TRUE = true,
FALSE = false,
NULL = null,

// Common variables
X = 'x', Y = 'y',
WIDTH = 'width',
HEIGHT = 'height',

// Positioning sides
TOP = 'top',
LEFT = 'left',
BOTTOM = 'bottom',
RIGHT = 'right',
CENTER = 'center',

// Position adjustment types
FLIP = 'flip',
FLIPINVERT = 'flipinvert',
SHIFT = 'shift',

// Shortcut vars
QTIP, PROTOTYPE, CORNER, CHECKS,
PLUGINS = {},
NAMESPACE = 'qtip',
ATTR_HAS = 'data-hasqtip',
ATTR_ID = 'data-qtip-id',
WIDGET = ['ui-widget', 'ui-tooltip'],
SELECTOR = '.'+NAMESPACE,
INACTIVE_EVENTS = 'click dblclick mousedown mouseup mousemove mouseleave mouseenter'.split(' '),

CLASS_FIXED = NAMESPACE+'-fixed',
CLASS_DEFAULT = NAMESPACE + '-default',
CLASS_FOCUS = NAMESPACE + '-focus',
CLASS_HOVER = NAMESPACE + '-hover',
CLASS_DISABLED = NAMESPACE+'-disabled',

replaceSuffix = '_replacedByqTip',
oldtitle = 'oldtitle',
trackingBound,

// Browser detection
BROWSER = {
	/*
	 * IE version detection
	 *
	 * Adapted from: http://ajaxian.com/archives/attack-of-the-ie-conditional-comment
	 * Credit to James Padolsey for the original implemntation!
	 */
	ie: (function() {
		/* eslint-disable no-empty */
		var v, i;
		for (
			v = 4, i = document.createElement('div');
			(i.innerHTML = '<!--[if gt IE ' + v + ']><i></i><![endif]-->') && i.getElementsByTagName('i')[0];
			v+=1
		) {}
		return v > 4 ? v : NaN;
		/* eslint-enable no-empty */
	})(),

	/*
	 * iOS version detection
	 */
	iOS: parseFloat(
		('' + (/CPU.*OS ([0-9_]{1,5})|(CPU like).*AppleWebKit.*Mobile/i.exec(navigator.userAgent) || [0,''])[1])
		.replace('undefined', '3_2').replace('_', '.').replace('_', '')
	) || FALSE
};
;function QTip(target, options, id, attr) {
	// Elements and ID
	this.id = id;
	this.target = target;
	this.tooltip = NULL;
	this.elements = { target: target };

	// Internal constructs
	this._id = NAMESPACE + '-' + id;
	this.timers = { img: {} };
	this.options = options;
	this.plugins = {};

	// Cache object
	this.cache = {
		event: {},
		target: $(),
		disabled: FALSE,
		attr: attr,
		onTooltip: FALSE,
		lastClass: ''
	};

	// Set the initial flags
	this.rendered = this.destroyed = this.disabled = this.waiting =
		this.hiddenDuringWait = this.positioning = this.triggering = FALSE;
}
PROTOTYPE = QTip.prototype;

PROTOTYPE._when = function(deferreds) {
	return $.when.apply($, deferreds);
};

PROTOTYPE.render = function(show) {
	if(this.rendered || this.destroyed) { return this; } // If tooltip has already been rendered, exit

	var self = this,
		options = this.options,
		cache = this.cache,
		elements = this.elements,
		text = options.content.text,
		title = options.content.title,
		button = options.content.button,
		posOptions = options.position,
		deferreds = [];

	// Add ARIA attributes to target
	$.attr(this.target[0], 'aria-describedby', this._id);

	// Create public position object that tracks current position corners
	cache.posClass = this._createPosClass(
		(this.position = { my: posOptions.my, at: posOptions.at }).my
	);

	// Create tooltip element
	this.tooltip = elements.tooltip = $('<div/>', {
		'id': this._id,
		'class': [ NAMESPACE, CLASS_DEFAULT, options.style.classes, cache.posClass ].join(' '),
		'width': options.style.width || '',
		'height': options.style.height || '',
		'tracking': posOptions.target === 'mouse' && posOptions.adjust.mouse,

		/* ARIA specific attributes */
		'role': 'alert',
		'aria-live': 'polite',
		'aria-atomic': FALSE,
		'aria-describedby': this._id + '-content',
		'aria-hidden': TRUE
	})
	.toggleClass(CLASS_DISABLED, this.disabled)
	.attr(ATTR_ID, this.id)
	.data(NAMESPACE, this)
	.appendTo(posOptions.container)
	.append(
		// Create content element
		elements.content = $('<div />', {
			'class': NAMESPACE + '-content',
			'id': this._id + '-content',
			'aria-atomic': TRUE
		})
	);

	// Set rendered flag and prevent redundant reposition calls for now
	this.rendered = -1;
	this.positioning = TRUE;

	// Create title...
	if(title) {
		this._createTitle();

		// Update title only if its not a callback (called in toggle if so)
		if(!$.isFunction(title)) {
			deferreds.push( this._updateTitle(title, FALSE) );
		}
	}

	// Create button
	if(button) { this._createButton(); }

	// Set proper rendered flag and update content if not a callback function (called in toggle)
	if(!$.isFunction(text)) {
		deferreds.push( this._updateContent(text, FALSE) );
	}
	this.rendered = TRUE;

	// Setup widget classes
	this._setWidget();

	// Initialize 'render' plugins
	$.each(PLUGINS, function(name) {
		var instance;
		if(this.initialize === 'render' && (instance = this(self))) {
			self.plugins[name] = instance;
		}
	});

	// Unassign initial events and assign proper events
	this._unassignEvents();
	this._assignEvents();

	// When deferreds have completed
	this._when(deferreds).then(function() {
		// tooltiprender event
		self._trigger('render');

		// Reset flags
		self.positioning = FALSE;

		// Show tooltip if not hidden during wait period
		if(!self.hiddenDuringWait && (options.show.ready || show)) {
			self.toggle(TRUE, cache.event, FALSE);
		}
		self.hiddenDuringWait = FALSE;
	});

	// Expose API
	QTIP.api[this.id] = this;

	return this;
};

PROTOTYPE.destroy = function(immediate) {
	// Set flag the signify destroy is taking place to plugins
	// and ensure it only gets destroyed once!
	if(this.destroyed) { return this.target; }

	function process() {
		if(this.destroyed) { return; }
		this.destroyed = TRUE;

		var target = this.target,
			title = target.attr(oldtitle),
			timer;

		// Destroy tooltip if rendered
		if(this.rendered) {
			this.tooltip.stop(1,0).find('*').remove().end().remove();
		}

		// Destroy all plugins
		$.each(this.plugins, function() {
			this.destroy && this.destroy();
		});

		// Clear timers
		for (timer in this.timers) {
			if (this.timers.hasOwnProperty(timer)) {
				clearTimeout(this.timers[timer]);
			}
		}

		// Remove api object and ARIA attributes
		target.removeData(NAMESPACE)
			.removeAttr(ATTR_ID)
			.removeAttr(ATTR_HAS)
			.removeAttr('aria-describedby');

		// Reset old title attribute if removed
		if(this.options.suppress && title) {
			target.attr('title', title).removeAttr(oldtitle);
		}

		// Remove qTip events associated with this API
		this._unassignEvents();

		// Remove ID from used id objects, and delete object references
		// for better garbage collection and leak protection
		this.options = this.elements = this.cache = this.timers =
			this.plugins = this.mouse = NULL;

		// Delete epoxsed API object
		delete QTIP.api[this.id];
	}

	// If an immediate destroy is needed
	if((immediate !== TRUE || this.triggering === 'hide') && this.rendered) {
		this.tooltip.one('tooltiphidden', $.proxy(process, this));
		!this.triggering && this.hide();
	}

	// If we're not in the process of hiding... process
	else { process.call(this); }

	return this.target;
};
;function invalidOpt(a) {
	return a === NULL || $.type(a) !== 'object';
}

function invalidContent(c) {
	return !($.isFunction(c) || 
            c && c.attr || 
            c.length || 
            $.type(c) === 'object' && (c.jquery || c.then));
}

// Option object sanitizer
function sanitizeOptions(opts) {
	var content, text, ajax, once;

	if(invalidOpt(opts)) { return FALSE; }

	if(invalidOpt(opts.metadata)) {
		opts.metadata = { type: opts.metadata };
	}

	if('content' in opts) {
		content = opts.content;

		if(invalidOpt(content) || content.jquery || content.done) {
			text = invalidContent(content) ? FALSE : content;
			content = opts.content = {
				text: text
			};
		}
		else { text = content.text; }

		// DEPRECATED - Old content.ajax plugin functionality
		// Converts it into the proper Deferred syntax
		if('ajax' in content) {
			ajax = content.ajax;
			once = ajax && ajax.once !== FALSE;
			delete content.ajax;

			content.text = function(event, api) {
				var loading = text || $(this).attr(api.options.content.attr) || 'Loading...',

				deferred = $.ajax(
					$.extend({}, ajax, { context: api })
				)
				.then(ajax.success, NULL, ajax.error)
				.then(function(newContent) {
					if(newContent && once) { api.set('content.text', newContent); }
					return newContent;
				},
				function(xhr, status, error) {
					if(api.destroyed || xhr.status === 0) { return; }
					api.set('content.text', status + ': ' + error);
				});

				return !once ? (api.set('content.text', loading), deferred) : loading;
			};
		}

		if('title' in content) {
			if($.isPlainObject(content.title)) {
				content.button = content.title.button;
				content.title = content.title.text;
			}

			if(invalidContent(content.title || FALSE)) {
				content.title = FALSE;
			}
		}
	}

	if('position' in opts && invalidOpt(opts.position)) {
		opts.position = { my: opts.position, at: opts.position };
	}

	if('show' in opts && invalidOpt(opts.show)) {
		opts.show = opts.show.jquery ? { target: opts.show } :
			opts.show === TRUE ? { ready: TRUE } : { event: opts.show };
	}

	if('hide' in opts && invalidOpt(opts.hide)) {
		opts.hide = opts.hide.jquery ? { target: opts.hide } : { event: opts.hide };
	}

	if('style' in opts && invalidOpt(opts.style)) {
		opts.style = { classes: opts.style };
	}

	// Sanitize plugin options
	$.each(PLUGINS, function() {
		this.sanitize && this.sanitize(opts);
	});

	return opts;
}

// Setup builtin .set() option checks
CHECKS = PROTOTYPE.checks = {
	builtin: {
		// Core checks
		'^id$': function(obj, o, v, prev) {
			var id = v === TRUE ? QTIP.nextid : v,
				newId = NAMESPACE + '-' + id;

			if(id !== FALSE && id.length > 0 && !$('#'+newId).length) {
				this._id = newId;

				if(this.rendered) {
					this.tooltip[0].id = this._id;
					this.elements.content[0].id = this._id + '-content';
					this.elements.title[0].id = this._id + '-title';
				}
			}
			else { obj[o] = prev; }
		},
		'^prerender': function(obj, o, v) {
			v && !this.rendered && this.render(this.options.show.ready);
		},

		// Content checks
		'^content.text$': function(obj, o, v) {
			this._updateContent(v);
		},
		'^content.attr$': function(obj, o, v, prev) {
			if(this.options.content.text === this.target.attr(prev)) {
				this._updateContent( this.target.attr(v) );
			}
		},
		'^content.title$': function(obj, o, v) {
			// Remove title if content is null
			if(!v) { return this._removeTitle(); }

			// If title isn't already created, create it now and update
			v && !this.elements.title && this._createTitle();
			this._updateTitle(v);
		},
		'^content.button$': function(obj, o, v) {
			this._updateButton(v);
		},
		'^content.title.(text|button)$': function(obj, o, v) {
			this.set('content.'+o, v); // Backwards title.text/button compat
		},

		// Position checks
		'^position.(my|at)$': function(obj, o, v){
			if('string' === typeof v) {
				this.position[o] = obj[o] = new CORNER(v, o === 'at');
			}
		},
		'^position.container$': function(obj, o, v){
			this.rendered && this.tooltip.appendTo(v);
		},

		// Show checks
		'^show.ready$': function(obj, o, v) {
			v && (!this.rendered && this.render(TRUE) || this.toggle(TRUE));
		},

		// Style checks
		'^style.classes$': function(obj, o, v, p) {
			this.rendered && this.tooltip.removeClass(p).addClass(v);
		},
		'^style.(width|height)': function(obj, o, v) {
			this.rendered && this.tooltip.css(o, v);
		},
		'^style.widget|content.title': function() {
			this.rendered && this._setWidget();
		},
		'^style.def': function(obj, o, v) {
			this.rendered && this.tooltip.toggleClass(CLASS_DEFAULT, !!v);
		},

		// Events check
		'^events.(render|show|move|hide|focus|blur)$': function(obj, o, v) {
			this.rendered && this.tooltip[($.isFunction(v) ? '' : 'un') + 'bind']('tooltip'+o, v);
		},

		// Properties which require event reassignment
		'^(show|hide|position).(event|target|fixed|inactive|leave|distance|viewport|adjust)': function() {
			if(!this.rendered) { return; }

			// Set tracking flag
			var posOptions = this.options.position;
			this.tooltip.attr('tracking', posOptions.target === 'mouse' && posOptions.adjust.mouse);

			// Reassign events
			this._unassignEvents();
			this._assignEvents();
		}
	}
};

// Dot notation converter
function convertNotation(options, notation) {
	var i = 0, obj, option = options,

	// Split notation into array
	levels = notation.split('.');

	// Loop through
	while(option = option[ levels[i++] ]) {
		if(i < levels.length) { obj = option; }
	}

	return [obj || options, levels.pop()];
}

PROTOTYPE.get = function(notation) {
	if(this.destroyed) { return this; }

	var o = convertNotation(this.options, notation.toLowerCase()),
		result = o[0][ o[1] ];

	return result.precedance ? result.string() : result;
};

function setCallback(notation, args) {
	var category, rule, match;

	for(category in this.checks) {
		if (!this.checks.hasOwnProperty(category)) { continue; }

		for(rule in this.checks[category]) {
			if (!this.checks[category].hasOwnProperty(rule)) { continue; }

			if(match = (new RegExp(rule, 'i')).exec(notation)) {
				args.push(match);

				if(category === 'builtin' || this.plugins[category]) {
					this.checks[category][rule].apply(
						this.plugins[category] || this, args
					);
				}
			}
		}
	}
}

var rmove = /^position\.(my|at|adjust|target|container|viewport)|style|content|show\.ready/i,
	rrender = /^prerender|show\.ready/i;

PROTOTYPE.set = function(option, value) {
	if(this.destroyed) { return this; }

	var rendered = this.rendered,
		reposition = FALSE,
		options = this.options,
		name;

	// Convert singular option/value pair into object form
	if('string' === typeof option) {
		name = option; option = {}; option[name] = value;
	}
	else { option = $.extend({}, option); }

	// Set all of the defined options to their new values
	$.each(option, function(notation, val) {
		if(rendered && rrender.test(notation)) {
			delete option[notation]; return;
		}

		// Set new obj value
		var obj = convertNotation(options, notation.toLowerCase()), previous;
		previous = obj[0][ obj[1] ];
		obj[0][ obj[1] ] = val && val.nodeType ? $(val) : val;

		// Also check if we need to reposition
		reposition = rmove.test(notation) || reposition;

		// Set the new params for the callback
		option[notation] = [obj[0], obj[1], val, previous];
	});

	// Re-sanitize options
	sanitizeOptions(options);

	/*
	 * Execute any valid callbacks for the set options
	 * Also set positioning flag so we don't get loads of redundant repositioning calls.
	 */
	this.positioning = TRUE;
	$.each(option, $.proxy(setCallback, this));
	this.positioning = FALSE;

	// Update position if needed
	if(this.rendered && this.tooltip[0].offsetWidth > 0 && reposition) {
		this.reposition( options.position.target === 'mouse' ? NULL : this.cache.event );
	}

	return this;
};
;PROTOTYPE._update = function(content, element) {
	var self = this,
		cache = this.cache;

	// Make sure tooltip is rendered and content is defined. If not return
	if(!this.rendered || !content) { return FALSE; }

	// Use function to parse content
	if($.isFunction(content)) {
		content = content.call(this.elements.target, cache.event, this) || '';
	}

	// Handle deferred content
	if($.isFunction(content.then)) {
		cache.waiting = TRUE;
		return content.then(function(c) {
			cache.waiting = FALSE;
			return self._update(c, element);
		}, NULL, function(e) {
			return self._update(e, element);
		});
	}

	// If content is null... return false
	if(content === FALSE || !content && content !== '') { return FALSE; }

	// Append new content if its a DOM array and show it if hidden
	if(content.jquery && content.length > 0) {
		element.empty().append(
			content.css({ display: 'block', visibility: 'visible' })
		);
	}

	// Content is a regular string, insert the new content
	else { element.html(content); }

	// Wait for content to be loaded, and reposition
	return this._waitForContent(element).then(function(images) {
		if(self.rendered && self.tooltip[0].offsetWidth > 0) {
			self.reposition(cache.event, !images.length);
		}
	});
};

PROTOTYPE._waitForContent = function(element) {
	var cache = this.cache;

	// Set flag
	cache.waiting = TRUE;

	// If imagesLoaded is included, ensure images have loaded and return promise
	return ( $.fn.imagesLoaded ? element.imagesLoaded() : new $.Deferred().resolve([]) )
		.done(function() { cache.waiting = FALSE; })
		.promise();
};

PROTOTYPE._updateContent = function(content, reposition) {
	this._update(content, this.elements.content, reposition);
};

PROTOTYPE._updateTitle = function(content, reposition) {
	if(this._update(content, this.elements.title, reposition) === FALSE) {
		this._removeTitle(FALSE);
	}
};

PROTOTYPE._createTitle = function()
{
	var elements = this.elements,
		id = this._id+'-title';

	// Destroy previous title element, if present
	if(elements.titlebar) { this._removeTitle(); }

	// Create title bar and title elements
	elements.titlebar = $('<div />', {
		'class': NAMESPACE + '-titlebar ' + (this.options.style.widget ? createWidgetClass('header') : '')
	})
	.append(
		elements.title = $('<div />', {
			'id': id,
			'class': NAMESPACE + '-title',
			'aria-atomic': TRUE
		})
	)
	.insertBefore(elements.content)

	// Button-specific events
	.delegate('.qtip-close', 'mousedown keydown mouseup keyup mouseout', function(event) {
		$(this).toggleClass('ui-state-active ui-state-focus', event.type.substr(-4) === 'down');
	})
	.delegate('.qtip-close', 'mouseover mouseout', function(event){
		$(this).toggleClass('ui-state-hover', event.type === 'mouseover');
	});

	// Create button if enabled
	if(this.options.content.button) { this._createButton(); }
};

PROTOTYPE._removeTitle = function(reposition)
{
	var elements = this.elements;

	if(elements.title) {
		elements.titlebar.remove();
		elements.titlebar = elements.title = elements.button = NULL;

		// Reposition if enabled
		if(reposition !== FALSE) { this.reposition(); }
	}
};
;PROTOTYPE._createPosClass = function(my) {
	return NAMESPACE + '-pos-' + (my || this.options.position.my).abbrev();
};

PROTOTYPE.reposition = function(event, effect) {
	if(!this.rendered || this.positioning || this.destroyed) { return this; }

	// Set positioning flag
	this.positioning = TRUE;

	var cache = this.cache,
		tooltip = this.tooltip,
		posOptions = this.options.position,
		target = posOptions.target,
		my = posOptions.my,
		at = posOptions.at,
		viewport = posOptions.viewport,
		container = posOptions.container,
		adjust = posOptions.adjust,
		method = adjust.method.split(' '),
		tooltipWidth = tooltip.outerWidth(FALSE),
		tooltipHeight = tooltip.outerHeight(FALSE),
		targetWidth = 0,
		targetHeight = 0,
		type = tooltip.css('position'),
		position = { left: 0, top: 0 },
		visible = tooltip[0].offsetWidth > 0,
		isScroll = event && event.type === 'scroll',
		win = $(window),
		doc = container[0].ownerDocument,
		mouse = this.mouse,
		pluginCalculations, offset, adjusted, newClass;

	// Check if absolute position was passed
	if($.isArray(target) && target.length === 2) {
		// Force left top and set position
		at = { x: LEFT, y: TOP };
		position = { left: target[0], top: target[1] };
	}

	// Check if mouse was the target
	else if(target === 'mouse') {
		// Force left top to allow flipping
		at = { x: LEFT, y: TOP };

		// Use the mouse origin that caused the show event, if distance hiding is enabled
		if((!adjust.mouse || this.options.hide.distance) && cache.origin && cache.origin.pageX) {
			event =  cache.origin;
		}

		// Use cached event for resize/scroll events
		else if(!event || event && (event.type === 'resize' || event.type === 'scroll')) {
			event = cache.event;
		}

		// Otherwise, use the cached mouse coordinates if available
		else if(mouse && mouse.pageX) {
			event = mouse;
		}

		// Calculate body and container offset and take them into account below
		if(type !== 'static') { position = container.offset(); }
		if(doc.body.offsetWidth !== (window.innerWidth || doc.documentElement.clientWidth)) {
			offset = $(document.body).offset();
		}

		// Use event coordinates for position
		position = {
			left: event.pageX - position.left + (offset && offset.left || 0),
			top: event.pageY - position.top + (offset && offset.top || 0)
		};

		// Scroll events are a pain, some browsers
		if(adjust.mouse && isScroll && mouse) {
			position.left -= (mouse.scrollX || 0) - win.scrollLeft();
			position.top -= (mouse.scrollY || 0) - win.scrollTop();
		}
	}

	// Target wasn't mouse or absolute...
	else {
		// Check if event targetting is being used
		if(target === 'event') {
			if(event && event.target && event.type !== 'scroll' && event.type !== 'resize') {
				cache.target = $(event.target);
			}
			else if(!event.target) {
				cache.target = this.elements.target;
			}
		}
		else if(target !== 'event'){
			cache.target = $(target.jquery ? target : this.elements.target);
		}
		target = cache.target;

		// Parse the target into a jQuery object and make sure there's an element present
		target = $(target).eq(0);
		if(target.length === 0) { return this; }

		// Check if window or document is the target
		else if(target[0] === document || target[0] === window) {
			targetWidth = BROWSER.iOS ? window.innerWidth : target.width();
			targetHeight = BROWSER.iOS ? window.innerHeight : target.height();

			if(target[0] === window) {
				position = {
					top: (viewport || target).scrollTop(),
					left: (viewport || target).scrollLeft()
				};
			}
		}

		// Check if the target is an <AREA> element
		else if(PLUGINS.imagemap && target.is('area')) {
			pluginCalculations = PLUGINS.imagemap(this, target, at, PLUGINS.viewport ? method : FALSE);
		}

		// Check if the target is an SVG element
		else if(PLUGINS.svg && target && target[0].ownerSVGElement) {
			pluginCalculations = PLUGINS.svg(this, target, at, PLUGINS.viewport ? method : FALSE);
		}

		// Otherwise use regular jQuery methods
		else {
			targetWidth = target.outerWidth(FALSE);
			targetHeight = target.outerHeight(FALSE);
			position = target.offset();
		}

		// Parse returned plugin values into proper variables
		if(pluginCalculations) {
			targetWidth = pluginCalculations.width;
			targetHeight = pluginCalculations.height;
			offset = pluginCalculations.offset;
			position = pluginCalculations.position;
		}

		// Adjust position to take into account offset parents
		position = this.reposition.offset(target, position, container);

		// Adjust for position.fixed tooltips (and also iOS scroll bug in v3.2-4.0 & v4.3-4.3.2)
		if(BROWSER.iOS > 3.1 && BROWSER.iOS < 4.1 ||
			BROWSER.iOS >= 4.3 && BROWSER.iOS < 4.33 ||
			!BROWSER.iOS && type === 'fixed'
		){
			position.left -= win.scrollLeft();
			position.top -= win.scrollTop();
		}

		// Adjust position relative to target
		if(!pluginCalculations || pluginCalculations && pluginCalculations.adjustable !== FALSE) {
			position.left += at.x === RIGHT ? targetWidth : at.x === CENTER ? targetWidth / 2 : 0;
			position.top += at.y === BOTTOM ? targetHeight : at.y === CENTER ? targetHeight / 2 : 0;
		}
	}

	// Adjust position relative to tooltip
	position.left += adjust.x + (my.x === RIGHT ? -tooltipWidth : my.x === CENTER ? -tooltipWidth / 2 : 0);
	position.top += adjust.y + (my.y === BOTTOM ? -tooltipHeight : my.y === CENTER ? -tooltipHeight / 2 : 0);

	// Use viewport adjustment plugin if enabled
	if(PLUGINS.viewport) {
		adjusted = position.adjusted = PLUGINS.viewport(
			this, position, posOptions, targetWidth, targetHeight, tooltipWidth, tooltipHeight
		);

		// Apply offsets supplied by positioning plugin (if used)
		if(offset && adjusted.left) { position.left += offset.left; }
		if(offset && adjusted.top) {  position.top += offset.top; }

		// Apply any new 'my' position
		if(adjusted.my) { this.position.my = adjusted.my; }
	}

	// Viewport adjustment is disabled, set values to zero
	else { position.adjusted = { left: 0, top: 0 }; }

	// Set tooltip position class if it's changed
	if(cache.posClass !== (newClass = this._createPosClass(this.position.my))) {
		cache.posClass = newClass;
		tooltip.removeClass(cache.posClass).addClass(newClass);
	}

	// tooltipmove event
	if(!this._trigger('move', [position, viewport.elem || viewport], event)) { return this; }
	delete position.adjusted;

	// If effect is disabled, target it mouse, no animation is defined or positioning gives NaN out, set CSS directly
	if(effect === FALSE || !visible || isNaN(position.left) || isNaN(position.top) || target === 'mouse' || !$.isFunction(posOptions.effect)) {
		tooltip.css(position);
	}

	// Use custom function if provided
	else if($.isFunction(posOptions.effect)) {
		posOptions.effect.call(tooltip, this, $.extend({}, position));
		tooltip.queue(function(next) {
			// Reset attributes to avoid cross-browser rendering bugs
			$(this).css({ opacity: '', height: '' });
			if(BROWSER.ie) { this.style.removeAttribute('filter'); }

			next();
		});
	}

	// Set positioning flag
	this.positioning = FALSE;

	return this;
};

// Custom (more correct for qTip!) offset calculator
PROTOTYPE.reposition.offset = function(elem, pos, container) {
	if(!container[0]) { return pos; }

	var ownerDocument = $(elem[0].ownerDocument),
		quirks = !!BROWSER.ie && document.compatMode !== 'CSS1Compat',
		parent = container[0],
		scrolled, position, parentOffset, overflow;

	function scroll(e, i) {
		pos.left += i * e.scrollLeft();
		pos.top += i * e.scrollTop();
	}

	// Compensate for non-static containers offset
	do {
		if((position = $.css(parent, 'position')) !== 'static') {
			if(position === 'fixed') {
				parentOffset = parent.getBoundingClientRect();
				scroll(ownerDocument, -1);
			}
			else {
				parentOffset = $(parent).position();
				parentOffset.left += parseFloat($.css(parent, 'borderLeftWidth')) || 0;
				parentOffset.top += parseFloat($.css(parent, 'borderTopWidth')) || 0;
			}

			pos.left -= parentOffset.left + (parseFloat($.css(parent, 'marginLeft')) || 0);
			pos.top -= parentOffset.top + (parseFloat($.css(parent, 'marginTop')) || 0);

			// If this is the first parent element with an overflow of "scroll" or "auto", store it
			if(!scrolled && (overflow = $.css(parent, 'overflow')) !== 'hidden' && overflow !== 'visible') { scrolled = $(parent); }
		}
	}
	while(parent = parent.offsetParent);

	// Compensate for containers scroll if it also has an offsetParent (or in IE quirks mode)
	if(scrolled && (scrolled[0] !== ownerDocument[0] || quirks)) {
		scroll(scrolled, 1);
	}

	return pos;
};

// Corner class
var C = (CORNER = PROTOTYPE.reposition.Corner = function(corner, forceY) {
	corner = ('' + corner).replace(/([A-Z])/, ' $1').replace(/middle/gi, CENTER).toLowerCase();
	this.x = (corner.match(/left|right/i) || corner.match(/center/) || ['inherit'])[0].toLowerCase();
	this.y = (corner.match(/top|bottom|center/i) || ['inherit'])[0].toLowerCase();
	this.forceY = !!forceY;

	var f = corner.charAt(0);
	this.precedance = f === 't' || f === 'b' ? Y : X;
}).prototype;

C.invert = function(z, center) {
	this[z] = this[z] === LEFT ? RIGHT : this[z] === RIGHT ? LEFT : center || this[z];
};

C.string = function(join) {
	var x = this.x, y = this.y;

	var result = x !== y ?
		x === 'center' || y !== 'center' && (this.precedance === Y || this.forceY) ? 
			[y,x] : 
			[x,y] :
		[x];

	return join !== false ? result.join(' ') : result;
};

C.abbrev = function() {
	var result = this.string(false);
	return result[0].charAt(0) + (result[1] && result[1].charAt(0) || '');
};

C.clone = function() {
	return new CORNER( this.string(), this.forceY );
};

;
PROTOTYPE.toggle = function(state, event) {
	var cache = this.cache,
		options = this.options,
		tooltip = this.tooltip;

	// Try to prevent flickering when tooltip overlaps show element
	if(event) {
		if((/over|enter/).test(event.type) && cache.event && (/out|leave/).test(cache.event.type) &&
			options.show.target.add(event.target).length === options.show.target.length &&
			tooltip.has(event.relatedTarget).length) {
			return this;
		}

		// Cache event
		cache.event = $.event.fix(event);
	}

	// If we're currently waiting and we've just hidden... stop it
	this.waiting && !state && (this.hiddenDuringWait = TRUE);

	// Render the tooltip if showing and it isn't already
	if(!this.rendered) { return state ? this.render(1) : this; }
	else if(this.destroyed || this.disabled) { return this; }

	var type = state ? 'show' : 'hide',
		opts = this.options[type],
		posOptions = this.options.position,
		contentOptions = this.options.content,
		width = this.tooltip.css('width'),
		visible = this.tooltip.is(':visible'),
		animate = state || opts.target.length === 1,
		sameTarget = !event || opts.target.length < 2 || cache.target[0] === event.target,
		identicalState, allow, after;

	// Detect state if valid one isn't provided
	if((typeof state).search('boolean|number')) { state = !visible; }

	// Check if the tooltip is in an identical state to the new would-be state
	identicalState = !tooltip.is(':animated') && visible === state && sameTarget;

	// Fire tooltip(show/hide) event and check if destroyed
	allow = !identicalState ? !!this._trigger(type, [90]) : NULL;

	// Check to make sure the tooltip wasn't destroyed in the callback
	if(this.destroyed) { return this; }

	// If the user didn't stop the method prematurely and we're showing the tooltip, focus it
	if(allow !== FALSE && state) { this.focus(event); }

	// If the state hasn't changed or the user stopped it, return early
	if(!allow || identicalState) { return this; }

	// Set ARIA hidden attribute
	$.attr(tooltip[0], 'aria-hidden', !!!state);

	// Execute state specific properties
	if(state) {
		// Store show origin coordinates
		this.mouse && (cache.origin = $.event.fix(this.mouse));

		// Update tooltip content & title if it's a dynamic function
		if($.isFunction(contentOptions.text)) { this._updateContent(contentOptions.text, FALSE); }
		if($.isFunction(contentOptions.title)) { this._updateTitle(contentOptions.title, FALSE); }

		// Cache mousemove events for positioning purposes (if not already tracking)
		if(!trackingBound && posOptions.target === 'mouse' && posOptions.adjust.mouse) {
			$(document).bind('mousemove.'+NAMESPACE, this._storeMouse);
			trackingBound = TRUE;
		}

		// Update the tooltip position (set width first to prevent viewport/max-width issues)
		if(!width) { tooltip.css('width', tooltip.outerWidth(FALSE)); }
		this.reposition(event, arguments[2]);
		if(!width) { tooltip.css('width', ''); }

		// Hide other tooltips if tooltip is solo
		if(!!opts.solo) {
			(typeof opts.solo === 'string' ? $(opts.solo) : $(SELECTOR, opts.solo))
				.not(tooltip).not(opts.target).qtip('hide', new $.Event('tooltipsolo'));
		}
	}
	else {
		// Clear show timer if we're hiding
		clearTimeout(this.timers.show);

		// Remove cached origin on hide
		delete cache.origin;

		// Remove mouse tracking event if not needed (all tracking qTips are hidden)
		if(trackingBound && !$(SELECTOR+'[tracking="true"]:visible', opts.solo).not(tooltip).length) {
			$(document).unbind('mousemove.'+NAMESPACE);
			trackingBound = FALSE;
		}

		// Blur the tooltip
		this.blur(event);
	}

	// Define post-animation, state specific properties
	after = $.proxy(function() {
		if(state) {
			// Prevent antialias from disappearing in IE by removing filter
			if(BROWSER.ie) { tooltip[0].style.removeAttribute('filter'); }

			// Remove overflow setting to prevent tip bugs
			tooltip.css('overflow', '');

			// Autofocus elements if enabled
			if('string' === typeof opts.autofocus) {
				$(this.options.show.autofocus, tooltip).focus();
			}

			// If set, hide tooltip when inactive for delay period
			this.options.show.target.trigger('qtip-'+this.id+'-inactive');
		}
		else {
			// Reset CSS states
			tooltip.css({
				display: '',
				visibility: '',
				opacity: '',
				left: '',
				top: ''
			});
		}

		// tooltipvisible/tooltiphidden events
		this._trigger(state ? 'visible' : 'hidden');
	}, this);

	// If no effect type is supplied, use a simple toggle
	if(opts.effect === FALSE || animate === FALSE) {
		tooltip[ type ]();
		after();
	}

	// Use custom function if provided
	else if($.isFunction(opts.effect)) {
		tooltip.stop(1, 1);
		opts.effect.call(tooltip, this);
		tooltip.queue('fx', function(n) {
			after(); n();
		});
	}

	// Use basic fade function by default
	else { tooltip.fadeTo(90, state ? 1 : 0, after); }

	// If inactive hide method is set, active it
	if(state) { opts.target.trigger('qtip-'+this.id+'-inactive'); }

	return this;
};

PROTOTYPE.show = function(event) { return this.toggle(TRUE, event); };

PROTOTYPE.hide = function(event) { return this.toggle(FALSE, event); };
;PROTOTYPE.focus = function(event) {
	if(!this.rendered || this.destroyed) { return this; }

	var qtips = $(SELECTOR),
		tooltip = this.tooltip,
		curIndex = parseInt(tooltip[0].style.zIndex, 10),
		newIndex = QTIP.zindex + qtips.length;

	// Only update the z-index if it has changed and tooltip is not already focused
	if(!tooltip.hasClass(CLASS_FOCUS)) {
		// tooltipfocus event
		if(this._trigger('focus', [newIndex], event)) {
			// Only update z-index's if they've changed
			if(curIndex !== newIndex) {
				// Reduce our z-index's and keep them properly ordered
				qtips.each(function() {
					if(this.style.zIndex > curIndex) {
						this.style.zIndex = this.style.zIndex - 1;
					}
				});

				// Fire blur event for focused tooltip
				qtips.filter('.' + CLASS_FOCUS).qtip('blur', event);
			}

			// Set the new z-index
			tooltip.addClass(CLASS_FOCUS)[0].style.zIndex = newIndex;
		}
	}

	return this;
};

PROTOTYPE.blur = function(event) {
	if(!this.rendered || this.destroyed) { return this; }

	// Set focused status to FALSE
	this.tooltip.removeClass(CLASS_FOCUS);

	// tooltipblur event
	this._trigger('blur', [ this.tooltip.css('zIndex') ], event);

	return this;
};
;PROTOTYPE.disable = function(state) {
	if(this.destroyed) { return this; }

	// If 'toggle' is passed, toggle the current state
	if(state === 'toggle') {
		state = !(this.rendered ? this.tooltip.hasClass(CLASS_DISABLED) : this.disabled);
	}

	// Disable if no state passed
	else if('boolean' !== typeof state) {
		state = TRUE;
	}

	if(this.rendered) {
		this.tooltip.toggleClass(CLASS_DISABLED, state)
			.attr('aria-disabled', state);
	}

	this.disabled = !!state;

	return this;
};

PROTOTYPE.enable = function() { return this.disable(FALSE); };
;PROTOTYPE._createButton = function()
{
	var self = this,
		elements = this.elements,
		tooltip = elements.tooltip,
		button = this.options.content.button,
		isString = typeof button === 'string',
		close = isString ? button : 'Close tooltip';

	if(elements.button) { elements.button.remove(); }

	// Use custom button if one was supplied by user, else use default
	if(button.jquery) {
		elements.button = button;
	}
	else {
		elements.button = $('<a />', {
			'class': 'qtip-close ' + (this.options.style.widget ? '' : NAMESPACE+'-icon'),
			'title': close,
			'aria-label': close
		})
		.prepend(
			$('<span />', {
				'class': 'ui-icon ui-icon-close',
				'html': '&times;'
			})
		);
	}

	// Create button and setup attributes
	elements.button.appendTo(elements.titlebar || tooltip)
		.attr('role', 'button')
		.click(function(event) {
			if(!tooltip.hasClass(CLASS_DISABLED)) { self.hide(event); }
			return FALSE;
		});
};

PROTOTYPE._updateButton = function(button)
{
	// Make sure tooltip is rendered and if not, return
	if(!this.rendered) { return FALSE; }

	var elem = this.elements.button;
	if(button) { this._createButton(); }
	else { elem.remove(); }
};
;// Widget class creator
function createWidgetClass(cls) {
	return WIDGET.concat('').join(cls ? '-'+cls+' ' : ' ');
}

// Widget class setter method
PROTOTYPE._setWidget = function()
{
	var on = this.options.style.widget,
		elements = this.elements,
		tooltip = elements.tooltip,
		disabled = tooltip.hasClass(CLASS_DISABLED);

	tooltip.removeClass(CLASS_DISABLED);
	CLASS_DISABLED = on ? 'ui-state-disabled' : 'qtip-disabled';
	tooltip.toggleClass(CLASS_DISABLED, disabled);

	tooltip.toggleClass('ui-helper-reset '+createWidgetClass(), on).toggleClass(CLASS_DEFAULT, this.options.style.def && !on);

	if(elements.content) {
		elements.content.toggleClass( createWidgetClass('content'), on);
	}
	if(elements.titlebar) {
		elements.titlebar.toggleClass( createWidgetClass('header'), on);
	}
	if(elements.button) {
		elements.button.toggleClass(NAMESPACE+'-icon', !on);
	}
};
;function delay(callback, duration) {
	// If tooltip has displayed, start hide timer
	if(duration > 0) {
		return setTimeout(
			$.proxy(callback, this), duration
		);
	}
	else{ callback.call(this); }
}

function showMethod(event) {
	if(this.tooltip.hasClass(CLASS_DISABLED)) { return; }

	// Clear hide timers
	clearTimeout(this.timers.show);
	clearTimeout(this.timers.hide);

	// Start show timer
	this.timers.show = delay.call(this,
		function() { this.toggle(TRUE, event); },
		this.options.show.delay
	);
}

function hideMethod(event) {
	if(this.tooltip.hasClass(CLASS_DISABLED) || this.destroyed) { return; }

	// Check if new target was actually the tooltip element
	var relatedTarget = $(event.relatedTarget),
		ontoTooltip = relatedTarget.closest(SELECTOR)[0] === this.tooltip[0],
		ontoTarget = relatedTarget[0] === this.options.show.target[0];

	// Clear timers and stop animation queue
	clearTimeout(this.timers.show);
	clearTimeout(this.timers.hide);

	// Prevent hiding if tooltip is fixed and event target is the tooltip.
	// Or if mouse positioning is enabled and cursor momentarily overlaps
	if(this !== relatedTarget[0] &&
		(this.options.position.target === 'mouse' && ontoTooltip) ||
		this.options.hide.fixed && (
			(/mouse(out|leave|move)/).test(event.type) && (ontoTooltip || ontoTarget))
		)
	{
		/* eslint-disable no-empty */
		try {
			event.preventDefault();
			event.stopImmediatePropagation();
		} catch(e) {}
		/* eslint-enable no-empty */

		return;
	}

	// If tooltip has displayed, start hide timer
	this.timers.hide = delay.call(this,
		function() { this.toggle(FALSE, event); },
		this.options.hide.delay,
		this
	);
}

function inactiveMethod(event) {
	if(this.tooltip.hasClass(CLASS_DISABLED) || !this.options.hide.inactive) { return; }

	// Clear timer
	clearTimeout(this.timers.inactive);

	this.timers.inactive = delay.call(this,
		function(){ this.hide(event); },
		this.options.hide.inactive
	);
}

function repositionMethod(event) {
	if(this.rendered && this.tooltip[0].offsetWidth > 0) { this.reposition(event); }
}

// Store mouse coordinates
PROTOTYPE._storeMouse = function(event) {
	(this.mouse = $.event.fix(event)).type = 'mousemove';
	return this;
};

// Bind events
PROTOTYPE._bind = function(targets, events, method, suffix, context) {
	if(!targets || !method || !events.length) { return; }
	var ns = '.' + this._id + (suffix ? '-'+suffix : '');
	$(targets).bind(
		(events.split ? events : events.join(ns + ' ')) + ns,
		$.proxy(method, context || this)
	);
	return this;
};
PROTOTYPE._unbind = function(targets, suffix) {
	targets && $(targets).unbind('.' + this._id + (suffix ? '-'+suffix : ''));
	return this;
};

// Global delegation helper
function delegate(selector, events, method) {
	$(document.body).delegate(selector,
		(events.split ? events : events.join('.'+NAMESPACE + ' ')) + '.'+NAMESPACE,
		function() {
			var api = QTIP.api[ $.attr(this, ATTR_ID) ];
			api && !api.disabled && method.apply(api, arguments);
		}
	);
}
// Event trigger
PROTOTYPE._trigger = function(type, args, event) {
	var callback = new $.Event('tooltip'+type);
	callback.originalEvent = event && $.extend({}, event) || this.cache.event || NULL;

	this.triggering = type;
	this.tooltip.trigger(callback, [this].concat(args || []));
	this.triggering = FALSE;

	return !callback.isDefaultPrevented();
};

PROTOTYPE._bindEvents = function(showEvents, hideEvents, showTargets, hideTargets, showCallback, hideCallback) {
	// Get tasrgets that lye within both
	var similarTargets = showTargets.filter( hideTargets ).add( hideTargets.filter(showTargets) ),
		toggleEvents = [];

	// If hide and show targets are the same...
	if(similarTargets.length) {

		// Filter identical show/hide events
		$.each(hideEvents, function(i, type) {
			var showIndex = $.inArray(type, showEvents);

			// Both events are identical, remove from both hide and show events
			// and append to toggleEvents
			showIndex > -1 && toggleEvents.push( showEvents.splice( showIndex, 1 )[0] );
		});

		// Toggle events are special case of identical show/hide events, which happen in sequence
		if(toggleEvents.length) {
			// Bind toggle events to the similar targets
			this._bind(similarTargets, toggleEvents, function(event) {
				var state = this.rendered ? this.tooltip[0].offsetWidth > 0 : false;
				(state ? hideCallback : showCallback).call(this, event);
			});

			// Remove the similar targets from the regular show/hide bindings
			showTargets = showTargets.not(similarTargets);
			hideTargets = hideTargets.not(similarTargets);
		}
	}

	// Apply show/hide/toggle events
	this._bind(showTargets, showEvents, showCallback);
	this._bind(hideTargets, hideEvents, hideCallback);
};

PROTOTYPE._assignInitialEvents = function(event) {
	var options = this.options,
		showTarget = options.show.target,
		hideTarget = options.hide.target,
		showEvents = options.show.event ? $.trim('' + options.show.event).split(' ') : [],
		hideEvents = options.hide.event ? $.trim('' + options.hide.event).split(' ') : [];

	// Catch remove/removeqtip events on target element to destroy redundant tooltips
	this._bind(this.elements.target, ['remove', 'removeqtip'], function() {
		this.destroy(true);
	}, 'destroy');

	/*
	 * Make sure hoverIntent functions properly by using mouseleave as a hide event if
	 * mouseenter/mouseout is used for show.event, even if it isn't in the users options.
	 */
	if(/mouse(over|enter)/i.test(options.show.event) && !/mouse(out|leave)/i.test(options.hide.event)) {
		hideEvents.push('mouseleave');
	}

	/*
	 * Also make sure initial mouse targetting works correctly by caching mousemove coords
	 * on show targets before the tooltip has rendered. Also set onTarget when triggered to
	 * keep mouse tracking working.
	 */
	this._bind(showTarget, 'mousemove', function(moveEvent) {
		this._storeMouse(moveEvent);
		this.cache.onTarget = TRUE;
	});

	// Define hoverIntent function
	function hoverIntent(hoverEvent) {
		// Only continue if tooltip isn't disabled
		if(this.disabled || this.destroyed) { return FALSE; }

		// Cache the event data
		this.cache.event = hoverEvent && $.event.fix(hoverEvent);
		this.cache.target = hoverEvent && $(hoverEvent.target);

		// Start the event sequence
		clearTimeout(this.timers.show);
		this.timers.show = delay.call(this,
			function() { this.render(typeof hoverEvent === 'object' || options.show.ready); },
			options.prerender ? 0 : options.show.delay
		);
	}

	// Filter and bind events
	this._bindEvents(showEvents, hideEvents, showTarget, hideTarget, hoverIntent, function() {
		if(!this.timers) { return FALSE; }
		clearTimeout(this.timers.show);
	});

	// Prerendering is enabled, create tooltip now
	if(options.show.ready || options.prerender) { hoverIntent.call(this, event); }
};

// Event assignment method
PROTOTYPE._assignEvents = function() {
	var self = this,
		options = this.options,
		posOptions = options.position,

		tooltip = this.tooltip,
		showTarget = options.show.target,
		hideTarget = options.hide.target,
		containerTarget = posOptions.container,
		viewportTarget = posOptions.viewport,
		documentTarget = $(document),
		windowTarget = $(window),

		showEvents = options.show.event ? $.trim('' + options.show.event).split(' ') : [],
		hideEvents = options.hide.event ? $.trim('' + options.hide.event).split(' ') : [];


	// Assign passed event callbacks
	$.each(options.events, function(name, callback) {
		self._bind(tooltip, name === 'toggle' ? ['tooltipshow','tooltiphide'] : ['tooltip'+name], callback, null, tooltip);
	});

	// Hide tooltips when leaving current window/frame (but not select/option elements)
	if(/mouse(out|leave)/i.test(options.hide.event) && options.hide.leave === 'window') {
		this._bind(documentTarget, ['mouseout', 'blur'], function(event) {
			if(!/select|option/.test(event.target.nodeName) && !event.relatedTarget) {
				this.hide(event);
			}
		});
	}

	// Enable hide.fixed by adding appropriate class
	if(options.hide.fixed) {
		hideTarget = hideTarget.add( tooltip.addClass(CLASS_FIXED) );
	}

	/*
	 * Make sure hoverIntent functions properly by using mouseleave to clear show timer if
	 * mouseenter/mouseout is used for show.event, even if it isn't in the users options.
	 */
	else if(/mouse(over|enter)/i.test(options.show.event)) {
		this._bind(hideTarget, 'mouseleave', function() {
			clearTimeout(this.timers.show);
		});
	}

	// Hide tooltip on document mousedown if unfocus events are enabled
	if(('' + options.hide.event).indexOf('unfocus') > -1) {
		this._bind(containerTarget.closest('html'), ['mousedown', 'touchstart'], function(event) {
			var elem = $(event.target),
				enabled = this.rendered && !this.tooltip.hasClass(CLASS_DISABLED) && this.tooltip[0].offsetWidth > 0,
				isAncestor = elem.parents(SELECTOR).filter(this.tooltip[0]).length > 0;

			if(elem[0] !== this.target[0] && elem[0] !== this.tooltip[0] && !isAncestor &&
				!this.target.has(elem[0]).length && enabled
			) {
				this.hide(event);
			}
		});
	}

	// Check if the tooltip hides when inactive
	if('number' === typeof options.hide.inactive) {
		// Bind inactive method to show target(s) as a custom event
		this._bind(showTarget, 'qtip-'+this.id+'-inactive', inactiveMethod, 'inactive');

		// Define events which reset the 'inactive' event handler
		this._bind(hideTarget.add(tooltip), QTIP.inactiveEvents, inactiveMethod);
	}

	// Filter and bind events
	this._bindEvents(showEvents, hideEvents, showTarget, hideTarget, showMethod, hideMethod);

	// Mouse movement bindings
	this._bind(showTarget.add(tooltip), 'mousemove', function(event) {
		// Check if the tooltip hides when mouse is moved a certain distance
		if('number' === typeof options.hide.distance) {
			var origin = this.cache.origin || {},
				limit = this.options.hide.distance,
				abs = Math.abs;

			// Check if the movement has gone beyond the limit, and hide it if so
			if(abs(event.pageX - origin.pageX) >= limit || abs(event.pageY - origin.pageY) >= limit) {
				this.hide(event);
			}
		}

		// Cache mousemove coords on show targets
		this._storeMouse(event);
	});

	// Mouse positioning events
	if(posOptions.target === 'mouse') {
		// If mouse adjustment is on...
		if(posOptions.adjust.mouse) {
			// Apply a mouseleave event so we don't get problems with overlapping
			if(options.hide.event) {
				// Track if we're on the target or not
				this._bind(showTarget, ['mouseenter', 'mouseleave'], function(event) {
					if(!this.cache) {return FALSE; }
					this.cache.onTarget = event.type === 'mouseenter';
				});
			}

			// Update tooltip position on mousemove
			this._bind(documentTarget, 'mousemove', function(event) {
				// Update the tooltip position only if the tooltip is visible and adjustment is enabled
				if(this.rendered && this.cache.onTarget && !this.tooltip.hasClass(CLASS_DISABLED) && this.tooltip[0].offsetWidth > 0) {
					this.reposition(event);
				}
			});
		}
	}

	// Adjust positions of the tooltip on window resize if enabled
	if(posOptions.adjust.resize || viewportTarget.length) {
		this._bind( $.event.special.resize ? viewportTarget : windowTarget, 'resize', repositionMethod );
	}

	// Adjust tooltip position on scroll of the window or viewport element if present
	if(posOptions.adjust.scroll) {
		this._bind( windowTarget.add(posOptions.container), 'scroll', repositionMethod );
	}
};

// Un-assignment method
PROTOTYPE._unassignEvents = function() {
	var options = this.options,
		showTargets = options.show.target,
		hideTargets = options.hide.target,
		targets = $.grep([
			this.elements.target[0],
			this.rendered && this.tooltip[0],
			options.position.container[0],
			options.position.viewport[0],
			options.position.container.closest('html')[0], // unfocus
			window,
			document
		], function(i) {
			return typeof i === 'object';
		});

	// Add show and hide targets if they're valid
	if(showTargets && showTargets.toArray) {
		targets = targets.concat(showTargets.toArray());
	}
	if(hideTargets && hideTargets.toArray) {
		targets = targets.concat(hideTargets.toArray());
	}

	// Unbind the events
	this._unbind(targets)
		._unbind(targets, 'destroy')
		._unbind(targets, 'inactive');
};

// Apply common event handlers using delegate (avoids excessive .bind calls!)
$(function() {
	delegate(SELECTOR, ['mouseenter', 'mouseleave'], function(event) {
		var state = event.type === 'mouseenter',
			tooltip = $(event.currentTarget),
			target = $(event.relatedTarget || event.target),
			options = this.options;

		// On mouseenter...
		if(state) {
			// Focus the tooltip on mouseenter (z-index stacking)
			this.focus(event);

			// Clear hide timer on tooltip hover to prevent it from closing
			tooltip.hasClass(CLASS_FIXED) && !tooltip.hasClass(CLASS_DISABLED) && clearTimeout(this.timers.hide);
		}

		// On mouseleave...
		else {
			// When mouse tracking is enabled, hide when we leave the tooltip and not onto the show target (if a hide event is set)
			if(options.position.target === 'mouse' && options.position.adjust.mouse &&
				options.hide.event && options.show.target && !target.closest(options.show.target[0]).length) {
				this.hide(event);
			}
		}

		// Add hover class
		tooltip.toggleClass(CLASS_HOVER, state);
	});

	// Define events which reset the 'inactive' event handler
	delegate('['+ATTR_ID+']', INACTIVE_EVENTS, inactiveMethod);
});
;// Initialization method
function init(elem, id, opts) {
	var obj, posOptions, attr, config, title,

	// Setup element references
	docBody = $(document.body),

	// Use document body instead of document element if needed
	newTarget = elem[0] === document ? docBody : elem,

	// Grab metadata from element if plugin is present
	metadata = elem.metadata ? elem.metadata(opts.metadata) : NULL,

	// If metadata type if HTML5, grab 'name' from the object instead, or use the regular data object otherwise
	metadata5 = opts.metadata.type === 'html5' && metadata ? metadata[opts.metadata.name] : NULL,

	// Grab data from metadata.name (or data-qtipopts as fallback) using .data() method,
	html5 = elem.data(opts.metadata.name || 'qtipopts');

	// If we don't get an object returned attempt to parse it manualyl without parseJSON
	/* eslint-disable no-empty */
	try { html5 = typeof html5 === 'string' ? $.parseJSON(html5) : html5; }
	catch(e) {}
	/* eslint-enable no-empty */

	// Merge in and sanitize metadata
	config = $.extend(TRUE, {}, QTIP.defaults, opts,
		typeof html5 === 'object' ? sanitizeOptions(html5) : NULL,
		sanitizeOptions(metadata5 || metadata));

	// Re-grab our positioning options now we've merged our metadata and set id to passed value
	posOptions = config.position;
	config.id = id;

	// Setup missing content if none is detected
	if('boolean' === typeof config.content.text) {
		attr = elem.attr(config.content.attr);

		// Grab from supplied attribute if available
		if(config.content.attr !== FALSE && attr) { config.content.text = attr; }

		// No valid content was found, abort render
		else { return FALSE; }
	}

	// Setup target options
	if(!posOptions.container.length) { posOptions.container = docBody; }
	if(posOptions.target === FALSE) { posOptions.target = newTarget; }
	if(config.show.target === FALSE) { config.show.target = newTarget; }
	if(config.show.solo === TRUE) { config.show.solo = posOptions.container.closest('body'); }
	if(config.hide.target === FALSE) { config.hide.target = newTarget; }
	if(config.position.viewport === TRUE) { config.position.viewport = posOptions.container; }

	// Ensure we only use a single container
	posOptions.container = posOptions.container.eq(0);

	// Convert position corner values into x and y strings
	posOptions.at = new CORNER(posOptions.at, TRUE);
	posOptions.my = new CORNER(posOptions.my);

	// Destroy previous tooltip if overwrite is enabled, or skip element if not
	if(elem.data(NAMESPACE)) {
		if(config.overwrite) {
			elem.qtip('destroy', true);
		}
		else if(config.overwrite === FALSE) {
			return FALSE;
		}
	}

	// Add has-qtip attribute
	elem.attr(ATTR_HAS, id);

	// Remove title attribute and store it if present
	if(config.suppress && (title = elem.attr('title'))) {
		// Final attr call fixes event delegatiom and IE default tooltip showing problem
		elem.removeAttr('title').attr(oldtitle, title).attr('title', '');
	}

	// Initialize the tooltip and add API reference
	obj = new QTip(elem, config, id, !!attr);
	elem.data(NAMESPACE, obj);

	return obj;
}

// jQuery $.fn extension method
QTIP = $.fn.qtip = function(options, notation, newValue)
{
	var command = ('' + options).toLowerCase(), // Parse command
		returned = NULL,
		args = $.makeArray(arguments).slice(1),
		event = args[args.length - 1],
		opts = this[0] ? $.data(this[0], NAMESPACE) : NULL;

	// Check for API request
	if(!arguments.length && opts || command === 'api') {
		return opts;
	}

	// Execute API command if present
	else if('string' === typeof options) {
		this.each(function() {
			var api = $.data(this, NAMESPACE);
			if(!api) { return TRUE; }

			// Cache the event if possible
			if(event && event.timeStamp) { api.cache.event = event; }

			// Check for specific API commands
			if(notation && (command === 'option' || command === 'options')) {
				if(newValue !== undefined || $.isPlainObject(notation)) {
					api.set(notation, newValue);
				}
				else {
					returned = api.get(notation);
					return FALSE;
				}
			}

			// Execute API command
			else if(api[command]) {
				api[command].apply(api, args);
			}
		});

		return returned !== NULL ? returned : this;
	}

	// No API commands. validate provided options and setup qTips
	else if('object' === typeof options || !arguments.length) {
		// Sanitize options first
		opts = sanitizeOptions($.extend(TRUE, {}, options));

		return this.each(function(i) {
			var api, id;

			// Find next available ID, or use custom ID if provided
			id = $.isArray(opts.id) ? opts.id[i] : opts.id;
			id = !id || id === FALSE || id.length < 1 || QTIP.api[id] ? QTIP.nextid++ : id;

			// Initialize the qTip and re-grab newly sanitized options
			api = init($(this), id, opts);
			if(api === FALSE) { return TRUE; }
			else { QTIP.api[id] = api; }

			// Initialize plugins
			$.each(PLUGINS, function() {
				if(this.initialize === 'initialize') { this(api); }
			});

			// Assign initial pre-render events
			api._assignInitialEvents(event);
		});
	}
};

// Expose class
$.qtip = QTip;

// Populated in render method
QTIP.api = {};
;$.each({
	/* Allow other plugins to successfully retrieve the title of an element with a qTip applied */
	attr: function(attr, val) {
		if(this.length) {
			var self = this[0],
				title = 'title',
				api = $.data(self, 'qtip');

			if(attr === title && api && api.options && 'object' === typeof api && 'object' === typeof api.options && api.options.suppress) {
				if(arguments.length < 2) {
					return $.attr(self, oldtitle);
				}

				// If qTip is rendered and title was originally used as content, update it
				if(api && api.options.content.attr === title && api.cache.attr) {
					api.set('content.text', val);
				}

				// Use the regular attr method to set, then cache the result
				return this.attr(oldtitle, val);
			}
		}

		return $.fn['attr'+replaceSuffix].apply(this, arguments);
	},

	/* Allow clone to correctly retrieve cached title attributes */
	clone: function(keepData) {
		// Clone our element using the real clone method
		var elems = $.fn['clone'+replaceSuffix].apply(this, arguments);

		// Grab all elements with an oldtitle set, and change it to regular title attribute, if keepData is false
		if(!keepData) {
			elems.filter('['+oldtitle+']').attr('title', function() {
				return $.attr(this, oldtitle);
			})
			.removeAttr(oldtitle);
		}

		return elems;
	}
}, function(name, func) {
	if(!func || $.fn[name+replaceSuffix]) { return TRUE; }

	var old = $.fn[name+replaceSuffix] = $.fn[name];
	$.fn[name] = function() {
		return func.apply(this, arguments) || old.apply(this, arguments);
	};
});

/* Fire off 'removeqtip' handler in $.cleanData if jQuery UI not present (it already does similar).
 * This snippet is taken directly from jQuery UI source code found here:
 *     http://code.jquery.com/ui/jquery-ui-git.js
 */
if(!$.ui) {
	$['cleanData'+replaceSuffix] = $.cleanData;
	$.cleanData = function( elems ) {
		for(var i = 0, elem; (elem = $( elems[i] )).length; i++) {
			if(elem.attr(ATTR_HAS)) {
				/* eslint-disable no-empty */
				try { elem.triggerHandler('removeqtip'); }
				catch( e ) {}
				/* eslint-enable no-empty */
			}
		}
		$['cleanData'+replaceSuffix].apply(this, arguments);
	};
}
;// qTip version
QTIP.version = '3.0.3';

// Base ID for all qTips
QTIP.nextid = 0;

// Inactive events array
QTIP.inactiveEvents = INACTIVE_EVENTS;

// Base z-index for all qTips
QTIP.zindex = 15000;

// Define configuration defaults
QTIP.defaults = {
	prerender: FALSE,
	id: FALSE,
	overwrite: TRUE,
	suppress: TRUE,
	content: {
		text: TRUE,
		attr: 'title',
		title: FALSE,
		button: FALSE
	},
	position: {
		my: 'top left',
		at: 'bottom right',
		target: FALSE,
		container: FALSE,
		viewport: FALSE,
		adjust: {
			x: 0, y: 0,
			mouse: TRUE,
			scroll: TRUE,
			resize: TRUE,
			method: 'flipinvert flipinvert'
		},
		effect: function(api, pos) {
			$(this).animate(pos, {
				duration: 200,
				queue: FALSE
			});
		}
	},
	show: {
		target: FALSE,
		event: 'mouseenter',
		effect: TRUE,
		delay: 90,
		solo: FALSE,
		ready: FALSE,
		autofocus: FALSE
	},
	hide: {
		target: FALSE,
		event: 'mouseleave',
		effect: TRUE,
		delay: 0,
		fixed: FALSE,
		inactive: FALSE,
		leave: 'window',
		distance: FALSE
	},
	style: {
		classes: '',
		widget: FALSE,
		width: FALSE,
		height: FALSE,
		def: TRUE
	},
	events: {
		render: NULL,
		move: NULL,
		show: NULL,
		hide: NULL,
		toggle: NULL,
		visible: NULL,
		hidden: NULL,
		focus: NULL,
		blur: NULL
	}
};
;var TIP,
createVML,
SCALE,
PIXEL_RATIO,
BACKING_STORE_RATIO,

// Common CSS strings
MARGIN = 'margin',
BORDER = 'border',
COLOR = 'color',
BG_COLOR = 'background-color',
TRANSPARENT = 'transparent',
IMPORTANT = ' !important',

// Check if the browser supports <canvas/> elements
HASCANVAS = !!document.createElement('canvas').getContext,

// Invalid colour values used in parseColours()
INVALID = /rgba?\(0, 0, 0(, 0)?\)|transparent|#123456/i;

// Camel-case method, taken from jQuery source
// http://code.jquery.com/jquery-1.8.0.js
function camel(s) { return s.charAt(0).toUpperCase() + s.slice(1); }

/*
 * Modified from Modernizr's testPropsAll()
 * http://modernizr.com/downloads/modernizr-latest.js
 */
var cssProps = {}, cssPrefixes = ['Webkit', 'O', 'Moz', 'ms'];
function vendorCss(elem, prop) {
	var ucProp = prop.charAt(0).toUpperCase() + prop.slice(1),
		props = (prop + ' ' + cssPrefixes.join(ucProp + ' ') + ucProp).split(' '),
		cur, val, i = 0;

	// If the property has already been mapped...
	if(cssProps[prop]) { return elem.css(cssProps[prop]); }

	while(cur = props[i++]) {
		if((val = elem.css(cur)) !== undefined) {
			cssProps[prop] = cur;
			return val;
		}
	}
}

// Parse a given elements CSS property into an int
function intCss(elem, prop) {
	return Math.ceil(parseFloat(vendorCss(elem, prop)));
}


// VML creation (for IE only)
if(!HASCANVAS) {
	createVML = function(tag, props, style) {
		return '<qtipvml:'+tag+' xmlns="urn:schemas-microsoft.com:vml" class="qtip-vml" '+(props||'')+
			' style="behavior: url(#default#VML); '+(style||'')+ '" />';
	};
}

// Canvas only definitions
else {
	PIXEL_RATIO = window.devicePixelRatio || 1;
	BACKING_STORE_RATIO = (function() {
		var context = document.createElement('canvas').getContext('2d');
		return context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio ||
				context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || 1;
	})();
	SCALE = PIXEL_RATIO / BACKING_STORE_RATIO;
}


function Tip(qtip, options) {
	this._ns = 'tip';
	this.options = options;
	this.offset = options.offset;
	this.size = [ options.width, options.height ];

	// Initialize
	this.qtip = qtip;
	this.init(qtip);
}

$.extend(Tip.prototype, {
	init: function(qtip) {
		var context, tip;

		// Create tip element and prepend to the tooltip
		tip = this.element = qtip.elements.tip = $('<div />', { 'class': NAMESPACE+'-tip' }).prependTo(qtip.tooltip);

		// Create tip drawing element(s)
		if(HASCANVAS) {
			// save() as soon as we create the canvas element so FF2 doesn't bork on our first restore()!
			context = $('<canvas />').appendTo(this.element)[0].getContext('2d');

			// Setup constant parameters
			context.lineJoin = 'miter';
			context.miterLimit = 100000;
			context.save();
		}
		else {
			context = createVML('shape', 'coordorigin="0,0"', 'position:absolute;');
			this.element.html(context + context);

			// Prevent mousing down on the tip since it causes problems with .live() handling in IE due to VML
			qtip._bind( $('*', tip).add(tip), ['click', 'mousedown'], function(event) { event.stopPropagation(); }, this._ns);
		}

		// Bind update events
		qtip._bind(qtip.tooltip, 'tooltipmove', this.reposition, this._ns, this);

		// Create it
		this.create();
	},

	_swapDimensions: function() {
		this.size[0] = this.options.height;
		this.size[1] = this.options.width;
	},
	_resetDimensions: function() {
		this.size[0] = this.options.width;
		this.size[1] = this.options.height;
	},

	_useTitle: function(corner) {
		var titlebar = this.qtip.elements.titlebar;
		return titlebar && (
			corner.y === TOP || corner.y === CENTER && this.element.position().top + this.size[1] / 2 + this.options.offset < titlebar.outerHeight(TRUE)
		);
	},

	_parseCorner: function(corner) {
		var my = this.qtip.options.position.my;

		// Detect corner and mimic properties
		if(corner === FALSE || my === FALSE) {
			corner = FALSE;
		}
		else if(corner === TRUE) {
			corner = new CORNER( my.string() );
		}
		else if(!corner.string) {
			corner = new CORNER(corner);
			corner.fixed = TRUE;
		}

		return corner;
	},

	_parseWidth: function(corner, side, use) {
		var elements = this.qtip.elements,
			prop = BORDER + camel(side) + 'Width';

		return (use ? intCss(use, prop) : 
			intCss(elements.content, prop) ||
			intCss(this._useTitle(corner) && elements.titlebar || elements.content, prop) ||
			intCss(elements.tooltip, prop)
		) || 0;
	},

	_parseRadius: function(corner) {
		var elements = this.qtip.elements,
			prop = BORDER + camel(corner.y) + camel(corner.x) + 'Radius';

		return BROWSER.ie < 9 ? 0 :
			intCss(this._useTitle(corner) && elements.titlebar || elements.content, prop) ||
			intCss(elements.tooltip, prop) || 0;
	},

	_invalidColour: function(elem, prop, compare) {
		var val = elem.css(prop);
		return !val || compare && val === elem.css(compare) || INVALID.test(val) ? FALSE : val;
	},

	_parseColours: function(corner) {
		var elements = this.qtip.elements,
			tip = this.element.css('cssText', ''),
			borderSide = BORDER + camel(corner[ corner.precedance ]) + camel(COLOR),
			colorElem = this._useTitle(corner) && elements.titlebar || elements.content,
			css = this._invalidColour, color = [];

		// Attempt to detect the background colour from various elements, left-to-right precedance
		color[0] = css(tip, BG_COLOR) || css(colorElem, BG_COLOR) || css(elements.content, BG_COLOR) ||
			css(elements.tooltip, BG_COLOR) || tip.css(BG_COLOR);

		// Attempt to detect the correct border side colour from various elements, left-to-right precedance
		color[1] = css(tip, borderSide, COLOR) || css(colorElem, borderSide, COLOR) ||
			css(elements.content, borderSide, COLOR) || css(elements.tooltip, borderSide, COLOR) || elements.tooltip.css(borderSide);

		// Reset background and border colours
		$('*', tip).add(tip).css('cssText', BG_COLOR+':'+TRANSPARENT+IMPORTANT+';'+BORDER+':0'+IMPORTANT+';');

		return color;
	},

	_calculateSize: function(corner) {
		var y = corner.precedance === Y,
			width = this.options.width,
			height = this.options.height,
			isCenter = corner.abbrev() === 'c',
			base = (y ? width: height) * (isCenter ? 0.5 : 1),
			pow = Math.pow,
			round = Math.round,
			bigHyp, ratio, result,

		smallHyp = Math.sqrt( pow(base, 2) + pow(height, 2) ),
		hyp = [
			this.border / base * smallHyp,
			this.border / height * smallHyp
		];

		hyp[2] = Math.sqrt( pow(hyp[0], 2) - pow(this.border, 2) );
		hyp[3] = Math.sqrt( pow(hyp[1], 2) - pow(this.border, 2) );

		bigHyp = smallHyp + hyp[2] + hyp[3] + (isCenter ? 0 : hyp[0]);
		ratio = bigHyp / smallHyp;

		result = [ round(ratio * width), round(ratio * height) ];
		return y ? result : result.reverse();
	},

	// Tip coordinates calculator
	_calculateTip: function(corner, size, scale) {
		scale = scale || 1;
		size = size || this.size;

		var width = size[0] * scale,
			height = size[1] * scale,
			width2 = Math.ceil(width / 2), height2 = Math.ceil(height / 2),

		// Define tip coordinates in terms of height and width values
		tips = {
			br:	[0,0,		width,height,	width,0],
			bl:	[0,0,		width,0,		0,height],
			tr:	[0,height,	width,0,		width,height],
			tl:	[0,0,		0,height,		width,height],
			tc:	[0,height,	width2,0,		width,height],
			bc:	[0,0,		width,0,		width2,height],
			rc:	[0,0,		width,height2,	0,height],
			lc:	[width,0,	width,height,	0,height2]
		};

		// Set common side shapes
		tips.lt = tips.br; tips.rt = tips.bl;
		tips.lb = tips.tr; tips.rb = tips.tl;

		return tips[ corner.abbrev() ];
	},

	// Tip coordinates drawer (canvas)
	_drawCoords: function(context, coords) {
		context.beginPath();
		context.moveTo(coords[0], coords[1]);
		context.lineTo(coords[2], coords[3]);
		context.lineTo(coords[4], coords[5]);
		context.closePath();
	},

	create: function() {
		// Determine tip corner
		var c = this.corner = (HASCANVAS || BROWSER.ie) && this._parseCorner(this.options.corner);

		// If we have a tip corner...
		this.enabled = !!this.corner && this.corner.abbrev() !== 'c';
		if(this.enabled) {
			// Cache it
			this.qtip.cache.corner = c.clone();

			// Create it
			this.update();
		}

		// Toggle tip element
		this.element.toggle(this.enabled);

		return this.corner;
	},

	update: function(corner, position) {
		if(!this.enabled) { return this; }

		var elements = this.qtip.elements,
			tip = this.element,
			inner = tip.children(),
			options = this.options,
			curSize = this.size,
			mimic = options.mimic,
			round = Math.round,
			color, precedance, context,
			coords, bigCoords, translate, newSize, border;

		// Re-determine tip if not already set
		if(!corner) { corner = this.qtip.cache.corner || this.corner; }

		// Use corner property if we detect an invalid mimic value
		if(mimic === FALSE) { mimic = corner; }

		// Otherwise inherit mimic properties from the corner object as necessary
		else {
			mimic = new CORNER(mimic);
			mimic.precedance = corner.precedance;

			if(mimic.x === 'inherit') { mimic.x = corner.x; }
			else if(mimic.y === 'inherit') { mimic.y = corner.y; }
			else if(mimic.x === mimic.y) {
				mimic[ corner.precedance ] = corner[ corner.precedance ];
			}
		}
		precedance = mimic.precedance;

		// Ensure the tip width.height are relative to the tip position
		if(corner.precedance === X) { this._swapDimensions(); }
		else { this._resetDimensions(); }

		// Update our colours
		color = this.color = this._parseColours(corner);

		// Detect border width, taking into account colours
		if(color[1] !== TRANSPARENT) {
			// Grab border width
			border = this.border = this._parseWidth(corner, corner[corner.precedance]);

			// If border width isn't zero, use border color as fill if it's not invalid (1.0 style tips)
			if(options.border && border < 1 && !INVALID.test(color[1])) { color[0] = color[1]; }

			// Set border width (use detected border width if options.border is true)
			this.border = border = options.border !== TRUE ? options.border : border;
		}

		// Border colour was invalid, set border to zero
		else { this.border = border = 0; }

		// Determine tip size
		newSize = this.size = this._calculateSize(corner);
		tip.css({
			width: newSize[0],
			height: newSize[1],
			lineHeight: newSize[1]+'px'
		});

		// Calculate tip translation
		if(corner.precedance === Y) {
			translate = [
				round(mimic.x === LEFT ? border : mimic.x === RIGHT ? newSize[0] - curSize[0] - border : (newSize[0] - curSize[0]) / 2),
				round(mimic.y === TOP ? newSize[1] - curSize[1] : 0)
			];
		}
		else {
			translate = [
				round(mimic.x === LEFT ? newSize[0] - curSize[0] : 0),
				round(mimic.y === TOP ? border : mimic.y === BOTTOM ? newSize[1] - curSize[1] - border : (newSize[1] - curSize[1]) / 2)
			];
		}

		// Canvas drawing implementation
		if(HASCANVAS) {
			// Grab canvas context and clear/save it
			context = inner[0].getContext('2d');
			context.restore(); context.save();
			context.clearRect(0,0,6000,6000);

			// Calculate coordinates
			coords = this._calculateTip(mimic, curSize, SCALE);
			bigCoords = this._calculateTip(mimic, this.size, SCALE);

			// Set the canvas size using calculated size
			inner.attr(WIDTH, newSize[0] * SCALE).attr(HEIGHT, newSize[1] * SCALE);
			inner.css(WIDTH, newSize[0]).css(HEIGHT, newSize[1]);

			// Draw the outer-stroke tip
			this._drawCoords(context, bigCoords);
			context.fillStyle = color[1];
			context.fill();

			// Draw the actual tip
			context.translate(translate[0] * SCALE, translate[1] * SCALE);
			this._drawCoords(context, coords);
			context.fillStyle = color[0];
			context.fill();
		}

		// VML (IE Proprietary implementation)
		else {
			// Calculate coordinates
			coords = this._calculateTip(mimic);

			// Setup coordinates string
			coords = 'm' + coords[0] + ',' + coords[1] + ' l' + coords[2] +
				',' + coords[3] + ' ' + coords[4] + ',' + coords[5] + ' xe';

			// Setup VML-specific offset for pixel-perfection
			translate[2] = border && /^(r|b)/i.test(corner.string()) ?
				BROWSER.ie === 8 ? 2 : 1 : 0;

			// Set initial CSS
			inner.css({
				coordsize: newSize[0]+border + ' ' + newSize[1]+border,
				antialias: ''+(mimic.string().indexOf(CENTER) > -1),
				left: translate[0] - translate[2] * Number(precedance === X),
				top: translate[1] - translate[2] * Number(precedance === Y),
				width: newSize[0] + border,
				height: newSize[1] + border
			})
			.each(function(i) {
				var $this = $(this);

				// Set shape specific attributes
				$this[ $this.prop ? 'prop' : 'attr' ]({
					coordsize: newSize[0]+border + ' ' + newSize[1]+border,
					path: coords,
					fillcolor: color[0],
					filled: !!i,
					stroked: !i
				})
				.toggle(!!(border || i));

				// Check if border is enabled and add stroke element
				!i && $this.html( createVML(
					'stroke', 'weight="'+border*2+'px" color="'+color[1]+'" miterlimit="1000" joinstyle="miter"'
				) );
			});
		}

		// Opera bug #357 - Incorrect tip position
		// https://github.com/Craga89/qTip2/issues/367
		window.opera && setTimeout(function() {
			elements.tip.css({
				display: 'inline-block',
				visibility: 'visible'
			});
		}, 1);

		// Position if needed
		if(position !== FALSE) { this.calculate(corner, newSize); }
	},

	calculate: function(corner, size) {
		if(!this.enabled) { return FALSE; }

		var self = this,
			elements = this.qtip.elements,
			tip = this.element,
			userOffset = this.options.offset,
			position = {},
			precedance, corners;

		// Inherit corner if not provided
		corner = corner || this.corner;
		precedance = corner.precedance;

		// Determine which tip dimension to use for adjustment
		size = size || this._calculateSize(corner);

		// Setup corners and offset array
		corners = [ corner.x, corner.y ];
		if(precedance === X) { corners.reverse(); }

		// Calculate tip position
		$.each(corners, function(i, side) {
			var b, bc, br;

			if(side === CENTER) {
				b = precedance === Y ? LEFT : TOP;
				position[ b ] = '50%';
				position[MARGIN+'-' + b] = -Math.round(size[ precedance === Y ? 0 : 1 ] / 2) + userOffset;
			}
			else {
				b = self._parseWidth(corner, side, elements.tooltip);
				bc = self._parseWidth(corner, side, elements.content);
				br = self._parseRadius(corner);

				position[ side ] = Math.max(-self.border, i ? bc : userOffset + (br > b ? br : -b));
			}
		});

		// Adjust for tip size
		position[ corner[precedance] ] -= size[ precedance === X ? 0 : 1 ];

		// Set and return new position
		tip.css({ margin: '', top: '', bottom: '', left: '', right: '' }).css(position);
		return position;
	},

	reposition: function(event, api, pos) {
		if(!this.enabled) { return; }

		var cache = api.cache,
			newCorner = this.corner.clone(),
			adjust = pos.adjusted,
			method = api.options.position.adjust.method.split(' '),
			horizontal = method[0],
			vertical = method[1] || method[0],
			shift = { left: FALSE, top: FALSE, x: 0, y: 0 },
			offset, css = {}, props;

		function shiftflip(direction, precedance, popposite, side, opposite) {
			// Horizontal - Shift or flip method
			if(direction === SHIFT && newCorner.precedance === precedance && adjust[side] && newCorner[popposite] !== CENTER) {
				newCorner.precedance = newCorner.precedance === X ? Y : X;
			}
			else if(direction !== SHIFT && adjust[side]){
				newCorner[precedance] = newCorner[precedance] === CENTER ?
					adjust[side] > 0 ? side : opposite :
					newCorner[precedance] === side ? opposite : side;
			}
		}

		function shiftonly(xy, side, opposite) {
			if(newCorner[xy] === CENTER) {
				css[MARGIN+'-'+side] = shift[xy] = offset[MARGIN+'-'+side] - adjust[side];
			}
			else {
				props = offset[opposite] !== undefined ?
					[ adjust[side], -offset[side] ] : [ -adjust[side], offset[side] ];

				if( (shift[xy] = Math.max(props[0], props[1])) > props[0] ) {
					pos[side] -= adjust[side];
					shift[side] = FALSE;
				}

				css[ offset[opposite] !== undefined ? opposite : side ] = shift[xy];
			}
		}

		// If our tip position isn't fixed e.g. doesn't adjust with viewport...
		if(this.corner.fixed !== TRUE) {
			// Perform shift/flip adjustments
			shiftflip(horizontal, X, Y, LEFT, RIGHT);
			shiftflip(vertical, Y, X, TOP, BOTTOM);

			// Update and redraw the tip if needed (check cached details of last drawn tip)
			if(newCorner.string() !== cache.corner.string() || cache.cornerTop !== adjust.top || cache.cornerLeft !== adjust.left) {
				this.update(newCorner, FALSE);
			}
		}

		// Setup tip offset properties
		offset = this.calculate(newCorner);

		// Readjust offset object to make it left/top
		if(offset.right !== undefined) { offset.left = -offset.right; }
		if(offset.bottom !== undefined) { offset.top = -offset.bottom; }
		offset.user = this.offset;

		// Perform shift adjustments
		shift.left = horizontal === SHIFT && !!adjust.left;
		if(shift.left) {
			shiftonly(X, LEFT, RIGHT);
		}
		shift.top = vertical === SHIFT && !!adjust.top;
		if(shift.top) {
			shiftonly(Y, TOP, BOTTOM);
		}

		/*
		* If the tip is adjusted in both dimensions, or in a
		* direction that would cause it to be anywhere but the
		* outer border, hide it!
		*/
		this.element.css(css).toggle(
			!(shift.x && shift.y || newCorner.x === CENTER && shift.y || newCorner.y === CENTER && shift.x)
		);

		// Adjust position to accomodate tip dimensions
		pos.left -= offset.left.charAt ? offset.user :
			horizontal !== SHIFT || shift.top || !shift.left && !shift.top ? offset.left + this.border : 0;
		pos.top -= offset.top.charAt ? offset.user :
			vertical !== SHIFT || shift.left || !shift.left && !shift.top ? offset.top + this.border : 0;

		// Cache details
		cache.cornerLeft = adjust.left; cache.cornerTop = adjust.top;
		cache.corner = newCorner.clone();
	},

	destroy: function() {
		// Unbind events
		this.qtip._unbind(this.qtip.tooltip, this._ns);

		// Remove the tip element(s)
		if(this.qtip.elements.tip) {
			this.qtip.elements.tip.find('*')
				.remove().end().remove();
		}
	}
});

TIP = PLUGINS.tip = function(api) {
	return new Tip(api, api.options.style.tip);
};

// Initialize tip on render
TIP.initialize = 'render';

// Setup plugin sanitization options
TIP.sanitize = function(options) {
	if(options.style && 'tip' in options.style) {
		var opts = options.style.tip;
		if(typeof opts !== 'object') { opts = options.style.tip = { corner: opts }; }
		if(!(/string|boolean/i).test(typeof opts.corner)) { opts.corner = TRUE; }
	}
};

// Add new option checks for the plugin
CHECKS.tip = {
	'^position.my|style.tip.(corner|mimic|border)$': function() {
		// Make sure a tip can be drawn
		this.create();

		// Reposition the tooltip
		this.qtip.reposition();
	},
	'^style.tip.(height|width)$': function(obj) {
		// Re-set dimensions and redraw the tip
		this.size = [ obj.width, obj.height ];
		this.update();

		// Reposition the tooltip
		this.qtip.reposition();
	},
	'^content.title|style.(classes|widget)$': function() {
		this.update();
	}
};

// Extend original qTip defaults
$.extend(TRUE, QTIP.defaults, {
	style: {
		tip: {
			corner: TRUE,
			mimic: FALSE,
			width: 6,
			height: 6,
			border: TRUE,
			offset: 0
		}
	}
});
;var MODAL, OVERLAY,
	MODALCLASS = 'qtip-modal',
	MODALSELECTOR = '.'+MODALCLASS;

OVERLAY = function()
{
	var self = this,
		focusableElems = {},
		current,
		prevState,
		elem;

	// Modified code from jQuery UI 1.10.0 source
	// http://code.jquery.com/ui/1.10.0/jquery-ui.js
	function focusable(element) {
		// Use the defined focusable checker when possible
		if($.expr[':'].focusable) { return $.expr[':'].focusable; }

		var isTabIndexNotNaN = !isNaN($.attr(element, 'tabindex')),
			nodeName = element.nodeName && element.nodeName.toLowerCase(),
			map, mapName, img;

		if('area' === nodeName) {
			map = element.parentNode;
			mapName = map.name;
			if(!element.href || !mapName || map.nodeName.toLowerCase() !== 'map') {
				return false;
			}
			img = $('img[usemap=#' + mapName + ']')[0];
			return !!img && img.is(':visible');
		}

		return /input|select|textarea|button|object/.test( nodeName ) ?
			!element.disabled :
			'a' === nodeName ?
				element.href || isTabIndexNotNaN :
				isTabIndexNotNaN
		;
	}

	// Focus inputs using cached focusable elements (see update())
	function focusInputs(blurElems) {
		// Blurring body element in IE causes window.open windows to unfocus!
		if(focusableElems.length < 1 && blurElems.length) { blurElems.not('body').blur(); }

		// Focus the inputs
		else { focusableElems.first().focus(); }
	}

	// Steal focus from elements outside tooltip
	function stealFocus(event) {
		if(!elem.is(':visible')) { return; }

		var target = $(event.target),
			tooltip = current.tooltip,
			container = target.closest(SELECTOR),
			targetOnTop;

		// Determine if input container target is above this
		targetOnTop = container.length < 1 ? FALSE :
			parseInt(container[0].style.zIndex, 10) > parseInt(tooltip[0].style.zIndex, 10);

		// If we're showing a modal, but focus has landed on an input below
		// this modal, divert focus to the first visible input in this modal
		// or if we can't find one... the tooltip itself
		if(!targetOnTop && target.closest(SELECTOR)[0] !== tooltip[0]) {
			focusInputs(target);
		}
	}

	$.extend(self, {
		init: function() {
			// Create document overlay
			elem = self.elem = $('<div />', {
				id: 'qtip-overlay',
				html: '<div></div>',
				mousedown: function() { return FALSE; }
			})
			.hide();

			// Make sure we can't focus anything outside the tooltip
			$(document.body).bind('focusin'+MODALSELECTOR, stealFocus);

			// Apply keyboard "Escape key" close handler
			$(document).bind('keydown'+MODALSELECTOR, function(event) {
				if(current && current.options.show.modal.escape && event.keyCode === 27) {
					current.hide(event);
				}
			});

			// Apply click handler for blur option
			elem.bind('click'+MODALSELECTOR, function(event) {
				if(current && current.options.show.modal.blur) {
					current.hide(event);
				}
			});

			return self;
		},

		update: function(api) {
			// Update current API reference
			current = api;

			// Update focusable elements if enabled
			if(api.options.show.modal.stealfocus !== FALSE) {
				focusableElems = api.tooltip.find('*').filter(function() {
					return focusable(this);
				});
			}
			else { focusableElems = []; }
		},

		toggle: function(api, state, duration) {
			var tooltip = api.tooltip,
				options = api.options.show.modal,
				effect = options.effect,
				type = state ? 'show': 'hide',
				visible = elem.is(':visible'),
				visibleModals = $(MODALSELECTOR).filter(':visible:not(:animated)').not(tooltip);

			// Set active tooltip API reference
			self.update(api);

			// If the modal can steal the focus...
			// Blur the current item and focus anything in the modal we an
			if(state && options.stealfocus !== FALSE) {
				focusInputs( $(':focus') );
			}

			// Toggle backdrop cursor style on show
			elem.toggleClass('blurs', options.blur);

			// Append to body on show
			if(state) {
				elem.appendTo(document.body);
			}

			// Prevent modal from conflicting with show.solo, and don't hide backdrop is other modals are visible
			if(elem.is(':animated') && visible === state && prevState !== FALSE || !state && visibleModals.length) {
				return self;
			}

			// Stop all animations
			elem.stop(TRUE, FALSE);

			// Use custom function if provided
			if($.isFunction(effect)) {
				effect.call(elem, state);
			}

			// If no effect type is supplied, use a simple toggle
			else if(effect === FALSE) {
				elem[ type ]();
			}

			// Use basic fade function
			else {
				elem.fadeTo( parseInt(duration, 10) || 90, state ? 1 : 0, function() {
					if(!state) { elem.hide(); }
				});
			}

			// Reset position and detach from body on hide
			if(!state) {
				elem.queue(function(next) {
					elem.css({ left: '', top: '' });
					if(!$(MODALSELECTOR).length) { elem.detach(); }
					next();
				});
			}

			// Cache the state
			prevState = state;

			// If the tooltip is destroyed, set reference to null
			if(current.destroyed) { current = NULL; }

			return self;
		}
	});

	self.init();
};
OVERLAY = new OVERLAY();

function Modal(api, options) {
	this.options = options;
	this._ns = '-modal';

	this.qtip = api;
	this.init(api);
}

$.extend(Modal.prototype, {
	init: function(qtip) {
		var tooltip = qtip.tooltip;

		// If modal is disabled... return
		if(!this.options.on) { return this; }

		// Set overlay reference
		qtip.elements.overlay = OVERLAY.elem;

		// Add unique attribute so we can grab modal tooltips easily via a SELECTOR, and set z-index
		tooltip.addClass(MODALCLASS).css('z-index', QTIP.modal_zindex + $(MODALSELECTOR).length);

		// Apply our show/hide/focus modal events
		qtip._bind(tooltip, ['tooltipshow', 'tooltiphide'], function(event, api, duration) {
			var oEvent = event.originalEvent;

			// Make sure mouseout doesn't trigger a hide when showing the modal and mousing onto backdrop
			if(event.target === tooltip[0]) {
				if(oEvent && event.type === 'tooltiphide' && /mouse(leave|enter)/.test(oEvent.type) && $(oEvent.relatedTarget).closest(OVERLAY.elem[0]).length) {
					/* eslint-disable no-empty */
					try { event.preventDefault(); }
					catch(e) {}
					/* eslint-enable no-empty */
				}
				else if(!oEvent || oEvent && oEvent.type !== 'tooltipsolo') {
					this.toggle(event, event.type === 'tooltipshow', duration);
				}
			}
		}, this._ns, this);

		// Adjust modal z-index on tooltip focus
		qtip._bind(tooltip, 'tooltipfocus', function(event, api) {
			// If focus was cancelled before it reached us, don't do anything
			if(event.isDefaultPrevented() || event.target !== tooltip[0]) { return; }

			var qtips = $(MODALSELECTOR),

			// Keep the modal's lower than other, regular qtips
			newIndex = QTIP.modal_zindex + qtips.length,
			curIndex = parseInt(tooltip[0].style.zIndex, 10);

			// Set overlay z-index
			OVERLAY.elem[0].style.zIndex = newIndex - 1;

			// Reduce modal z-index's and keep them properly ordered
			qtips.each(function() {
				if(this.style.zIndex > curIndex) {
					this.style.zIndex -= 1;
				}
			});

			// Fire blur event for focused tooltip
			qtips.filter('.' + CLASS_FOCUS).qtip('blur', event.originalEvent);

			// Set the new z-index
			tooltip.addClass(CLASS_FOCUS)[0].style.zIndex = newIndex;

			// Set current
			OVERLAY.update(api);

			// Prevent default handling
			/* eslint-disable no-empty */
			try { event.preventDefault(); }
			catch(e) {}
			/* eslint-enable no-empty */
		}, this._ns, this);

		// Focus any other visible modals when this one hides
		qtip._bind(tooltip, 'tooltiphide', function(event) {
			if(event.target === tooltip[0]) {
				$(MODALSELECTOR).filter(':visible').not(tooltip).last().qtip('focus', event);
			}
		}, this._ns, this);
	},

	toggle: function(event, state, duration) {
		// Make sure default event hasn't been prevented
		if(event && event.isDefaultPrevented()) { return this; }

		// Toggle it
		OVERLAY.toggle(this.qtip, !!state, duration);
	},

	destroy: function() {
		// Remove modal class
		this.qtip.tooltip.removeClass(MODALCLASS);

		// Remove bound events
		this.qtip._unbind(this.qtip.tooltip, this._ns);

		// Delete element reference
		OVERLAY.toggle(this.qtip, FALSE);
		delete this.qtip.elements.overlay;
	}
});


MODAL = PLUGINS.modal = function(api) {
	return new Modal(api, api.options.show.modal);
};

// Setup sanitiztion rules
MODAL.sanitize = function(opts) {
	if(opts.show) {
		if(typeof opts.show.modal !== 'object') { opts.show.modal = { on: !!opts.show.modal }; }
		else if(typeof opts.show.modal.on === 'undefined') { opts.show.modal.on = TRUE; }
	}
};

// Base z-index for all modal tooltips (use qTip core z-index as a base)
/* eslint-disable camelcase */
QTIP.modal_zindex = QTIP.zindex - 200;
/* eslint-enable camelcase */

// Plugin needs to be initialized on render
MODAL.initialize = 'render';

// Setup option set checks
CHECKS.modal = {
	'^show.modal.(on|blur)$': function() {
		// Initialise
		this.destroy();
		this.init();

		// Show the modal if not visible already and tooltip is visible
		this.qtip.elems.overlay.toggle(
			this.qtip.tooltip[0].offsetWidth > 0
		);
	}
};

// Extend original api defaults
$.extend(TRUE, QTIP.defaults, {
	show: {
		modal: {
			on: FALSE,
			effect: TRUE,
			blur: TRUE,
			stealfocus: TRUE,
			escape: TRUE
		}
	}
});
;PLUGINS.viewport = function(api, position, posOptions, targetWidth, targetHeight, elemWidth, elemHeight)
{
	var target = posOptions.target,
		tooltip = api.elements.tooltip,
		my = posOptions.my,
		at = posOptions.at,
		adjust = posOptions.adjust,
		method = adjust.method.split(' '),
		methodX = method[0],
		methodY = method[1] || method[0],
		viewport = posOptions.viewport,
		container = posOptions.container,
		adjusted = { left: 0, top: 0 },
		fixed, newMy, containerOffset, containerStatic,
		viewportWidth, viewportHeight, viewportScroll, viewportOffset;

	// If viewport is not a jQuery element, or it's the window/document, or no adjustment method is used... return
	if(!viewport.jquery || target[0] === window || target[0] === document.body || adjust.method === 'none') {
		return adjusted;
	}

	// Cach container details
	containerOffset = container.offset() || adjusted;
	containerStatic = container.css('position') === 'static';

	// Cache our viewport details
	fixed = tooltip.css('position') === 'fixed';
	viewportWidth = viewport[0] === window ? viewport.width() : viewport.outerWidth(FALSE);
	viewportHeight = viewport[0] === window ? viewport.height() : viewport.outerHeight(FALSE);
	viewportScroll = { left: fixed ? 0 : viewport.scrollLeft(), top: fixed ? 0 : viewport.scrollTop() };
	viewportOffset = viewport.offset() || adjusted;

	// Generic calculation method
	function calculate(side, otherSide, type, adjustment, side1, side2, lengthName, targetLength, elemLength) {
		var initialPos = position[side1],
			mySide = my[side],
			atSide = at[side],
			isShift = type === SHIFT,
			myLength = mySide === side1 ? elemLength : mySide === side2 ? -elemLength : -elemLength / 2,
			atLength = atSide === side1 ? targetLength : atSide === side2 ? -targetLength : -targetLength / 2,
			sideOffset = viewportScroll[side1] + viewportOffset[side1] - (containerStatic ? 0 : containerOffset[side1]),
			overflow1 = sideOffset - initialPos,
			overflow2 = initialPos + elemLength - (lengthName === WIDTH ? viewportWidth : viewportHeight) - sideOffset,
			offset = myLength - (my.precedance === side || mySide === my[otherSide] ? atLength : 0) - (atSide === CENTER ? targetLength / 2 : 0);

		// shift
		if(isShift) {
			offset = (mySide === side1 ? 1 : -1) * myLength;

			// Adjust position but keep it within viewport dimensions
			position[side1] += overflow1 > 0 ? overflow1 : overflow2 > 0 ? -overflow2 : 0;
			position[side1] = Math.max(
				-containerOffset[side1] + viewportOffset[side1],
				initialPos - offset,
				Math.min(
					Math.max(
						-containerOffset[side1] + viewportOffset[side1] + (lengthName === WIDTH ? viewportWidth : viewportHeight),
						initialPos + offset
					),
					position[side1],

					// Make sure we don't adjust complete off the element when using 'center'
					mySide === 'center' ? initialPos - myLength : 1E9
				)
			);

		}

		// flip/flipinvert
		else {
			// Update adjustment amount depending on if using flipinvert or flip
			adjustment *= type === FLIPINVERT ? 2 : 0;

			// Check for overflow on the left/top
			if(overflow1 > 0 && (mySide !== side1 || overflow2 > 0)) {
				position[side1] -= offset + adjustment;
				newMy.invert(side, side1);
			}

			// Check for overflow on the bottom/right
			else if(overflow2 > 0 && (mySide !== side2 || overflow1 > 0)  ) {
				position[side1] -= (mySide === CENTER ? -offset : offset) + adjustment;
				newMy.invert(side, side2);
			}

			// Make sure we haven't made things worse with the adjustment and reset if so
			if(position[side1] < viewportScroll[side1] && -position[side1] > overflow2) {
				position[side1] = initialPos; newMy = my.clone();
			}
		}

		return position[side1] - initialPos;
	}

	// Set newMy if using flip or flipinvert methods
	if(methodX !== 'shift' || methodY !== 'shift') { newMy = my.clone(); }

	// Adjust position based onviewport and adjustment options
	adjusted = {
		left: methodX !== 'none' ? calculate( X, Y, methodX, adjust.x, LEFT, RIGHT, WIDTH, targetWidth, elemWidth ) : 0,
		top: methodY !== 'none' ? calculate( Y, X, methodY, adjust.y, TOP, BOTTOM, HEIGHT, targetHeight, elemHeight ) : 0,
		my: newMy
	};

	return adjusted;
};
;PLUGINS.polys = {
	// POLY area coordinate calculator
	//	Special thanks to Ed Cradock for helping out with this.
	//	Uses a binary search algorithm to find suitable coordinates.
	polygon: function(baseCoords, corner) {
		var result = {
			width: 0, height: 0,
			position: {
				top: 1e10, right: 0,
				bottom: 0, left: 1e10
			},
			adjustable: FALSE
		},
		i = 0, next,
		coords = [],
		compareX = 1, compareY = 1,
		realX = 0, realY = 0,
		newWidth, newHeight;

		// First pass, sanitize coords and determine outer edges
		i = baseCoords.length; 
		while(i--) {
			next = [ parseInt(baseCoords[--i], 10), parseInt(baseCoords[i+1], 10) ];

			if(next[0] > result.position.right){ result.position.right = next[0]; }
			if(next[0] < result.position.left){ result.position.left = next[0]; }
			if(next[1] > result.position.bottom){ result.position.bottom = next[1]; }
			if(next[1] < result.position.top){ result.position.top = next[1]; }

			coords.push(next);
		}

		// Calculate height and width from outer edges
		newWidth = result.width = Math.abs(result.position.right - result.position.left);
		newHeight = result.height = Math.abs(result.position.bottom - result.position.top);

		// If it's the center corner...
		if(corner.abbrev() === 'c') {
			result.position = {
				left: result.position.left + result.width / 2,
				top: result.position.top + result.height / 2
			};
		}
		else {
			// Second pass, use a binary search algorithm to locate most suitable coordinate
			while(newWidth > 0 && newHeight > 0 && compareX > 0 && compareY > 0)
			{
				newWidth = Math.floor(newWidth / 2);
				newHeight = Math.floor(newHeight / 2);

				if(corner.x === LEFT){ compareX = newWidth; }
				else if(corner.x === RIGHT){ compareX = result.width - newWidth; }
				else{ compareX += Math.floor(newWidth / 2); }

				if(corner.y === TOP){ compareY = newHeight; }
				else if(corner.y === BOTTOM){ compareY = result.height - newHeight; }
				else{ compareY += Math.floor(newHeight / 2); }

				i = coords.length;
				while(i--)
				{
					if(coords.length < 2){ break; }

					realX = coords[i][0] - result.position.left;
					realY = coords[i][1] - result.position.top;

					if(
						corner.x === LEFT && realX >= compareX ||
						corner.x === RIGHT && realX <= compareX ||
						corner.x === CENTER && (realX < compareX || realX > result.width - compareX) ||
						corner.y === TOP && realY >= compareY ||
						corner.y === BOTTOM && realY <= compareY ||
						corner.y === CENTER && (realY < compareY || realY > result.height - compareY)) {
						coords.splice(i, 1);
					}
				}
			}
			result.position = { left: coords[0][0], top: coords[0][1] };
		}

		return result;
	},

	rect: function(ax, ay, bx, by) {
		return {
			width: Math.abs(bx - ax),
			height: Math.abs(by - ay),
			position: {
				left: Math.min(ax, bx),
				top: Math.min(ay, by)
			}
		};
	},

	_angles: {
		tc: 3 / 2, tr: 7 / 4, tl: 5 / 4,
		bc: 1 / 2, br: 1 / 4, bl: 3 / 4,
		rc: 2, lc: 1, c: 0
	},
	ellipse: function(cx, cy, rx, ry, corner) {
		var c = PLUGINS.polys._angles[ corner.abbrev() ],
			rxc = c === 0 ? 0 : rx * Math.cos( c * Math.PI ),
			rys = ry * Math.sin( c * Math.PI );

		return {
			width: rx * 2 - Math.abs(rxc),
			height: ry * 2 - Math.abs(rys),
			position: {
				left: cx + rxc,
				top: cy + rys
			},
			adjustable: FALSE
		};
	},
	circle: function(cx, cy, r, corner) {
		return PLUGINS.polys.ellipse(cx, cy, r, r, corner);
	}
};
;PLUGINS.svg = function(api, svg, corner)
{
	var elem = svg[0],
		root = $(elem.ownerSVGElement),
		ownerDocument = elem.ownerDocument,
		strokeWidth2 = (parseInt(svg.css('stroke-width'), 10) || 0) / 2,
		frameOffset, mtx, transformed,
		len, next, i, points,
		result, position;

	// Ascend the parentNode chain until we find an element with getBBox()
	while(!elem.getBBox) { elem = elem.parentNode; }
	if(!elem.getBBox || !elem.parentNode) { return FALSE; }

	// Determine which shape calculation to use
	switch(elem.nodeName) {
		case 'ellipse':
		case 'circle':
			result = PLUGINS.polys.ellipse(
				elem.cx.baseVal.value,
				elem.cy.baseVal.value,
				(elem.rx || elem.r).baseVal.value + strokeWidth2,
				(elem.ry || elem.r).baseVal.value + strokeWidth2,
				corner
			);
		break;

		case 'line':
		case 'polygon':
		case 'polyline':
			// Determine points object (line has none, so mimic using array)
			points = elem.points || [
				{ x: elem.x1.baseVal.value, y: elem.y1.baseVal.value },
				{ x: elem.x2.baseVal.value, y: elem.y2.baseVal.value }
			];

			for(result = [], i = -1, len = points.numberOfItems || points.length; ++i < len;) {
				next = points.getItem ? points.getItem(i) : points[i];
				result.push.apply(result, [next.x, next.y]);
			}

			result = PLUGINS.polys.polygon(result, corner);
		break;

		// Unknown shape or rectangle? Use bounding box
		default:
			result = elem.getBBox();
			result = {
				width: result.width,
				height: result.height,
				position: {
					left: result.x,
					top: result.y
				}
			};
		break;
	}

	// Shortcut assignments
	position = result.position;
	root = root[0];

	// Convert position into a pixel value
	if(root.createSVGPoint) {
		mtx = elem.getScreenCTM();
		points = root.createSVGPoint();

		points.x = position.left;
		points.y = position.top;
		transformed = points.matrixTransform( mtx );
		position.left = transformed.x;
		position.top = transformed.y;
	}

	// Check the element is not in a child document, and if so, adjust for frame elements offset
	if(ownerDocument !== document && api.position.target !== 'mouse') {
		frameOffset = $((ownerDocument.defaultView || ownerDocument.parentWindow).frameElement).offset();
		if(frameOffset) {
			position.left += frameOffset.left;
			position.top += frameOffset.top;
		}
	}

	// Adjust by scroll offset of owner document
	ownerDocument = $(ownerDocument);
	position.left += ownerDocument.scrollLeft();
	position.top += ownerDocument.scrollTop();

	return result;
};
;PLUGINS.imagemap = function(api, area, corner)
{
	if(!area.jquery) { area = $(area); }

	var shape = (area.attr('shape') || 'rect').toLowerCase().replace('poly', 'polygon'),
		image = $('img[usemap="#'+area.parent('map').attr('name')+'"]'),
		coordsString = $.trim(area.attr('coords')),
		coordsArray = coordsString.replace(/,$/, '').split(','),
		imageOffset, coords, i, result, len;

	// If we can't find the image using the map...
	if(!image.length) { return FALSE; }

	// Pass coordinates string if polygon
	if(shape === 'polygon') {
		result = PLUGINS.polys.polygon(coordsArray, corner);
	}

	// Otherwise parse the coordinates and pass them as arguments
	else if(PLUGINS.polys[shape]) {
		for(i = -1, len = coordsArray.length, coords = []; ++i < len;) {
			coords.push( parseInt(coordsArray[i], 10) );
		}

		result = PLUGINS.polys[shape].apply(
			this, coords.concat(corner)
		);
	}

	// If no shapre calculation method was found, return false
	else { return FALSE; }

	// Make sure we account for padding and borders on the image
	imageOffset = image.offset();
	imageOffset.left += Math.ceil((image.outerWidth(FALSE) - image.width()) / 2);
	imageOffset.top += Math.ceil((image.outerHeight(FALSE) - image.height()) / 2);

	// Add image position to offset coordinates
	result.position.left += imageOffset.left;
	result.position.top += imageOffset.top;

	return result;
};
;var IE6,

/*
 * BGIFrame adaption (http://plugins.jquery.com/project/bgiframe)
 * Special thanks to Brandon Aaron
 */
BGIFRAME = '<iframe class="qtip-bgiframe" frameborder="0" tabindex="-1" src="javascript:\'\';" ' +
	' style="display:block; position:absolute; z-index:-1; filter:alpha(opacity=0); ' +
		'-ms-filter:"progid:DXImageTransform.Microsoft.Alpha(Opacity=0)";"></iframe>';

function Ie6(api) {
	this._ns = 'ie6';

	this.qtip = api;
	this.init(api);
}

$.extend(Ie6.prototype, {
	_scroll : function() {
		var overlay = this.qtip.elements.overlay;
		overlay && (overlay[0].style.top = $(window).scrollTop() + 'px');
	},

	init: function(qtip) {
		var tooltip = qtip.tooltip;

		// Create the BGIFrame element if needed
		if($('select, object').length < 1) {
			this.bgiframe = qtip.elements.bgiframe = $(BGIFRAME).appendTo(tooltip);

			// Update BGIFrame on tooltip move
			qtip._bind(tooltip, 'tooltipmove', this.adjustBGIFrame, this._ns, this);
		}

		// redraw() container for width/height calculations
		this.redrawContainer = $('<div/>', { id: NAMESPACE+'-rcontainer' })
			.appendTo(document.body);

		// Fixup modal plugin if present too
		if( qtip.elements.overlay && qtip.elements.overlay.addClass('qtipmodal-ie6fix') ) {
			qtip._bind(window, ['scroll', 'resize'], this._scroll, this._ns, this);
			qtip._bind(tooltip, ['tooltipshow'], this._scroll, this._ns, this);
		}

		// Set dimensions
		this.redraw();
	},

	adjustBGIFrame: function() {
		var tooltip = this.qtip.tooltip,
			dimensions = {
				height: tooltip.outerHeight(FALSE),
				width: tooltip.outerWidth(FALSE)
			},
			plugin = this.qtip.plugins.tip,
			tip = this.qtip.elements.tip,
			tipAdjust, offset;

		// Adjust border offset
		offset = parseInt(tooltip.css('borderLeftWidth'), 10) || 0;
		offset = { left: -offset, top: -offset };

		// Adjust for tips plugin
		if(plugin && tip) {
			tipAdjust = plugin.corner.precedance === 'x' ? [WIDTH, LEFT] : [HEIGHT, TOP];
			offset[ tipAdjust[1] ] -= tip[ tipAdjust[0] ]();
		}

		// Update bgiframe
		this.bgiframe.css(offset).css(dimensions);
	},

	// Max/min width simulator function
	redraw: function() {
		if(this.qtip.rendered < 1 || this.drawing) { return this; }

		var tooltip = this.qtip.tooltip,
			style = this.qtip.options.style,
			container = this.qtip.options.position.container,
			perc, width, max, min;

		// Set drawing flag
		this.qtip.drawing = 1;

		// If tooltip has a set height/width, just set it... like a boss!
		if(style.height) { tooltip.css(HEIGHT, style.height); }
		if(style.width) { tooltip.css(WIDTH, style.width); }

		// Simulate max/min width if not set width present...
		else {
			// Reset width and add fluid class
			tooltip.css(WIDTH, '').appendTo(this.redrawContainer);

			// Grab our tooltip width (add 1 if odd so we don't get wrapping problems.. huzzah!)
			width = tooltip.width();
			if(width % 2 < 1) { width += 1; }

			// Grab our max/min properties
			max = tooltip.css('maxWidth') || '';
			min = tooltip.css('minWidth') || '';

			// Parse into proper pixel values
			perc = (max + min).indexOf('%') > -1 ? container.width() / 100 : 0;
			max = (max.indexOf('%') > -1 ? perc : 1 * parseInt(max, 10)) || width;
			min = (min.indexOf('%') > -1 ? perc : 1 * parseInt(min, 10)) || 0;

			// Determine new dimension size based on max/min/current values
			width = max + min ? Math.min(Math.max(width, min), max) : width;

			// Set the newly calculated width and remvoe fluid class
			tooltip.css(WIDTH, Math.round(width)).appendTo(container);
		}

		// Set drawing flag
		this.drawing = 0;

		return this;
	},

	destroy: function() {
		// Remove iframe
		this.bgiframe && this.bgiframe.remove();

		// Remove bound events
		this.qtip._unbind([window, this.qtip.tooltip], this._ns);
	}
});

IE6 = PLUGINS.ie6 = function(api) {
	// Proceed only if the browser is IE6
	return BROWSER.ie === 6 ? new Ie6(api) : FALSE;
};

IE6.initialize = 'render';

CHECKS.ie6 = {
	'^content|style$': function() {
		this.redraw();
	}
};
;}));
}( window, document ));

},{}],226:[function(require,module,exports){
/*!
* screenfull
* v5.0.2 - 2020-02-13
* (c) Sindre Sorhus; MIT License
*/
(function () {
	'use strict';

	var document = typeof window !== 'undefined' && typeof window.document !== 'undefined' ? window.document : {};
	var isCommonjs = typeof module !== 'undefined' && module.exports;

	var fn = (function () {
		var val;

		var fnMap = [
			[
				'requestFullscreen',
				'exitFullscreen',
				'fullscreenElement',
				'fullscreenEnabled',
				'fullscreenchange',
				'fullscreenerror'
			],
			// New WebKit
			[
				'webkitRequestFullscreen',
				'webkitExitFullscreen',
				'webkitFullscreenElement',
				'webkitFullscreenEnabled',
				'webkitfullscreenchange',
				'webkitfullscreenerror'

			],
			// Old WebKit
			[
				'webkitRequestFullScreen',
				'webkitCancelFullScreen',
				'webkitCurrentFullScreenElement',
				'webkitCancelFullScreen',
				'webkitfullscreenchange',
				'webkitfullscreenerror'

			],
			[
				'mozRequestFullScreen',
				'mozCancelFullScreen',
				'mozFullScreenElement',
				'mozFullScreenEnabled',
				'mozfullscreenchange',
				'mozfullscreenerror'
			],
			[
				'msRequestFullscreen',
				'msExitFullscreen',
				'msFullscreenElement',
				'msFullscreenEnabled',
				'MSFullscreenChange',
				'MSFullscreenError'
			]
		];

		var i = 0;
		var l = fnMap.length;
		var ret = {};

		for (; i < l; i++) {
			val = fnMap[i];
			if (val && val[1] in document) {
				for (i = 0; i < val.length; i++) {
					ret[fnMap[0][i]] = val[i];
				}
				return ret;
			}
		}

		return false;
	})();

	var eventNameMap = {
		change: fn.fullscreenchange,
		error: fn.fullscreenerror
	};

	var screenfull = {
		request: function (element) {
			return new Promise(function (resolve, reject) {
				var onFullScreenEntered = function () {
					this.off('change', onFullScreenEntered);
					resolve();
				}.bind(this);

				this.on('change', onFullScreenEntered);

				element = element || document.documentElement;

				var returnPromise = element[fn.requestFullscreen]();

				if (returnPromise instanceof Promise) {
					returnPromise.then(onFullScreenEntered).catch(reject);
				}
			}.bind(this));
		},
		exit: function () {
			return new Promise(function (resolve, reject) {
				if (!this.isFullscreen) {
					resolve();
					return;
				}

				var onFullScreenExit = function () {
					this.off('change', onFullScreenExit);
					resolve();
				}.bind(this);

				this.on('change', onFullScreenExit);

				var returnPromise = document[fn.exitFullscreen]();

				if (returnPromise instanceof Promise) {
					returnPromise.then(onFullScreenExit).catch(reject);
				}
			}.bind(this));
		},
		toggle: function (element) {
			return this.isFullscreen ? this.exit() : this.request(element);
		},
		onchange: function (callback) {
			this.on('change', callback);
		},
		onerror: function (callback) {
			this.on('error', callback);
		},
		on: function (event, callback) {
			var eventName = eventNameMap[event];
			if (eventName) {
				document.addEventListener(eventName, callback, false);
			}
		},
		off: function (event, callback) {
			var eventName = eventNameMap[event];
			if (eventName) {
				document.removeEventListener(eventName, callback, false);
			}
		},
		raw: fn
	};

	if (!fn) {
		if (isCommonjs) {
			module.exports = {isEnabled: false};
		} else {
			window.screenfull = {isEnabled: false};
		}

		return;
	}

	Object.defineProperties(screenfull, {
		isFullscreen: {
			get: function () {
				return Boolean(document[fn.fullscreenElement]);
			}
		},
		element: {
			enumerable: true,
			get: function () {
				return document[fn.fullscreenElement];
			}
		},
		isEnabled: {
			enumerable: true,
			get: function () {
				// Coerce to boolean in case of old WebKit
				return Boolean(document[fn.fullscreenEnabled]);
			}
		}
	});

	if (isCommonjs) {
		module.exports = screenfull;
	} else {
		window.screenfull = screenfull;
	}
})();

},{}],227:[function(require,module,exports){
(function (Buffer){
(function() {
  var crypt = require('crypt'),
      utf8 = require('charenc').utf8,
      bin = require('charenc').bin,

  // The core
  sha1 = function (message) {
    // Convert to byte array
    if (message.constructor == String)
      message = utf8.stringToBytes(message);
    else if (typeof Buffer !== 'undefined' && typeof Buffer.isBuffer == 'function' && Buffer.isBuffer(message))
      message = Array.prototype.slice.call(message, 0);
    else if (!Array.isArray(message))
      message = message.toString();

    // otherwise assume byte array

    var m  = crypt.bytesToWords(message),
        l  = message.length * 8,
        w  = [],
        H0 =  1732584193,
        H1 = -271733879,
        H2 = -1732584194,
        H3 =  271733878,
        H4 = -1009589776;

    // Padding
    m[l >> 5] |= 0x80 << (24 - l % 32);
    m[((l + 64 >>> 9) << 4) + 15] = l;

    for (var i = 0; i < m.length; i += 16) {
      var a = H0,
          b = H1,
          c = H2,
          d = H3,
          e = H4;

      for (var j = 0; j < 80; j++) {

        if (j < 16)
          w[j] = m[i + j];
        else {
          var n = w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16];
          w[j] = (n << 1) | (n >>> 31);
        }

        var t = ((H0 << 5) | (H0 >>> 27)) + H4 + (w[j] >>> 0) + (
                j < 20 ? (H1 & H2 | ~H1 & H3) + 1518500249 :
                j < 40 ? (H1 ^ H2 ^ H3) + 1859775393 :
                j < 60 ? (H1 & H2 | H1 & H3 | H2 & H3) - 1894007588 :
                         (H1 ^ H2 ^ H3) - 899497514);

        H4 = H3;
        H3 = H2;
        H2 = (H1 << 30) | (H1 >>> 2);
        H1 = H0;
        H0 = t;
      }

      H0 += a;
      H1 += b;
      H2 += c;
      H3 += d;
      H4 += e;
    }

    return [H0, H1, H2, H3, H4];
  },

  // Public API
  api = function (message, options) {
    var digestbytes = crypt.wordsToBytes(sha1(message));
    return options && options.asBytes ? digestbytes :
        options && options.asString ? bin.bytesToString(digestbytes) :
        crypt.bytesToHex(digestbytes);
  };

  api._blocksize = 16;
  api._digestsize = 20;

  module.exports = api;
})();

}).call(this,require("buffer").Buffer)

},{"buffer":109,"charenc":110,"crypt":111}],228:[function(require,module,exports){
'use strict';

let fastProto = null;

// Creates an object with permanently fast properties in V8. See Toon Verwaest's
// post https://medium.com/@tverwaes/setting-up-prototypes-in-v8-ec9c9491dfe2#5f62
// for more details. Use %HasFastProperties(object) and the Node.js flag
// --allow-natives-syntax to check whether an object has fast properties.
function FastObject(o) {
	// A prototype object will have "fast properties" enabled once it is checked
	// against the inline property cache of a function, e.g. fastProto.property:
	// https://github.com/v8/v8/blob/6.0.122/test/mjsunit/fast-prototype.js#L48-L63
	if (fastProto !== null && typeof fastProto.property) {
		const result = fastProto;
		fastProto = FastObject.prototype = null;
		return result;
	}
	fastProto = FastObject.prototype = o == null ? Object.create(null) : o;
	return new FastObject;
}

// Initialize the inline property cache of FastObject
FastObject();

module.exports = function toFastproperties(o) {
	return FastObject(o);
};

},{}]},{},[15])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJtb2R1bGVzL2Fubm90YXRvci1jb25maWcuanNvbiIsIm1vZHVsZXMvYW5ub3RhdG9yL2Fubm90YXRpb24tbWFuYWdlci5qcyIsIm1vZHVsZXMvYW5ub3RhdG9yL2Fubm90YXRpb24uanMiLCJtb2R1bGVzL2Fubm90YXRvci9hbm5vdGF0b3IuanMiLCJtb2R1bGVzL2Fubm90YXRvci9jb21wb25lbnRzL2Fubm90YXRpb24tZ3VpLmpzIiwibW9kdWxlcy9hbm5vdGF0b3IvY29tcG9uZW50cy9pbmRleC1jb250YWluZXIuanMiLCJtb2R1bGVzL2Fubm90YXRvci9jb21wb25lbnRzL2luZm8tY29udGFpbmVyLmpzIiwibW9kdWxlcy9hbm5vdGF0b3IvY29tcG9uZW50cy9tZXNzYWdlLW92ZXJsYXkuanMiLCJtb2R1bGVzL2Fubm90YXRvci9jb21wb25lbnRzL3BvbHlnb24tZWRpdG9yLmpzIiwibW9kdWxlcy9hbm5vdGF0b3IvY29tcG9uZW50cy9wb2x5Z29uLW92ZXJsYXkuanMiLCJtb2R1bGVzL2Fubm90YXRvci9jb21wb25lbnRzL3RpY2stYmFyLmpzIiwibW9kdWxlcy9hbm5vdGF0b3Ivc2VydmVyLWludGVyZmFjZS5qcyIsIm1vZHVsZXMvYW5ub3RhdG9yL3Nlc3Npb24tbWFuYWdlci5qcyIsIm1vZHVsZXMvY29uZmlnLmpzb24iLCJtb2R1bGVzL21haW4uanMiLCJtb2R1bGVzL3V0aWxzL2FycmF5LWV4dGVuc2lvbnMuanMiLCJtb2R1bGVzL3V0aWxzL2NsaXAtcGF0aC1wb2x5Z29uLTEuMC4xNS5qcyIsIm1vZHVsZXMvdXRpbHMvanF1ZXJ5LWV4dGVuc2lvbnMuanMiLCJtb2R1bGVzL3V0aWxzL3ByZWZlcmVuY2UtbWFuYWdlci5qcyIsIm1vZHVsZXMvdXRpbHMvcmVxdWlyZW1lbnRzLmpzIiwibW9kdWxlcy91dGlscy9zdHJpbmctZXh0ZW5zaW9ucy5qcyIsIm1vZHVsZXMvdXRpbHMvdGltZS5qcyIsIm1vZHVsZXMvdmVuZG9yLmpzIiwibW9kdWxlcy92aWRlby1wbGF5ZXIvc2Vla2Jhci10b29sdGlwLmpzIiwibW9kdWxlcy92aWRlby1wbGF5ZXIvdmlkZW8tcGxheWVyLWJhci5qcyIsIm1vZHVsZXMvdmlkZW8tcGxheWVyL3ZpZGVvLXBsYXllci5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvaGVscGVyLXZhbGlkYXRvci1pZGVudGlmaWVyL2xpYi9pZGVudGlmaWVyLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9oZWxwZXItdmFsaWRhdG9yLWlkZW50aWZpZXIvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9oZWxwZXItdmFsaWRhdG9yLWlkZW50aWZpZXIvbGliL2tleXdvcmQuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9hc3NlcnRzL2Fzc2VydE5vZGUuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9hc3NlcnRzL2dlbmVyYXRlZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2J1aWxkZXJzL2J1aWxkZXIuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9idWlsZGVycy9mbG93L2NyZWF0ZUZsb3dVbmlvblR5cGUuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9idWlsZGVycy9mbG93L2NyZWF0ZVR5cGVBbm5vdGF0aW9uQmFzZWRPblR5cGVvZi5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2J1aWxkZXJzL2dlbmVyYXRlZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2J1aWxkZXJzL3JlYWN0L2J1aWxkQ2hpbGRyZW4uanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9idWlsZGVycy90eXBlc2NyaXB0L2NyZWF0ZVRTVW5pb25UeXBlLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY2xvbmUvY2xvbmUuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jbG9uZS9jbG9uZURlZXAuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jbG9uZS9jbG9uZURlZXBXaXRob3V0TG9jLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY2xvbmUvY2xvbmVOb2RlLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY2xvbmUvY2xvbmVXaXRob3V0TG9jLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY29tbWVudHMvYWRkQ29tbWVudC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2NvbW1lbnRzL2FkZENvbW1lbnRzLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY29tbWVudHMvaW5oZXJpdElubmVyQ29tbWVudHMuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb21tZW50cy9pbmhlcml0TGVhZGluZ0NvbW1lbnRzLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY29tbWVudHMvaW5oZXJpdFRyYWlsaW5nQ29tbWVudHMuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb21tZW50cy9pbmhlcml0c0NvbW1lbnRzLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY29tbWVudHMvcmVtb3ZlQ29tbWVudHMuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb25zdGFudHMvZ2VuZXJhdGVkL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY29uc3RhbnRzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY29udmVydGVycy9lbnN1cmVCbG9jay5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2NvbnZlcnRlcnMvZ2F0aGVyU2VxdWVuY2VFeHByZXNzaW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2NvbnZlcnRlcnMvdG9CaW5kaW5nSWRlbnRpZmllck5hbWUuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb252ZXJ0ZXJzL3RvQmxvY2suanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb252ZXJ0ZXJzL3RvQ29tcHV0ZWRLZXkuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb252ZXJ0ZXJzL3RvRXhwcmVzc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2NvbnZlcnRlcnMvdG9JZGVudGlmaWVyLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY29udmVydGVycy90b0tleUFsaWFzLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY29udmVydGVycy90b1NlcXVlbmNlRXhwcmVzc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2NvbnZlcnRlcnMvdG9TdGF0ZW1lbnQuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb252ZXJ0ZXJzL3ZhbHVlVG9Ob2RlLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvZGVmaW5pdGlvbnMvY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2RlZmluaXRpb25zL2V4cGVyaW1lbnRhbC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2RlZmluaXRpb25zL2Zsb3cuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9kZWZpbml0aW9ucy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2RlZmluaXRpb25zL2pzeC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2RlZmluaXRpb25zL21pc2MuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9kZWZpbml0aW9ucy9wbGFjZWhvbGRlcnMuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9kZWZpbml0aW9ucy90eXBlc2NyaXB0LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvZGVmaW5pdGlvbnMvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL21vZGlmaWNhdGlvbnMvYXBwZW5kVG9NZW1iZXJFeHByZXNzaW9uLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvbW9kaWZpY2F0aW9ucy9mbG93L3JlbW92ZVR5cGVEdXBsaWNhdGVzLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvbW9kaWZpY2F0aW9ucy9pbmhlcml0cy5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL21vZGlmaWNhdGlvbnMvcHJlcGVuZFRvTWVtYmVyRXhwcmVzc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL21vZGlmaWNhdGlvbnMvcmVtb3ZlUHJvcGVydGllcy5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL21vZGlmaWNhdGlvbnMvcmVtb3ZlUHJvcGVydGllc0RlZXAuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9tb2RpZmljYXRpb25zL3R5cGVzY3JpcHQvcmVtb3ZlVHlwZUR1cGxpY2F0ZXMuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9yZXRyaWV2ZXJzL2dldEJpbmRpbmdJZGVudGlmaWVycy5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3JldHJpZXZlcnMvZ2V0T3V0ZXJCaW5kaW5nSWRlbnRpZmllcnMuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi90cmF2ZXJzZS90cmF2ZXJzZS5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3RyYXZlcnNlL3RyYXZlcnNlRmFzdC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3V0aWxzL2luaGVyaXQuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi91dGlscy9yZWFjdC9jbGVhbkpTWEVsZW1lbnRMaXRlcmFsQ2hpbGQuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi91dGlscy9zaGFsbG93RXF1YWwuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL2J1aWxkTWF0Y2hNZW1iZXJFeHByZXNzaW9uLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvdmFsaWRhdG9ycy9nZW5lcmF0ZWQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL2lzLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvdmFsaWRhdG9ycy9pc0JpbmRpbmcuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL2lzQmxvY2tTY29wZWQuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL2lzSW1tdXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvdmFsaWRhdG9ycy9pc0xldC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvaXNOb2RlLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvdmFsaWRhdG9ycy9pc05vZGVzRXF1aXZhbGVudC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvaXNQbGFjZWhvbGRlclR5cGUuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL2lzUmVmZXJlbmNlZC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvaXNTY29wZS5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvaXNTcGVjaWZpZXJEZWZhdWx0LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvdmFsaWRhdG9ycy9pc1R5cGUuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL2lzVmFsaWRFUzNJZGVudGlmaWVyLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvdmFsaWRhdG9ycy9pc1ZhbGlkSWRlbnRpZmllci5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvaXNWYXIuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL21hdGNoZXNQYXR0ZXJuLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvdmFsaWRhdG9ycy9yZWFjdC9pc0NvbXBhdFRhZy5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvcmVhY3QvaXNSZWFjdENvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvdmFsaWRhdGUuanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jaGFyZW5jL2NoYXJlbmMuanMiLCJub2RlX21vZHVsZXMvY3J5cHQvY3J5cHQuanMiLCJub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX0RhdGFWaWV3LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fSGFzaC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX0xpc3RDYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcENhY2hlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fUHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX1NldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX1N0YWNrLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fU3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fVWludDhBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX1dlYWtNYXAuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUVhY2guanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5TGlrZUtleXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVB1c2guanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hc3NpZ25WYWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc29jSW5kZXhPZi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VBc3NpZ24uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduSW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduVmFsdWUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQ2xvbmUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQ3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldEFsbEtleXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0VGFnLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzQXJndW1lbnRzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTWFwLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmF0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzUmVnRXhwLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzU2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUtleXNJbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUaW1lcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VVbmFyeS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQXJyYXlCdWZmZXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZUJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lRGF0YVZpZXcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZVJlZ0V4cC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lU3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVUeXBlZEFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weUFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weU9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlTeW1ib2xzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weVN5bWJvbHNJbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcmVKc0RhdGEuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19kZWZpbmVQcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2ZyZWVHbG9iYWwuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXRBbGxLZXlzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0QWxsS2V5c0luLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TWFwRGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE5hdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFByb3RvdHlwZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFJhd1RhZy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFN5bWJvbHMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXRTeW1ib2xzSW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXRUYWcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXRWYWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hDbGVhci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hEZWxldGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoR2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEhhcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hTZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19pbml0Q2xvbmVBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2luaXRDbG9uZUJ5VGFnLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faXNJbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzTWFza2VkLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faXNQcm90b3R5cGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVDbGVhci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZURlbGV0ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUdldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUhhcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZVNldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZURlbGV0ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlR2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVIYXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZVNldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUtleXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVLZXlzSW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19ub2RlVXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX29iamVjdFRvU3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlckFyZy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3Jvb3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0NsZWFyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tEZWxldGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0dldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrSGFzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tTZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL190b1NvdXJjZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvY2xvbmUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2VxLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FyZ3VtZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheUxpa2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzQnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc0Z1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc0xlbmd0aC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNNYXAuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdExpa2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzUGxhaW5PYmplY3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzUmVnRXhwLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc1NldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNUeXBlZEFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzSW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL3N0dWJBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvc3R1YkZhbHNlLmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9xdGlwMi9kaXN0L2pxdWVyeS5xdGlwLmpzIiwibm9kZV9tb2R1bGVzL3NjcmVlbmZ1bGwvZGlzdC9zY3JlZW5mdWxsLmpzIiwibm9kZV9tb2R1bGVzL3NoYTEvc2hhMS5qcyIsIm5vZGVfbW9kdWxlcy90by1mYXN0LXByb3BlcnRpZXMvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDTkE7Ozs7Ozs7Ozs7Ozs7O0lBRU0saUI7QUFDRiwrQkFBYTtBQUFBOztBQUNULFNBQUssV0FBTCxHQUFtQixFQUFuQjtBQUNBLFNBQUssZUFBTCxHQUF1QixFQUF2QjtBQUNIOzs7O3FDQUVnQixJLEVBQUs7QUFFbEIsVUFBSSxJQUFJLENBQUMsTUFBTCxJQUFlLENBQW5CLEVBQXFCO0FBQ2pCLFFBQUEsT0FBTyxDQUFDLElBQVIsQ0FBYSwrQkFBYjtBQUNIOztBQUVELFVBQUksZUFBZSxPQUFPLElBQUksQ0FBQyxLQUEvQixFQUF1QztBQUFHO0FBQUgsbURBQ2pCLElBRGlCO0FBQUE7O0FBQUE7QUFDbkMsOERBQXVCO0FBQUEsZ0JBQWYsTUFBZTtBQUNuQixpQkFBSyxrQkFBTCxDQUF3QixNQUF4QjtBQUNI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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdjdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2h0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNuOENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Y0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMVRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWhKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwiY2xpZW50X2lkXCI6IFwic2NhbGFyXCIsXG4gICAgXCJjbGllbnRfdmVyXCI6IFwiMi42XCIsXG4gICAgXCJuYXRpdmVcIjogXCJ0cnVlXCIsXG4gICAgXCJpZFwiOiBcIlwiLFxuICAgIFwiYXBpX2tleVwiOiBcIlwiXG59IiwiaW1wb3J0IHsgQW5ub3RhdGlvbiB9IGZyb20gXCIuL2Fubm90YXRpb24uanNcIjtcblxuY2xhc3MgQW5ub3RhdGlvbk1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5vbm9teVZvY2FidWxhcnkgPSBbXTtcbiAgICB9XG5cbiAgICBQb3B1bGF0ZUZyb21KU09OKGpzb24pe1xuICAgIFxuICAgICAgICBpZiAoanNvbi5sZW5ndGggPT0gMCl7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJKU09OIGNvbnRhaW5zIG5vIGFubm90YXRpb25zLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgndW5kZWZpbmVkJyA9PSB0eXBlb2YoanNvbi5pdGVtcykpIHsgIC8vIFZlcnNpb24gMVxuICAgICAgICAgICAgZm9yKGxldCBvYmplY3Qgb2YganNvbil7XG4gICAgICAgICAgICAgICAgdGhpcy5SZWdpc3RlckFubm90YXRpb24ob2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHsgIC8vIFZlcnNpb24gMlxuICAgICAgICAgICAgZm9yIChsZXQgb2JqZWN0IG9mIGpzb24uaXRlbXNbMF0uaXRlbXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLlJlZ2lzdGVyQW5ub3RhdGlvbihvYmplY3QsIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoanNvbi5pdGVtc1swXSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgUmVnaXN0ZXJBbm5vdGF0aW9uKGpzb25PYmplY3QsIGNhbnZhc09iamVjdCl7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJSZWdpc3RlcmluZyBuZXcgYW5ub3RhdGlvbiB3aXRoIElEIFwiICsganNvbk9iamVjdC5pZCk7XG4gICAgICAgIGxldCBhbm5vID0gbmV3IEFubm90YXRpb24oanNvbk9iamVjdCwgY2FudmFzT2JqZWN0KTtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9ucy5wdXNoKGFubm8pO1xuICAgIH1cblxuICAgIFJlbW92ZUFubm90YXRpb24oaWQpe1xuICAgICAgICB0aGlzLmFubm90YXRpb25zID0gdGhpcy5hbm5vdGF0aW9ucy5maWx0ZXIoKG9iaikgPT4ge1xuICAgICAgICAgICAgaWYgKCd1bmRlZmluZWQnID09IHR5cGVvZihvYmouaXRlbXMpKSB7IC8vIFZlcnNpb24gMVxuICAgICAgICAgICAgICAgIHJldHVybiBpZCAhPT0gb2JqLmlkO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8gVmVyc2lvbiAyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkICE9PSBvYmouaXRlbXNbMF0uaXRlbXNbMF0uaXRlbXNbMF0uaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgZ2l2ZW4gYW5ub3RhdGlvbiBpbiB0aGUgc3RvcmVkIGFycmF5XG4gICAgICovXG4gICAgVXBkYXRlQW5ub3RhdGlvbihhbm5vdGF0aW9uLCBvbGRJRCl7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJVcGRhdGluZyBhbm5vdGF0aW9uIElEIFwiICsgb2xkSUQgKyBcIiB0byBcIiArIGFubm90YXRpb24ubWV0YWRhdGEuaWQpO1xuICAgICAgICB0aGlzLlJlbW92ZUFubm90YXRpb24ob2xkSUQpO1xuICAgICAgICAvL3RoaXMuUmVnaXN0ZXJBbm5vdGF0aW9uKGFubm90YXRpb24pO1xuICAgICAgICB0aGlzLlBvcHVsYXRlRnJvbUpTT04oYW5ub3RhdGlvbik7XG4gICAgfVxuXG4gICAgQW5ub3RhdGlvbnNBdFRpbWUodGltZSl7XG5cbiAgICAgICAgLy8gVE9ETzogUmVlbmFibGUgd2l0aCBzb21lIGtpbmQgb2YgZm9yY2UgcGFyYW1ldGVyXG5cbiAgICAgICAgLy8gLy8gSWYgdGhlIGxhc3QgdGltZSByZXF1ZXN0ZWQgaXMgYXNrZWQgZm9yIGFnYWluLCBqdXN0IGdpdmUgYmFjayB0aGUgY2FjaGVkIHJlc3VsdFxuICAgICAgICAvLyBpZih0aW1lTVMgPT0gdGhpcy5sYXN0VGltZVJlcXVlc3RlZCl7XG4gICAgICAgIC8vICAgICAvL2NvbnNvbGUubG9nKFwiVXNpbmcgY2FjaGVcIik7XG4gICAgICAgIC8vICAgICByZXR1cm4gdGhpcy5jYWNoZWQ7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gdGhpcy5sYXN0VGltZVJlcXVlc3RlZCA9IHRpbWVNUztcblxuICAgICAgICAvLyBGaWx0ZXIgYWxsIGxvYWRlZCBhbm5vdGF0aW9ucyB0aGF0IGZpdCB3aXRoaW4gdGhlIHJhbmdlIHF1ZXJ5LlxuICAgICAgICBsZXQgZmlsdGVyZWQgPSB0aGlzLmFubm90YXRpb25zLmZpbHRlcihmdW5jdGlvbihpdGVtKXtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmJlZ2luVGltZSA8PSB0aW1lICYmIHRpbWUgPD0gaXRlbS5lbmRUaW1lO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmNhY2hlZCA9IGZpbHRlcmVkO1xuXG4gICAgICAgIHJldHVybiBmaWx0ZXJlZDtcbiAgICB9XG5cbiAgICBHZXRPbm9teVZvY2FidWxhcnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9ub215Vm9jYWJ1bGFyeTtcbiAgICB9XG5cbiAgICBVcGRhdGVPbm9teVZvY2FidWxhcnkodm9jYWJ1bGFyeSkge1xuICAgICAgICB0aGlzLm9ub215Vm9jYWJ1bGFyeSA9IHZvY2FidWxhcnk7XG4gICAgfVxuXG59XG5cbmV4cG9ydCB7IEFubm90YXRpb25NYW5hZ2VyIH07IiwiLy8vIEEgd3JhcHBlciBmb3IgSlNPTiBvYmplY3RzLlxuY2xhc3MgQW5ub3RhdGlvbiB7XG5cbiAgICBjb25zdHJ1Y3Rvcihqc29uID0gbnVsbCwgY2FudmFzID0gbnVsbCkge1xuXG4gICAgICAgIGxldCB2ZXJzaW9uID0gXCJ2MlwiO1xuXG4gICAgICAgIGlmIChqc29uKSB7XG4gICAgICAgICAgICBpZiAoJ3VuZGVmaW5lZCcgPT0gdHlwZW9mKGpzb24uaXRlbXMpKSB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbiA9IFwidjFcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbiA9IFwidjJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZlcjFcbiAgICAgICAgaWYgKHZlcnNpb24gPT0gXCJ2MVwiKSB7XG4gICAgICAgICAgICB0aGlzW1wiQGNvbnRleHRcIl0gPSBcImh0dHA6Ly93d3cudzMub3JnL25zL2Fubm8uanNvbmxkXCI7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXNbXCJyZXF1ZXN0XCJdID0ge1xuICAgICAgICAgICAgICAgIFwiY2xpZW50X2lkXCI6IFwic2NhbGFyXCIsXG4gICAgICAgICAgICAgICAgXCJjbGllbnRfdmVyXCI6IFwiMi41LjEyXCIsXG4gICAgICAgICAgICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwibmF0aXZlXCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBcImlkXCI6IFwiX19DSEVDS19DT05GSUdfRklMRV9fSURfX1wiLFxuICAgICAgICAgICAgICAgICAgICBcImFwaV9rZXlcIjogXCJfX0NIRUNLX0NPTkZJR19GSUxFX19BUElfS0VZX19cIixcbiAgICAgICAgICAgICAgICAgICAgXCJhY3Rpb25cIjogXCJUT0JFRklMTEVEXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZm9ybWF0XCI6IFwianNvblwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXNbXCJ0eXBlXCJdID0gXCJBbm5vdGF0aW9uXCI7ICBcbiAgICAgICAgICAgIHRoaXNbXCJtb3RpdmF0aW9uXCJdID0gXCJoaWdobGlnaHRpbmdcIjtcbiAgICAgICAgICAgIHRoaXNbXCJib2R5XCJdID0gW107XG4gICAgICAgICAgICB0aGlzW1widGFyZ2V0XCJdID0ge307XG4gICAgICAgICAgICB0aGlzW1wiYW5ub3RhdGlvbl92ZXJzaW9uXCJdID0gXCJ2MVwiO1xuXG4gICAgICAgICAgICB0aGlzLnJlYWRDb25maWcodmVyc2lvbik7XG5cbiAgICAgICAgICAgIGlmIChqc29uKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBqc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHZlcjIgZG9jcy93ZWJhbm5vdGF0aW9uX3NwZWMvc2FtcGxlXzIuMC5qc29uXG4gICAgICAgICAgICB0aGlzW1wiQGNvbnRleHRcIl0gPSBbXCJodHRwOi8vd3d3LnczLm9yZy9ucy9hbm5vLmpzb25sZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaHR0cDovL2lpaWYuaW8vYXBpL3ByZXNlbnRhdGlvbi8zL2NvbnRleHQuanNvblwiXTtcbiAgICAgICAgICAgIHRoaXNbXCJzZXJ2aWNlXCJdID0gW3tcbiAgICAgICAgICAgICAgICBcImNsaWVudF9pZFwiOiBcInNjYWxhclwiLFxuICAgICAgICAgICAgICAgIFwiY2xpZW50X3ZlclwiOiBcIjIuNS4xMlwiLFxuICAgICAgICAgICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgICAgICAgICBcIm5hdGl2ZVwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgXCJpZFwiOiBcIl9fQ0hFQ0tfQ09ORklHX0ZJTEVfX0lEX19cIixcbiAgICAgICAgICAgICAgICAgICAgXCJhcGlfa2V5XCI6IFwiX19DSEVDS19DT05GSUdfRklMRV9fQVBJX0tFWV9fXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYWN0aW9uXCI6IFwiVE9CRUZJTExFRFwiLFxuICAgICAgICAgICAgICAgICAgICBcImZvcm1hdFwiOiBcImpzb25cIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgdGhpc1tcInR5cGVcIl0gPSBcIk1hbmlmZXN0XCI7XG4gICAgICAgICAgICB0aGlzW1wiaXRlbXNcIl0gPSBbXTtcbiAgICAgICAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzW1wiaXRlbXNcIl0ucHVzaCggY2FudmFzICk7ICAvLyBUaGUgXCJDYW52YXNcIlxuICAgICAgICAgICAgICAgIHRoaXNbXCJpdGVtc1wiXVswXS5pdGVtcyA9IFsganNvbiBdOyAgLy8gVGhlIFwiQW5ub3RhdGlvblBhZ2VcIiArIFwiQW5ub3RhdGlvblwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzW1wiYW5ub3RhdGlvbl92ZXJzaW9uXCJdID0gXCJ2MlwiO1xuXG4gICAgICAgICAgICB0aGlzLnJlYWRDb25maWcodmVyc2lvbik7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGpzb24pIHtcbiAgICAgICAgICAgIC8vIENvbXB1dGUgcmVhZCBvbmx5IGVhc3kgYWNjZXNzIHByb3BlcnRpZXNcbiAgICAgICAgICAgIHRoaXMucmVjYWxjdWxhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmVhZENvbmZpZyh2ZXJzaW9uKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHJlcXVpcmUoXCIuLi9hbm5vdGF0b3ItY29uZmlnLmpzb25cIik7XG4gICAgICAgIGlmICh2ZXJzaW9uID09IFwidjFcIikge1xuICAgICAgICAgICAgLy8gdmVyMVxuICAgICAgICAgICAgdGhpc1tcInJlcXVlc3RcIl1bXCJjbGllbnRfaWRcIl0gPSBjb25maWcuY2xpZW50X2lkO1xuICAgICAgICAgICAgdGhpc1tcInJlcXVlc3RcIl1bXCJjbGllbnRfdmVyXCJdID0gY29uZmlnLmNsaWVudF92ZXI7XG4gICAgICAgICAgICB0aGlzW1wicmVxdWVzdFwiXVtcIml0ZW1zXCJdW1wibmF0aXZlXCJdID0gY29uZmlnLm5hdGl2ZTtcbiAgICAgICAgICAgIHRoaXNbXCJyZXF1ZXN0XCJdW1wiaXRlbXNcIl1bXCJpZFwiXSA9IGNvbmZpZy5pZDtcbiAgICAgICAgICAgIHRoaXNbXCJyZXF1ZXN0XCJdW1wiaXRlbXNcIl1bXCJhcGlfa2V5XCJdID0gY29uZmlnLmFwaV9rZXk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB2ZXIyXG4gICAgICAgICAgICB0aGlzW1wic2VydmljZVwiXVswXVtcImNsaWVudF9pZFwiXSA9IGNvbmZpZy5jbGllbnRfaWQ7XG4gICAgICAgICAgICB0aGlzW1wic2VydmljZVwiXVswXVtcImNsaWVudF92ZXJcIl0gPSBjb25maWcuY2xpZW50X3ZlcjtcbiAgICAgICAgICAgIHRoaXNbXCJzZXJ2aWNlXCJdWzBdW1wiaXRlbXNcIl1bXCJuYXRpdmVcIl0gPSBjb25maWcubmF0aXZlO1xuICAgICAgICAgICAgdGhpc1tcInNlcnZpY2VcIl1bMF1bXCJpdGVtc1wiXVtcImlkXCJdID0gY29uZmlnLmlkO1xuICAgICAgICAgICAgdGhpc1tcInNlcnZpY2VcIl1bMF1bXCJpdGVtc1wiXVtcImFwaV9rZXlcIl0gPSBjb25maWcuYXBpX2tleTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vLyBDb21wdXRlIHJlYWQgb25seSBlYXN5IGFjY2VzcyBwcm9wZXJ0aWVzXG4gICAgcmVjYWxjdWxhdGUoKSB7XG5cbiAgICAgICAgY29uc29sZS5sb2codGhpcyk7XG5cbiAgICAgICAgaWYgKCd1bmRlZmluZWQnID09IHR5cGVvZih0aGlzLml0ZW1zKSkgeyAvLyBWZXJzaW9uIDFcbiAgICAgICAgICAgIHZhciB0aW1lU2xpY2UgPSB0aGlzLnRhcmdldC5zZWxlY3Rvci5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS50eXBlID09PSBcIkZyYWdtZW50U2VsZWN0b3JcIjtcbiAgICAgICAgICAgICAgfSlbMF0udmFsdWU7XG4gICAgICAgIH0gZWxzZSB7IC8vIFZlcnNpb24gMlxuICAgICAgICAgICAgdmFyIHRpbWVTbGljZSA9IHRoaXMuaXRlbXNbMF0uaXRlbXNbMF0uaXRlbXNbMF0udGFyZ2V0LnNlbGVjdG9yLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRpbWVTbGljZSA9IHRpbWVTbGljZS5yZXBsYWNlKCcjdD1ucHQ6JywndD0nKTtcbiAgICAgICAgdGltZVNsaWNlID0gdGltZVNsaWNlLnJlcGxhY2UoXCJ0PVwiLCBcIlwiKTtcblxuICAgICAgICAvLy8gU3RhcnQgdGltZSBpbiBzZWNvbmRzXG4gICAgICAgIHRoaXMuYmVnaW5UaW1lID0gcGFyc2VGbG9hdCh0aW1lU2xpY2Uuc3BsaXQoXCIsXCIpWzBdKTtcbiAgICAgICAgLy8vIEVuZCB0aW1lIGluIHNlY29uZHNcbiAgICAgICAgdGhpcy5lbmRUaW1lID0gcGFyc2VGbG9hdCh0aW1lU2xpY2Uuc3BsaXQoXCIsXCIpWzFdKTtcbiAgICAgICAgY29uc29sZS5sb2coJ2JlZ2luVGltZTogJyArIHRoaXMuYmVnaW5UaW1lICsgJyBlbmRUaW1lOiAnICsgdGhpcy5lbmRUaW1lKTtcblxuICAgICAgICAvLy8gRXh0cmFjdCB0YWdzIGZyb20gYW5ub3RhdGlvblxuICAgICAgICBpZiAoJ3VuZGVmaW5lZCcgPT0gdHlwZW9mKHRoaXMuaXRlbXMpKSB7IC8vIFZlcnNpb24gMVxuICAgICAgICAgICAgdGhpcy50YWdzID0gdGhpcy5ib2R5LmZpbHRlcihpdGVtID0+IGl0ZW0ucHVycG9zZSA9PT0gXCJ0YWdnaW5nXCIpLm1hcChpdGVtID0+IGl0ZW0udmFsdWUpO1xuICAgICAgICB9IGVsc2UgeyAvLyBWZXJzaW9uIDJcbiAgICAgICAgICAgIHRoaXMudGFncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLml0ZW1zWzBdLml0ZW1zWzBdLml0ZW1zWzBdLmJvZHkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pdGVtc1swXS5pdGVtc1swXS5pdGVtc1swXS5ib2R5W2pdLnB1cnBvc2UgIT0gJ3RhZ2dpbmcnKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mKHRoaXMuaXRlbXNbMF0uaXRlbXNbMF0uaXRlbXNbMF0uYm9keVtqXS52YWx1ZSkpIHsgIC8vIEJhc2ljIHRhZ1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhZ3MucHVzaCh0aGlzLml0ZW1zWzBdLml0ZW1zWzBdLml0ZW1zWzBdLmJvZHlbal0udmFsdWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mKHRoaXMuaXRlbXNbMF0uaXRlbXNbMF0uaXRlbXNbMF0uYm9keVtqXS5zb3VyY2UpKSB7ICAvLyBPbm9teSB0YWdcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YWdzLnB1c2godGhpcy5pdGVtc1swXS5pdGVtc1swXS5pdGVtc1swXS5ib2R5W2pdLnNvdXJjZS5sYWJlbFsnZW4nXSk7ICAvLyBUT0RPOiBlbmdsaXNoIGhhcmQtY29kZWQgaGVyZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZygnVGFnczogJyArIHRoaXMudGFncyk7XG5cbiAgICAgICAgLy8gU3RhcnQgYW5kIGVuZCBwb2x5IHBvaW50c1xuICAgICAgICB0aGlzLnBvbHlTdGFydCA9IG51bGw7XG4gICAgICAgIHRoaXMucG9seUVuZCA9IG51bGw7XG5cbiAgICAgICAgdmFyIHBvaW50c1NlbGVjdG9yID0gW107XG4gICAgICAgIGlmICgndW5kZWZpbmVkJyA9PSB0eXBlb2YodGhpcy5pdGVtcykpIHsgLy8gVmVyc2lvbiAxXG4gICAgICAgICAgICBwb2ludHNTZWxlY3RvciA9IHRoaXMudGFyZ2V0LnNlbGVjdG9yLmZpbHRlcihpdGVtID0+IGl0ZW0udHlwZSA9PT0gXCJTdmdTZWxlY3RvclwiKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gVmVyc2lvbiAyXG4gICAgICAgICAgICBwb2ludHNTZWxlY3RvciA9ICgndW5kZWZpbmVkJyAhPSB0eXBlb2YodGhpcy5pdGVtc1swXS5pdGVtc1swXS5pdGVtc1swXS50YXJnZXQuc2VsZWN0b3IucmVmaW5lZEJ5KSkgPyBbdGhpcy5pdGVtc1swXS5pdGVtc1swXS5pdGVtc1swXS50YXJnZXQuc2VsZWN0b3IucmVmaW5lZEJ5XSA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb2ludHNTZWxlY3Rvci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgcG9pbnRzU3ZnID0gcG9pbnRzU2VsZWN0b3JbMF0udmFsdWU7XG4gICAgICAgICAgICBsZXQgcmVnRXhTdHJpbmcgPSBuZXcgUmVnRXhwKFwiKD86cG9pbnRzPScpKC4qPykoPzonKVwiLCBcImlnXCIpO1xuICAgICAgICAgICAgdmFyIHBvaW50c1JFID0gcmVnRXhTdHJpbmcuZXhlYyhwb2ludHNTdmcpWzFdO1xuICAgICAgICAgICAgdmFyIHBvaW50c0RhdGEgPSBwb2ludHNSRS50cmltKCkuc3BsaXQoXCIgXCIpLm1hcChpdGVtID0+IGl0ZW0uc3BsaXQoXCIsXCIpKTtcbiAgICAgICAgICAgIHRoaXMucG9seVN0YXJ0ID0gcG9pbnRzRGF0YTtcblxuICAgICAgICAgICAgbGV0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICAgICAgICAgIGxldCB4bWxEb2MgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHBvaW50c1N2ZywgXCJ0ZXh0L3htbFwiKTtcbiAgICAgICAgICAgIGlmICh4bWxEb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJhbmltYXRlXCIpLmxlbmd0aCkgeyAgLy8gSWYgdGhlcmUgaXMgbm8gYW5pbWF0aW9uIGVsZW1lbnQsIGNyZWF0ZSBhbiBcImFuaW1hdGlvblwiIGZyb20gdGhlIHN0YXRpYyBwb2ludHNcbiAgICAgICAgICAgICAgICBwb2ludHNSRSA9IHhtbERvYy5nZXRFbGVtZW50c0J5VGFnTmFtZShcImFuaW1hdGVcIilbMF0uZ2V0QXR0cmlidXRlKFwidG9cIik7XG4gICAgICAgICAgICAgICAgcG9pbnRzRGF0YSA9IHBvaW50c1JFLnRyaW0oKS5zcGxpdChcIiBcIikubWFwKGl0ZW0gPT4gaXRlbS5zcGxpdChcIixcIikpO1xuICAgICAgICAgICAgICAgIHRoaXMucG9seUVuZCA9IHBvaW50c0RhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coJ3BvbHlTdGFydDogJyk7XG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMucG9seVN0YXJ0KTtcbiAgICAgICAgY29uc29sZS5sb2coJ3BvbHlFbmQ6ICcpO1xuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnBvbHlFbmQpO1xuXG4gICAgfVxuXG4gICAgZ2V0UG9seSgpIHtcbiAgICAgICAgdmFyIHBvaW50c1NlbGVjdG9yID0gW107XG4gICAgICAgIGlmICgndW5kZWZpbmVkJyA9PSB0eXBlb2YodGhpcy5pdGVtcykpIHsgLy8gVmVyc2lvbiAxXG4gICAgICAgICAgICBwb2ludHNTZWxlY3RvciA9IHRoaXMudGFyZ2V0LnNlbGVjdG9yLmZpbHRlcihpdGVtID0+IGl0ZW0udHlwZSA9PT0gXCJTdmdTZWxlY3RvclwiKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gVmVyc2lvbiAyXG4gICAgICAgICAgICBwb2ludHNTZWxlY3RvciA9ICgndW5kZWZpbmVkJyAhPSB0eXBlb2YodGhpcy5pdGVtc1swXS5pdGVtc1swXS5pdGVtc1swXS50YXJnZXQuc2VsZWN0b3IucmVmaW5lZEJ5KSkgPyBbdGhpcy5pdGVtc1swXS5pdGVtc1swXS5pdGVtc1swXS50YXJnZXQuc2VsZWN0b3IucmVmaW5lZEJ5XSA6IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvaW50c1NlbGVjdG9yLmxlbmd0aCA9PSAwKSByZXR1cm4gbnVsbDtcblxuICAgICAgICAvLyBQYXJzZSB0aGUgcG9pbnRzIGFycmF5IGZyb20gdGhlIGFubm90YXRpb25cbiAgICAgICAgbGV0IHBvaW50c1N2ZyA9IHBvaW50c1NlbGVjdG9yWzBdLnZhbHVlO1xuICAgICAgICBsZXQgcmVnRXhTdHJpbmcgPSBuZXcgUmVnRXhwKFwiKD86cG9pbnRzPScpKC4qPykoPzonKVwiLCBcImlnXCIpOyAvL3NldCBpZyBmbGFnIGZvciBnbG9iYWwgc2VhcmNoIGFuZCBjYXNlIGluc2Vuc2l0aXZlXG4gICAgICAgIFxuICAgICAgICBsZXQgcG9pbnRzUkUgPSByZWdFeFN0cmluZy5leGVjKHBvaW50c1N2ZylbMV07XG4gICAgICAgIGxldCBwb2ludHNEYXRhID0gcG9pbnRzUkUudHJpbSgpLnNwbGl0KFwiIFwiKS5tYXAoaXRlbSA9PiBpdGVtLnNwbGl0KFwiLFwiKSk7XG5cbiAgICAgICAgcmV0dXJuIHBvaW50c0RhdGE7XG4gICAgfVxuXG4gICAgZ2V0U1ZHUG9seVBvaW50cygpIHtcbiAgICAgICAgdmFyIHBvaW50c1NlbGVjdG9yID0gW107XG4gICAgICAgIGlmICgndW5kZWZpbmVkJyA9PSB0eXBlb2YodGhpcy5pdGVtcykpIHsgLy8gVmVyc2lvbiAxXG4gICAgICAgICAgICBwb2ludHNTZWxlY3RvciA9IHRoaXMudGFyZ2V0LnNlbGVjdG9yLmZpbHRlcihpdGVtID0+IGl0ZW0udHlwZSA9PT0gXCJTdmdTZWxlY3RvclwiKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gVmVyc2lvbiAyXG4gICAgICAgICAgICBwb2ludHNTZWxlY3RvciA9ICgndW5kZWZpbmVkJyAhPSB0eXBlb2YodGhpcy5pdGVtc1swXS5pdGVtc1swXS5pdGVtc1swXS50YXJnZXQuc2VsZWN0b3IucmVmaW5lZEJ5KSkgPyBbdGhpcy5pdGVtc1swXS5pdGVtc1swXS5pdGVtc1swXS50YXJnZXQuc2VsZWN0b3IucmVmaW5lZEJ5XSA6IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYocG9pbnRzU2VsZWN0b3IubGVuZ3RoID09IDApIHJldHVybiBudWxsO1xuXG4gICAgICAgIC8vIFBhcnNlIHRoZSBwb2ludHMgYXJyYXkgZnJvbSB0aGUgYW5ub3RhdGlvblxuICAgICAgICBsZXQgcG9pbnRzU3ZnID0gcG9pbnRzU2VsZWN0b3JbMF0udmFsdWU7XG4gICAgICAgIGxldCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgICAgIGxldCB4bWxEb2MgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHBvaW50c1N2ZywgXCJ0ZXh0L3htbFwiKTtcblxuICAgICAgICBpZiAoIXhtbERvYy5nZXRFbGVtZW50c0J5VGFnTmFtZShcImFuaW1hdGVcIikubGVuZ3RoKSB7ICAvLyBJZiB0aGVyZSBpcyBubyBhbmltYXRpb24gZWxlbWVudCwgY3JlYXRlIGFuIFwiYW5pbWF0aW9uXCIgZnJvbSB0aGUgc3RhdGljIHBvaW50c1xuICAgICAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMuZ2V0UG9seSgpO1xuICAgICAgICAgICAgcmV0dXJuIFtwb2ludHMsIHBvaW50c107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW3htbERvYy5nZXRFbGVtZW50c0J5VGFnTmFtZShcImFuaW1hdGVcIilbMF0uZ2V0QXR0cmlidXRlKFwiZnJvbVwiKSwgeG1sRG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYW5pbWF0ZVwiKVswXS5nZXRBdHRyaWJ1dGUoXCJ0b1wiKV07XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuXG5cbmV4cG9ydCB7IEFubm90YXRpb24gfTsiLCJpbXBvcnQgeyBTZXJ2ZXJJbnRlcmZhY2UgfSBmcm9tIFwiLi9zZXJ2ZXItaW50ZXJmYWNlLmpzXCI7XG5pbXBvcnQgeyBBbm5vdGF0aW9uTWFuYWdlciB9IGZyb20gXCIuL2Fubm90YXRpb24tbWFuYWdlci5qc1wiO1xuaW1wb3J0IHsgVGlja0JhciB9IGZyb20gXCIuL2NvbXBvbmVudHMvdGljay1iYXIuanNcIjtcbmltcG9ydCB7IFBvbHlnb25PdmVybGF5IH0gZnJvbSBcIi4vY29tcG9uZW50cy9wb2x5Z29uLW92ZXJsYXkuanNcIjtcbmltcG9ydCB7IHByZWZlcmVuY2VzIH0gZnJvbSBcIi4uL3V0aWxzL3ByZWZlcmVuY2UtbWFuYWdlci5qc1wiO1xuaW1wb3J0IHsgQW5ub3RhdGlvbkdVSSB9IGZyb20gXCIuL2NvbXBvbmVudHMvYW5ub3RhdGlvbi1ndWkuanNcIjtcbmltcG9ydCB7IEluZm9Db250YWluZXIgfSBmcm9tIFwiLi9jb21wb25lbnRzL2luZm8tY29udGFpbmVyLmpzXCI7XG5pbXBvcnQgeyBJbmRleENvbnRhaW5lciB9IGZyb20gXCIuL2NvbXBvbmVudHMvaW5kZXgtY29udGFpbmVyLmpzXCI7XG5pbXBvcnQgeyBTZXNzaW9uTWFuYWdlciB9IGZyb20gXCIuL3Nlc3Npb24tbWFuYWdlci5qc1wiO1xuaW1wb3J0IHsgTWVzc2FnZU92ZXJsYXkgfSBmcm9tIFwiLi9jb21wb25lbnRzL21lc3NhZ2Utb3ZlcmxheS5qc1wiO1xuaW1wb3J0IHsgQW5ub3RhdGlvbiB9IGZyb20gXCIuL2Fubm90YXRpb24uanNcIjtcbmxldCBzaGExID0gcmVxdWlyZSgnc2hhMScpO1xuXG5jbGFzcyBWaWRlb0Fubm90YXRvciB7XG4gICAgY29uc3RydWN0b3IoYXJncyl7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiW1ZpZGVvQW5ub3RhdG9yXSBDcmVhdGluZyBWaWRlb0Fubm90YXRvci4uLlwiKTtcblxuICAgICAgICAvL1BhcnNlIGFyZ3VtZW50c1xuICAgICAgICAvL1RoaXMgaXMgYWN0dWFsbHkgcmVxdWlyZWRcbiAgICAgICAgaWYodHlwZW9mIGFyZ3MucGxheWVyID09PSAndW5kZWZpbmVkJyl7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQ2FsbGVkIGZvciBhIG5ldyBWaWRlb0Fubm90YXRvciB3aXRob3V0IHBhc3NpbmcgYSBwbGF5ZXIhJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wbGF5ZXIgPSBhcmdzLnBsYXllcjsgIC8vIEJyaW5nIGluIHRoZSBhcmd1bWVudCBmcm9tIHRoZSBjb25zdHJ1Y3RvclxuICAgICAgICBcblxuICAgICAgICAvL1RoZXNlIGNvbmZpZyBvcHRpb25zIGFyZSByZXF1aXJlZCBmb3Igc2F2aW5nIGFubm90YXRpb25zIHRvIGEgc2VydmVyXG4gICAgICAgIHRoaXMuc2VydmVyVVJMID0gdHlwZW9mIGFyZ3Muc2VydmVyVVJMID09PSAndW5kZWZpbmVkJyA/ICcnIDogYXJncy5zZXJ2ZXJVUkw7XG4gICAgICAgIHRoaXMudGFnc1VSTCA9IHR5cGVvZiBhcmdzLnRhZ3NVUkwgPT09ICd1bmRlZmluZWQnID8gJycgOiBhcmdzLnRhZ3NVUkw7XG4gICAgICAgIHRoaXMuYXBpS2V5ID0gdHlwZW9mIGFyZ3MuYXBpS2V5ID09PSAndW5kZWZpbmVkJyA/ICcnIDogYXJncy5hcGlLZXk7XG5cbiAgICAgICAgLy9JZiBhcGlLZXkgaXMgc2V0IGFuZCBjbXNVc2VybmFtZSBhbmQgY21zRW1haWwgYXJlIHBhc3NlZCwgd2UnbGwgYXV0byBsb2dpbiBsYXRlclxuICAgICAgICB0aGlzLmNtc1VzZXJuYW1lID0gdHlwZW9mIGFyZ3MuY21zVXNlcm5hbWUgPT09ICd1bmRlZmluZWQnID8gJycgOiBhcmdzLmNtc1VzZXJuYW1lO1xuICAgICAgICB0aGlzLmNtc0VtYWlsID0gdHlwZW9mIGFyZ3MuY21zRW1haWwgPT09ICd1bmRlZmluZWQnID8gJycgOiBhcmdzLmNtc0VtYWlsO1xuXG4gICAgICAgIC8vVGhpcyBjb25maWcgb3B0aW9uIGlzIHJlcXVpcmVkIGZvciB1c2luZyBhIHN0YXRpYyBhbm5vdGF0aW9uIGZpbGVcbiAgICAgICAgdGhpcy5sb2NhbFVSTCA9IHR5cGVvZiBhcmdzLmxvY2FsVVJMID09PSAndW5kZWZpbmVkJyA/ICcnIDogYXJncy5sb2NhbFVSTDtcblxuICAgICAgICAvL09wdGlvbmFsIHBhcmFtc1xuICAgICAgICAvL1JlbW92ZXMgdGhlIGVkaXRpbmcgaW50ZXJmYWNlXG4gICAgICAgIHRoaXMua2lvc2tNb2RlID0gdHlwZW9mIGFyZ3Mua2lvc2tNb2RlID09PSAndW5kZWZpbmVkJyA/ICcnIDogYXJncy5raW9za01vZGU7XG4gICAgICAgIC8vU2hvd3MgdGhlICdvcGVuIG1hbmlmZXN0JyBidXR0b24gaWYga2lvc2tNb2RlIGlzIG9mZlxuICAgICAgICB0aGlzLnNob3dNYW5pZmVzdCA9IHR5cGVvZiBhcmdzLnNob3dNYW5pZmVzdCA9PT0gJ3VuZGVmaW5lZCcgPyBmYWxzZSA6IGFyZ3Muc2hvd01hbmlmZXN0OyAgICAgICAgXG4gICAgICAgIC8vQWxsb3dzIHBhc3NpbmcgaW4gYSBmdW5jdGlvbiB0aGF0IG92ZXJyaWRlcyB0aGUgZGVmYXVsdCBhbm5vdGF0aW9uIHJlbmRlcmVyXG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSB0eXBlb2YgYXJncy5yZW5kZXJlciA9PT0gJ3VuZGVmaW5lZCcgPyBmYWxzZSA6IGFyZ3MucmVuZGVyZXI7XG4gICAgICAgIC8vQWxsb3dzIHBhc3NpbmcgaW4gYSBmdW5jdGlvbiB0aGF0IG92ZXJyaWRlcyB0aGUgZGVmYXVsdCBhbm5vdGF0aW9uIHJlbmRlcmVyXG4gICAgICAgIHRoaXMudW5yZW5kZXJlciA9IHR5cGVvZiBhcmdzLnVucmVuZGVyZXIgPT09ICd1bmRlZmluZWQnID8gZmFsc2UgOiBhcmdzLnVucmVuZGVyZXI7XG4gICAgICAgIC8vRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCB0aGUgYW5ub3RhdGlvbiBjb250YWluZXIgaXMgY2xlYXJlZCBldmVyeSB0aW1lIGl0IHVwZGF0ZXNcbiAgICAgICAgdGhpcy5jbGVhckNvbnRhaW5lciA9IHR5cGVvZiBhcmdzLmNsZWFyQ29udGFpbmVyID09PSAndW5kZWZpbmVkJyA/IHRydWUgOiBhcmdzLmNsZWFyQ29udGFpbmVyO1xuICAgICAgICAvL0RldGVybWluZXMgd2hldGhlciBvciBub3QgdG8gY3JlYXRlIGEgbmF2aWdhYmxlIGluZGV4IG9mIGFubm90YXRpb25zXG4gICAgICAgIHRoaXMuZGlzcGxheUluZGV4ID0gdHlwZW9mIGFyZ3MuZGlzcGxheUluZGV4ID09PSAndW5kZWZpbmVkJyA/IGZhbHNlIDogYXJncy5kaXNwbGF5SW5kZXg7ICAgXG4gICAgICAgIFxuICAgICAgICAvL0RldGVybWluZSB0aGUgbGFuZ3VhZ2Ugb2YgdGhlIGFubm90YXRpb25cbiAgICAgICAgdGhpcy5vbm9teUxhbmd1YWdlID0gdHlwZW9mIGFyZ3Mub25vbXlMYW5ndWFnZSA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6IGFyZ3Mub25vbXlMYW5ndWFnZTtcblxuICAgICAgICB0aGlzLm9ub215Vm9jYWJ1bGFyeSA9IFtdO1xuICAgICAgICAvL2xvY2FsVVJMIGltcGxpZXMga2lvc2sgbW9kZVxuICAgICAgICBpZih0aGlzLmxvY2FsVVJMICE9ICcnKSB0aGlzLmtpb3NrTW9kZSA9IHRydWU7XG5cbiAgICAgICAgLy9hZGRpdGlvbmFsIGRhdGEgZnJvbSBhbm5vdGF0aW9ucyBjb2xsZWN0ZWQgZnJvbSBzY2FsYXIgdG8gYmUgYWRkZWQgaW4gQVBJIDIuMCBcbiAgICAgICAgdGhpcy5jb250ZW50TGFiZWwgPSBcIlwiO1xuICAgICAgICB0aGlzLmFydFVSTCA9IFwiXCI7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvblBhZ2VVUkwgPSBcIlwiO1xuXG4gICAgICAgIHRoaXMuV3JhcCgpO1xuICAgICAgICB0aGlzLlBvcHVsYXRlQ29udHJvbHMoKTtcblxuICAgICAgICAvL21heSBuZWVkIHRvIG1vdmUgdGhpcyBiZWxvdyB0aGUgdGhpcy5zZXJ2ZXIgYmxvY2sgbGF0ZXI/XG4gICAgICAgIHRoaXMubWVzc2FnZU92ZXJsYXkgPSBuZXcgTWVzc2FnZU92ZXJsYXkodGhpcyk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbk1hbmFnZXIgPSBuZXcgQW5ub3RhdGlvbk1hbmFnZXIoKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uTWFuYWdlciA9IG5ldyBTZXNzaW9uTWFuYWdlcih0aGlzKTtcblxuICAgICAgICAvL2xvYWQgb25vbXkgdm9jYWJ1bGFyeVxuICAgICAgICAkLmFqYXgodGhpcy5ndWkuR2V0VGFnc1F1ZXJ5KCkpLmRvbmUoKHZvY2FidWxhcnkpPT57XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiT25vbXlWb2NhYnVsYXJ5IGlzIGxvYWRlZFwiKTtcbiAgICAgICAgICAgIGxldCBwYXJzZWRWb2NhYnVsYXJ5ID0gdGhpcy5ndWkuT25vbXlWb2NhYnVsYXJQcm9jZXNzKHZvY2FidWxhcnksIHRoaXMub25vbXlMYW5ndWFnZSk7XG4gICAgICAgICAgICB0aGlzLmFubm90YXRpb25NYW5hZ2VyLlVwZGF0ZU9ub215Vm9jYWJ1bGFyeShwYXJzZWRWb2NhYnVsYXJ5KTtcbiAgICAgICAgICAgIHRoaXMub25vbXlWb2NhYnVsYXJ5ID0gcGFyc2VkVm9jYWJ1bGFyeTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy9sb2NhbFVSTCB0YWtlcyBwcmVjZW5kZW5jZSAtIGlmIGl0IGlzIGFueXRoaW5nIGJ1dCAnJyB0aGVuIGRvIG5vdCBsb2FkIGZyb20gc2VydmVyXG4gICAgICAgIGlmKHRoaXMubG9jYWxVUkwgPT0gJycpe1xuICAgICAgICAgICAgdGhpcy5zZXJ2ZXIgPSBuZXcgU2VydmVySW50ZXJmYWNlKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5zZXJ2ZXIuU2V0QmFzZVVSTCh0aGlzLnNlcnZlclVSTCk7XG5cbiAgICAgICAgICAgIC8vIExvYWQgYW5ub3RhdGlvbnMgZnJvbSBzZXJ2ZXIgYmFzZWQgb24gdGhlIHBsYXllcidzIHZpZGVvIFVSTFxuICAgICAgICAgICAgdGhpcy5zZXJ2ZXIuRmV0Y2hBbm5vdGF0aW9ucygnbG9jYXRpb24nLCB0aGlzLnBsYXllci52aWRlb0VsZW1lbnQuY3VycmVudFNyYylcbiAgICAgICAgICAgIC5kb25lKChqc29uKT0+e1xuICAgICAgICAgICAgICAgIGlmICgndW5kZWZpbmVkJyA9PSB0eXBlb2YoanNvbi5pdGVtcykpIHsgIC8vIFZlcnNpb24gMVxuICAgICAgICAgICAgICAgICAgICAvL2pzb24uc2hpZnQoKSAgLy8gQXNzdW1lIGZpcnN0IG5vZGUgaXMgYSBjb250ZW50IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGpzb24ubGVuZ3RoLTE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihqc29uW2pdLnR5cGUgIT0gXCJBbm5vdGF0aW9uXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbm5vdGF0aW9uX2luZm8gPSBqc29uW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGVudExhYmVsID0gYW5ub3RhdGlvbl9pbmZvW1wiZGN0ZXJtczp0aXRsZVwiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFydFVSTCA9IGFubm90YXRpb25faW5mb1tcImFydDp1cmxcIl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYW5ub3RhdGlvbl9pbmZvW1wiZGN0ZXJtczp0aXRsZVwiXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbi5zcGxpY2UoaiwxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBqc29uW2pdLnRhcmdldC5zZWxlY3Rvci5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJ0ZyYWdtZW50U2VsZWN0b3InICE9IGpzb25bal0udGFyZ2V0LnNlbGVjdG9yW2tdLnR5cGUpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uW2pdLnRhcmdldC5zZWxlY3RvcltrXS52YWx1ZSA9IGpzb25bal0udGFyZ2V0LnNlbGVjdG9yW2tdLnZhbHVlLnJlcGxhY2UoJyN0PW5wdDonLCd0PScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAvLyBWZXJzaW9uIDJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZW50TGFiZWwgPSBqc29uLmxhYmVsLmVuWzBdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFydFVSTCA9IGpzb24uaXRlbXNbMF0uY29udGVudC5pZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbm5vdGF0aW9uUGFnZVVSTCA9IGpzb24uaXRlbXNbMF0uaXRlbXNbMF0uaXRlbXNbMF0uaWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5hbm5vdGF0aW9uTWFuYWdlci5Qb3B1bGF0ZUZyb21KU09OKGpzb24pO1xuICAgICAgICAgICAgICAgIHRoaXMuQW5ub3RhdGlvbnNMb2FkZWQoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvL2F1dG8tbG9naW4gaWYgbm90IGluIGtpb3NrIG1vZGUsIGFuZCB3ZSBoYXZlIHRoZSBjbXMgdmFyaWFibGVzIGFuZCBBUEkga2V5XG4gICAgICAgICAgICBpZighdGhpcy5raW9za01vZGUpe1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuYXBpS2V5ICYmIHRoaXMuY21zRW1haWwgJiYgdGhpcy5jbXNVc2VybmFtZSl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VydmVyLkxvZ091dCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlcnZlci5Mb2dJbih0aGlzLmNtc1VzZXJuYW1lLCBzaGExKHRoaXMuY21zRW1haWwpKS5kb25lKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW01haW5dIENNUyBsb2dpbiBzdWNjZXNzXCIpO1xuICAgICAgICAgICAgICAgICAgICB9KS5mYWlsKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW01haW5dIENNUyBsb2dpbiBmYWlsZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0xvYWRpbmcgbG9jYWwgY2FjaGUgZmlsZTogJyArIHRoaXMubG9jYWxVUkwpO1xuICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICB1cmw6IHRoaXMubG9jYWxVUkwsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJHRVRcIixcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogXCJqc29uXCIsXG4gICAgICAgICAgICAgICAgYXN5bmM6IHRydWVcbiAgICAgICAgICAgIH0pLmRvbmUoKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRmV0Y2hlZCAke2RhdGEubGVuZ3RofSBhbm5vdGF0aW9ucyBmcm9tIGxvY2FsIGNhY2hlLmApO1xuICAgICAgICAgICAgICAgIHZhciBqc29uID0gZGF0YTtcbiAgICAgICAgICAgICAgICBpZiAoJ3VuZGVmaW5lZCcgPT0gdHlwZW9mKGpzb24uaXRlbXMpKSB7ICAvLyBWZXJzaW9uIDFcbiAgICAgICAgICAgICAgICAgICAgLy9qc29uLnNoaWZ0KCkgIC8vIEFzc3VtZSBmaXJzdCBub2RlIGlzIGEgY29udGVudCBub2RlXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBqc29uLmxlbmd0aC0xOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoanNvbltqXS50eXBlICE9IFwiQW5ub3RhdGlvblwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW5ub3RhdGlvbl9pbmZvID0ganNvbltqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRMYWJlbCA9IGFubm90YXRpb25faW5mb1tcImRjdGVybXM6dGl0bGVcIl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcnRVUkwgPSBhbm5vdGF0aW9uX2luZm9bXCJhcnQ6dXJsXCJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGFubm90YXRpb25faW5mb1tcImRjdGVybXM6dGl0bGVcIl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb24uc3BsaWNlKGosMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwganNvbltqXS50YXJnZXQuc2VsZWN0b3IubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCdGcmFnbWVudFNlbGVjdG9yJyAhPSBqc29uW2pdLnRhcmdldC5zZWxlY3RvcltrXS50eXBlKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbltqXS50YXJnZXQuc2VsZWN0b3Jba10udmFsdWUgPSBqc29uW2pdLnRhcmdldC5zZWxlY3RvcltrXS52YWx1ZS5yZXBsYWNlKCcjdD1ucHQ6JywndD0nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAgLy8gVmVyc2lvbiAyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGVudExhYmVsID0ganNvbi5sYWJlbC5lblswXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcnRVUkwgPSBqc29uLml0ZW1zWzBdLmNvbnRlbnQuaWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuYW5ub3RhdGlvbk1hbmFnZXIuUG9wdWxhdGVGcm9tSlNPTihkYXRhKTtcbiAgICAgICAgICAgICAgICB0aGlzLkFubm90YXRpb25zTG9hZGVkKCk7XG4gICAgICAgICAgICB9KS5mYWlsKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBhbm5vdGF0aW9ucyBmcm9tIGxvY2FsIGNhY2hlXCJcXG4ke3Jlc3BvbnNlLnJlc3BvbnNlSlNPTi5kZXRhaWx9LmApO1xuICAgICAgICAgICAgICAgIHRoaXMuYW5ub3RhdG9yLm1lc3NhZ2VPdmVybGF5LlNob3dFcnJvcihgQ291bGQgbm90IHJldHJpZXZlIGFubm90YXRpb25zITxicj4oJHtyZXNwb25zZS5yZXNwb25zZUpTT04uZGV0YWlsfSlgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wbGF5ZXIuJGNvbnRhaW5lci5vbihcIk9uVGltZVVwZGF0ZVwiLCAoZXZlbnQsIHRpbWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuT25UaW1lVXBkYXRlKHRpbWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLiRjb250YWluZXIub24oXCJPblBvbHlDbGlja2VkXCIsIChldmVudCwgYW5ub3RhdGlvbikgPT4ge1xuICAgICAgICAgICAgLy8gRWRpdCBhIHBvbHkgd2hlbiBjbGlja2VkLCBidXQgb25seSBpZiB0aGUgZWRpdG9yIGlzbid0IGFscmVhZHkgb3BlblxuICAgICAgICAgICAgaWYoIXRoaXMuZ3VpLm9wZW4pe1xuICAgICAgICAgICAgICAgIHRoaXMuJGFkZEFubm90YXRpb25CdXR0b24uYnV0dG9uKFwiZGlzYWJsZVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmd1aS5CZWdpbkVkaXRpbmcoYW5ub3RhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuJGNvbnRhaW5lci5vbihcIk9uUG9seWdvbkNsaWNrZWRcIiwgKGV2ZW50LCBhbm5vdGF0aW9uKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIk9uUG9seWdvbkNsaWNrZWQgZXZlbnQgY2FwdHVyZWRcIik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuJGNvbnRhaW5lci5vbihcIk9uQW5pbWF0aW9uQ2xpY2tlZFwiLCAoZXZlbnQsIGFubm90YXRpb24pID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiT25BbmltYXRpb25DbGlja2VkIGV2ZW50IGNhcHR1cmVkXCIpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmd1aS4kY29udGFpbmVyLm9uKFwiT25HVUlDbG9zZWRcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLiRhZGRBbm5vdGF0aW9uQnV0dG9uLmJ1dHRvbihcImVuYWJsZVwiKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy51cmwgPSB0aGlzLnBsYXllci52aWRlb0VsZW1lbnQuY3VycmVudFNyYztcblxuICAgICAgICBjb25zb2xlLmxvZyhcIltWaWRlb0Fubm90YXRvcl0gQW5ub3RhdG9yIGNyZWF0ZWQgZm9yIHZpZGVvLlwiKTtcbiAgICB9XG5cblxuICAgIHJlYWRDb25maWcoKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHJlcXVpcmUoXCIuLi9hbm5vdGF0b3ItY29uZmlnLmpzb25cIik7IFxuICAgICAgICB0aGlzLmFwaUtleSA9IGNvbmZpZy5hcGlfa2V5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBkaXZzIHRoYXQgc3Vycm91bmQgdGhlIHZpZGVvIHBsYXllci5cbiAgICAgKi9cbiAgICBXcmFwKCl7XG4gICAgICAgIC8vIFdyYXAgdGhlIHZpZGVvIHBsYXllciB3aXRoIHRoaXMgY29udGFpbmVyLiBDYW4ndCB1c2UgLndyYXAgZHVlIHRvIGR1cGxpY2F0aW9uIGlzc3VlcyAgICBcbiAgICAgICAgdmFyIHZpZGVvQ29udGFpbmVyID0gJCh0aGlzLnBsYXllci4kY29udGFpbmVyKS5wYXJlbnQoKTtcbiAgICAgICAgdmFyIHdhbGRvcmZDb250YWluZXIgPSAkKFwiPGRpdiBjbGFzcz0nd2FsZG9yZi1jb250YWluZXInPjwvZGl2PlwiKTtcbiAgICAgICAgd2FsZG9yZkNvbnRhaW5lci5pbnNlcnRCZWZvcmUoJCh0aGlzLnBsYXllci4kY29udGFpbmVyKSk7XG4gICAgICAgIHdhbGRvcmZDb250YWluZXIuYXBwZW5kKHRoaXMucGxheWVyLiRjb250YWluZXIpO1xuICAgICAgICB0aGlzLiRjb250YWluZXIgPSB2aWRlb0NvbnRhaW5lci5wYXJlbnQoKTtcblxuICAgICAgICAvLyBTZXQgdGhlIGNvbnRhaW5lciB0byB0aGUgd2lkdGggb2YgdGhlIHZpZGVvIHBsYXllclxuICAgICAgICB0aGlzLiRjb250YWluZXIud2lkdGgodGhpcy5wbGF5ZXIuJGNvbnRhaW5lci53aWR0aCgpKTtcblxuICAgICAgICAvLyBBbGxvdyB0aGUgdmlkZW8gcGxheWVyIGNvbnRhaW5lciB0byBncm93XG4gICAgICAgIC8vdGhpcy5wbGF5ZXIuJGNvbnRhaW5lci53aWR0aChcIjEwMCVcIik7XG4gICAgICAgIC8vdGhpcy5wbGF5ZXIuJGNvbnRhaW5lci5oZWlnaHQoXCIxMDAlXCIpO1xuXG4gICAgICAgIC8vIENvcHkgdGhlIHZpZGVvIHN0eWxlcyB0byB0aGUgY29udGFpbmVyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMucGxheWVyLm9yaWdpbmFsU3R5bGVzKTtcbiAgICAgICAgdGhpcy4kY29udGFpbmVyLmNzcyh0aGlzLnBsYXllci5vcmlnaW5hbFN0eWxlcyk7XG4gICAgfVxuXG4gICAgUG9wdWxhdGVDb250cm9scygpe1xuICAgICAgICAvLyBDcmVhdGUgdGhlIHRpY2sgYmFyXG4gICAgICAgIHRoaXMudGlja0JhciA9IG5ldyBUaWNrQmFyKHRoaXMpO1xuXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgcG9seWdvbiBvdmVybGF5XG4gICAgICAgIHRoaXMucG9seU92ZXJsYXkgPSBuZXcgUG9seWdvbk92ZXJsYXkodGhpcyk7XG5cbiAgICAgICAgaWYoIXRoaXMua2lvc2tNb2RlICYmIHRoaXMuc2hvd01hbmlmZXN0KXtcbiAgICAgICAgICAgIHRoaXMuJGRlYnVnQ29udHJvbHMgPSAkKFwiPGRpdiBjbGFzcz0nd2FsZG9yZi1kZWJ1Zy1jb250cm9scyc+PC9kaXY+XCIpLmFwcGVuZFRvKHRoaXMuJGNvbnRhaW5lcik7XG4gICAgICAgICAgICB2YXIgJHNob3dBbGxBbm5vdGF0aW9uc0J1dHRvbiA9IHRoaXMuJGRlYnVnQ29udHJvbHMuYXBwZW5kKCc8YnV0dG9uPk9wZW4gQW5ub3RhdGlvbiBNYW5pZmVzdCBpbiBOZXcgV2luZG93PC9idXR0b24+Jyk7XG4gICAgICAgICAgICAkc2hvd0FsbEFubm90YXRpb25zQnV0dG9uLmNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgdXJsID0gdGhpcy5wbGF5ZXIudmlkZW9FbGVtZW50LmN1cnJlbnRTcmM7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXJ2ZXIuRmV0Y2hBbm5vdGF0aW9ucyhcImxvY2F0aW9uXCIsIHVybCkuZG9uZSgoanNvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgd2luID0gd2luZG93Lm9wZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYod2luID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiQ291bGRuJ3Qgc2hvdyBhbm5vdGF0aW9uIG1hbmlmZXN0OyBwbGVhc2UgYWxsb3cgcG9wLXVwcy5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2VPdmVybGF5LlNob3dFcnJvcihcIkNvdWxkbid0IHNob3cgYW5ub3RhdGlvbiBtYW5pZmVzdDsgcGxlYXNlIGFsbG93IHBvcC11cHMuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luLmRvY3VtZW50Lm9wZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbi5kb2N1bWVudC53cml0ZShgPHRpdGxlPkFubm90YXRpb24gTWFuaWZlc3QgZm9yICR7dXJsfTwvdGl0bGU+YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW4uZG9jdW1lbnQud3JpdGUoXCI8cHJlPlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbi5kb2N1bWVudC53cml0ZShKU09OLnN0cmluZ2lmeShqc29uLCBudWxsLCAyKS5lc2NhcGVIVE1MKCkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW4uZG9jdW1lbnQud3JpdGUoXCI8L3ByZT5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW4uZG9jdW1lbnQuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXcmFwIGFsbCB0aGUgYnV0dG9ucyB3aXRoIHRoZSBsaXN0IHRhZ1xuICAgICAgICAvL3RoaXMuJGRlYnVnQ29udHJvbHMud3JhcElubmVyKFwiPHVsPjwvdWw+XCIpO1xuICAgICAgICAvLyBXcmFwIGVhY2ggYnV0dG9uIHdpdGggdGhlIGxpc3QgZWxlbWVudCB0YWdcbiAgICAgICAgLy90aGlzLiRkZWJ1Z0NvbnRyb2xzLmZpbmQoXCJidXR0b25cIikud3JhcChcIjxsaT48L2xpPlwiKTtcblxuICAgICAgICAvLyBDcmVhdGUgdGhlIGluZm8gY29udGFpbmVyXG4gICAgICAgIHRoaXMuaW5mb0NvbnRhaW5lciA9IG5ldyBJbmZvQ29udGFpbmVyKHRoaXMpO1xuXG4gICAgICAgIGlmKHRoaXMuZGlzcGxheUluZGV4KSB0aGlzLmluZGV4Q29udGFpbmVyID0gbmV3IEluZGV4Q29udGFpbmVyKHRoaXMpO1xuXG4gICAgICAgIC8vIEluamVjdCB0aGUgYW5ub3RhdGlvbiBlZGl0IGJ1dHRvbiBpbnRvIHRoZSB0b29sYmFyXG4gICAgICAgIGlmKCF0aGlzLmtpb3NrTW9kZSl7XG4gICAgICAgICAgICB0aGlzLiRhZGRBbm5vdGF0aW9uQnV0dG9uID0gJChcIjxidXR0b24+QWRkIE5ldyBBbm5vdGF0aW9uPC9idXR0b24+XCIpLmJ1dHRvbih7XG4gICAgICAgICAgICAgICAgaWNvbjogXCJmYSBmYS1wbHVzXCIsXG4gICAgICAgICAgICAgICAgc2hvd0xhYmVsOiBmYWxzZVxuICAgICAgICAgICAgfSkuY2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuJGFkZEFubm90YXRpb25CdXR0b24uYnV0dG9uKFwiZGlzYWJsZVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmd1aS5CZWdpbkVkaXRpbmcoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5wbGF5ZXIuY29udHJvbEJhci5SZWdpc3RlckVsZW1lbnQodGhpcy4kYWRkQW5ub3RhdGlvbkJ1dHRvbiwgMywgJ2ZsZXgtZW5kJyk7XG5cbiAgICAgICAgICAgIC8vIEluamVjdCB0aGUgYW5ub3RhdGlvbiB1cGxvYWQgYnV0dG9uIGludG8gdGhlIHRvb2xiYXJcbiAgICAgICAgICAgIHRoaXMuJHVwbG9hZEFubm90YXRpb25CdXR0b24gPSAkKFwiPGJ1dHRvbiB0eXBlPSdmaWxlJz5JbXBvcnQgQW5ub3RhdGlvbiBGcm9tIEZpbGU8L2J1dHRvbj5cIikuYnV0dG9uKHtcbiAgICAgICAgICAgICAgICBpY29uOiBcImZhIGZhLXVwbG9hZFwiLFxuICAgICAgICAgICAgICAgIHNob3dMYWJlbDogZmFsc2VcbiAgICAgICAgICAgIH0pLmNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLkxvYWRGcm9tRmlsZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnBsYXllci5jb250cm9sQmFyLlJlZ2lzdGVyRWxlbWVudCh0aGlzLiR1cGxvYWRBbm5vdGF0aW9uQnV0dG9uLCAyLCAnZmxleC1lbmQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmd1aSA9IG5ldyBBbm5vdGF0aW9uR1VJKHRoaXMpO1xuXG4gICAgfVxuXG4gICAgQW5ub3RhdGlvbnNMb2FkZWQoKXtcbiAgICAgICAgLy9TZW5kIGFubm90YXRpb24gbG9hZGVkIGV2ZW50XG4gICAgICAgIHRoaXMuJGNvbnRhaW5lci50cmlnZ2VyKFwiT25Bbm5vdGF0aW9uc0xvYWRlZFwiLCB0aGlzLmFubm90YXRpb25NYW5hZ2VyKTtcbiAgICB9XG5cbiAgICBPblRpbWVVcGRhdGUodGltZSl7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbnNOb3cgPSB0aGlzLmFubm90YXRpb25NYW5hZ2VyLkFubm90YXRpb25zQXRUaW1lKHRpbWUpO1xuXG4gICAgICAgIGlmKHRoaXMuYW5ub3RhdGlvbnNOb3cuZXF1YWxzKHRoaXMubGFzdEFubm90YXRpb25TZXQpKXsgIFxuICAgICAgICAgICAgdGhpcy5TZXRBbm5vdGF0aW9uVGltZVBvc2l0aW9uKHRpbWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IFxuICAgICAgICB0aGlzLmxhc3RBbm5vdGF0aW9uU2V0ID0gdGhpcy5hbm5vdGF0aW9uc05vdztcblxuICAgICAgICB0aGlzLlVwZGF0ZVZpZXdzKCk7XG4gICAgfVxuXG4gICAgU2V0QW5ub3RhdGlvblRpbWVQb3NpdGlvbih0aW1lKXtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcInRpbWU6IFwiICsgdGltZSk7XG4gICAgICAgIC8vQ2hlY2sgc2FmYXJpIGFuZCBtdWx0aXBsZSBnZW9tZXRyaWMgYW5ub3RhdGlvblxuICAgICAgICBpZiAodGhpcy5Jc1NhZmFyaSgpICYmIHRoaXMuYW5ub3RhdGlvbnNOb3cubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbGV0IG1zZyA9IFwiTXVsdGlwbGUgZ2VvbWV0cmljIGFubm90YXRpb25zIGFyZSBkZXRlY3RlZC48YnI+XCI7XG4gICAgICAgICAgICBtc2cgKz0gXCJTYWZhcmkgZG9lc24ndCBzdXBwb3J0IG11bHRpcGxlIGdlb21ldHJpYyBhbm5vdGF0aW9ucy48YnI+XCI7XG4gICAgICAgICAgICBtc2cgKz0gXCJDaHJvbWUgb3IgRmlyZWZveCBhcmUgcmVjb21tZW5kZWQuXCI7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VPdmVybGF5LlNob3dNZXNzYWdlKG1zZywgMi4wKTtcbiAgICAgICAgICAgIHJldHVybjsgLy9ubyBhbmltYXRpb24gZm9yIHNhZmFyaSBicm93c2VyIHdpdGggbXVsdGlwbGUgZ2VvbWV0cmljIGFubm90YXRpb25cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hbm5vdGF0aW9uc05vdy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgIGxldCBhbm5vdGF0aW9uX2lkID0gdGhpcy5hbm5vdGF0aW9uc05vd1tpXS5pZDtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvbHlPdmVybGF5LnN2Z0VsZW1lbnRzSGFzaFthbm5vdGF0aW9uX2lkXSkge1xuICAgICAgICAgICAgICAgIHRoaXMucG9seU92ZXJsYXkuc3ZnRWxlbWVudHNIYXNoW2Fubm90YXRpb25faWRdLmFuaW1hdGUuYmVnaW5FbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgbGV0IHRpbWVfZGlmZiA9IHRpbWUgLSB0aGlzLmFubm90YXRpb25zTm93W2ldLmJlZ2luVGltZTtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudF90aW1lID0gdGhpcy5wb2x5T3ZlcmxheS5zdmdFbGVtZW50c0hhc2hbYW5ub3RhdGlvbl9pZF0uc3ZnRWxlbWVudC5nZXRDdXJyZW50VGltZSgpO1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJcXHQgaTpcIiArIGkgKyBcIiAoXCIgKyBhbm5vdGF0aW9uX2lkICsgXCIpLCBzdmcgY3VycmVudF90aW1lOlwiICsgY3VycmVudF90aW1lICsgXCIsIGFuaW1hdGUgdGltZV9kaWZmOiBcIiArIHRpbWVfZGlmZik7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2x5T3ZlcmxheS5zdmdFbGVtZW50c0hhc2hbYW5ub3RhdGlvbl9pZF0uc3ZnRWxlbWVudC5zZXRDdXJyZW50VGltZShjdXJyZW50X3RpbWUgKyB0aW1lX2RpZmYpO1xuICAgICAgICAgICAgICAgIHRoaXMucG9seU92ZXJsYXkuc3ZnRWxlbWVudHNIYXNoW2Fubm90YXRpb25faWRdLmFuaW1hdGUuZW5kRWxlbWVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgIH1cblxuICAgIFVwZGF0ZVZpZXdzKCl7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJhbm5vdGF0b3IuanM6MjY3IFVwZGF0ZVZpZXdzXCIpO1xuICAgICAgICB0aGlzLmFubm90YXRpb25zTm93ID0gdGhpcy5hbm5vdGF0aW9uTWFuYWdlci5Bbm5vdGF0aW9uc0F0VGltZSh0aGlzLnBsYXllci52aWRlb0VsZW1lbnQuY3VycmVudFRpbWUpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgaW5mbyBjb250YWluZXJcbiAgICAgICAgdGhpcy5pbmZvQ29udGFpbmVyLlJlYnVpbGQodGhpcy5hbm5vdGF0aW9uc05vdywgdGhpcy5jbGVhckNvbnRhaW5lcik7XG5cbiAgICAgICAgdGhpcy4kY29udGFpbmVyLnRyaWdnZXIoXCJPbk5ld0Fubm90YXRpb25TZXRcIiwgW3RoaXMuYW5ub3RhdGlvbnNOb3ddKTtcbiAgICAgICAgdGhpcy5TZXRBbm5vdGF0aW9uVGltZVBvc2l0aW9uKHRoaXMucGxheWVyLnZpZGVvRWxlbWVudC5jdXJyZW50VGltZSk7XG4gICAgfVxuXG4gICAgR2V0QW5ub3RhdGlvbnMoKXtcbiAgICAgICAgbGV0IG9yZGVyZWQgPSB0aGlzLmFubm90YXRpb25NYW5hZ2VyLmFubm90YXRpb25zLnNsaWNlKCk7XG4gICAgICAgIGxldCBvcmRlckJ5U3RhcnQgPSBmdW5jdGlvbihhLCBiKXtcbiAgICAgICAgICAgIGxldCBhVGltZSA9IGEuYmVnaW5UaW1lO1xuICAgICAgICAgICAgbGV0IGJUaW1lID0gYi5iZWdpblRpbWU7XG4gICAgICAgICAgICByZXR1cm4gKChhVGltZSA8IGJUaW1lKSA/IC0xIDogKChhVGltZSA+IGJUaW1lKSA/IDEgOiAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgb3JkZXJlZC5zb3J0KG9yZGVyQnlTdGFydCk7XG4gICAgICAgIHJldHVybiBvcmRlcmVkO1xuICAgIH1cblxuICAgIFJlZ2lzdGVyTmV3QW5ub3RhdGlvbihhbm5vdGF0aW9uKXtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhhbm5vdGF0aW9uKTtcbiAgICAgICAgLy90aGlzLmFubm90YXRpb25NYW5hZ2VyLlJlZ2lzdGVyQW5ub3RhdGlvbihhbm5vdGF0aW9uKTtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uTWFuYWdlci5Qb3B1bGF0ZUZyb21KU09OKGFubm90YXRpb24pO1xuXG4gICAgICAgIC8vIFRocm93IGV2ZW50IGZvciBsaXN0ZW5pbmcgb2JqZWN0cyAoZS5nLiB0aWNrLWJhcilcbiAgICAgICAgdGhpcy4kY29udGFpbmVyLnRyaWdnZXIoXCJPbkFubm90YXRpb25SZWdpc3RlcmVkXCIsIFthbm5vdGF0aW9uXSk7XG5cbiAgICAgICAgLy8gVXBkYXRlIGRlcGVuZGVudCB2aWV3c1xuICAgICAgICB0aGlzLlVwZGF0ZVZpZXdzKCk7XG4gICAgfVxuXG4gICAgVXBkYXRlQW5ub3RhdGlvbihhbm5vdGF0aW9uLCBvbGRJRCl7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbk1hbmFnZXIuVXBkYXRlQW5ub3RhdGlvbihhbm5vdGF0aW9uLCBvbGRJRCk7XG5cbiAgICAgICAgLy8gVGhyb3cgZXZlbnQgZm9yIGxpc3RlbmluZyBvYmplY3RzIChlLmcuIHRpY2stYmFyKVxuICAgICAgICB0aGlzLiRjb250YWluZXIudHJpZ2dlcihcIk9uQW5ub3RhdGlvblJlbW92ZWRcIiwgW29sZElEXSk7XG4gICAgICAgIHRoaXMuJGNvbnRhaW5lci50cmlnZ2VyKFwiT25Bbm5vdGF0aW9uUmVnaXN0ZXJlZFwiLCBbYW5ub3RhdGlvbl0pO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBkZXBlbmRlbnQgdmlld3NcbiAgICAgICAgdGhpcy5VcGRhdGVWaWV3cygpO1xuICAgIH1cblxuICAgIERlcmVnaXN0ZXJBbm5vdGF0aW9uKGFubm90YXRpb24pe1xuICAgICAgICB2YXIgaWQgPSAnJztcbiAgICAgICAgaWYgKCd1bmRlZmluZWQnID09IHR5cGVvZihhbm5vdGF0aW9uLml0ZW1zKSkgeyAvLyBWZXIgMVxuICAgICAgICAgICAgaWQgPSBhbm5vdGF0aW9uLmlkO1xuICAgICAgICB9IGVsc2UgeyAvLyBWZXIgMlxuICAgICAgICAgICAgaWQgPSBhbm5vdGF0aW9uLml0ZW1zWzBdLml0ZW1zWzBdLml0ZW1zWzBdLmlkO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLmFubm90YXRpb25NYW5hZ2VyLlJlbW92ZUFubm90YXRpb24oaWQpO1xuICAgICAgICAvL3RoaXMuYW5ub3RhdGlvbnNOb3cgPSB0aGlzLmFubm90YXRpb25NYW5hZ2VyLkFubm90YXRpb25zQXRUaW1lKHRoaXMucGxheWVyLnZpZGVvRWxlbWVudC5jdXJyZW50VGltZSk7XG5cbiAgICAgICAgLy8gVGhyb3cgZXZlbnQgZm9yIGxpc3RlbmluZyBvYmplY3RzIChlLmcuIHRpY2stYmFyKVxuICAgICAgICB0aGlzLiRjb250YWluZXIudHJpZ2dlcihcIk9uQW5ub3RhdGlvblJlbW92ZWRcIiwgW2lkXSk7XG5cbiAgICAgICAgLy8gVXBkYXRlIGRlcGVuZGVudCB2aWV3c1xuICAgICAgICB0aGlzLlVwZGF0ZVZpZXdzKCk7XG5cbiAgICB9XG5cbiAgICBMb2FkRnJvbUZpbGUoKSB7XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgZGlhbG9nXG4gICAgICAgIGxldCAkY29udGFpbmVyID0gJChcIjxkaXYgY2xhc3M9J3dhbGRvcmYtc2Vzc2lvbi1tb2RhbCcgdGl0bGU9J0ltcG9ydCBBbm5vdGF0aW9uJz48L2Rpdj5cIik7IC8vIE91dGVybW9zdCBIVE1MXG4gICAgICAgIGxldCAkaGVhZFRleHQgPSAkKFwiPHAgY2xhc3M9J3ZhbGlkYXRlVGlwcyc+QW5ub3RhdGlvbnMgbXVzdCBiZSBXM0MgT0EgY29tcGxpYW50IGluIEpTT04gZm9ybWF0LjwvcD5cIikuYXBwZW5kVG8oJGNvbnRhaW5lcik7XG4gICAgICAgIGxldCAkZXJyb3JUZXh0ID0gJChcIjxwIGNsYXNzPSd2YWxpZGF0ZVRpcHMgbW9kYWwtZXJyb3ItdGV4dCc+PC9wPlwiKS5hcHBlbmRUbygkY29udGFpbmVyKTtcbiAgICAgICAgJGVycm9yVGV4dC5oaWRlKCk7XG4gICAgICAgIGxldCAkZm9ybSA9ICQoXCI8Zm9ybT48L2Zvcm0+XCIpLmFwcGVuZFRvKCRjb250YWluZXIpO1xuXG4gICAgICAgIGxldCAkaW1wb3J0RmllbGQ7XG5cbiAgICAgICAgJChcIjxsYWJlbCBmb3I9J2ltcG9ydEZpbGUnPlNlbGVjdCBGaWxlPC9sYWJlbD5cIikuYXBwZW5kVG8oJGZvcm0pO1xuICAgICAgICAkaW1wb3J0RmllbGQgPSAkKFwiPGlucHV0IHR5cGU9J2ZpbGUnIG5hbWU9J2ltcG9ydEZpbGUnIGNsYXNzPSdmaWxlIHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGwnPlwiKS5hcHBlbmRUbygkZm9ybSk7XG4gICAgICAgIFxuICAgICAgICAkZm9ybS53cmFwSW5uZXIoXCI8ZmllbGRzZXQgLz5cIik7XG5cbiAgICAgICAgbGV0IGVycm9yID0gKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICAkZXJyb3JUZXh0Lmh0bWwobWVzc2FnZSk7XG4gICAgICAgICAgICAkZXJyb3JUZXh0LnNob3coKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzZWxmID0gdGhpcztcbiAgICAgICAgJGltcG9ydEZpZWxkLm9uKCdjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgZmlsZXMgPSAkaW1wb3J0RmllbGQuZ2V0KDApLmZpbGVzO1xuICAgICAgICAgICAgbGV0IGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcblxuICAgICAgICAgICAgZnIub25sb2FkID0gKChsb2NhbEZpbGUpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgSlNPTiBpcyBtYWxmb3JtZWQsIHNob3cgYW4gZXJyb3IgYW5kIHN0b3AgaGVyZS5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBKU09OLnBhcnNlKGxvY2FsRmlsZS50YXJnZXQucmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKFwiSlNPTiBmaWxlIGlzIG1hbGZvcm1lZCFcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgbG9jYWxKc29uID0gSlNPTi5wYXJzZShsb2NhbEZpbGUudGFyZ2V0LnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgaWYodHlwZW9mKGxvY2FsSnNvbi50YXJnZXQpIT1cInVuZGVmaW5lZFwiKXtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFubm90YXRpb24gPSBuZXcgQW5ub3RhdGlvbihsb2NhbEpzb24pO1xuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLlZhbGlkYXRlQW5ub3RhdGlvbihhbm5vdGF0aW9uKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPcGVuIHRoZSBHVUkgYW5kIHBvcHVsYXRlIGl0IHdpdGggdGhpcyBhbm5vdGF0aW9uJ3MgZGF0YS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ3VpLkJlZ2luRWRpdGluZyhhbm5vdGF0aW9uLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ3VpLkNvbW1pdEFubm90YXRpb25Ub1NlcnZlcihmdW5jdGlvbigpe3JldHVybjt9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKFwiSlNPTiBpcyBpbnZhbGlkIVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPGxvY2FsSnNvbi5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYW5ub3RhdGlvbiA9IG5ldyBBbm5vdGF0aW9uKGxvY2FsSnNvbltpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0aGlzLlZhbGlkYXRlQW5ub3RhdGlvbihhbm5vdGF0aW9uKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3BlbiB0aGUgR1VJIGFuZCBwb3B1bGF0ZSBpdCB3aXRoIHRoaXMgYW5ub3RhdGlvbidzIGRhdGEuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ndWkuQmVnaW5FZGl0aW5nKGFubm90YXRpb24sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ3VpLkNvbW1pdEFubm90YXRpb25Ub1NlcnZlcigoYW5ub3RhdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLlJlZ2lzdGVyTmV3QW5ub3RhdGlvbihhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ndWkuQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKFwiSlNPTiBpcyBpbnZhbGlkIVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkZGlhbG9nLmRpYWxvZyhcImNsb3NlXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmci5yZWFkQXNUZXh0KGZpbGVzWzBdKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0ICRkaWFsb2cgPSAkY29udGFpbmVyLmRpYWxvZyh7XG4gICAgICAgICAgICBhdXRvT3BlbjogdHJ1ZSxcbiAgICAgICAgICAgIGRyYWdnYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBtb2RhbDogdHJ1ZSxcbiAgICAgICAgICAgIGJ1dHRvbnM6IHtcbiAgICAgICAgICAgICAgICBDYW5jZWw6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgJGRpYWxvZy5kaWFsb2coXCJjbG9zZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2U6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAkZGlhbG9nLmZpbmQoXCJmb3JtXCIpWyAwIF0ucmVzZXQoKTtcbiAgICAgICAgICAgICAgICAkZGlhbG9nLmZpbmQoXCJpbnB1dFwiKS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1lcnJvclwiICk7XG4gICAgICAgICAgICAgICAgLy90aGlzLk9uTW9kYWxDbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBWYWxpZGF0ZUFubm90YXRpb24oYW5ub3RhdGlvbikge1xuICAgICAgICAvLyBUT0RPOiBWYWxpZGF0ZSBhbm5vdGF0aW9uIGhlcmUuIFJldHVybiBmYWxzZSBpZiBhbnlcbiAgICAgICAgLy8gcmVxdWlyZWQgcHJvcGVydGllcyBhcmUgbm90IHByZXNlbnQuXG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gY2hlY2tpbmcgd2hldGhlciB0aGUgYnJvd3NlciBpcyBzYWZhcmkgb3Igbm90XG4gICAgSXNTYWZhcmkoKSB7XG4gICAgICAgIC8vcmVmOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80OTg3MjExMS9kZXRlY3Qtc2FmYXJpLWFuZC1zdG9wLXNjcmlwdFxuICAgICAgICBsZXQgaXNTYWZhcmkgPSAvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgICAgICByZXR1cm4gaXNTYWZhcmk7XG4gICAgfVxuXG5cbn1cblxuZXhwb3J0IHsgVmlkZW9Bbm5vdGF0b3IgfTsiLCJpbXBvcnQgeyBHZXRGb3JtYXR0ZWRUaW1lLCBHZXRTZWNvbmRzRnJvbUhNUyB9IGZyb20gXCIuLi8uLi91dGlscy90aW1lLmpzXCI7XG5pbXBvcnQgeyBQb2x5Z29uRWRpdG9yIH0gZnJvbSBcIi4vcG9seWdvbi1lZGl0b3IuanNcIjtcbmltcG9ydCB7IEFubm90YXRpb24gfSBmcm9tIFwiLi4vYW5ub3RhdGlvbi5qc1wiO1xuaW1wb3J0IHsgdHNUaGlzVHlwZSB9IGZyb20gXCJAYmFiZWwvdHlwZXNcIjtcblxuY2xhc3MgQW5ub3RhdGlvbkdVSSB7XG5cbiAgICBjb25zdHJ1Y3Rvcihhbm5vdGF0b3Ipe1xuICAgICAgICB0aGlzLmFubm90YXRvciA9IGFubm90YXRvcjtcblxuICAgICAgICB0aGlzLkNyZWF0ZSgpO1xuXG4gICAgICAgIHRoaXMub3BlbiA9IGZhbHNlO1xuXG4gICAgICAgIC8vSGlkZSB0aGUgY29udGFpbmVyXG4gICAgICAgIHRoaXMuaXNWaXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuJGNvbnRhaW5lci5tYWtlVmlzaWJsZShmYWxzZSk7XG5cbiAgICAgICAgdGhpcy5wb2x5RWRpdG9yID0gbmV3IFBvbHlnb25FZGl0b3IodGhpcy5hbm5vdGF0b3IpO1xuXG4gICAgICAgIHRoaXMuYW5ub3RhdG9yLiRjb250YWluZXIub24oXCJPblBvbHlnb25FZGl0aW5nRW5kZWRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5TZXRWaXNpYmxlKHRydWUpO1xuICAgICAgICAgICAgdGhpcy5wb2x5RWRpdG9yLlNob3dKdXN0UG9seWdvbigpO1xuICAgICAgICB9KTtcblxuICAgIH1cblxuICAgIENyZWF0ZSgpe1xuICAgICAgICAvKlxuICAgICAgICAgKiAvL25ldyBVSVxuICAgICAgICAgKiBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuJGNvbnRhaW5lciA9ICQoXCI8ZGl2IGlkPSdjcmVhdGUtZGlhbG9nJyBjbGFzcz0ndWktd2lkZ2V0LWNvbnRlbnQgY2VudGVyJz5cIikuYXBwZW5kVG8odGhpcy5hbm5vdGF0b3IucGxheWVyLiRjb250YWluZXIpO1xuICAgICAgICB0aGlzLiRjb250YWluZXIuZHJhZ2dhYmxlKCk7XG4gICAgICAgIHRoaXMuJHRpdGxlID0gJChcIjxkaXYgY2xhc3M9J2RpYWxvZy10aXRsZSc+Q3JlYXRlIEFubm90YXRpb248L2Rpdj5cIikuYXBwZW5kVG8odGhpcy4kY29udGFpbmVyKTtcblxuICAgICAgICAvLyBNYWtlIGNhbmNlbCBidXR0b25cbiAgICAgICAgbGV0ICRleGl0QnV0dG9uID0gJChcIjxidXR0b24+RXhpdCBBbm5vdGF0aW9uIEVkaXRpbmc8L2J1dHRvbj5cIikuYnV0dG9uKHtcbiAgICAgICAgICAgIGljb25zOiB7cHJpbWFyeTogJ2ZhIGZhLXJlbW92ZSd9LFxuICAgICAgICAgICAgc2hvd0xhYmVsOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgJGV4aXRCdXR0b24uY3NzKFwiZmxvYXRcIiwgXCJyaWdodFwiKTtcbiAgICAgICAgJGV4aXRCdXR0b24uYXR0cigndGl0bGUnLCBcIkV4aXQgYW5ub3RhdGlvbiBlZGl0aW5nXCIpO1xuICAgICAgICAkZXhpdEJ1dHRvbi5hZGRDbGFzcyhcIndhbGRvcmYtY2FuY2VsLWJ1dHRvblwiKTtcbiAgICAgICAgJGV4aXRCdXR0b24uY2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wb2x5RWRpdG9yLlJlc2V0UG9seWdvbnMoKTtcbiAgICAgICAgICAgIHRoaXMuQ2xvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuUmVnaXN0ZXJFbGVtZW50KCRleGl0QnV0dG9uLCB0aGlzLiR0aXRsZSwgLTEpO1xuXG4gICAgICAgIHRoaXMuJHRhYnMgPSAkKFwiPGRpdiBpZD0ndGFicyc+PC9kaXY+XCIpLmFwcGVuZFRvKHRoaXMuJGNvbnRhaW5lcik7XG4gICAgXG4gICAgICAgIFxuICAgICAgICBsZXQgJHRhYlVJID0gJChcIjx1bD48L3VsPlwiKTtcbiAgICAgICAgbGV0ICRzdGFydFVJID0gJChcIjxsaT48YSBocmVmPScjc3RhcnRfdGFiJz5TdGFydCA8L2E+PC9saT5cIik7XG4gICAgICAgIGxldCAkYm9keVVJID0gJChcIjxsaT48YSBocmVmPScjYm9keV90YWInPkJvZHkgPC9hPjwvbGk+XCIpO1xuICAgICAgICBsZXQgJHN0b3BVSSA9ICQoXCI8bGk+PGEgaHJlZj0nI3N0b3BfdGFiJz5TdG9wIDwvYT48L2xpPlwiKTtcbiAgICAgICAgdGhpcy5SZWdpc3RlckVsZW1lbnQoJHRhYlVJLCB0aGlzLiR0YWJzLCAtMSk7XG4gICAgICAgIHRoaXMuUmVnaXN0ZXJFbGVtZW50KCRzdGFydFVJLCAkdGFiVUksIC0xKTtcbiAgICAgICAgdGhpcy5SZWdpc3RlckVsZW1lbnQoJGJvZHlVSSwgJHRhYlVJLCAtMSk7XG4gICAgICAgIHRoaXMuUmVnaXN0ZXJFbGVtZW50KCRzdG9wVUksICR0YWJVSSwgLTEpO1xuXG4gICAgICAgIC8vQ3JlYXRlIHRhYnNcbiAgICAgICAgbGV0ICRzdGFydFRhYiA9ICQoXCI8ZGl2IGlkPSdzdGFydF90YWInIGNsYXNzPSd1aS1maWVsZC1jb250YWluJz48L2Rpdj5cIik7XG4gICAgICAgIHRoaXMuUmVnaXN0ZXJFbGVtZW50KCRzdGFydFRhYiwgdGhpcy4kdGFicywgLTEpO1xuXG4gICAgICAgIGxldCAkYm9keVRhYiA9ICQoXCI8ZGl2IGlkPSdib2R5X3RhYic+PC9kaXY+XCIpO1xuICAgICAgICB0aGlzLlJlZ2lzdGVyRWxlbWVudCgkYm9keVRhYiwgdGhpcy4kdGFicywgLTEpO1xuXG4gICAgICAgIGxldCAkc3RvcFRhYiA9ICQoXCI8ZGl2IGlkPSdzdG9wX3RhYic+PC9kaXY+XCIpO1xuICAgICAgICB0aGlzLlJlZ2lzdGVyRWxlbWVudCgkc3RvcFRhYiwgdGhpcy4kdGFicywgLTEpO1xuXG4gICAgICAgIC8vQmVnaW4gZmlsbGluZyBzdGFydCB0YWJcbiAgICAgICAgLy8gTWFrZSBcIlN0YXJ0IHRpbWVcIiBsYWJlbCBhbmQgZmllbGRcbiAgICAgICAgdGhpcy4kdGltZVN0YXJ0RmllbGQgPSAkKCc8aW5wdXQgdHlwZT1cInRleHRcIiBuYW1lPVwidGltZS1zdGFydFwiIGlkPVwidGltZS1zdGFydFwiIHZhbHVlPVwiXCI+PGJyPjxicj4nKTtcbiAgICAgICAgdGhpcy4kdGltZVN0YXJ0RmllbGQud2lkdGgoNzIpO1xuICAgICAgICB0aGlzLiR0aW1lU3RhcnRGaWVsZC5jc3MoXCJmb250LWZhbWlseVwiLCBcIkNvdXJpZXIsIG1vbm9zcGFjZVwiKTtcbiAgICAgICAgdGhpcy4kdGltZVN0YXJ0RmllbGQuY3NzKFwibWFyZ2luLXJpZ2h0XCIsIFwiMnB4XCIpO1xuICAgICAgICB0aGlzLiR0aW1lU3RhcnRGaWVsZC5hZGRDbGFzcyhcInVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYWxsXCIpO1xuICAgICAgICB0aGlzLiR0aW1lU3RhcnRGaWVsZC5hdHRyKCd0aXRsZScsIFwiU3RhcnQgdGltZSAoaGg6bW06c3Muc3MpXCIpO1xuICAgICAgICB0aGlzLiR0aW1lU3RhcnRGaWVsZC5vbigna2V5cHJlc3MnLCBmdW5jdGlvbihldmVudCl7XG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSA0NiB8fCAoZXZlbnQua2V5Q29kZSA+PSA0OCAmJiBldmVudC5rZXlDb2RlIDw9IDU4KSl7IC8vMC05LCBwZXJpb2QsIGFuZCBjb2xvblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcblxuICAgICAgICAvL2FkZCBzdGFydCBtYXJrZXIgYnV0dG9uXG4gICAgICAgIHRoaXMuJHN0YXJ0VGltZU1hcmtlciA9ICQoXCI8YnV0dG9uIHN0eWxlPSdwYWRkaW5nOjA7IGxpbmUtaGVpZ2h0OjEuNCc+U2V0IFN0YXJ0PC9idXR0b24+IFwiKS5idXR0b24oe1xuICAgICAgICAgICAgaWNvbjogXCJmYSBmYS1tYXAtbWFya2VyXCIsXG4gICAgICAgICAgICBzaG93TGFiZWw6IGZhbHNlXG4gICAgICAgIH0pLmNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuJHRpbWVTdGFydEZpZWxkWzBdLnZhbHVlID0gR2V0Rm9ybWF0dGVkVGltZSh0aGlzLmFubm90YXRvci5wbGF5ZXIudmlkZW9FbGVtZW50LmN1cnJlbnRUaW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuUmVnaXN0ZXJFbGVtZW50KHRoaXMuJHN0YXJ0VGltZU1hcmtlciwgJHN0YXJ0VGFiLCAtMik7ICAgXG5cbiAgICAgICAgJChcIjxsYWJlbCBmb3I9J3RpbWUtc3RhcnQnPlN0YXJ0IFRpbWU6IDwvbGFiZWw+IFwiKS5hcHBlbmRUbygkc3RhcnRUYWIpO1xuICAgICAgICB0aGlzLiR0aW1lU3RhcnRGaWVsZC5hcHBlbmRUbygkc3RhcnRUYWIpO1xuXG4gICAgICAgIC8vTWFrZSBcIkVkaXQgcG9seWdvblwiIGJ1dHRvblxuICAgICAgICBsZXQgJGVkaXRQb2x5QnV0dG9uID0gJChcIjxidXR0b24gc3R5bGU9J3BhZGRpbmc6MDsgbGluZS1oZWlnaHQ6MS40Jz5FZGl0IFBvbHlnb248L2J1dHRvbj5cIikuYnV0dG9uKHtcbiAgICAgICAgICAgIGljb246IFwiZmEgZmEtcGVuY2lsXCIsXG4gICAgICAgICAgICBzaG93TGFiZWw6IGZhbHNlXG4gICAgICAgIH0pLmNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuU2V0VmlzaWJsZShmYWxzZSk7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiYW5ub3RhdGlvbi1ndWk6MzUzIENyZWF0ZVwiKTtcbiAgICAgICAgICAgIHRoaXMucG9seUVkaXRvci5CZWdpbkVkaXRpbmcoJ3N0YXJ0Jyk7XG4gICAgICAgIH0pO1xuICAgICAgICAkZWRpdFBvbHlCdXR0b24uYXR0cigndGl0bGUnLCBcIkVkaXQgcG9seWdvblwiKTtcbiAgICAgICAgdGhpcy5SZWdpc3RlckVsZW1lbnQoJGVkaXRQb2x5QnV0dG9uLCAkc3RhcnRUYWIsIC0xKTtcblxuICAgICAgICBsZXQgJHN0YXJ0VGFyZ2V0TGFiZWwgPSAkKFwiPGxhYmVsPlN0YXJ0IFRhcmdldDwvbGFiZWw+IFwiKTtcbiAgICAgICAgJHN0YXJ0VGFyZ2V0TGFiZWwuY3NzKFwiY29sb3JcIiwgXCJ3aGl0ZVwiKTtcbiAgICAgICAgdGhpcy5SZWdpc3RlckVsZW1lbnQoJHN0YXJ0VGFyZ2V0TGFiZWwsICRzdGFydFRhYiwgLTEpO1xuXG4gIFxuICAgICAgICBcbiAgICAgICAgLy9zdGFydCBwb2ludCBwb2x5Z29uIGlzIGFkZGVkIChUaGlzIHNlZW1zIHRvIGJlIHVudXNlZD8gSlBCIDIwMjEtMDktMTYpXG4gICAgICAgIC8vIHRoaXMuJHN0YXJ0UG9seWdvblNldCA9ICQoXCI8YnV0dG9uIHN0eWxlPSdwYWRkaW5nOjA7IGxpbmUtaGVpZ2h0OjEuNCc+U3RhcnQgUG9seWdvbiBTZXQ8L2J1dHRvbj5cIikuYnV0dG9uKHtcbiAgICAgICAgLy8gICAgIGljb246IFwiZmEgZmEtY2hlY2stc3F1YXJlLW9cIixcbiAgICAgICAgLy8gICAgIHNob3dMYWJlbDogZmFsc2VcbiAgICAgICAgLy8gfSk7XG4gICAgICAgIC8vIC8vdGhpcy4kc3RhcnRQb2x5Z29uU2V0LmNzcyhcInZpc2liaWxpdHlcIiwgXCJpbmhlcml0XCIpO1xuICAgICAgICAvLyB0aGlzLiRzdGFydFBvbHlnb25TZXQuY3NzKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcbiAgICAgICAgLy8gdGhpcy4kc3RhcnRQb2x5Z29uU2V0LmFkZENsYXNzKFwid2FsZG9yZi1jb25maXJtLWJ1dHRvblwiKTtcbiAgICAgICAgLy90aGlzLlJlZ2lzdGVyRWxlbWVudCh0aGlzLiRzdGFydFBvbHlnb25TZXQsICRzdGFydFRhYiwgLTIpOyBcblxuXG4gICAgICAgIC8vIEFkZCB0YWdzIGlucHV0IGZpZWxkXG4gICAgICAgIHRoaXMuJHRhZ3NGaWVsZCA9ICQoJzxzZWxlY3QgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBtdWx0aXBsZT1cIm11bHRpcGxlXCI+PC9zZWxlY3Q+Jyk7XG4gICAgICAgIHRoaXMuJHRhZ3NGaWVsZC53aWR0aChcIjEwMCVcIik7XG4gICAgICAgIHRoaXMuJHRhZ3NGaWVsZC5jc3MoXCJtYXJnaW4tdG9wXCIsIFwiLThweFwiKTtcbiAgICAgICAgdGhpcy5SZWdpc3RlckVsZW1lbnQodGhpcy4kdGFnc0ZpZWxkLCAkYm9keVRhYiwgLTEpO1xuICAgICAgICB0aGlzLiR0YWdzRmllbGQuc2VsZWN0Mih7XG4gICAgICAgICAgICB0YWdzOiB0cnVlLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXI6IFwiVGFnc1wiLFxuICAgICAgICAgICAgYWpheDogdGhpcy5HZXRUYWdzUXVlcnkoKSxcbiAgICAgICAgICAgIHNlbGVjdE9uQmx1cjogdHJ1ZSxcbiAgICAgICAgICAgIC8vIEFsbG93IG1hbnVhbGx5IGVudGVyZWQgdGV4dCBpbiBkcm9wIGRvd24uXG4gICAgICAgICAgICBjcmVhdGVUYWc6IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpZDogcGFyYW1zLnRlcm0sXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHBhcmFtcy50ZXJtLFxuICAgICAgICAgICAgICAgICAgICBuZXdPcHRpb246IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBBZGQgY3VzdG9tIGNsYXNzIGZvciBicmluZ2luZyB0aGUgZHJvcGRvd24gdG8gdGhlIGZyb250IChmdWxsc2NyZWVuIGZpeClcbiAgICAgICAgdGhpcy4kdGFnc0ZpZWxkLmRhdGEoJ3NlbGVjdDInKS4kZHJvcGRvd24uYWRkQ2xhc3MoXCJzZWxlY3QyLWRyb3Bkb3duLWFubm90YXRvclwiKTtcblxuICAgICAgICAvLyBNYWtlIG5vdGVzIHRleHQgZmllbGRcbiAgICAgICAgdGhpcy4kdGV4dEZpZWxkID0gJCgnPHRleHRhcmVhIHR5cGU9XCJ0ZXh0XCIgbmFtZT1cImFubm8tdGV4dFwiIGlkPVwiYW5uby10ZXh0XCIgdmFsdWU9XCJcIiBwbGFjZWhvbGRlcj1cIk5vdGVzXCI+Jyk7XG4gICAgICAgIHRoaXMuJHRleHRGaWVsZC5jc3MoXCJtYXJnaW4tdG9wXCIsIFwiMnB4XCIpO1xuICAgICAgICB0aGlzLiR0ZXh0RmllbGQud2lkdGgoXCI5OC41JVwiKTtcbiAgICAgICAgdGhpcy4kdGV4dEZpZWxkLmFkZENsYXNzKFwidWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGxcIik7XG4gICAgICAgIHRoaXMuJHRleHRGaWVsZC5hdHRyKCd0aXRsZScsICdBbm5vdGF0aW9uIHRleHQnKTtcbiAgICAgICAgdGhpcy4kdGV4dEZpZWxkLmNzcyhcImZsZXgtZ3Jvd1wiLCAyKTtcbiAgICAgICAgdGhpcy5SZWdpc3RlckVsZW1lbnQodGhpcy4kdGV4dEZpZWxkLCAkYm9keVRhYiwgLTEpO1xuXG4gICAgICAgIC8vIE1ha2UgXCJTdG9wIHRpbWVcIiBsYWJlbCBhbmQgZmllbGRcbiAgICAgICAgdGhpcy4kdGltZUVuZEZpZWxkID0gJCgnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cInRpbWUtc3RvcFwiIGlkPVwidGltZS1zdG9wXCIgdmFsdWU9XCJcIj48YnI+PGJyPicpO1xuICAgICAgICB0aGlzLiR0aW1lRW5kRmllbGQud2lkdGgoNzIpO1xuICAgICAgICB0aGlzLiR0aW1lRW5kRmllbGQuY3NzKFwiZm9udC1mYW1pbHlcIiwgXCJDb3VyaWVyLCBtb25vc3BhY2VcIik7XG4gICAgICAgIHRoaXMuJHRpbWVFbmRGaWVsZC5jc3MoXCJtYXJnaW4tcmlnaHRcIiwgXCIycHhcIik7XG4gICAgICAgIHRoaXMuJHRpbWVFbmRGaWVsZC5hZGRDbGFzcyhcInVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYWxsXCIpO1xuICAgICAgICB0aGlzLiR0aW1lRW5kRmllbGQuYXR0cigndGl0bGUnLCBcIlN0YXJ0IHRpbWUgKGhoOm1tOnNzLnNzKVwiKTtcbiAgICAgICAgdGhpcy4kdGltZUVuZEZpZWxkLm9uKCdrZXlwcmVzcycsIGZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IDQ2IHx8IChldmVudC5rZXlDb2RlID49IDQ4ICYmIGV2ZW50LmtleUNvZGUgPD0gNTgpKXsgLy8wLTksIHBlcmlvZCwgYW5kIGNvbG9uXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vYWRkIGVuZCBtYXJrZXIgYnV0dG9uXG4gICAgICAgIHRoaXMuJGVuZFRpbWVNYXJrZXIgPSAkKFwiPGJ1dHRvbiBzdHlsZT0ncGFkZGluZzowOyBsaW5lLWhlaWdodDoxLjQnPlNldCBFbmQ8L2J1dHRvbj5cIikuYnV0dG9uKHtcbiAgICAgICAgICAgIGljb246IFwiZmEgZmEtbWFwLW1hcmtlclwiLFxuICAgICAgICAgICAgc2hvd0xhYmVsOiBmYWxzZVxuICAgICAgICB9KS5jbGljaygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLiR0aW1lRW5kRmllbGRbMF0udmFsdWUgPSBHZXRGb3JtYXR0ZWRUaW1lKHRoaXMuYW5ub3RhdG9yLnBsYXllci52aWRlb0VsZW1lbnQuY3VycmVudFRpbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuUmVnaXN0ZXJFbGVtZW50KHRoaXMuJGVuZFRpbWVNYXJrZXIsICRzdG9wVGFiLCAtMik7XG4gICAgICAgICQoXCI8bGFiZWwgZm9yPSdzdG9wX3RpbWUnPlN0b3AgVGltZTogPC9sYWJlbD4gXCIpLmFwcGVuZFRvKCRzdG9wVGFiKTtcbiAgICAgICAgdGhpcy4kdGltZUVuZEZpZWxkLmFwcGVuZFRvKCRzdG9wVGFiKTtcblxuICAgICAgICAvL01ha2UgXCJFZGl0IHBvbHlnb25cIiBidXR0b25cbiAgICAgICAgbGV0ICRlZGl0U3RvcFBvbHlCdXR0b24gPSAkKFwiPGJ1dHRvbiBzdHlsZT0ncGFkZGluZzowOyBsaW5lLWhlaWdodDoxLjQnPkVkaXQgUG9seWdvbjwvYnV0dG9uPlwiKS5idXR0b24oe1xuICAgICAgICAgICAgaWNvbjogXCJmYSBmYS1wZW5jaWxcIixcbiAgICAgICAgICAgIHNob3dMYWJlbDogZmFsc2VcbiAgICAgICAgfSkuY2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5TZXRWaXNpYmxlKGZhbHNlKTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJhbm5vdGF0aW9uLWd1aTozNTMgQ3JlYXRlXCIpO1xuICAgICAgICAgICAgdGhpcy5wb2x5RWRpdG9yLkJlZ2luRWRpdGluZygnc3RvcCcpO1xuICAgICAgICB9KTtcbiAgICAgICAgJGVkaXRTdG9wUG9seUJ1dHRvbi5hdHRyKCd0aXRsZScsIFwiRWRpdCBwb2x5Z29uXCIpO1xuICAgICAgICB0aGlzLlJlZ2lzdGVyRWxlbWVudCgkZWRpdFN0b3BQb2x5QnV0dG9uLCAkc3RvcFRhYiwgLTEpO1xuXG4gICAgICAgIGxldCAkc3RvcFRhcmdldExhYmVsID0gJChcIjxsYWJlbD5TdG9wIFRhcmdldDwvbGFiZWw+IFwiKTtcbiAgICAgICAgJHN0b3BUYXJnZXRMYWJlbC5jc3MoXCJjb2xvclwiLCBcIndoaXRlXCIpO1xuICAgICAgICB0aGlzLlJlZ2lzdGVyRWxlbWVudCgkc3RvcFRhcmdldExhYmVsLCAkc3RvcFRhYiwgLTEpO1xuXG4gICAgICAgIC8vc3RvcCBwb2ludCBwb2x5Z29uIGlzIGFkZGVkXG4gICAgICAgIHRoaXMuJGVuZFBvbHlnb25TZXQgPSAkKFwiPGJ1dHRvbiBzdHlsZT0ncGFkZGluZzowOyBsaW5lLWhlaWdodDoxLjQnPkVuZCBQb2x5Z29uIFNldDwvYnV0dG9uPlwiKS5idXR0b24oe1xuICAgICAgICAgICAgaWNvbjogXCJmYSBmYS1jaGVjay1zcXVhcmUtb1wiLFxuICAgICAgICAgICAgc2hvd0xhYmVsOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgLy90aGlzLiRlbmRQb2x5Z29uU2V0LmNzcyhcInZpc2liaWxpdHlcIiwgXCJpbmhlcml0XCIpO1xuICAgICAgICB0aGlzLiRlbmRQb2x5Z29uU2V0LmNzcyhcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIik7XG4gICAgICAgIC8vdGhpcy4kZW5kUG9seWdvblNldC5hZGRDbGFzcyhcIndhbGRvcmYtY29uZmlybS1idXR0b25cIik7XG4gICAgXG4gICAgICAgIC8vQWRkIHNvbWUgZXJyb3IgY2hlY2tpbmcuLi5cbiAgICAgICAgdGhpcy4kdGltZUVuZEZpZWxkLmJsdXIoKCkgPT4ge1xuICAgICAgICAgICAgbGV0IGUgPSAkKHRoaXMuJHRpbWVFbmRGaWVsZCkudmFsKCk7XG4gICAgICAgICAgICBsZXQgcyA9ICQodGhpcy4kdGltZVN0YXJ0RmllbGQpLnZhbCgpO1xuICAgICAgICAgICAgaWYoR2V0U2Vjb25kc0Zyb21ITVMocysxKSA+IEdldFNlY29uZHNGcm9tSE1TKGUpKXtcbiAgICAgICAgICAgICAgICAkKHRoaXMuJHRpbWVFbmRGaWVsZCkudmFsKEdldEZvcm1hdHRlZFRpbWUoR2V0U2Vjb25kc0Zyb21ITVMocykrLjAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiR0aW1lU3RhcnRGaWVsZC5ibHVyKCgpID0+IHtcbiAgICAgICAgICAgIGxldCBlID0gJCh0aGlzLiR0aW1lRW5kRmllbGQpLnZhbCgpO1xuICAgICAgICAgICAgbGV0IHMgPSAkKHRoaXMuJHRpbWVTdGFydEZpZWxkKS52YWwoKTtcbiAgICAgICAgICAgIGlmKEdldFNlY29uZHNGcm9tSE1TKHMrMSkgPiBHZXRTZWNvbmRzRnJvbUhNUyhlKSl7XG4gICAgICAgICAgICAgICAgJCh0aGlzLiR0aW1lRW5kRmllbGQpLnZhbChHZXRGb3JtYXR0ZWRUaW1lKEdldFNlY29uZHNGcm9tSE1TKHMpKy4wMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLlJlZ2lzdGVyRWxlbWVudCh0aGlzLiRlbmRQb2x5Z29uU2V0LCAkc3RvcFRhYiwgLTIpOyBcblxuICAgICAgICBsZXQgJGJ1dHRvblBhbmVsID0gJChcIjxkaXYgY2xhc3M9J2J1dHRvbl9wYW5lbCc+PC9kaXY+XCIpLmFwcGVuZFRvKHRoaXMuJGNvbnRhaW5lcik7XG5cbiAgICAgICAgLy8gTWFrZSBkZWxldGUgYnV0dG9uLiBUaGlzIHNob3VsZCBvbmx5IGFwcGVhciBpZiB3ZSdyZSBlZGl0aW5nLCBub3QgaWYgaXQncyBhIG5ldyBhbm5vdGF0aW9uXG4gICAgICAgIHRoaXMuJGRlbGV0ZUJ1dHRvbiA9ICQoXCI8YnV0dG9uPkRlbGV0ZSBBbm5vdGF0aW9uPC9idXR0b24+XCIpLmJ1dHRvbih7XG4gICAgICAgICAgICAvLyBpY29uOiBcImZhIGZhLWJvbWJcIixcbiAgICAgICAgICAgIHNob3dMYWJlbDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4kZGVsZXRlQnV0dG9uLmhpZGUoKTtcbiAgICAgICAgdGhpcy4kZGVsZXRlQnV0dG9uLmF0dHIoJ3RpdGxlJywgXCJEZWxldGUgYW5ub3RhdGlvblwiKTtcbiAgICAgICAgdGhpcy4kZGVsZXRlQnV0dG9uLmNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYW5ub3RhdG9yLnNlcnZlci5EZWxldGVBbm5vdGF0aW9uKHRoaXMub3JpZ2luYWxBbm5vdGF0aW9uLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbm5vdGF0b3IuRGVyZWdpc3RlckFubm90YXRpb24odGhpcy5vcmlnaW5hbEFubm90YXRpb24pO1xuICAgICAgICAgICAgICAgIHRoaXMuQ2xvc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5SZWdpc3RlckVsZW1lbnQodGhpcy4kZGVsZXRlQnV0dG9uLCAkYnV0dG9uUGFuZWwsIC0xKTtcblxuXG4gICAgICAgIC8vIE1ha2UgY2FuY2VsIGJ1dHRvblxuICAgICAgICBsZXQgJGNhbmNlbEJ1dHRvbiA9ICQoXCI8YnI+PGJyPjxidXR0b24+Q2FuY2VsPC9idXR0b24+XCIpLmJ1dHRvbih7XG4gICAgICAgICAgICBzaG93TGFiZWw6IHRydWVcbiAgICAgICAgfSkuY2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wb2x5RWRpdG9yLlJlc2V0UG9seWdvbnMoKTtcbiAgICAgICAgICAgIHRoaXMuQ2xvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgICRjYW5jZWxCdXR0b24uY3NzKFwiZmxvYXRcIiwgXCJyaWdodFwiKTtcbiAgICAgICAgJGNhbmNlbEJ1dHRvbi5hdHRyKCd0aXRsZScsIFwiRXhpdCBhbm5vdGF0aW9uIGVkaXRpbmdcIik7XG4gICAgICAgIC8vJGNhbmNlbF9idXR0b24uYWRkQ2xhc3MoXCJ3YWxkb3JmLWNhbmNlbC1idXR0b25cIik7XG4gICAgICAgIHRoaXMuUmVnaXN0ZXJFbGVtZW50KCRjYW5jZWxCdXR0b24sICRidXR0b25QYW5lbCwgLTEpO1xuICAgICAgICBcbiAgICAgICAgLy8gTWFrZSBzYXZlIGJ1dHRvblxuICAgICAgICBsZXQgJHNhdmVCdXR0b24gPSAkKFwiPGJ1dHRvbj5TYXZlPC9idXR0b24+XCIpLmJ1dHRvbih7XG4gICAgICAgICAgICBzaG93TGFiZWw6IHRydWVcbiAgICAgICAgfSkuY2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5Db21taXRBbm5vdGF0aW9uVG9TZXJ2ZXIoKGFubm90YXRpb24sIG9sZElEKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5lZGl0TW9kZSl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5ub3RhdG9yLlVwZGF0ZUFubm90YXRpb24oYW5ub3RhdGlvbiwgb2xkSUQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5ub3RhdG9yLlJlZ2lzdGVyTmV3QW5ub3RhdGlvbihhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wb2x5RWRpdG9yLlJlc2V0UG9seWdvbnMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLkNsb3NlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgICRzYXZlQnV0dG9uLmNzcyhcImZsb2F0XCIsIFwibGVmdFwiKTtcbiAgICAgICAgdGhpcy5SZWdpc3RlckVsZW1lbnQoJHNhdmVCdXR0b24sICRidXR0b25QYW5lbCwgLTEpO1xuXG4gICAgICAgIC8vaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTM4MzczMDQvanF1ZXJ5LXVpLW5vbi1hamF4LXRhYi1sb2FkaW5nLXdob2xlLXdlYnNpdGUtaW50by1pdHNlbGZcbiAgICAgICAgJCgnYmFzZScpLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLiR0YWJzLnRhYnMoKS5hZGRDbGFzcygndWktdGFicy12ZXJ0aWNhbCcpO1xuICAgICAgICAvL2xldCAkc2NyaXB0X3NlY3Rpb24gPSAkXG4gICAgICAgIC8vdGhpcy4kY29udGFpbmVyLmhpZGUoKTtcbiAgICB9XG5cbiAgICBSZWdpc3RlckVsZW1lbnQoJGVsZW1lbnQsICRjb250YWluZXIsIG9yZGVyLCBqdXN0aWZpY2F0aW9uID0gJ2ZsZXgtc3RhcnQnKXtcbiAgICAgICAgJGVsZW1lbnQuY3NzKCdvcmRlcicsIG9yZGVyKTtcbiAgICAgICAgJGVsZW1lbnQuY3NzKCdhbGlnbi1zZWxmJywganVzdGlmaWNhdGlvbik7XG4gICAgICAgIC8vIFNldHMgZ3JvdyBbc2hyaW5rXSBbYmFzaXNdXG4gICAgICAgIC8vJGVsZW1lbnQuY3NzKCdmbGV4JywgJzAgMCBhdXRvJyk7XG4gICAgICAgICRjb250YWluZXIuYXBwZW5kKCRlbGVtZW50KTtcbiAgICB9XG5cbiAgICBTZXRWaXNpYmxlKGlzVmlzaWJsZSwgZHVyYXRpb24gPSAwKXtcblxuICAgICAgICAvL2NvbnNvbGUubG9nKGlzVmlzaWJsZSArIFwiIFwiICsgZHVyYXRpb24pO1xuICAgICAgICBpZihpc1Zpc2libGUpe1xuICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyLmZhZGVUbyhkdXJhdGlvbiwgMS4wKTtcbiAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci5tYWtlVmlzaWJsZSh0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci5zdG9wKHRydWUsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyLmZhZGVUbyhkdXJhdGlvbiwgMC4wKTtcbiAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci5tYWtlVmlzaWJsZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1Zpc2libGUgPSBpc1Zpc2libGU7XG5cbiAgICB9XG5cbiAgICBUb2dnbGVPcGVuKCl7XG5cbiAgICAgICAgaWYodGhpcy5vcGVuKXtcbiAgICAgICAgICAgIHRoaXMuQ2xvc2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuT3BlbigpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBPcGVuKCl7XG4gICAgICAgIHRoaXMuU2V0VmlzaWJsZSh0cnVlKTtcbiAgICAgICAgdGhpcy5vcGVuID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wb2x5RWRpdG9yLkRvbmUoKTtcbiAgICAgICAgLy8gRGlzYWJsZSBhdXRvZmFkaW5nIHdoZW4gdGhlIGd1aSBpcyB2aXNpYmxlXG4gICAgICAgIHRoaXMuYW5ub3RhdG9yLnBsYXllci5TZXRBdXRvRmFkZShmYWxzZSk7XG4gICAgfVxuXG4gICAgQ2xvc2UoKXtcbiAgICAgICAgdGhpcy5TZXRWaXNpYmxlKGZhbHNlKTtcbiAgICAgICAgdGhpcy5vcGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMucG9seUVkaXRvci5Eb25lKCk7XG4gICAgICAgIC8vIFJlLWVuYWJsZSBhdXRvZmFkaW5nIHdoZW4gdGhlIGd1aSBpcyBoaWRkZW5cbiAgICAgICAgdGhpcy5hbm5vdGF0b3IucGxheWVyLlNldEF1dG9GYWRlKHRydWUpO1xuICAgICAgICB0aGlzLiRjb250YWluZXIudHJpZ2dlcihcIk9uR1VJQ2xvc2VkXCIpO1xuICAgIH1cbiAgICBcbiAgICBUb2dnbGVWaXNpYmxlKCl7XG4gICAgICAgIHRoaXMuU2V0VmlzaWJsZSghdGhpcy5pc1Zpc2libGUsIDApO1xuICAgIH1cblxuICAgIEJlZ2luRWRpdGluZyhhbm5vdGF0aW9uID0gbnVsbCwgZm9yY2VOZXcgPSBmYWxzZSl7XG4gICAgICAgIC8vIE9wZW4gdGhlIEdVSSBpZiBpdCBpc24ndCBhbHJlYWR5XG4gICAgICAgIHRoaXMuT3BlbigpO1xuICAgICAgICBcbiAgICAgICAgLy8gUG9wdWxhdGUgZGF0YSBmcm9tIHRoZSBwYXNzZWQgaW4gYW5ub3RhdGlvblxuICAgICAgICBpZiAoYW5ub3RhdGlvbiB8fCBmb3JjZU5ldykge1xuICAgICAgICAgICAgLy8gUG9wdWxhdGUgdGhlIGZpZWxkcyBmcm9tIHRoZSBhbm5vdGF0aW9uXG4gICAgICAgICAgICB0aGlzLmVkaXRNb2RlID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gRmxpcCBlZGl0IG1vZGUgYmFjayB0byBmYWxzZSBpZiBmb3JjZU5ldy4gV2Ugd2FudCB0b1xuICAgICAgICAgICAgLy8gcG9wdWxhdGUgZnJvbSB0aGUgZW50aXJlIHBhc3NlZCBpbiBhbm5vdGF0aW9uLCBidXQgdHJlYXRcbiAgICAgICAgICAgIC8vIGl0IGFzIG5ldy5cbiAgICAgICAgICAgIGlmKGZvcmNlTmV3KSB0aGlzLmVkaXRNb2RlID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHRoaXMub3JpZ2luYWxBbm5vdGF0aW9uID0gYW5ub3RhdGlvbjtcblxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJQb3B1bGF0ZWQgZnJvbSBhbiBleGlzdGluZyBhbm5vdGF0aW9uXCIpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYW5ub3RhdGlvbik7XG4gICAgICAgICAgICB0aGlzLiR0aW1lU3RhcnRGaWVsZC52YWwoR2V0Rm9ybWF0dGVkVGltZShhbm5vdGF0aW9uLmJlZ2luVGltZSkpO1xuICAgICAgICAgICAgdGhpcy4kdGltZUVuZEZpZWxkLnZhbChHZXRGb3JtYXR0ZWRUaW1lKGFubm90YXRpb24uZW5kVGltZSkpO1xuICAgICAgICAgICAgaWYgKCd1bmRlZmluZWQnID09IHR5cGVvZihhbm5vdGF0aW9uLml0ZW1zKSkgeyAvLyBWZXJzaW9uIDFcbiAgICAgICAgICAgICAgICB0aGlzLiR0ZXh0RmllbGQudmFsKGFubm90YXRpb24uYm9keS5maWx0ZXIoaXRlbSA9PiBpdGVtLnB1cnBvc2UgPT0gXCJkZXNjcmliaW5nXCIpWzBdLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAvLyBWZXJzaW9uIDEgZG9lc24ndCBoYXZlIGEgdGhpcy5pZCBjb250ZXh0XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBWZXJzaW9uIDJcbiAgICAgICAgICAgICAgICB0aGlzLiR0ZXh0RmllbGQudmFsKGFubm90YXRpb24uaXRlbXNbMF0uaXRlbXNbMF0uaXRlbXNbMF0uYm9keS5maWx0ZXIoaXRlbSA9PiBpdGVtLnB1cnBvc2UgPT0gXCJkZXNjcmliaW5nXCIpWzBdLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlkID0gYW5ub3RhdGlvbi5pdGVtc1swXS5pdGVtc1swXS5pdGVtc1swXS5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlc2V0IHRoZSB0YWdzIGZpZWxkXG4gICAgICAgICAgICB0aGlzLiR0YWdzRmllbGQudmFsKFwiXCIpLnRyaWdnZXIoXCJjaGFuZ2VcIik7XG4gICAgICAgICAgICB0aGlzLiR0YWdzRmllbGQuZmluZChcIm9wdGlvblwiKS5yZW1vdmUoKTtcblxuICAgICAgICAgICAgZm9yKGxldCB0YWcgb2YgYW5ub3RhdGlvbi50YWdzKXtcbiAgICAgICAgICAgICAgICB0aGlzLiR0YWdzRmllbGQuYXBwZW5kKFwiPG9wdGlvbiB2YWx1ZT0nXCIrdGFnK1wiJyBzZWxlY3RlZD5cIit0YWcrXCI8L29wdGlvbj5cIik7XG4gICAgICAgICAgICAgICAgdGhpcy4kdGFnc0ZpZWxkLnRyaWdnZXIoXCJjaGFuZ2VcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucG9seUVkaXRvci5Jbml0UG9seShhbm5vdGF0aW9uLmdldFBvbHkoKSk7XG4gICAgICAgICAgICB0aGlzLnBvbHlFZGl0b3IuU2hvd0p1c3RQb2x5Z29uKCk7XG5cbiAgICAgICAgICAgIC8vIFByb3BhZ2F0ZSB0aGUgcG9seWdvbiBlZGl0b3IncyBwb2x5Z29ucyBhcnJheSB3aXRoIHBvbHlnb25zIGZyb20gdGhlIGFubm90YXRpb25cbiAgICAgICAgICAgIHRoaXMucG9seUVkaXRvci4kcG9seWdvbnMgPSBbXTtcbiAgICAgICAgICAgIGlmIChhbm5vdGF0aW9uLnBvbHlTdGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2x5RWRpdG9yLiRwb2x5Z29ucy5wdXNoKGFubm90YXRpb24ucG9seVN0YXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoYW5ub3RhdGlvbi5wb2x5RW5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2x5RWRpdG9yLiRwb2x5Z29ucy5wdXNoKGFubm90YXRpb24ucG9seUVuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgLy8gSW5zZXJ0IHRlbXBsYXRlIGRhdGEgaWYgbm8gYW5ub3RhdGlvbiBpcyBnaXZlblxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFBvcHVsYXRlIGZpZWxkcyBpZiBubyBhbm5vdGF0aW9uIGlzIGdpdmVuXG4gICAgICAgICAgICB0aGlzLmVkaXRNb2RlID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHRoaXMub3JpZ2luYWxBbm5vdGF0aW9uID0gbnVsbDtcblxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJQb3B1bGF0ZWQgd2l0aCB0ZW1wbGF0ZSBkYXRhXCIpO1xuICAgICAgICAgICAgdGhpcy4kdGltZVN0YXJ0RmllbGQudmFsKEdldEZvcm1hdHRlZFRpbWUodGhpcy5hbm5vdGF0b3IucGxheWVyLnZpZGVvRWxlbWVudC5jdXJyZW50VGltZSkpO1xuICAgICAgICAgICAgdGhpcy4kdGltZUVuZEZpZWxkLnZhbChHZXRGb3JtYXR0ZWRUaW1lKHRoaXMuYW5ub3RhdG9yLnBsYXllci52aWRlb0VsZW1lbnQuZHVyYXRpb24pKTtcbiAgICAgICAgICAgIHRoaXMuJHRleHRGaWVsZC52YWwoXCJcIik7XG4gICAgICAgICAgICAvLyBSZXNldCB0aGUgdGFncyBmaWVsZFxuICAgICAgICAgICAgdGhpcy4kdGFnc0ZpZWxkLnZhbChcIlwiKS50cmlnZ2VyKFwiY2hhbmdlXCIpO1xuICAgICAgICAgICAgdGhpcy4kdGFnc0ZpZWxkLmZpbmQoXCJvcHRpb25cIikucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgIHRoaXMucG9seUVkaXRvci5Jbml0UG9seSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTW9kaWZ5IEdVSSBiYXNlZCBvbiBlZGl0IG1vZGVcbiAgICAgICAgaWYodGhpcy5lZGl0TW9kZSkge1xuICAgICAgICAgICAgdGhpcy4kdGl0bGUudGV4dChcIkVkaXQgQW5ub3RhdGlvblwiKTtcbiAgICAgICAgICAgIHRoaXMuJGRlbGV0ZUJ1dHRvbi5idXR0b24oXCJlbmFibGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiR0aXRsZS50ZXh0KFwiQ3JlYXRlIEFubm90YXRpb25cIik7XG4gICAgICAgICAgICB0aGlzLiRkZWxldGVCdXR0b24uYnV0dG9uKFwiZGlzYWJsZVwiKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgQ29tbWl0QW5ub3RhdGlvblRvU2VydmVyKGNhbGxiYWNrKXtcbiAgICAgICAgaWYodGhpcy5lZGl0TW9kZSl7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNlbmRpbmcgZWRpdGVkIGFubm90YXRpb24gdG8gc2VydmVyLi4uXCIpO1xuICAgICAgICAgICAgdGhpcy5hbm5vdGF0b3Iuc2VydmVyLkVkaXRBbm5vdGF0aW9uKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNle1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJTZW5kaW5nIG5ldyBhbm5vdGF0aW9uIHRvIHNlcnZlci4uLlwiKTtcbiAgICAgICAgICAgIHRoaXMuYW5ub3RhdG9yLnNlcnZlci5Qb3N0QW5ub3RhdGlvbihjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBCdWlsZCBhbiBvYmplY3QgZnJvbSB0aGUgZGF0YS5cbiAgICBHZXRBbm5vdGF0aW9uT2JqZWN0KCkge1xuXG4gICAgICAgIGxldCBhbm5vdGF0aW9uID0gbmV3IEFubm90YXRpb24oKTtcbiAgICAgICBcbiAgICAgICAgaWYgKCd1bmRlZmluZWQnID09IHR5cGVvZihhbm5vdGF0aW9uLml0ZW1zKSkgeyAvLyBWZXJzaW9uIDFcbiAgICAgICAgICAgIGFubm90YXRpb25bXCJib2R5XCJdID0gdGhpcy5CdWlsZEFubm90YXRpb25Cb2R5VjEoKTtcbiAgICAgICAgICAgIGFubm90YXRpb25bXCJ0YXJnZXRcIl0gPSB0aGlzLkJ1aWxkQW5ub3RhdGlvblRhcmdldCh0cnVlKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gVmVyc2lvbiAyXG4gICAgICAgICAgICBhbm5vdGF0aW9uW1wibGFiZWxcIl0gPSB7XG4gICAgICAgICAgICAgICAgXCJlblwiOiBbdGhpcy5hbm5vdGF0b3IuY29udGVudExhYmVsXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFubm90YXRpb25bXCJpdGVtc1wiXSA9IHRoaXMuQnVpbGRBbm5vdGF0aW9uSXRlbXMoKTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICAvLyBSZWNvbXB1dGUgcmVhZC1vbmx5IGFjY2VzcyBwcm9wZXJ0aWVzIGFmdGVyIGFsbCBvdGhlciBwcm9wZXJ0aWVzIGhhdmUgYmVlbiBzZXRcbiAgICAgICAgYW5ub3RhdGlvbi5yZWNhbGN1bGF0ZSgpO1xuXG4gICAgICAgIC8vIENsb25lIHRoZSBvYmplY3Qgc28gd2UgZG9uJ3QgbW9kaWZ5IGFueXRoaW5nIGJ5IGNoYW5naW5nIHRoaXMgb2JqZWN0XG4gICAgICAgIGxldCBjbG9uZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYW5ub3RhdGlvbikpXG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9XG5cbiAgICBCdWlsZEFubm90YXRpb25JdGVtcygpIHtcbiAgICAgICAgbGV0IGJ1aWxkVGltZSA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTsgLy9cIjIwMjAtMDgtMTZUMTI6MDA6MDBaXCJcbiAgICAgICAgbGV0IHZpZGVvRHVyYXRpb24gPSB0aGlzLmFubm90YXRvci5wbGF5ZXIudmlkZW9FbGVtZW50LmR1cmF0aW9uO1xuICAgICAgICBsZXQgdmlkZW9XaWR0aCA9IHRoaXMuYW5ub3RhdG9yLnBsYXllci52aWRlb0VsZW1lbnQudmlkZW9XaWR0aDtcbiAgICAgICAgbGV0IHZpZGVvSGVpZ2h0ID0gdGhpcy5hbm5vdGF0b3IucGxheWVyLnZpZGVvRWxlbWVudC52aWRlb0hlaWdodDtcblxuICAgICAgICAvLyBsZXQgdmlkZW9EaW1lbnNpb24gPSB0aGlzLmFubm90YXRvci5wbGF5ZXIuR2V0VmlkZW9EaW1lbnNpb25zKClcbiAgICAgICAgLy8gdmlkZW9XaWR0aCA9IHZpZGVvRGltZW5zaW9uLndpZHRoO1xuICAgICAgICAvLyB2aWRlb0hlaWdodCA9IHZpZGVvRGltZW5zaW9uLmhlaWdodDtcblxuICAgICAgICBsZXQgaXRlbXMgPSBbe1xuICAgICAgICAgICAgXCJpZFwiOiB0aGlzLmFubm90YXRvci51cmwsIC8vVE9ETzogc2NhbGFyIHNwZWNpZmljIHVybCAtIHNob3VsZCBiZSBzdXBwbGllZCB0byBwbHVnaW4gXG4gICAgICAgICAgICBcInR5cGVcIjogXCJDYW52YXNcIixcbiAgICAgICAgICAgIFwiaGVpZ2h0XCI6IHZpZGVvSGVpZ2h0LFxuICAgICAgICAgICAgXCJ3aWR0aFwiOiB2aWRlb1dpZHRoLFxuICAgICAgICAgICAgXCJkdXJhdGlvblwiOiB2aWRlb0R1cmF0aW9uLCBcbiAgICAgICAgICAgIFwiY29udGVudFwiOiB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiB0aGlzLmFubm90YXRvci51cmwsIFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIlZpZGVvXCIsXG4gICAgICAgICAgICAgICAgXCJoZWlnaHRcIjogdmlkZW9IZWlnaHQsXG4gICAgICAgICAgICAgICAgXCJ3aWR0aFwiOiB2aWRlb1dpZHRoLFxuICAgICAgICAgICAgICAgIFwiZHVyYXRpb25cIjogdmlkZW9EdXJhdGlvbixcbiAgICAgICAgICAgICAgICBcImxhYmVsXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJlblwiOiB0aGlzLmFubm90YXRvci5jb250ZW50TGFiZWwgLy9cImRjdGVybXM6dGl0bGVcIiBmcm9tIHRoZSBhbm5vdGF0aW9uIGpzb24gZmlsZSBmcm9tIHNjYWxhclxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiZW5cIjogXCJcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIml0ZW1zXCI6IFt7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiB0aGlzLmFubm90YXRvci51cmwsICBcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJBbm5vdGF0aW9uUGFnZVwiLFxuICAgICAgICAgICAgICAgIFwiZ2VuZXJhdG9yXCI6IFwiaHR0cDovL2dpdGh1Yi5jb20vYW52Yy9zY2FsYXJcIixcbiAgICAgICAgICAgICAgICBcImdlbmVyYXRlZFwiOiBidWlsZFRpbWUsIFxuICAgICAgICAgICAgICAgIFwiaXRlbXNcIjogW3tcbiAgICAgICAgICAgICAgICAgICAgXCJpZFwiOiB0aGlzLmlkLCAvLyBVUkwgdG8gdGhlIGFubm90YXRpb24tcGFnZVxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJBbm5vdGF0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZ2VuZXJhdG9yXCI6IFwiaHR0cDovL2dpdGh1Yi5jb20vbm92b21hbmN5L3dhbGRvcmYtc2NhbGFyXCIsIFxuICAgICAgICAgICAgICAgICAgICBcIm1vdGl2YXRpb25cIjogXCJoaWdobGlnaHRpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgXCJjcmVhdG9yXCI6IHRoaXMuQnVpbGRDcmVhdG9yVGVtcGxhdGUoKSwgIFxuICAgICAgICAgICAgICAgICAgICBcImNyZWF0ZWRcIjogYnVpbGRUaW1lLCAgXG4gICAgICAgICAgICAgICAgICAgIFwicmlnaHRzXCI6IFwiaHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LzQuMC9cIixcbiAgICAgICAgICAgICAgICAgICAgXCJib2R5XCI6IHRoaXMuQnVpbGRBbm5vdGF0aW9uQm9keVYyKCksXG4gICAgICAgICAgICAgICAgICAgIFwidGFyZ2V0XCI6IHRoaXMuQnVpbGRBbm5vdGF0aW9uVGFyZ2V0KGZhbHNlKVxuICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfV1cbiAgICBcbiAgICAgICAgfV07XG5cblxuICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgICAgICAgICAgICAgXG4gICAgfVxuXG4gICAgQnVpbGRDcmVhdG9yVGVtcGxhdGUoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJQZXJzb25cIixcbiAgICAgICAgICAgIFwibmlja25hbWVcIjogbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3dhbGRvcmZfdXNlcl9uYW1lJyksXG4gICAgICAgICAgICBcImVtYWlsX3NoYTFcIjogbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3dhbGRvcmZfdXNlcl9lbWFpbCcpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvL0J1aWxkIHdpdGggdGFncyBlbnRyaWVzIGZyb20gb25vbXlcbiAgICBCdWlsZEFubm90YXRpb25Cb2R5VjIoKSB7XG4gICAgICAgIGxldCBib2R5ID0gW107XG5cbiAgICAgICAgLy8gQnVpbGQgdGV4dCBkZXNjcmlwdG9yXG4gICAgICAgIGxldCBib2R5VGV4dCA9IHtcbiAgICAgICAgICAgIFwidHlwZVwiIDogXCJUZXh0dWFsQm9keVwiLFxuICAgICAgICAgICAgXCJ2YWx1ZVwiIDogdGhpcy4kdGV4dEZpZWxkLnZhbCgpLFxuICAgICAgICAgICAgXCJmb3JtYXRcIiA6IFwidGV4dC9wbGFpblwiLFxuICAgICAgICAgICAgXCJsYW5ndWFnZVwiIDogXCJlblwiLFxuICAgICAgICAgICAgXCJwdXJwb3NlXCI6IFwiZGVzY3JpYmluZ1wiXG4gICAgICAgIH07XG4gICAgICAgIGJvZHkucHVzaChib2R5VGV4dCk7XG5cbiAgICAgICAgLy8gQnVpbGQgdGFnIGRlc2NyaXB0b3JzXG4gICAgICAgIC8vbGV0IHRhZ3MgPSB0aGlzLiR0YWdzRmllbGQuc2VsZWN0MihcImRhdGFcIikubWFwKChpdGVtKSA9PiB7IHJldHVybiBpdGVtLnRleHQ7IH0pO1xuICAgICAgICBsZXQgc2VsZWN0ZWRfdGFncyA9IHRoaXMuJHRhZ3NGaWVsZC5zZWxlY3QyKFwiZGF0YVwiKS5tYXAoKGl0ZW0pID0+IHsgcmV0dXJuIHtpZDogaXRlbS5pZCwgdGV4dDogaXRlbS50ZXh0fX0pO1xuICAgICAgICBsZXQgb25vbXlfbWFwID0gdGhpcy5hbm5vdGF0b3IuYW5ub3RhdGlvbk1hbmFnZXIub25vbXlWb2NhYnVsYXJ5LnJlc3VsdHMucmVkdWNlKGZ1bmN0aW9uKGFjYywgY3Vycikge2FjY1tjdXJyWydpZCddXSA9IGN1cnI7IHJldHVybiBhY2M7fSwge30pO1xuXG4gICAgICAgIGZvcihsZXQgdGFnIG9mIHNlbGVjdGVkX3RhZ3Mpe1xuICAgICAgICAgICAgbGV0IG9ub215X3JlZiA9IG9ub215X21hcFt0YWcuaWRdO1xuICAgICAgICAgICAgbGV0IGJvZHlUYWcgPSB7fVxuICAgICAgICAgICAgaWYgKG9ub215X3JlZikge1xuICAgICAgICAgICAgICAgIGJvZHlUYWcgPSB7XG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIlNwZWNpZmljUmVzb3VyY2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJwdXJwb3NlXCI6IFwidGFnZ2luZ1wiLFxuICAgICAgICAgICAgICAgICAgICBcInNvdXJjZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgXCJpZFwiOiBvbm9teV9yZWYudGVybXNfaWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJmb3JtYXRcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJsYWJlbFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImVuXCI6IG9ub215X3JlZi50ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZW5cIjogb25vbXlfcmVmLmNvbW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYm9keVRhZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiVGV4dHVhbEJvZHlcIixcbiAgICAgICAgICAgICAgICAgICAgXCJwdXJwb3NlXCI6IFwidGFnZ2luZ1wiLFxuICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCI6IHRhZy50ZXh0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm9keS5wdXNoKGJvZHlUYWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgfVxuXG4gICAgQnVpbGRBbm5vdGF0aW9uQm9keVYxKCkge1xuICAgICAgICBsZXQgYm9keSA9IFtdO1xuXG4gICAgICAgIC8vIEJ1aWxkIHRleHQgZGVzY3JpcHRvclxuICAgICAgICBsZXQgYm9keVRleHQgPSB7XG4gICAgICAgICAgICBcInR5cGVcIiA6IFwiVGV4dHVhbEJvZHlcIixcbiAgICAgICAgICAgIFwidmFsdWVcIiA6IHRoaXMuJHRleHRGaWVsZC52YWwoKSxcbiAgICAgICAgICAgIFwiZm9ybWF0XCIgOiBcInRleHQvcGxhaW5cIixcbiAgICAgICAgICAgIFwibGFuZ3VhZ2VcIiA6IFwiZW5cIixcbiAgICAgICAgICAgIFwicHVycG9zZVwiOiBcImRlc2NyaWJpbmdcIlxuICAgICAgICB9O1xuICAgICAgICBib2R5LnB1c2goYm9keVRleHQpO1xuXG4gICAgICAgIC8vIEJ1aWxkIHRhZyBkZXNjcmlwdG9yc1xuICAgICAgICBsZXQgdGFncyA9IHRoaXMuJHRhZ3NGaWVsZC5zZWxlY3QyKFwiZGF0YVwiKS5tYXAoKGl0ZW0pID0+IHsgcmV0dXJuIGl0ZW0udGV4dDsgfSk7XG4gICAgICAgIGZvcihsZXQgdGFnU3RyIG9mIHRhZ3Mpe1xuICAgICAgICAgICAgbGV0IGJvZHlUYWcgPSB7XG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiVGV4dHVhbEJvZHlcIixcbiAgICAgICAgICAgICAgICBcInB1cnBvc2VcIjogXCJ0YWdnaW5nXCIsXG4gICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiB0YWdTdHJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJvZHkucHVzaChib2R5VGFnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBib2R5O1xuICAgIH1cblxuICAgIC8vdXNlZCBib3RoIHYxIGFuZCB2MlxuICAgIEJ1aWxkQW5ub3RhdGlvblRhcmdldChzZWxlY3RvcnNJbkFycmF5KSB7XG5cbiAgICAgICAgaWYgKCd1bmRlZmluZWQnID09IHR5cGVvZihzZWxlY3RvcnNJbkFycmF5KSkgc2VsZWN0b3JzSW5BcnJheSA9IGZhbHNlO1xuXG4gICAgICAgIGxldCB0YXJnZXQgPSB7XG4gICAgICAgICAgICBcImlkXCI6IHRoaXMuYW5ub3RhdG9yLnVybCwgLy8gVVJMIG9mIHRoZSB2aWRlb1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiVmlkZW9cIlxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHNlbGVjdG9ycyA9IFtdO1xuXG4gICAgICAgIGxldCBzYWZlRW5kVGltZSA9IEdldFNlY29uZHNGcm9tSE1TKHRoaXMuJHRpbWVTdGFydEZpZWxkLnZhbCgpKTtcbiAgICAgICAgaWYoR2V0U2Vjb25kc0Zyb21ITVModGhpcy4kdGltZUVuZEZpZWxkLnZhbCgpKSA+IEdldFNlY29uZHNGcm9tSE1TKHRoaXMuJHRpbWVTdGFydEZpZWxkLnZhbCgpKSl7XG4gICAgICAgICAgICBzYWZlRW5kVGltZSA9IEdldFNlY29uZHNGcm9tSE1TKHRoaXMuJHRpbWVFbmRGaWVsZC52YWwoKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0VGltZSA9IEdldFNlY29uZHNGcm9tSE1TKHRoaXMuJHRpbWVTdGFydEZpZWxkLnZhbCgpKTtcblxuICAgICAgICAvLyBCdWlsZCB0aW1lIHNlbGVjdG9yXG4gICAgICAgIGxldCB0aW1lU2VsZWN0b3IgPSB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJGcmFnbWVudFNlbGVjdG9yXCIsXG4gICAgICAgICAgICBcImNvbmZvcm1zVG9cIjogXCJodHRwOi8vd3d3LnczLm9yZy9UUi9tZWRpYS1mcmFncy9cIiwgLy8gU2VlIG1lZGlhIGZyYWdtZW50IHNwZWNpZmljYXRpb25cbiAgICAgICAgICAgIFwidmFsdWVcIjogYHQ9JHtzdGFydFRpbWV9LCR7c2FmZUVuZFRpbWV9YCAvLyBUaW1lIGludGVydmFsIGluIHNlY29uZHNcbiAgICAgICAgfVxuXG4gICAgICAgIC8vQnVpbGQgU3ZnU2VsZWN0b3JcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnBvbHlFZGl0b3IuJHZlcnRpY2VzLnN0YXJ0ICE9ICd1bmRlZmluZWQnICYmIHRoaXMucG9seUVkaXRvci4kdmVydGljZXMuc3RhcnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBsZXQgcG9pbnRzU3RyID0gdGhpcy5wb2x5RWRpdG9yLiR2ZXJ0aWNlcy5zdGFydC5tYXAoaXRlbSA9PiB7IHJldHVybiBgJHtpdGVtWzBdfSwke2l0ZW1bMV19YCB9KS5qb2luKFwiIFwiKTtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IFwiPHN2ZyB2aWV3Qm94PScwIDAgMTAwIDEwMCcgcHJlc2VydmVBc3BlY3RSYXRpbz0nbm9uZSc+XCI7XG4gICAgICAgICAgICB2YWx1ZSArPSBcIjxwb2x5Z29uIHBvaW50cz0nXCIgKyBwb2ludHNTdHIgKyBcIicgLz5cIjtcblxuICAgICAgICAgICAgaWYgKHRoaXMucG9seUVkaXRvci5Jc0FuaW1hdGVkKCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgYW5pbWVTdHIgPSB0aGlzLnBvbHlFZGl0b3IuJHZlcnRpY2VzLnN0b3AubWFwKGl0ZW0gPT4geyByZXR1cm4gYCR7aXRlbVswXX0sJHtpdGVtWzFdfWAgfSkuam9pbihcIiBcIik7XG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gXCI8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPSdwb2ludHMnIGZyb209J1wiICsgcG9pbnRzU3RyICsgXCInIHRvPSdcIiArIGFuaW1lU3RyICsgXCInXCI7XG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gXCIgc3RhcnQ9J1wiICsgc3RhcnRUaW1lICsgXCInIGVuZD0nXCIgKyBzYWZlRW5kVGltZSArIFwiJyAvPlwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZSArPSBcIjwvc3ZnPlwiO1xuXG4gICAgICAgICAgICBsZXQgcG9seWdvblNlbGVjdG9yID0ge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIlN2Z1NlbGVjdG9yXCIsXG4gICAgICAgICAgICAgICAgXCJjb25mb3Jtc1RvXCI6IFwiaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL1wiLCAvL2FkZGVkIGZvciB2MlxuICAgICAgICAgICAgICAgIFwidmFsdWVcIjogYCR7dmFsdWV9YCAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNDg5ODcyOFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGVjdG9yc0luQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvcnMucHVzaChwb2x5Z29uU2VsZWN0b3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aW1lU2VsZWN0b3JbXCJyZWZpbmVkQnlcIl0gPSBwb2x5Z29uU2VsZWN0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZWN0b3JzSW5BcnJheSkge1xuICAgICAgICAgICAgc2VsZWN0b3JzLnB1c2godGltZVNlbGVjdG9yKTsgICBcbiAgICAgICAgICAgIHRhcmdldFtcInNlbGVjdG9yXCJdID0gc2VsZWN0b3JzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0W1wic2VsZWN0b3JcIl0gPSB0aW1lU2VsZWN0b3I7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIEdldFRhZ3NRdWVyeSgpIHtcbiAgICAgICAgaWYgKHRoaXMuYW5ub3RhdG9yLmFubm90YXRpb25NYW5hZ2VyICE9IHVuZGVmaW5lZCAmJiB0aGlzLmFubm90YXRvci5hbm5vdGF0aW9uTWFuYWdlci5vbm9teVZvY2FidWxhcnkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5ub3RhdG9yLmFubm90YXRpb25NYW5hZ2VyLm9ub215Vm9jYWJ1bGFyeTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1cmw6IHRoaXMuYW5ub3RhdG9yLnRhZ3NVUkwsXG4gICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgZGVsYXk6IDI1MCxcbiAgICAgICAgICAgIGNhY2hlOiB0cnVlLFxuICAgICAgICAgICAgb25vbXlMYW5ndWFnZTogdGhpcy5hbm5vdGF0b3Iub25vbXlMYW5ndWFnZSxcbiAgICAgICAgICAgIGFubm90YXRpb25NYW5hZ2VyOiB0aGlzLmFubm90YXRvci5hbm5vdGF0aW9uTWFuYWdlcixcbiAgICAgICAgICAgIHBhcnNlRnVuY3Rpb246IHRoaXMuT25vbXlWb2NhYnVsYXJQcm9jZXNzLFxuICAgICAgICAgICAgcHJvY2Vzc1Jlc3VsdHM6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWpheE9wdGlvbnMucGFyc2VGdW5jdGlvbihkYXRhLCB0aGlzLmFqYXhPcHRpb25zLm9ub215TGFuZ3VhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIE9ub215Vm9jYWJ1bGFyUHJvY2VzcyhkYXRhLCBvbm9teUxhbmd1YWdlKSB7ICBcbiAgICAgICAgLy8gUGFyc2UgdGhlIGxhYmVscyBpbnRvIHRoZSBmb3JtYXQgZXhwZWN0ZWQgYnkgU2VsZWN0MlxuICAgICAgICAvLyBtdWx0aWxpbmd1YWwgdGFnc1xuICAgICAgICBsZXQgbXVsdGlsaW5ndWFsX3RhZ3MgPSBbXTtcbiAgICAgICAgbGV0IG1fY29tbWVudHMgPSB7fTtcbiAgICAgICAgbGV0IGNvbW1lbnRzID0ge307XG4gICAgICAgIGxldCBtX2luZGV4ID0gMTtcblxuICAgICAgICBsZXQgdGFncyA9IFtdO1xuICAgICAgICBsZXQgaW5kZXggPSAxO1xuICAgICAgICBcbiAgICAgICAgZm9yKGxldCB0ZXJtIG9mIGRhdGFbXCJ0ZXJtc1wiXSl7XG4gICAgICAgICAgICAvL2lmIG9ub215TGFuZ3VhZ2UgaXMgZGVmaW5lZCBjb2xsZWN0IG11bHRpbGluZ3VhbCB0YWdzXG4gICAgICAgICAgICBsZXQgdGVybXNfaWQgPSB0ZXJtW1wicmRmczphYm91dFwiXTtcbiAgICAgICAgICAgIGxldCB0ZXJtc19jb21tZW50ID0gdGVybVtcInJkZnM6Y29tbWVudFwiXTtcbiAgICAgICAgICAgIGlmIChvbm9teUxhbmd1YWdlICE9ICcnICYmIHRlcm1bJ2xhYmVscyddICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxldCB0X2xhYmVsID0gXCJcIjtcbiAgICAgICAgICAgICAgICBsZXQgdF9jb21tZW50ID0gXCJcIjtcblxuICAgICAgICAgICAgICAgIC8vZ2V0IGxhYmVsc1xuICAgICAgICAgICAgICAgIGZvcihsZXQgbGFiZWwgb2YgdGVybVtcImxhYmVsc1wiXSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeG1sX2xhbmcgPSBsYWJlbFtcInhtbDpsYW5nXCJdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbV9sYWJlbCA9IGxhYmVsW1wicmRmczpsYWJlbFwiXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhtbF9sYW5nID09IG9ub215TGFuZ3VhZ2UgJiYgbV9sYWJlbCAmJiBtX2xhYmVsLnRyaW0gIT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdF9sYWJlbCA9IG1fbGFiZWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy9nZXQgY29tbWVudHNcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBsYWJlbCBvZiB0ZXJtWydjb21tZW50cyddKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB4bWxfbGFuZyA9IGxhYmVsW1wieG1sOmxhbmdcIl07XG4gICAgICAgICAgICAgICAgICAgIGxldCBtX2NvbW1lbnQgPSBsYWJlbFtcInJkZnM6Y29tbWVudHNcIl07IC8vVE9ETzogY2hhbmdlIHRvIGNvbW1lbnQgYWZ0ZXIgZml4aW5nIE9ub215XG4gICAgICAgICAgICAgICAgICAgIGlmICh4bWxfbGFuZyA9PSBvbm9teUxhbmd1YWdlICYmIG1fY29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdF9jb21tZW50ID0gbV9jb21tZW50O1xuICAgICAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgdGVybSBjb21tZW50IHZhbHVlIGlmIGNvbW1lbnQgaXMgYmxhbmtcbiAgICAgICAgICAgICAgICBpZiAodF9jb21tZW50ID09IHVuZGVmaW5lZCB8fCB0X2NvbW1lbnQudHJpbSA9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRfY29tbWVudCA9IHRlcm1zX2NvbW1lbnRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbXVsdGlsaW5ndWFsX3RhZ3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBtX2luZGV4LFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0X2xhYmVsLFxuICAgICAgICAgICAgICAgICAgICB0ZXJtc19pZDogdGVybXNfaWQsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQ6IHRfY29tbWVudFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG1faW5kZXgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB0YWdzLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkOiBpbmRleCxcbiAgICAgICAgICAgICAgICB0ZXh0OiB0ZXJtW1wicmRmczpsYWJlbFwiXSxcbiAgICAgICAgICAgICAgICB0ZXJtc19pZDogdGVybVtcInJkZnM6YWJvdXRcIl0sXG4gICAgICAgICAgICAgICAgY29tbWVudDogdGVybVtcInJkZnM6Y29tbWVudFwiXVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmV0dXJuX3RhZ3MgPSBtdWx0aWxpbmd1YWxfdGFnc1xuICAgICAgICBpZiAocmV0dXJuX3RhZ3MubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybl90YWdzID0gdGFnc1xuICAgICAgICB9XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJyZXR1cm5fdGFnc1wiKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhyZXR1cm5fdGFncyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN1bHRzOiByZXR1cm5fdGFncyxcbiAgICAgICAgfTtcbiAgICB9XG5cblxuXG59XG5cbmV4cG9ydCB7IEFubm90YXRpb25HVUkgfTsiLCJpbXBvcnQgeyBHZXRGb3JtYXR0ZWRUaW1lIH0gZnJvbSBcIi4uLy4uL3V0aWxzL3RpbWUuanNcIjtcbmxldCBzaGExID0gcmVxdWlyZSgnc2hhMScpO1xuXG5jbGFzcyBJbmRleENvbnRhaW5lciB7XG4gICAgY29uc3RydWN0b3IoYW5ub3RhdG9yKXtcbiAgICAgICAgY29uc29sZS5sb2coXCJbSW5kZXggQ29udGFpbmVyXSBDcmVhdGluZyBhbm5vdGF0aW9uIGluZGV4XCIpO1xuICAgICAgICB0aGlzLmFubm90YXRvciA9IGFubm90YXRvcjtcbiAgICAgICAgbGV0IGNvbnRhaW5lciA9ICQoXCIud2FsZG9yZi1pbmRleFwiKTtcbiAgICAgICAgaWYoY29udGFpbmVyLmxlbmd0aCA+IDApe1xuICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyID0gY29udGFpbmVyLmZpcnN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiRjb250YWluZXIgPSAkKFwiPGRpdiBjbGFzcz0nd2FsZG9yZi1pbmRleCcgYXJpYS1saXZlPSdwb2xpdGUnIHJvbGU9J25hdmlnYXRpb24nPjwvZGl2PlwiKS5hcHBlbmRUbyh0aGlzLmFubm90YXRvci4kY29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFubm90YXRpb25MaXN0ID0gJChcIjx1bCBjbGFzcz0nd2FsZG9yZi1hbm5vdGF0aW9uLWxpc3QnIHJvbGU9J21lbnViYXInPjwvdWw+XCIpLmFwcGVuZFRvKHRoaXMuJGNvbnRhaW5lcik7XG4gICAgICAgIC8vIEF0dGFjaCBldmVudCBoYW5kbGVyc1xuICAgICAgICB0aGlzLmFubm90YXRvci4kY29udGFpbmVyLm9uKFwiT25Bbm5vdGF0aW9uc0xvYWRlZFwiLCBcbiAgICAgICAgICAgIChldmVudCwgYW5ub3RhdGlvbk1hbmFnZXIpID0+IHRoaXMuUmVidWlsZCgpKTtcbiAgICAgICAgdGhpcy5hbm5vdGF0b3IuJGNvbnRhaW5lci5vbihcIk9uQW5ub3RhdGlvblJlZ2lzdGVyZWRcIixcbiAgICAgICAgICAgIChldmVudCwgYW5ub3RhdGlvbikgPT4gdGhpcy5SZWJ1aWxkKCkpO1xuICAgICAgICB0aGlzLmFubm90YXRvci4kY29udGFpbmVyLm9uKFwiT25Bbm5vdGF0aW9uUmVtb3ZlZFwiLFxuICAgICAgICAgICAgKGV2ZW50LCBpZCkgPT4gdGhpcy5SZWJ1aWxkKCkpOyAgICAgICAgICAgIFxuXG4gICAgfVxuXG4gICAgUmVidWlsZCgpe1xuICAgICAgICB0aGlzLmFubm90YXRpb25MaXN0LmVtcHR5KCk7XG4gICAgICAgIC8vIGlmKHRoaXMuYW5ub3RhdG9yLnVucmVuZGVyZXIpIHRoaXMuYW5ub3RhdG9yLnVucmVuZGVyZXIodGhpcy5hbm5vdGF0b3IpO1xuXG4gICAgICAgIC8vIGxldCBwbHVyYWwgPSBhbm5vdGF0aW9ucy5sZW5ndGggPT0gMSA/IFwiXCIgOiBcInNcIjtcbiAgICAgICAgLy8gbGV0IHRvdGFsQW5ub3RhdGlvbnMgPSB0aGlzLmFubm90YXRvci5hbm5vdGF0aW9uTWFuYWdlci5hbm5vdGF0aW9ucy5sZW5ndGg7XG4gICAgICAgIC8vIHRoaXMuJGNvbnRhaW5lci5odG1sKGA8cD5TaG93aW5nICR7YW5ub3RhdGlvbnMubGVuZ3RofSBhbm5vdGF0aW9uJHtwbHVyYWx9ICgke3RvdGFsQW5ub3RhdGlvbnN9IHRvdGFsKS48L3A+YCk7XG5cbiAgICAgICAgLy8gQWRkIGVhY2ggYW5ub3RhdGlvbiB0byB0aGUgcmVhZG91dFxuICAgICAgICBsZXQgb3JkZXJlZCA9IHRoaXMuYW5ub3RhdG9yLkdldEFubm90YXRpb25zKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JkZXJlZC5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB0aGlzLmFubm90YXRpb25MaXN0LmFwcGVuZCh0aGlzLk1ha2VDb250YWluZXIodGhpcy5hbm5vdGF0b3IsIG9yZGVyZWRbaV0sIGkpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIE1ha2VDb250YWluZXIoYW5ub3RhdG9yLCBhbm5vdGF0aW9uKXtcbiAgICAgICAgLy9UT0RPOiBBUklBIGFuZCBnZW5lcmFsIHNjcmVlbiByZWFkZXIgY29tcGF0aWJpbGl0eVxuICAgICAgICBsZXQgJHBhbmVsID0gJChcIjxsaSByb2xlPSdwcmVzZW50YXRpb24nIGRhdGEtY3JlYXRvcj1cIithbm5vdGF0aW9uLmNyZWF0b3IuZW1haWwrXCIgZGF0YS10YWdzPSdcIithbm5vdGF0aW9uLnRhZ3Muam9pbihcIiwgXCIpLnJlcGxhY2UoXCInXCIsIFwiJTI3XCIpK1wiJz48L2xpPlwiKTtcbiAgICAgICAgLy9sZXQgdGV4dCA9IEpTT04uc3RyaW5naWZ5KGFubm90YXRpb24uQXNPcGVuQW5ub3RhdGlvbigpLCBudWxsLCAyKTtcblxuICAgICAgICBsZXQgaGVhZGVyVGV4dCA9IEdldEZvcm1hdHRlZFRpbWUoYW5ub3RhdGlvbi5iZWdpblRpbWUpICsgXCIgLSBcIiArIEdldEZvcm1hdHRlZFRpbWUoYW5ub3RhdGlvbi5lbmRUaW1lKTtcbiBcbiAgICAgICAgLy8gQWRkIGNsaWNrYWJsZSBoZWFkZXIgdGhhdCBicmluZ3MgdXAgdGhlIGVkaXQgaW50ZXJmYWNlLlxuICAgICAgICBsZXQgJGhlYWRlciA9ICQoXCI8YSBocmVmPScnIHRpdGxlPSdHbyB0byBBbm5vdGF0aW9uJyByb2xlPSdtZW51aXRlbSc+XCIraGVhZGVyVGV4dCtcIjwvYT48YnI+XCIpO1xuICAgICAgICAkaGVhZGVyLmNsaWNrKCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBhbm5vdGF0b3IucGxheWVyLnZpZGVvRWxlbWVudC5jdXJyZW50VGltZSA9IGFubm90YXRpb24uYmVnaW5UaW1lO1xuICAgICAgICAgICAgLy8gaWYoYW5ub3RhdG9yLnBsYXllci52aWRlb0VsZW1lbnQuYW5ub3RhdGlvblRpbWVvdXQpIGNsZWFyVGltZW91dChhbm5vdGF0b3IucGxheWVyLnZpZGVvRWxlbWVudC5hbm5vdGF0aW9uVGltZW91dCk7XG4gICAgICAgICAgICAvLyBhbm5vdGF0b3IucGxheWVyLnZpZGVvRWxlbWVudC5hbm5vdGF0aW9uVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIC8vICAgICBhbm5vdGF0b3IucGxheWVyLnZpZGVvRWxlbWVudC5wYXVzZSgpfSwgKGFubm90YXRpb24uZW5kVGltZS1hbm5vdGF0aW9uLmJlZ2luVGltZSkgKiAxMDAwXG4gICAgICAgICAgICAvLyApO1xuICAgICAgICAgICAgLy9hbm5vdGF0b3IucGxheWVyLnZpZGVvRWxlbWVudC5zcmM9YW5ub3RhdG9yLnVybCArIFwiI3Q9XCIgKyBhbm5vdGF0aW9uLmJlZ2luVGltZSArXCIsXCIrYW5ub3RhdGlvbi5lbmRUaW1lO1xuICAgICAgICAgICAgLy9hbm5vdGF0b3IucGxheWVyLnZpZGVvRWxlbWVudC5wbGF5KCk7XG4gICAgICAgICAgICBhbm5vdGF0b3IucGxheWVyLlBsYXkoKTtcbiAgICAgICAgICAgIGFubm90YXRvci5wbGF5ZXIuZW5kVGltZSA9IGFubm90YXRpb24uZW5kVGltZTtcbiAgICAgICAgICAgIGlmKGFubm90YXRpb24uYmVnaW5UaW1lKzEgPiBhbm5vdGF0aW9uLmVuZFRpbWUpe1xuICAgICAgICAgICAgICAgIGFubm90YXRvci5wbGF5ZXIuUGF1c2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgJHBhbmVsLmFwcGVuZCgkaGVhZGVyKTtcbiAgICAgICAgbGV0ICRjb250ZW50ID0gJChcIjxwPjwvcD5cIik7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICRjb250ZW50LmFwcGVuZChcIjxiPlRleHQ6IDwvYj4gXCIgKyBhbm5vdGF0aW9uLmJvZHkuZmlsdGVyKGl0ZW0gPT4gaXRlbS5wdXJwb3NlID09PSBcImRlc2NyaWJpbmdcIilbMF0udmFsdWUpO1xuICAgICAgICAkY29udGVudC5hcHBlbmQoXCI8YnI+XCIpO1xuICAgICAgICAkY29udGVudC5hcHBlbmQoXCI8Yj5UYWdzOiA8L2I+IFwiICsgYW5ub3RhdGlvbi50YWdzLmpvaW4oXCIsIFwiKSk7XG4gICAgICAgICRjb250ZW50LmFwcGVuZChcIjxicj5cIik7XG5cbiAgICAgICAgJHBhbmVsLmFwcGVuZCgkY29udGVudCk7XG4gICAgICAgICRwYW5lbC5hcHBlbmRUbyhhbm5vdGF0b3IuJGFubm90YXRpb25MaXN0KTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJHBhbmVsKTtcbiAgICAgICAgcmV0dXJuICRwYW5lbDtcbiAgICB9XG5cbn1cblxuZXhwb3J0IHsgSW5kZXhDb250YWluZXIgfTsiLCJpbXBvcnQgeyBHZXRGb3JtYXR0ZWRUaW1lIH0gZnJvbSBcIi4uLy4uL3V0aWxzL3RpbWUuanNcIjtcbmxldCBzaGExID0gcmVxdWlyZSgnc2hhMScpO1xuXG5jbGFzcyBJbmZvQ29udGFpbmVyIHtcbiAgICBjb25zdHJ1Y3Rvcihhbm5vdGF0b3Ipe1xuICAgICAgICB0aGlzLmFubm90YXRvciA9IGFubm90YXRvcjtcbiAgICAgICAgbGV0IGNvbnRhaW5lciA9ICQoXCIud2FsZG9yZi1pbmZvXCIpO1xuICAgICAgICBpZihjb250YWluZXIubGVuZ3RoID4gMCl7XG4gICAgICAgICAgICB0aGlzLiRjb250YWluZXIgPSBjb250YWluZXIuZmlyc3QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lciA9ICQoXCI8ZGl2IGNsYXNzPSd3YWxkb3JmLWluZm8nIGFyaWEtbGl2ZT0ncG9saXRlJyBhcmlhLWF0b21pYz0ndHJ1ZSc+PC9kaXY+XCIpLmFwcGVuZFRvKHRoaXMuYW5ub3RhdG9yLiRjb250YWluZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgUmVidWlsZChhbm5vdGF0aW9ucywgY2xlYXJDb250YWluZXIpe1xuICAgICAgICBpZihjbGVhckNvbnRhaW5lcikgdGhpcy4kY29udGFpbmVyLmVtcHR5KCk7XG4gICAgICAgIGlmKHRoaXMuYW5ub3RhdG9yLnVucmVuZGVyZXIpIHRoaXMuYW5ub3RhdG9yLnVucmVuZGVyZXIodGhpcy5hbm5vdGF0b3IpO1xuXG4gICAgICAgIC8vIGxldCBwbHVyYWwgPSBhbm5vdGF0aW9ucy5sZW5ndGggPT0gMSA/IFwiXCIgOiBcInNcIjtcbiAgICAgICAgLy8gbGV0IHRvdGFsQW5ub3RhdGlvbnMgPSB0aGlzLmFubm90YXRvci5hbm5vdGF0aW9uTWFuYWdlci5hbm5vdGF0aW9ucy5sZW5ndGg7XG4gICAgICAgIC8vIHRoaXMuJGNvbnRhaW5lci5odG1sKGA8cD5TaG93aW5nICR7YW5ub3RhdGlvbnMubGVuZ3RofSBhbm5vdGF0aW9uJHtwbHVyYWx9ICgke3RvdGFsQW5ub3RhdGlvbnN9IHRvdGFsKS48L3A+YCk7XG5cbiAgICAgICAgLy8gQWRkIGVhY2ggYW5ub3RhdGlvbiB0byB0aGUgcmVhZG91dFxuICAgICAgICBsZXQgcmVuZGVyZXIgPSB0aGlzLmFubm90YXRvci5yZW5kZXJlciA9PT0gZmFsc2UgPyB0aGlzLk1ha2VDb250YWluZXIgOiB0aGlzLmFubm90YXRvci5yZW5kZXJlcjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbm5vdGF0aW9ucy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB0aGlzLiRjb250YWluZXIuYXBwZW5kKHJlbmRlcmVyKHRoaXMuYW5ub3RhdG9yLCBhbm5vdGF0aW9uc1tpXSwgaSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgTWFrZUNvbnRhaW5lcihhbm5vdGF0b3IsIGFubm90YXRpb24sIGluZGV4KXtcbiAgICAgICAgbGV0ICRwYW5lbCA9ICQoXCI8cD48L3A+XCIpLmFwcGVuZFRvKCQoXCI8ZGl2PjwvZGl2PlwiKS5hcHBlbmRUbyhhbm5vdGF0b3IuJGNvbnRhaW5lcikpO1xuICAgICAgICAvL2xldCB0ZXh0ID0gSlNPTi5zdHJpbmdpZnkoYW5ub3RhdGlvbi5Bc09wZW5Bbm5vdGF0aW9uKCksIG51bGwsIDIpO1xuXG4gICAgICAgIC8vIEFkZCBjbGlja2FibGUgaGVhZGVyIHRoYXQgYnJpbmdzIHVwIHRoZSBlZGl0IGludGVyZmFjZS5cbiAgICAgICAgbGV0ICRoZWFkZXIgPSAkKGA8Yj5Bbm5vdGF0aW9uICR7aW5kZXggKyAxfTo8L2I+PGJyPmApO1xuICAgICAgICBpZihhbm5vdGF0b3Iua2lvc2tNb2RlPT1mYWxzZSl7XG4gICAgICAgICAgICAkaGVhZGVyID0gJChgPGEgaHJlZj0nJyB0aXRsZT0nRWRpdCBBbm5vdGF0aW9uJz48Yj5Bbm5vdGF0aW9uICR7aW5kZXggKyAxfTo8L2I+PGJyPjwvYT5gKTtcbiAgICAgICAgICAgICRoZWFkZXIuY2xpY2soIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgYW5ub3RhdG9yLmd1aS5CZWdpbkVkaXRpbmcoYW5ub3RhdGlvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgICRwYW5lbC5hcHBlbmQoJGhlYWRlcik7XG4gICAgICAgIGxldCAkY29udGVudCA9ICQoXCI8cD48L3A+XCIpO1xuICAgICAgICBcbiAgICAgICAgaWYgKCd1bmRlZmluZWQnID09IHR5cGVvZihhbm5vdGF0aW9uLml0ZW1zKSkgeyAvLyBWZXJzaW9uIDFcbiAgICAgICAgICAgIHZhciBhbm5vdGF0aW9uX2JvZHkgPSBhbm5vdGF0aW9uLmJvZHkuZmlsdGVyKGl0ZW0gPT4gaXRlbS5wdXJwb3NlID09PSBcImRlc2NyaWJpbmdcIilbMF07XG4gICAgICAgICAgICB2YXIgYW5ub3RhdGlvbl9jcmVhdG9yID0gKGFubm90YXRpb24uY3JlYXRvciAhPSBudWxsKSA/IGFubm90YXRpb24uY3JlYXRvciA6IHt9O1xuICAgICAgICB9IGVsc2UgeyAvLyBWZXJzaW9uIDJcbiAgICAgICAgICAgIHZhciBhbm5vdGF0aW9uX2JvZHkgPSBhbm5vdGF0aW9uLml0ZW1zWzBdLml0ZW1zWzBdLml0ZW1zWzBdLmJvZHkuZmlsdGVyKGl0ZW0gPT4gaXRlbS5wdXJwb3NlID09PSBcImRlc2NyaWJpbmdcIilbMF07XG4gICAgICAgICAgICB2YXIgYW5ub3RhdGlvbl9jcmVhdG9yID0gYW5ub3RhdGlvbi5pdGVtc1swXS5pdGVtc1swXS5pdGVtc1swXS5jcmVhdG9yO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAkY29udGVudC5hcHBlbmQoXCI8Yj5UZXh0OiA8L2I+IFwiICsgYW5ub3RhdGlvbl9ib2R5LnZhbHVlKTtcbiAgICAgICAgJGNvbnRlbnQuYXBwZW5kKFwiPGJyPlwiKTtcbiAgICAgICAgJGNvbnRlbnQuYXBwZW5kKFwiPGI+VGFnczogPC9iPiBcIiArIGFubm90YXRpb24udGFncy5qb2luKFwiLCBcIikpO1xuICAgICAgICAkY29udGVudC5hcHBlbmQoXCI8YnI+XCIpO1xuICAgICAgICAkY29udGVudC5hcHBlbmQoXCI8Yj5UaW1lOiA8L2I+IFwiIFxuICAgICAgICAgICAgICAgICsgR2V0Rm9ybWF0dGVkVGltZShhbm5vdGF0aW9uLmJlZ2luVGltZSkgXG4gICAgICAgICAgICAgICAgKyBcIiAtIFwiIFxuICAgICAgICAgICAgICAgICsgR2V0Rm9ybWF0dGVkVGltZShhbm5vdGF0aW9uLmVuZFRpbWUpKTtcbiAgICAgICAgJGNvbnRlbnQuYXBwZW5kKFwiPGJyPlwiKTtcblxuICAgICAgICAkY29udGVudC5hcHBlbmQoXCI8Yj5TdWJtaXR0ZXI6PC9iPiBcIlxuICAgICAgICAgICAgICAgICsgKCgndW5kZWZpbmVkJyAhPSB0eXBlb2YoYW5ub3RhdGlvbl9jcmVhdG9yLm5pY2tuYW1lKSAmJiBhbm5vdGF0aW9uX2NyZWF0b3Iubmlja25hbWUubGVuZ3RoKSA/IGFubm90YXRpb25fY3JlYXRvci5uaWNrbmFtZSA6IFwiPGk+Tm90IGF2YWlsYWJsZTwvaT5cIilcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgIC8vJHBhcmFncmFwaC5hcHBlbmQoXCI8c3Ryb25nPkFubm90YXRpb24gXCIgKyAoaW5kZXggKyAxKSArIFwiOjwvc3Ryb25nPjxicj48cHJlPlwiICsgdGV4dC5lc2NhcGVIVE1MKCkgKyBcIjwvcHJlPlwiKTtcblxuICAgICAgICAkcGFuZWwuYXBwZW5kKCRjb250ZW50KTtcbiAgICAgICAgcmV0dXJuICRwYW5lbDtcbiAgICB9XG5cbn1cblxuZXhwb3J0IHsgSW5mb0NvbnRhaW5lciB9OyIsIlxuY2xhc3MgTWVzc2FnZU92ZXJsYXkge1xuICAgIGNvbnN0cnVjdG9yKGFubm90YXRvcil7XG4gICAgICAgIHRoaXMuYW5ub3RhdG9yID0gYW5ub3RhdG9yO1xuXG4gICAgICAgIHRoaXMuJGNvbnRhaW5lciA9ICQoXCI8ZGl2IGNsYXNzPSd3YWxkb3JmLW1lc3NhZ2Utb3ZlcmxheSc+PC9kaXY+XCIpO1xuICAgICAgICB0aGlzLiRjb250YWluZXIuYXBwZW5kVG8odGhpcy5hbm5vdGF0b3IucGxheWVyLiRjb250YWluZXIpO1xuXG4gICAgICAgIHRoaXMuJHRleHQgPSAkKFwiPHAgcm9sZT0nYWxlcnQnIGFyaWEtbGl2ZT0nYXNzZXJ0aXZlJyBhcmlhLWF0b21pYz0ndHJ1ZSc+PC9wPlwiKS5hcHBlbmRUbyh0aGlzLiRjb250YWluZXIpO1xuICAgICAgICB0aGlzLiRjb250YWluZXIuZmFkZU91dCgwKTtcblxuICAgIH1cblxuICAgIFNob3dFcnJvcihtZXNzYWdlLCBkdXJhdGlvbiA9IDMuMCl7XG4gICAgICAgIHRoaXMuJGNvbnRhaW5lci5hZGRDbGFzcyhcIndhbGRvcmYtbWVzc2FnZS1vdmVybGF5LWVycm9yXCIpO1xuXG4gICAgICAgIHRoaXMuX1Nob3dUZXh0KG1lc3NhZ2UsIGR1cmF0aW9uKTtcbiAgICB9XG5cbiAgICBTaG93TWVzc2FnZShtZXNzYWdlLCBkdXJhdGlvbiA9IDUuMCl7XG4gICAgICAgIHRoaXMuJGNvbnRhaW5lci5yZW1vdmVDbGFzcyhcIndhbGRvcmYtbWVzc2FnZS1vdmVybGF5LWVycm9yXCIpO1xuXG4gICAgICAgIHRoaXMuX1Nob3dUZXh0KG1lc3NhZ2UsIGR1cmF0aW9uKTtcbiAgICB9XG5cbiAgICBfU2hvd1RleHQobWVzc2FnZSwgZHVyYXRpb24gPSA1LjApe1xuICAgICAgICB0aGlzLiR0ZXh0Lmh0bWwobWVzc2FnZSk7XG4gICAgICAgIC8vdGhpcy4kY29udGFpbmVyLnN0b3AodHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuJGNvbnRhaW5lci5maW5pc2goKTtcbiAgICAgICAgdGhpcy4kY29udGFpbmVyLlxuICAgICAgICAgICAgZmFkZUluKDApLlxuICAgICAgICAgICAgZGVsYXkoZHVyYXRpb24gKiAxMDAwKS5cbiAgICAgICAgICAgIGZhZGVPdXQoNDAwKTtcbiAgICB9XG5cbn1cblxuZXhwb3J0IHsgTWVzc2FnZU92ZXJsYXkgfTsiLCJcbi8qKlxuICogTWFuYWdlcyB0aGUgY3JlYXRpbmcgb3IgZWRpdGluZyBvZiBhIHNpbmdsZSBwb2x5Z29uIG9uIHRoZSB2aWRlby5cbiAqIENvbnNpc3RzIG9mIGEgdG9vbGJhciwgYW4gb3ZlcmxheSwgYW5kIHRoZSBwb2x5Z29uIGluc2lkZSB0aGUgb3ZlcmxheS5cbiAqXG4gKiBDbGljayB0byBwbGFjZSBvciByZW1vdmUgYSBkcmFnZ2FibGUgcG9pbnQuIFBvaW50cyBzaG91bGQgYmVcbiAqIHB1dCBkb3duIGluIGNsb2Nrd2lzZSBvcmRlci5cbiAqL1xuY2xhc3MgUG9seWdvbkVkaXRvciB7XG4gICAgY29uc3RydWN0b3IoYW5ub3RhdG9yKXtcbiAgICAgICAgdGhpcy5hbm5vdGF0b3IgPSBhbm5vdGF0b3I7XG4gICAgICAgIHRoaXMuYmFzZVogPSAyMTQ3NDgzNjQ5O1xuICAgICAgICB0aGlzLiRicmVhZGNydW1icyA9IFtdO1xuICAgICAgICB0aGlzLiR2ZXJ0aWNlcyA9IHsgJ3N0YXJ0JzogW10sICdzdG9wJzogW10gfTsgICAvL2FycmF5cyBvZiB2ZXJ0aWNlcyBmb3Igc3RhcnQvc3RvcCBwb2x5c1xuICAgICAgICB0aGlzLiRwb2x5Z29ucyA9IHsgJ3N0YXJ0JzogbnVsbCwgJ3N0b3AnOiBudWxsIH07ICAgLy9ET00gbm9kZXMgZm9yIHRoZSBhY3R1YWwgcG9seWdvbnNcbiAgICAgICAgLy8gdGhpcy4kdGVtcEJyZWFkQ3J1bWJzID0gW107XG4gICAgICAgIHRoaXMuJHN0YXJ0U3RvcCA9IG51bGw7XG5cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSB2aWRlbyBvdmVybGF5XG4gICAgICAgIHRoaXMuJGNsaWNrU3VyZmFjZSA9ICQoXCI8ZGl2IGNsYXNzPSd3YWxkb3JmLWVkaXQtb3ZlcmxheSB3YWxkb3JmLXZwLWNsaWNrLXN1cmZhY2UnPjwvZGl2PlwiKS5hcHBlbmRUbyh0aGlzLmFubm90YXRvci5wbGF5ZXIuJGNvbnRhaW5lcik7XG4gICAgICAgIC8vdGhpcy4kY2xpY2tTdXJmYWNlLmNzcyhcInotaW5kZXhcIiwgdGhpcy5iYXNlWik7XG4gICAgICAgIHRoaXMuJGNsaWNrU3VyZmFjZS5jbGljaygoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuT25TdXJmYWNlQ2xpY2soZXZlbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBwb2x5Z29uIERPTSBub2Rlc1xuICAgICAgICB0aGlzLiRwb2x5Z29ucy5zdGFydCA9ICQoXCI8ZGl2IGNsYXNzPSd3YWxkb3JmLXN0YXJ0LXBvbHknPjwvZGl2PlwiKS5hcHBlbmRUbyh0aGlzLiRjbGlja1N1cmZhY2UpO1xuICAgICAgICB0aGlzLiRwb2x5Z29ucy5zdGFydC5jc3MoXCJ6LWluZGV4XCIsIHRoaXMuYmFzZVogKyAxKTtcbiAgICAgICAgdGhpcy4kcG9seWdvbnMuc3RvcCA9ICQoXCI8ZGl2IGNsYXNzPSd3YWxkb3JmLXN0b3AtcG9seSc+PC9kaXY+XCIpLmFwcGVuZFRvKHRoaXMuJGNsaWNrU3VyZmFjZSk7XG4gICAgICAgIHRoaXMuJHBvbHlnb25zLnN0b3AuY3NzKFwiei1pbmRleFwiLCB0aGlzLmJhc2VaICsgMSk7XG5cbiAgICAgICAgdGhpcy5SZXNpemVPdmVybGF5KCk7XG4gICAgICAgIHRoaXMuYW5ub3RhdG9yLnBsYXllci4kY29udGFpbmVyLm9uKFwiT25GdWxsc2NyZWVuQ2hhbmdlXCIsIChldmVudCwgc2V0RnVsbHNjcmVlbikgPT4gdGhpcy5SZXNpemVPdmVybGF5KCkpO1xuXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgdG9vbGJhciB1cCB0b3BcbiAgICAgICAgLy8gdGhpcy4kYmFyID0gJChcIjxkaXYgY2xhc3M9J3dhbGRvcmYtdnAtcG9zdCc+PC9kaXY+XCIpLmFwcGVuZFRvKHRoaXMuYW5ub3RhdG9yLnBsYXllci4kY29udGFpbmVyKTtcbiAgICAgICAgLy8gdGhpcy4kcG9zdFRvb2xiYXIgPSAkKFwiPGRpdiBjbGFzcz0nZmxleC10b29sYmFyJz48L2Rpdj5cIikuYXBwZW5kVG8odGhpcy4kYmFyKTtcbiAgICAgICAgLy8gSW52aXNpYmxlIGV4cGFuZGluZyBkaXZpZGVyXG4gICAgICAgIC8vLTMvL3RoaXMuJHBvc3RUb29sYmFyLmFwcGVuZCgkKFwiPGRpdj48cCBzdHlsZT0nY29sb3I6d2hpdGUnPkVkaXQgUG9seWdvbjwvcD48L2Rpdj5cIikuY3NzKFwiZmxleC1ncm93XCIsIDEpLmNzcyhcIm9yZGVyXCIsIDApKTtcblxuXG4gICAgICAgIC8vIE1ha2UgXCJDb2xsZWN0IFBvbHlnb24gc3RhdGVcIiBidXR0b25cbiAgICAgICAgLy8gdGhpcy4kY2FwUG9seUJ1dHRvbiA9ICQoXCI8YnV0dG9uPkNhcHR1cmUgUG9seWdvbjwvYnV0dG9uPlwiKS5idXR0b24oe1xuICAgICAgICAvLyAgICAgaWNvbjogXCJmYSBmYS1jYW1lcmEtcmV0cm9cIixcbiAgICAgICAgLy8gICAgIHNob3dMYWJlbDogZmFsc2VcbiAgICAgICAgLy8gfSkuY2xpY2soKCkgPT4ge1xuICAgICAgICAvLyAgICAgLy90aGlzLlNldFZpc2libGUoZmFsc2UpO1xuICAgICAgICAvLyAgICAgLy90aGlzLkdldFBvaW50cygpO1xuXG4gICAgICAgIC8vICAgICAvLyBCdWlsZCBwb2x5Z29uIHNlbGVjdG9yXG4gICAgICAgIC8vICAgICAvLyBsZXQgcG9pbnRzID0gdGhpcy5HZXRQb2ludHMoKTtcbiAgICAgICAgLy8gICAgIC8vIGlmKHBvaW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vICAgICAvLyAgICAgbGV0IHBvaW50c1N0ciA9IHBvaW50cy5tYXAoaXRlbSA9PiB7IHJldHVybiBgJHtpdGVtWzBdfSwke2l0ZW1bMV19YCB9KS5qb2luKFwiIFwiKTtcbiAgICAgICAgLy8gICAgIC8vICAgICBsZXQgcG9seWdvblNlbGVjdG9yID0ge1xuICAgICAgICAvLyAgICAgLy8gICAgICAgICBcInR5cGVcIjogXCJTdmdTZWxlY3RvclwiLFxuICAgICAgICAvLyAgICAgLy8gICAgICAgICBcInZhbHVlXCI6IGA8c3ZnOnN2ZyB2aWV3Qm94PScwIDAgMTAwIDEwMCcgcHJlc2VydmVBc3BlY3RSYXRpbz0nbm9uZSc+PHBvbHlnb24gcG9pbnRzPScke3BvaW50c1N0cn0nIC8+PC9zdmc6c3ZnPmAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjQ4OTg3MjhcbiAgICAgICAgLy8gICAgIC8vICAgICB9XG4gICAgICAgIC8vICAgICAvLyAgICAgdG1wU2VsZWN0b3JzLnB1c2gocG9seWdvblNlbGVjdG9yKTtcbiAgICAgICAgLy8gICAgIC8vIH1cbiAgICAgICAgLy8gICAgIC8vIGNvbnNvbGUubG9nKFwidG1wU2VsZWN0b3JzXCIpO1xuICAgICAgICAvLyAgICAgLy8gY29uc29sZS5sb2codG1wU2VsZWN0b3JzKTtcbiAgICAgICAgLy8gICAgIHRoaXMuYW5ub3RhdG9yLkFkZFBvbHlnb25TZXQodGhpcy5hbm5vdGF0b3IuYW5ub3RhdGlvbi5nZXRQb2x5KCkpO1xuXG4gICAgICAgIC8vIH0pO1xuICAgICAgICAvLyB0aGlzLiRjYXBQb2x5QnV0dG9uLmNzcyhcIm1hcmdpbi1yaWdodFwiLCBcIjE1cHhcIik7XG4gICAgICAgIC8vIHRoaXMuJGNhcFBvbHlCdXR0b24uYXR0cigndGl0bGUnLCBcIkNhcHR1cmUgcG9seWdvblwiKTtcbiAgICAgICAgLy8tMy8vdGhpcy5SZWdpc3RlckVsZW1lbnQodGhpcy4kY2FwUG9seUJ1dHRvbiwgdGhpcy4kcG9zdFRvb2xiYXIsIDEsICdmbGV4LWVuZCcpO1xuXG4gICAgICAgIC8vIENyZWF0ZSB1bmRvIGJ1dHRvblxuICAgICAgICAvLyB0aGlzLiR1bmRvQnV0dG9uID0gJChcIjxidXR0b24+UmVtb3ZlIExhc3QgUG9pbnQ8L2J1dHRvbj5cIikuYnV0dG9uKHtcbiAgICAgICAgLy8gICAgIGljb246IFwiZmEgZmEtdW5kb1wiLFxuICAgICAgICAvLyAgICAgc2hvd0xhYmVsOiBmYWxzZVxuICAgICAgICAvLyB9KTtcbiAgICAgICAgLy8gdGhpcy4kdW5kb0J1dHRvbi5jc3MoXCJtYXJnaW4tcmlnaHRcIiwgXCIxNXB4XCIpO1xuICAgICAgICAvLyB0aGlzLiR1bmRvQnV0dG9uLmF0dHIoJ3RpdGxlJywgXCJSZW1vdmUgbGFzdCBwb2ludFwiKTtcbiAgICAgICAgLy8gdGhpcy4kdW5kb0J1dHRvbi5jbGljaygoKSA9PiB7XG4gICAgICAgIC8vICAgICB0aGlzLlJlbW92ZUxhc3RCcmVhZGNydW1iKCk7XG4gICAgICAgIC8vIH0pO1xuICAgICAgICAvLy0zLy90aGlzLlJlZ2lzdGVyRWxlbWVudCh0aGlzLiR1bmRvQnV0dG9uLCB0aGlzLiRwb3N0VG9vbGJhciwgMSwgJ2ZsZXgtZW5kJyk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBjb25maXJtIGJ1dHRvblxuICAgICAgICAvLyB0aGlzLiRjb25maXJtQnV0dG9uID0gJChcIjxidXR0b24+RmluaXNoIHBvbHlnb248L2J1dHRvbj5cIikuYnV0dG9uKHtcbiAgICAgICAgLy8gICAgIGljb246IFwiZmEgZmEtY2hlY2tcIixcbiAgICAgICAgLy8gICAgIHNob3dMYWJlbDogZmFsc2VcbiAgICAgICAgLy8gfSk7XG4gICAgICAgIC8vIHRoaXMuJGNvbmZpcm1CdXR0b24uYXR0cigndGl0bGUnLCBcIkZpbmlzaCBwb2x5Z29uXCIpO1xuICAgICAgICAvLyB0aGlzLiRjb25maXJtQnV0dG9uLmFkZENsYXNzKFwid2FsZG9yZi1jb25maXJtLWJ1dHRvblwiKTtcbiAgICAgICAgLy8gdGhpcy4kY29uZmlybUJ1dHRvbi5jbGljaygoKSA9PiB7XG4gICAgICAgIC8vICAgICB0aGlzLm9yaWdpbmFsSlNPTiA9IHRoaXMuR2V0SlNPTigpO1xuICAgICAgICAvLyAgICAgdGhpcy5Eb25lKCk7XG4gICAgICAgIC8vICAgICB0aGlzLmFubm90YXRvci4kY29udGFpbmVyLnRyaWdnZXIoXCJPblBvbHlnb25FZGl0aW5nRW5kZWRcIik7XG4gICAgICAgIC8vIH0pO1xuICAgICAgICAvLyAvLy0zLy90aGlzLlJlZ2lzdGVyRWxlbWVudCh0aGlzLiRjb25maXJtQnV0dG9uLCB0aGlzLiRwb3N0VG9vbGJhciwgMywgJ2ZsZXgtZW5kJyk7XG5cbiAgICAgICAgLy8gLy8gQ3JlYXRlIHRoZSBjYW5jZWwgYnV0dG9uXG4gICAgICAgIC8vIHRoaXMuJGNhbmNlbEJ1dHRvbiA9ICQoXCI8YnV0dG9uPlN0b3AgcG9seWdvbiBlZGl0aW5nPC9idXR0b24+XCIpLmJ1dHRvbih7XG4gICAgICAgIC8vICAgICBpY29uOiBcImZhIGZhLXJlbW92ZVwiLFxuICAgICAgICAvLyAgICAgc2hvd0xhYmVsOiBmYWxzZVxuICAgICAgICAvLyB9KTtcbiAgICAgICAgLy8gdGhpcy4kY2FuY2VsQnV0dG9uLmFkZENsYXNzKFwid2FsZG9yZi1jYW5jZWwtYnV0dG9uXCIpO1xuICAgICAgICAvLyB0aGlzLiRjYW5jZWxCdXR0b24uYXR0cigndGl0bGUnLCBcIlN0b3AgcG9seWdvbiBlZGl0aW5nXCIpO1xuICAgICAgICAvLyB0aGlzLiRjYW5jZWxCdXR0b24uY2xpY2soKCkgPT4ge1xuICAgICAgICAvLyAgICAgLy9SZXN0b3JlIHRoZSBvcmlnaW5hbCBzdGF0ZVxuICAgICAgICAvLyAgICAgdGhpcy5SZXN0b3JlKCk7XG4gICAgICAgIC8vICAgICB0aGlzLkRvbmUoKTtcbiAgICAgICAgLy8gICAgIHRoaXMuYW5ub3RhdG9yLiRjb250YWluZXIudHJpZ2dlcihcIk9uUG9seWdvbkVkaXRpbmdFbmRlZFwiKTtcbiAgICAgICAgLy8gfSk7XG4gICAgICAgIC8vIC8vLTMvL3RoaXMuUmVnaXN0ZXJFbGVtZW50KHRoaXMuJGNhbmNlbEJ1dHRvbiwgdGhpcy4kcG9zdFRvb2xiYXIsIDIsICdmbGV4LWVuZCcpO1xuXG4gICAgICAgIC8vICQod2luZG93KS5yZXNpemUoKCkgPT4gdGhpcy5SZXNpemVPdmVybGF5KCkpO1xuXG5cbiAgICAgICAgLyogXG4gICAgICAgICogbmV3IFVJXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuJGVkaXREaWFsb2cgPSAkKFwiPGRpdiBpZD0nZWRpdC1kaWFsb2cnIGNsYXNzPSd3YWxkb3JmLWVkaXQtb3ZlcmxheSB3YWxkb3JmLXZwLWNsaWNrLXN1cmZhY2UnPjwvZGl2PlwiKS5hcHBlbmRUbyh0aGlzLmFubm90YXRvci5wbGF5ZXIuJGNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuJGVkaXREaWFsb2cuZHJhZ2dhYmxlKCk7XG4gICAgICAgIHRoaXMuJGVkaXREaWFsb2cuY3NzKCd6LWluZGV4JywgdGhpcy5iYXNlWiArIDEwMCk7XG4gICAgICAgIHRoaXMuJGVkaXREaWFsb2cuY2xpY2soKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLk9uU3VyZmFjZUNsaWNrKGV2ZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy4kc3BhY2UgPSAkKFwiPGRpdj4mbmJzcDs8L2Rpdj48aHI+XCIpO1xuICAgICAgICB0aGlzLlJlZ2lzdGVyRWxlbWVudCh0aGlzLiRzcGFjZSwgdGhpcy4kZWRpdERpYWxvZywgMSwgJ2ZsZXgtZW5kJyk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIHVuZG8gYnV0dG9uXG4gICAgICAgIHRoaXMuJHVuZG9CdXR0b24gPSAkKFwiPGJ1dHRvbj5SZW1vdmUgTGFzdCBQb2ludDwvYnV0dG9uPlwiKS5idXR0b24oe1xuICAgICAgICAgICAgaWNvbjogXCJmYSBmYS11bmRvXCIsXG4gICAgICAgICAgICBzaG93TGFiZWw6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiR1bmRvQnV0dG9uLmNzcyhcIm1hcmdpblwiLCBcIjBweCA1cHggNHB4IDVweFwiKTtcbiAgICAgICAgdGhpcy4kdW5kb0J1dHRvbi5hdHRyKCd0aXRsZScsIFwiUmVtb3ZlIGxhc3QgcG9pbnRcIik7XG4gICAgICAgIHRoaXMuJHVuZG9CdXR0b24uY3NzKCd6LWluZGV4JywgdGhpcy5iYXNlWiArIDEwNSk7XG4gICAgICAgIHRoaXMuJHVuZG9CdXR0b24uY2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5SZW1vdmVMYXN0QnJlYWRjcnVtYigpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5SZWdpc3RlckVsZW1lbnQodGhpcy4kdW5kb0J1dHRvbiwgdGhpcy4kZWRpdERpYWxvZywgMSwgJ2ZsZXgtZW5kJyk7XG5cbiAgICAgICAgLy8gTWFrZSBcIkNvbGxlY3QgUG9seWdvbiBzdGF0ZVwiIGJ1dHRvblxuICAgICAgICB0aGlzLiRjYXBQb2x5QnV0dG9uID0gJChcIjxidXR0b24+Q2FwdHVyZSBQb2x5Z29uPC9idXR0b24+XCIpLmJ1dHRvbih7XG4gICAgICAgICAgICBpY29uOiBcImZhIGZhLWNhbWVyYS1yZXRyb1wiLFxuICAgICAgICAgICAgc2hvd0xhYmVsOiBmYWxzZVxuICAgICAgICB9KS5jbGljaygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLkFkZFBvbHlnb25TZXQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuJGNhcFBvbHlCdXR0b24uY3NzKFwibWFyZ2luXCIsIFwiMHB4IDVweCA0cHggNXB4XCIpO1xuICAgICAgICB0aGlzLiRjYXBQb2x5QnV0dG9uLmF0dHIoJ3RpdGxlJywgXCJDYXB0dXJlIFBvbHlnb25cIik7XG4gICAgICAgIHRoaXMuJGNhcFBvbHlCdXR0b24uY3NzKCd6LWluZGV4JywgdGhpcy5iYXNlWiArIDEwNSk7XG4gICAgICAgIHRoaXMuUmVnaXN0ZXJFbGVtZW50KHRoaXMuJGNhcFBvbHlCdXR0b24sIHRoaXMuJGVkaXREaWFsb2csIDEsICdmbGV4LWVuZCcpO1xuXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgY2FuY2VsIGJ1dHRvblxuICAgICAgICB0aGlzLiRjYW5jZWxCdXR0b24gPSAkKFwiPGJ1dHRvbj5TdG9wIHBvbHlnb24gZWRpdGluZzwvYnV0dG9uPlwiKS5idXR0b24oe1xuICAgICAgICAgICAgaWNvbjogXCJmYSBmYS1yZW1vdmVcIixcbiAgICAgICAgICAgIHNob3dMYWJlbDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuJGNhbmNlbEJ1dHRvbi5jc3MoXCJtYXJnaW5cIiwgXCIwcHggNXB4IDRweCA1cHhcIik7XG4gICAgICAgIHRoaXMuJGNhbmNlbEJ1dHRvbi5hZGRDbGFzcyhcIndhbGRvcmYtY2FuY2VsLWJ1dHRvblwiKTtcbiAgICAgICAgdGhpcy4kY2FuY2VsQnV0dG9uLmF0dHIoJ3RpdGxlJywgXCJTdG9wIFBvbHlnb24gRWRpdGluZ1wiKTtcbiAgICAgICAgdGhpcy4kY2FuY2VsQnV0dG9uLmNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgIC8vUmVzdG9yZSB0aGUgb3JpZ2luYWwgc3RhdGVcbiAgICAgICAgICAgIC8vdGhpcy5SZXN0b3JlKCk7XG4gICAgICAgICAgICB0aGlzLlJlbW92ZUFsbEJyZWFkY3J1bWJzKCk7XG4gICAgICAgICAgICB0aGlzLmFubm90YXRvci4kY29udGFpbmVyLnRyaWdnZXIoXCJPblBvbHlnb25FZGl0aW5nRW5kZWRcIik7XG4gICAgICAgICAgICB0aGlzLkRvbmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuUmVnaXN0ZXJFbGVtZW50KHRoaXMuJGNhbmNlbEJ1dHRvbiwgdGhpcy4kZWRpdERpYWxvZywgMiwgJ2ZsZXgtZW5kJyk7XG5cbiAgICAgICAgJCh3aW5kb3cpLnJlc2l6ZSgoKSA9PiB0aGlzLlJlc2l6ZU92ZXJsYXkoKSk7XG5cbiAgICAgICAgdGhpcy5Eb25lKCk7XG4gICAgfVxuXG4gICAgT25TdXJmYWNlQ2xpY2soZXZlbnQpe1xuICAgICAgICBpZiAoJChldmVudC5jdXJyZW50VGFyZ2V0KS5hdHRyKFwiaWRcIikgPT0gXCJlZGl0LWRpYWxvZ1wiIHx8IHRoaXMuJHN0YXJ0U3RvcCAhPSBcInN0YXJ0XCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBhIGJyZWFkY3J1bWIgb24gY2xpY2ssIGJ1dCBvbmx5IGZvciB0aGUgc3RhcnQgcG9seWdvbi4gRW5kIHZlcnRpY2VzIGNhbiBvbmx5IGJlIGRyYWdnZWRcbiAgICAgICAgbGV0IHRhcmdldCA9ICQoZXZlbnQuY3VycmVudFRhcmdldCk7XG4gICAgICAgIGxldCB4ID0gZXZlbnQucGFnZVggLSB0YXJnZXQub2Zmc2V0KCkubGVmdDtcbiAgICAgICAgbGV0IHkgPSBldmVudC5wYWdlWSAtIHRhcmdldC5vZmZzZXQoKS50b3A7XG4gICAgICAgIFxuICAgICAgICBsZXQgeFBlcmNlbnQgPSAoeCAvIHRhcmdldC53aWR0aCgpKSAqIDEwMDtcbiAgICAgICAgbGV0IHlQZXJjZW50ID0gKHkgLyB0YXJnZXQuaGVpZ2h0KCkpICogMTAwO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5BZGRCcmVhZGNydW1iKHhQZXJjZW50LCB5UGVyY2VudCk7XG4gICAgICAgIFxuICAgICAgICAvL3RoaXMubmV3UG9seVBvaW50cy5wdXNoKFt4UGVyY2VudC50b0ZpeGVkKDMpLCB5UGVyY2VudC50b0ZpeGVkKDMpXSk7XG4gICAgICAgIHRoaXMuVXBkYXRlUG9seUNsaXBwaW5nKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBicmVhZGNydW1iIGF0IHRoZSBnaXZlbiAoeCwgeSkgcG9pbnQgb24gdGhlXG4gICAgICogY2xpY2tTdXJmYWNlLCB3aGVyZSB4IGFuZCB5IGFyZSBwZXJjZW50YWdlcyBmcm9tIDAgdG8gMTAwLlxuICAgICAqL1xuICAgIEFkZEJyZWFkY3J1bWIoeFBlcmNlbnQsIHlQZXJjZW50KXtcbiAgICAgICAgbGV0ICRicmVhZGNydW1iID0gJChcIjxkaXYgY2xhc3M9J2JyZWFkY3J1bWInPjwvZGl2PlwiKTtcbiAgICAgICAgJGJyZWFkY3J1bWIuYXBwZW5kVG8odGhpcy4kY2xpY2tTdXJmYWNlKTtcbiAgICAgICAgJGJyZWFkY3J1bWIuY3NzKFwicG9zaXRpb25cIiwgXCJhYnNvbHV0ZVwiKTtcblxuICAgICAgICAvLyBQZXJjZW50YWdlIHJlcHJlc2VudGF0aW9ucyBvZiBicmVhZGNydW1iIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgICAgbGV0IG9mZlBlcmNlbnRYID0gKCRicmVhZGNydW1iLm91dGVyV2lkdGgoKSAvIHRoaXMuJGNsaWNrU3VyZmFjZS53aWR0aCgpKSAqIDEwMDtcbiAgICAgICAgbGV0IG9mZlBlcmNlbnRZID0gKCRicmVhZGNydW1iLm91dGVySGVpZ2h0KCkgLyB0aGlzLiRjbGlja1N1cmZhY2UuaGVpZ2h0KCkpICogMTAwO1xuICAgICAgICAvLyBQZXJjZW50YWdlIHJlcHJlc2VudGF0aW9ucyBvZiBicmVhZGNydW1iIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgICAgJGJyZWFkY3J1bWIuY3NzKFwibGVmdFwiLCAoeFBlcmNlbnQgLSAob2ZmUGVyY2VudFggLyAyKSkudG9TdHJpbmcoKSArIFwiJVwiKTtcbiAgICAgICAgJGJyZWFkY3J1bWIuY3NzKFwidG9wXCIsICh5UGVyY2VudCAtIChvZmZQZXJjZW50WSAvIDIpKS50b1N0cmluZygpICsgXCIlXCIpO1xuICAgICAgICAvLyRicmVhZGNydW1iLmNzcyhcInotaW5kZXhcIiwgdGhpcy5iYXNlWiAtIDUwKTtcblxuICAgICAgICBcbiAgICAgICAgJGJyZWFkY3J1bWIuZHJhZ2dhYmxlKHsgXG4gICAgICAgICAgICAvL2NvbnRhaW5tZW50OiBcInBhcmVudFwiLFxuICAgICAgICAgICAgZHJhZzogKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFJlY2FsY3VsYXRlIHBlcmNlbnRhZ2VzIChtYW5nbGVkIGJ5IGpRdWVyeSBVSSBkcmFnZ2FibGUgY29kZSlcbiAgICAgICAgICAgICAgICAvLyBTZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjM2NzM0NjJcbiAgICAgICAgICAgICAgICB2YXIgbCA9ICggMTAwICogcGFyc2VGbG9hdCgkYnJlYWRjcnVtYi5jc3MoXCJsZWZ0XCIpKSAvIHBhcnNlRmxvYXQoJGJyZWFkY3J1bWIucGFyZW50KCkuY3NzKFwid2lkdGhcIikpICkrIFwiJVwiIDtcbiAgICAgICAgICAgICAgICB2YXIgdCA9ICggMTAwICogcGFyc2VGbG9hdCgkYnJlYWRjcnVtYi5jc3MoXCJ0b3BcIikpIC8gcGFyc2VGbG9hdCgkYnJlYWRjcnVtYi5wYXJlbnQoKS5jc3MoXCJoZWlnaHRcIikpICkrIFwiJVwiIDtcbiAgICAgICAgICAgICAgICAkYnJlYWRjcnVtYi5jc3MoXCJsZWZ0XCIgLCBsKTtcbiAgICAgICAgICAgICAgICAkYnJlYWRjcnVtYi5jc3MoXCJ0b3BcIiAsIHQpO1xuICAgICAgICAgICAgICAgIHRoaXMuVXBkYXRlUG9seUNsaXBwaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZih0aGlzLiRzdGFydFN0b3A9PVwic3RhcnRcIil7XG4gICAgICAgICAgICAvL2JyZWFkY3J1bWJzIGNhbiBvbmx5IGJlIGFkZGVkIG9yIHJlbW92ZWQgaW4gdGhlIGZpcnN0IHBvbHlnb25cbiAgICAgICAgICAgICRicmVhZGNydW1iLmNsaWNrKChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgYnJlYWRjcnVtYiBvbiBjbGlja1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICRicmVhZGNydW1iLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGJyZWFkY3J1bWJzLnNwbGljZSh0aGlzLiRicmVhZGNydW1icy5pbmRleE9mKCRicmVhZGNydW1iKSwgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5VcGRhdGVQb2x5Q2xpcHBpbmcoKTtcbiAgICAgICAgICAgICAgICB0aGlzLlVwZGF0ZUJyZWFkY3J1bWJDb2xvcmluZygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRoaXMuJGJyZWFkY3J1bWJzLnB1c2goJGJyZWFkY3J1bWIpO1xuXG4gICAgICAgIC8vdGhpcy5VcGRhdGVQb2x5Q2xpcHBpbmcoKTtcbiAgICAgICAgdGhpcy5VcGRhdGVCcmVhZGNydW1iQ29sb3JpbmcoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBsYXN0LXBsYWNlZCBicmVhZGNydW1iIGZyb20gdGhlIGxpc3RcbiAgICAgKiBhbmQgdXBkYXRlcyB0aGUgdmlldy5cbiAgICAgKi9cbiAgICBSZW1vdmVMYXN0QnJlYWRjcnVtYigpe1xuICAgICAgICBsZXQgJHJlbW92ZWQgPSB0aGlzLiRicmVhZGNydW1icy5wb3AoKTtcbiAgICAgICAgJHJlbW92ZWQucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMuVXBkYXRlUG9seUNsaXBwaW5nKCk7XG4gICAgICAgIHRoaXMuVXBkYXRlQnJlYWRjcnVtYkNvbG9yaW5nKCk7XG4gICAgfVxuXG4gICAgUmVtb3ZlQWxsQnJlYWRjcnVtYnMoKXtcbiAgICAgICAgY29uc29sZS5sb2coXCJSZW1vdmluZyBhbGwgYnJlYWRjcnVtYnNcIik7XG4gICAgICAgIHdoaWxlKHRoaXMuJGJyZWFkY3J1bWJzLmxlbmd0aCA+IDApe1xuICAgICAgICAgICAgdGhpcy5SZW1vdmVMYXN0QnJlYWRjcnVtYigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY2VudGVyIG9mIHRoZSBicmVhZGNydW1iIGFzIGFuICh4LCB5KSBwYWlyXG4gICAgICogcmVwcmVzZW50aW5nIHRoZSBwZXJjZW50YWdlIGRpc3RhbmNlIGZyb20gdGhlIHRvcCBhbmQgbGVmdFxuICAgICAqIG9mIHRoZSBjbGljayBzdXJmYWNlICgwJSAtIDEwMCUpLlxuICAgICAqL1xuICAgIEdldENlbnRlclBlcmNlbnRhZ2UoJGJyZWFkY3J1bWIpe1xuICAgICAgICBsZXQgdG9wUGVyY2VudCA9ICgkYnJlYWRjcnVtYi5wb3NpdGlvbigpLnRvcCAvICRicmVhZGNydW1iLnBhcmVudCgpLmhlaWdodCgpKSAqIDEwMDtcbiAgICAgICAgbGV0IGxlZnRQZXJjZW50ID0gKCRicmVhZGNydW1iLnBvc2l0aW9uKCkubGVmdCAvICRicmVhZGNydW1iLnBhcmVudCgpLndpZHRoKCkpICogMTAwO1xuXG4gICAgICAgIC8vIFBlcmNlbnRhZ2UgdmFsdWVzIGZvciB0aGUgZGltZW5zaW9ucyBvZiB0aGUgYnJlYWRjcnVtYiByZWxhdGl2ZSB0byB0aGUgY2xpY2sgc3VyZmFjZVxuICAgICAgICBsZXQgb2ZmUGVyY2VudFggPSAoJGJyZWFkY3J1bWIub3V0ZXJXaWR0aCgpIC8gJGJyZWFkY3J1bWIucGFyZW50KCkud2lkdGgoKSkgKiAxMDA7XG4gICAgICAgIGxldCBvZmZQZXJjZW50WSA9ICgkYnJlYWRjcnVtYi5vdXRlckhlaWdodCgpIC8gJGJyZWFkY3J1bWIucGFyZW50KCkuaGVpZ2h0KCkpICogMTAwO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBsZWZ0UGVyY2VudCArIChvZmZQZXJjZW50WCAvIDIuMCksXG4gICAgICAgICAgICB5OiB0b3BQZXJjZW50ICsgKG9mZlBlcmNlbnRZIC8gMi4wKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgUmVzZXQoKXtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlbW92ZSBhbGwgYnJlYWRjcnVtYnNcbiAgICAgICAgZm9yKGxldCAkYnJlYWRjcnVtYiBvZiB0aGlzLiRicmVhZGNydW1icyl7XG4gICAgICAgICAgICAkYnJlYWRjcnVtYi5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRicmVhZGNydW1icyA9IFtdO1xuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgcG9seSBpZiBpdCBhbHJlYWR5IGV4aXN0c1xuICAgICAgICAvLyBpZih0aGlzLiRwb2x5ICE9IG51bGwpe1xuICAgICAgICAvLyAgICAgdGhpcy4kcG9seS5yZW1vdmUoKTtcbiAgICAgICAgLy8gfVxuICAgIH1cblxuICAgIFJlc2V0UG9seWdvbnMoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwicmVzZXR0aW5nIHBvbHlnb25zXCIpO1xuICAgICAgICBpZiAodGhpcy4kcG9seWdvbnMuc3RhcnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicmVzZXQgc3RhcnQgcG9seVwiKTtcbiAgICAgICAgICAgIHRoaXMuJHBvbHlnb25zLnN0YXJ0Lm1ha2VWaXNpYmxlKGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuJHBvbHlnb25zLnN0YXJ0LmNzcyhcImNsaXAtcGF0aFwiLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4kcG9seWdvbnMuc3RvcCkge1xuICAgICAgICAgICAgdGhpcy4kcG9seWdvbnMuc3RvcC5tYWtlVmlzaWJsZShmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLiRwb2x5Z29ucy5zdG9wLmNzcyhcImNsaXAtcGF0aFwiLCBcIlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJHZlcnRpY2VzID0geyAnc3RhcnQnOiBbXSwgJ3N0b3AnOiBbXSB9O1xuICAgICAgICB0aGlzLlVwZGF0ZVBvbHlDbGlwcGluZygpO1xuICAgICAgICB0aGlzLlJlbW92ZUFsbEJyZWFkY3J1bWJzKCk7XG4gICAgfVxuXG4gICAgUmVzdG9yZSgpe1xuICAgICAgICB0aGlzLkluaXRQb2x5KHRoaXMub3JpZ2luYWxKU09OKTtcbiAgICB9XG5cbiAgICBJbml0UG9seShwb2ludHMgPSBudWxsKXtcbiAgICAgICAgdGhpcy5SZXNldCgpO1xuXG4gICAgICAgIC8vIElmIEpTT04gd2FzIHNwZWNpZmllZCwgZ2VuZXJhdGUgYnJlYWRjcnVtYnMgZnJvbSBpdC5cbiAgICAgICAgaWYocG9pbnRzICE9IG51bGwpe1xuICAgICAgICAgICAgLy8gUHV0IGRvd24gdGhlIGJyZWFkY3J1bWJzXG4gICAgICAgICAgICBmb3IobGV0IHBvaW50IG9mIHBvaW50cyl7XG4gICAgICAgICAgICAgICAgdGhpcy5BZGRCcmVhZGNydW1iKHBvaW50WzBdLCBwb2ludFsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLlVwZGF0ZVBvbHlDbGlwcGluZygpO1xuXG4gICAgICAgIHRoaXMub3JpZ2luYWxKU09OID0gcG9pbnRzO1xuICAgIH1cblxuICAgIERyYXdQb2x5Z29ucygpIHtcbiAgICAgICAgdGhpcy5SZW1vdmVBbGxCcmVhZGNydW1icygpO1xuICAgICAgICBpZiAodGhpcy4kdmVydGljZXMuc3RhcnQgIT0gW10pIHtcbiAgICAgICAgICAgIC8vbGV0IHN0YXJ0UG9seWdvbiA9IHRoaXMuJHZlcnRpY2VzLnN0YXJ0OyAvLy5tYXAoaXRlbSA9PiB7IHJldHVybiBgJHtpdGVtWzBdfSwke2l0ZW1bMV19YCB9KS5qb2luKFwiIFwiKTs7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgcG9seSBvYmplY3RzXG4gICAgICAgICAgICAvLyB0aGlzLiRwb2x5Z29ucy5zdGFydCA9ICQoXCI8ZGl2IGNsYXNzPSd3YWxkb3JmLXN0YXJ0LXBvbHknPjwvZGl2PlwiKS5hcHBlbmRUbyh0aGlzLiRjbGlja1N1cmZhY2UpO1xuICAgICAgICAgICAgLy8gdGhpcy4kcG9seWdvbnMuc3RhcnQuY3NzKFwiei1pbmRleFwiLCB0aGlzLmJhc2VaICsgMTAwMCk7XG5cbiAgICAgICAgICAgIGlmKHRoaXMuJHZlcnRpY2VzLnN0YXJ0Lmxlbmd0aCA8IDMpe1xuICAgICAgICAgICAgICAgIHRoaXMuJHBvbHlnb25zLnN0YXJ0Lm1ha2VWaXNpYmxlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRwb2x5Z29ucy5zdGFydC5jbGlwUGF0aChbXSwge1xuICAgICAgICAgICAgICAgICAgICBzdmdEZWZJZDogJ2Fubm90YXRvclN0YXJ0UG9seVN2ZydcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kcG9seWdvbnMuc3RhcnQubWFrZVZpc2libGUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy4kcG9seWdvbnMuc3RhcnQuY2xpcFBhdGgodGhpcy4kdmVydGljZXMuc3RhcnQsIHtcbiAgICAgICAgICAgICAgICAgICAgaXNQZXJjZW50YWdlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzdmdEZWZJZDogJ2Fubm90YXRvclN0YXJ0UG9seVN2ZydcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZih0aGlzLiRzdGFydFN0b3A9PVwic3RhcnRcIil7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHZlcnRpY2VzLnN0YXJ0Lm1hcCgocG9pbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuQWRkQnJlYWRjcnVtYihwb2ludFswXSwgcG9pbnRbMV0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuJHZlcnRpY2VzLnN0b3AgIT0gW10pIHtcblxuICAgICAgICAgICAgLy8gdGhpcy4kc3RvcFBvbHkucmVtb3ZlKCk7XG4gICAgICAgICAgICAvLyB0aGlzLiRzdG9wUG9seSA9ICQoXCI8ZGl2IGNsYXNzPSd3YWxkb3JmLXN0b3AtcG9seSc+PC9kaXY+XCIpLmFwcGVuZFRvKHRoaXMuJGNsaWNrU3VyZmFjZSk7XG4gICAgICAgICAgICAvLyB0aGlzLiRzdG9wUG9seS5jc3MoXCJ6LWluZGV4XCIsIHRoaXMuYmFzZVogKyAxMDAwKTtcblxuICAgICAgICAgICAgaWYodGhpcy4kdmVydGljZXMuc3RvcC5sZW5ndGggPCAzKXtcbiAgICAgICAgICAgICAgICB0aGlzLiRwb2x5Z29ucy5zdG9wLmNsaXBQYXRoKFtdLCB7XG4gICAgICAgICAgICAgICAgICAgIHN2Z0RlZklkOiAnYW5ub3RhdG9yU3RvcFBvbHlTdmcnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuJHBvbHlnb25zLnN0b3AuY2xpcFBhdGgodGhpcy4kdmVydGljZXMuc3RvcCwge1xuICAgICAgICAgICAgICAgICAgICBpc1BlcmNlbnRhZ2U6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHN2Z0RlZklkOiAnYW5ub3RhdG9yU3RvcFBvbHlTdmcnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYodGhpcy4kc3RhcnRTdG9wPT1cInN0b3BcIil7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHZlcnRpY2VzLnN0b3AubWFwKChwb2ludCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5BZGRCcmVhZGNydW1iKHBvaW50WzBdLCBwb2ludFsxXSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBVcGRhdGVQb2x5Q2xpcHBpbmcoKXtcbiAgICAgICAgaWYodGhpcy4kc3RhcnRTdG9wPT1udWxsKSByZXR1cm47XG4gICAgICAgIGxldCBzdmdJZCA9IHRoaXMuJHN0YXJ0U3RvcCA9PSBcInN0YXJ0XCIgPyBcImFubm90YXRvclN0YXJ0UG9seVN2Z1wiIDogXCJhbm5vdGF0b3JTdG9wUG9seVN2Z1wiO1xuICAgICAgICBpZih0aGlzLiRicmVhZGNydW1icy5sZW5ndGggPCAzKXtcbiAgICAgICAgICAgIHRoaXMuJHBvbHlnb25zW3RoaXMuJHN0YXJ0U3RvcF0ubWFrZVZpc2libGUoZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy4kcG9seWdvbnNbdGhpcy4kc3RhcnRTdG9wXS5jbGlwUGF0aChbXSwge1xuICAgICAgICAgICAgICAgIHN2Z0RlZklkOiBzdmdJZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgcG9pbnRzID0gdGhpcy4kYnJlYWRjcnVtYnMubWFwKCgkY3J1bWIpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcG9zID0gdGhpcy5HZXRDZW50ZXJQZXJjZW50YWdlKCRjcnVtYik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtwb3MueCwgcG9zLnldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLiRwb2x5Z29uc1t0aGlzLiRzdGFydFN0b3BdLm1ha2VWaXNpYmxlKHRydWUpO1xuICAgICAgICAgICAgdGhpcy4kcG9seWdvbnNbdGhpcy4kc3RhcnRTdG9wXS5jbGlwUGF0aChwb2ludHMsIHtcbiAgICAgICAgICAgICAgICBpc1BlcmNlbnRhZ2U6IHRydWUsXG4gICAgICAgICAgICAgICAgc3ZnRGVmSWQ6IHN2Z0lkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIFVwZGF0ZUJyZWFkY3J1bWJDb2xvcmluZygpe1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy4kYnJlYWRjcnVtYnMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgbGV0ICRjcnVtYiA9IHRoaXMuJGJyZWFkY3J1bWJzW2ldO1xuICAgICAgICAgICAgLy8gUmVjb2xvciBlYWNoIGJyZWFkY3J1bWJcbiAgICAgICAgICAgIGxldCBjb2xvciA9IFwiIzAwMDAwMFwiO1xuXG4gICAgICAgICAgICBpZiAoaSA9PSB0aGlzLiRicmVhZGNydW1icy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgY29sb3IgPSBcIiNGRjAwMDBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGkgPT0gMCl7XG4gICAgICAgICAgICAgICAgY29sb3IgPSBcIiMwMEZGMDBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuJGJyZWFkY3J1bWJzW2ldLmNzcyhcImJvcmRlci1jb2xvclwiLCBjb2xvcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFuIGFycmF5IG9mIHBlcmNlbnRhZ2VzIHJlcHJlc2VudGluZyB0aGUgeCBhbmQgeSBwZXJjZW50YWdlcyBvZiBlYWNoXG4gICAgICogcG9pbnQgaW4gdGhlIHBvbHlnb24uXG4gICAgICovXG4gICAgR2V0SlNPTigpe1xuICAgICAgICAvLyBFeHRyYWN0IHRoZSBjb29yZGluYXRlcyBmcm9tIHRoZSBjcnVtYnMgYW5kIHB1dCB0aGVtIGluIHRoZSBhcnJheVxuICAgICAgICBsZXQgcG9pbnRzID0gW107XG4gICAgICAgIGZvcihsZXQgY3J1bWIgb2YgdGhpcy4kYnJlYWRjcnVtYnMpe1xuICAgICAgICAgICAgbGV0IHBvaW50ID0gdGhpcy5HZXRDZW50ZXJQZXJjZW50YWdlKGNydW1iKTtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKFtwb2ludC54LnRvU3RyaW5nKCksIHBvaW50LnkudG9TdHJpbmcoKV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHBvaW50cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbiBhcnJheSBvZiBwZXJjZW50YWdlcyByZXByZXNlbnRpbmcgdGhlIHggYW5kIHkgcGVyY2VudGFnZXMgb2YgZWFjaFxuICAgICAqIHBvaW50IGluIHRoZSBwb2x5Z29uLlxuICAgICAqL1xuICAgIEdldFBvaW50cygpIHtcbiAgICAgICAgbGV0IHBvaW50cyA9IFtdO1xuICAgICAgICBmb3IobGV0IGNydW1iIG9mIHRoaXMuJGJyZWFkY3J1bWJzKXtcbiAgICAgICAgICAgIGxldCBwb2ludCA9IHRoaXMuR2V0Q2VudGVyUGVyY2VudGFnZShjcnVtYik7XG4gICAgICAgICAgICBwb2ludHMucHVzaChbcG9pbnQueCwgcG9pbnQueV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBhbGwgc3RhcnQgdmVydGljZXMgbWF0Y2ggc3RvcCB2ZXJ0aWNlc1xuICAgICAqIHJldHVybnMgdHJ1ZSBpZiB0aGUgdmVydGljZXMgZG9uJ3QgbWF0Y2ggZXhhY3RseVxuICAgICAqL1xuICAgIElzQW5pbWF0ZWQoKSB7XG4gICAgICAgIGxldCBjb21wID0gdGhpcy4kdmVydGljZXMuc3RhcnQ7XG4gICAgICAgIGxldCBzdGFydFN0cmluZyA9IEpTT04uc3RyaW5naWZ5KGNvbXApO1xuICAgICAgICBjb21wID0gdGhpcy4kdmVydGljZXMuc3RvcDtcbiAgICAgICAgbGV0IHN0b3BTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShjb21wKTtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0YXJ0U3RyaW5nKSAhPSBKU09OLnN0cmluZ2lmeShzdG9wU3RyaW5nKTtcbiAgICB9XG5cbiAgICBCZWdpbkVkaXRpbmcoc3RhcnRTdG9wKXtcbiAgICAgICAgdGhpcy4kc3RhcnRTdG9wID0gc3RhcnRTdG9wO1xuICAgICAgICAvL3N0YXJ0U3RvcCBpcyBlaXRoZXIgJ3N0YXJ0JyBvciAnc3RvcCcsIGRlcGVuZGluZyBvbiB3aGljaCBwb2x5Z29uIGlzIGJlaW5nIGVkaXRlZFxuICAgICAgICB0aGlzLiRjbGlja1N1cmZhY2UubWFrZVZpc2libGUodHJ1ZSk7XG4gICAgICAgIHRoaXMuJGVkaXREaWFsb2cubWFrZVZpc2libGUodHJ1ZSk7XG4gICAgICAgIHRoaXMuJHBvbHlnb25zLnN0YXJ0Lm1ha2VWaXNpYmxlKHRydWUpO1xuICAgICAgICB0aGlzLiRwb2x5Z29ucy5zdG9wLm1ha2VWaXNpYmxlKHRydWUpO1xuICAgICAgICAvLy0zLy90aGlzLiRiYXIubWFrZVZpc2libGUodHJ1ZSk7XG4gICAgICAgIHRoaXMuRHJhd1BvbHlnb25zKCk7XG4gICAgICAgIHRoaXMuVXBkYXRlUG9seUNsaXBwaW5nKCk7XG4gICAgfVxuXG4gICAgRG9uZSgpe1xuICAgICAgICB0aGlzLiRjbGlja1N1cmZhY2UubWFrZVZpc2libGUoZmFsc2UpO1xuICAgICAgICB0aGlzLiRlZGl0RGlhbG9nLm1ha2VWaXNpYmxlKGZhbHNlKTtcbiAgICAgICAgdGhpcy4kcG9seWdvbnMuc3RhcnQubWFrZVZpc2libGUoZmFsc2UpO1xuICAgICAgICB0aGlzLiRwb2x5Z29ucy5zdG9wLm1ha2VWaXNpYmxlKGZhbHNlKTtcbiAgICAgICAgLy8tMy8vdGhpcy4kYmFyLm1ha2VWaXNpYmxlKGZhbHNlKTtcbiAgICB9XG5cbiAgICBSZXNpemVPdmVybGF5KCl7XG4gICAgICAgIC8vIFJlc2l6ZSB2aWRlbyBvdmVybGF5IHRvIGZpdCBhY3R1YWwgdmlkZW8gZGltZW5zaW9uc1xuICAgICAgICBsZXQgdmlkZW9EaW1zID0gdGhpcy5hbm5vdGF0b3IucGxheWVyLkdldFZpZGVvRGltZW5zaW9ucygpO1xuICAgICAgICB0aGlzLiRjbGlja1N1cmZhY2UuY3NzKCd3aWR0aCcsIHZpZGVvRGltcy53aWR0aCk7XG4gICAgICAgIHRoaXMuJGNsaWNrU3VyZmFjZS5jc3MoJ2hlaWdodCcsIHZpZGVvRGltcy5oZWlnaHQpO1xuXG4gICAgICAgIGxldCBoZWlnaHREaWZmID0gKHRoaXMuYW5ub3RhdG9yLnBsYXllci4kdmlkZW8uaGVpZ2h0KCkgLSB2aWRlb0RpbXMuaGVpZ2h0KSAvIDI7XG4gICAgICAgIHRoaXMuJGNsaWNrU3VyZmFjZS5jc3MoJ3RvcCcsIGhlaWdodERpZmYpO1xuXG4gICAgICAgIGxldCB3aWR0aERpZmYgPSAodGhpcy5hbm5vdGF0b3IucGxheWVyLiR2aWRlby53aWR0aCgpIC0gdmlkZW9EaW1zLndpZHRoKSAvIDI7XG4gICAgICAgIHRoaXMuJGNsaWNrU3VyZmFjZS5jc3MoJ2xlZnQnLCB3aWR0aERpZmYpO1xuXG4gICAgICAgIHRoaXMuJHBvbHlnb25zLnN0YXJ0LndpZHRoKHZpZGVvRGltcy53aWR0aCk7XG4gICAgICAgIHRoaXMuJHBvbHlnb25zLnN0YXJ0LmhlaWdodCh2aWRlb0RpbXMuaGVpZ2h0KTtcbiAgICAgICAgdGhpcy4kcG9seWdvbnMuc3RhcnQuY3NzKFwidG9wXCIsIGhlaWdodERpZmYpO1xuICAgICAgICB0aGlzLiRwb2x5Z29ucy5zdGFydC5jc3MoXCJsZWZ0XCIsIHdpZHRoRGlmZik7XG4gICAgICAgIHRoaXMuJHBvbHlnb25zLnN0YXJ0LmNzcyhcInBvc2l0aW9uXCIsIFwiYWJzb2x1dGVcIik7XG4gICAgICAgIHRoaXMuJHBvbHlnb25zLnN0YXJ0Lm1ha2VWaXNpYmxlKGZhbHNlKTtcblxuICAgICAgICB0aGlzLiRwb2x5Z29ucy5zdG9wLndpZHRoKHZpZGVvRGltcy53aWR0aCk7XG4gICAgICAgIHRoaXMuJHBvbHlnb25zLnN0b3AuaGVpZ2h0KHZpZGVvRGltcy5oZWlnaHQpO1xuICAgICAgICB0aGlzLiRwb2x5Z29ucy5zdG9wLmNzcyhcInRvcFwiLCBoZWlnaHREaWZmKTtcbiAgICAgICAgdGhpcy4kcG9seWdvbnMuc3RvcC5jc3MoXCJsZWZ0XCIsIHdpZHRoRGlmZik7XG4gICAgICAgIHRoaXMuJHBvbHlnb25zLnN0b3AuY3NzKFwicG9zaXRpb25cIiwgXCJhYnNvbHV0ZVwiKTtcbiAgICAgICAgdGhpcy4kcG9seWdvbnMuc3RvcC5tYWtlVmlzaWJsZShmYWxzZSk7XG5cbiAgICB9XG5cbiAgICBSZWdpc3RlckVsZW1lbnQoJGVsZW1lbnQsICRjb250YWluZXIsIG9yZGVyLCBqdXN0aWZpY2F0aW9uID0gJ2ZsZXgtc3RhcnQnKXtcbiAgICAgICAgJGVsZW1lbnQuY3NzKCdvcmRlcicsIG9yZGVyKTtcbiAgICAgICAgJGVsZW1lbnQuY3NzKCdhbGlnbi1zZWxmJywganVzdGlmaWNhdGlvbik7XG4gICAgICAgIC8vIFNldHMgZ3JvdyBbc2hyaW5rXSBbYmFzaXNdXG4gICAgICAgIC8vJGVsZW1lbnQuY3NzKCdmbGV4JywgJzAgMCBhdXRvJyk7XG4gICAgICAgICRjb250YWluZXIuYXBwZW5kKCRlbGVtZW50KTtcbiAgICB9XG5cbiAgICBTaG93SnVzdFBvbHlnb24oKXtcbiAgICAgICAgdGhpcy4kcG9seWdvbnMuc3RhcnQubWFrZVZpc2libGUodHJ1ZSk7XG4gICAgICAgIHRoaXMuJHBvbHlnb25zLnN0b3AubWFrZVZpc2libGUodHJ1ZSk7XG4gICAgfVxuXG4gICAgQWRkUG9seWdvblNldCgpIHtcbiAgICAgICAgLy9UaGlzIGlzIHNhdmluZyBhIHNldCBvZiBicmVhZGNydW1icyBpbnRvIHRoZSB2ZXJ0aWNlcyBmb3IgYSBwb2x5Z29uXG4gICAgICAgIHRoaXMuJHZlcnRpY2VzW3RoaXMuJHN0YXJ0U3RvcF0gPSB0aGlzLkdldFBvaW50cygpO1xuICAgICAgICBpZih0aGlzLiRzdGFydFN0b3A9PVwic3RhcnRcIiAmJiB0aGlzLiR2ZXJ0aWNlcy5zdG9wLmxlbmd0aCAhPSB0aGlzLiR2ZXJ0aWNlcy5zdGFydC5sZW5ndGgpe1xuICAgICAgICAgICAgdGhpcy4kdmVydGljZXMuc3RvcCA9IHRoaXMuR2V0UG9pbnRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5SZW1vdmVBbGxCcmVhZGNydW1icygpO1xuICAgICAgICB0aGlzLmFubm90YXRvci5tZXNzYWdlT3ZlcmxheS5TaG93TWVzc2FnZShcIkNhcHR1cmVkIFwiK3RoaXMuJHN0YXJ0U3RvcCtcIiBwb2x5Z29uLlwiKTtcblxuICAgICAgICAvLyBpZiAodGhpcy4kdmVydGljZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyAgICAgdGhpcy4kcG9seWdvbnMgPSBbXTtcbiAgICAgICAgLy8gICAgIHRoaXMuJHRlbXBCcmVhZENydW1icyA9IFtdO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgLy8gaWYgKCF0aGlzLiRwb2x5Z29ucy5sZW5ndGgpIHtcbiAgICAgICAgLy8gICAgIHRoaXMuJHBvbHlnb25zLnN0YXJ0ID0gdGhpcy5HZXRQb2ludHMoKTtcbiAgICAgICAgLy8gICAgIHRoaXMuJHRlbXBCcmVhZENydW1ic1swXSA9IFt0aGlzLiRicmVhZGNydW1ic107XG4gICAgICAgIC8vICAgICB2YXIgbXNnID0gXCJTdWNjZXNzZnVsbHkgY2FwdHVyZWQgZmlyc3QgcG9seWdvbi5cIjtcbiAgICAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgLy8gICAgIHRoaXMuJHBvbHlnb25zLnN0b3AgPSB0aGlzLkdldFBvaW50cygpO1xuICAgICAgICAvLyAgICAgdGhpcy4kdGVtcEJyZWFkQ3J1bWJzWzFdID0gW3RoaXMuJGJyZWFkY3J1bWJzXTtcbiAgICAgICAgLy8gICAgIHZhciBtc2cgPSBcIlN1Y2Nlc3NmdWxseSBjYXB0dXJlZCBzZWNvbmQgcG9seWdvbi5cIjtcbiAgICAgICAgLy8gfSBcblxuICAgICAgICB0aGlzLmFubm90YXRvci4kY29udGFpbmVyLnRyaWdnZXIoXCJPblBvbHlnb25FZGl0aW5nRW5kZWRcIik7XG4gICAgICAgIHRoaXMuRG9uZSgpO1xuXG5cbiAgICB9XG5cbn1cblxuZXhwb3J0IHsgUG9seWdvbkVkaXRvciB9OyIsImNsYXNzIFBvbHlnb25PdmVybGF5IHtcbiAgICBjb25zdHJ1Y3Rvcihhbm5vdGF0b3Ipe1xuICAgICAgICB0aGlzLmFubm90YXRvciA9IGFubm90YXRvcjtcbiAgICAgICAgdGhpcy5wb2x5RWxlbWVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5zdmdFbGVtZW50cyA9IFtdO1xuICAgICAgICB0aGlzLmFuaW1hdGVFbGVtZW50cyA9IFtdO1xuICAgICAgICB0aGlzLmJhc2VaID0gMjE0NzQ4MzY0OTtcbiAgICAgICAgdGhpcy5sYXN0QW5ub3RhdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5zdmdFbGVtZW50c0hhc2ggPSB7fTtcblxuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSB2aWRlbyBvdmVybGF5XG4gICAgICAgIHRoaXMuJHZpZGVvT3ZlcmxheSA9ICQoXCI8ZGl2IGNsYXNzPSd3YWxkb3JmLXZpZGVvLW92ZXJsYXknPjwvZGl2PlwiKS5hcHBlbmRUbyh0aGlzLmFubm90YXRvci5wbGF5ZXIuJGNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuUmVzaXplT3ZlcmxheSgpO1xuICAgICAgICB0aGlzLmFubm90YXRvci5wbGF5ZXIuJGNvbnRhaW5lci5vbihcIk9uRnVsbHNjcmVlbkNoYW5nZVwiLCAoZXZlbnQsIHNldEZ1bGxzY3JlZW4pID0+IHRoaXMuUmVzaXplT3ZlcmxheSgpKTtcblxuICAgICAgICB0aGlzLmFubm90YXRvci4kY29udGFpbmVyLm9uKFwiT25OZXdBbm5vdGF0aW9uU2V0XCIsIChldmVudCwgYW5ub3RhdGlvbnMpID0+IHRoaXMuVXBkYXRlKGFubm90YXRpb25zKSk7XG4gICAgICAgIHRoaXMudmlkZW9EaW1zID0gdGhpcy5hbm5vdGF0b3IucGxheWVyLkdldFZpZGVvRGltZW5zaW9ucygpO1xuXG4gICAgICAgICQod2luZG93KS5yZXNpemUoKCkgPT4gdGhpcy5SZXNpemVPdmVybGF5KCkpO1xuICAgIH1cblxuICAgIFVwZGF0ZShhbm5vdGF0aW9ucyl7XG4gICAgICAgIHRoaXMuQ2xlYXIoKTtcblxuICAgICAgICAvLyBsZXQgcHJldlNldCA9IG5ldyBTZXQodGhpcy5sYXN0QW5ub3RhdGlvbnMpO1xuICAgICAgICAvLyBsZXQgbmV3U2V0ID0gbmV3IFNldChhbm5vdGF0aW9ucyk7XG5cbiAgICAgICAgLy8gLy8gaW4gbmV3U2V0IGFuZCBub3QgaW4gcHJldlNldFxuICAgICAgICAvLyBsZXQgdG9BZGQgPSBuZXcgU2V0KFxuICAgICAgICAvLyAgICAgWy4uLm5ld1NldF0uZmlsdGVyKHggPT4gIXByZXZTZXQuaGFzKHgpKSk7XG5cbiAgICAgICAgLy8gLy8gaW4gcHJldkFubm90YXRpb25zIGFuZCBub3QgaW4gYW5ub3RhdGlvbnNcbiAgICAgICAgLy8gbGV0IHRvRGVzdHJveSA9IG5ldyBTZXQoXG4gICAgICAgIC8vICAgICBbLi4ucHJldlNldF0uZmlsdGVyKHggPT4gIW5ld1NldC5oYXMoeCkpKTtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZyhBcnJheS5mcm9tKHRvQWRkKSk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKEFycmF5LmZyb20odG9EZXN0cm95KSk7XG4gICAgICAgIFxuICAgICAgICAvL1NvcnQgcG9seWdvbiBvcmRlciBieSBzaXplIChhc2NlbmRpbmcpXG4gICAgICAgIC8vIHBvbHlnb25zLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAvLyAgICAgcmV0dXJuIHRoaXMuR2V0QXJlYShhKSA+IHRoaXMuR2V0QXJlYShiKTtcbiAgICAgICAgLy8gfSlcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFubm90YXRpb25zLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgICAgIGxldCBhbm5vdGF0aW9uUG9seVBvaW50cyA9IGFubm90YXRpb25zW2ldLmdldFBvbHkoKTtcbiAgICAgICAgICAgIGlmIChhbm5vdGF0aW9uUG9seVBvaW50cyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIHRoaXMgYW5ub3RhdGlvbiBpZiBpdCBoYXMgbm8gcG9seWdvblxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgc3ZnUG9seVBvaW50cyA9IGFubm90YXRpb25zW2ldLmdldFNWR1BvbHlQb2ludHMoKTtcbiAgICAgICAgXG4gICAgICAgICAgICBsZXQgZHVyYXRpb24gPSBhbm5vdGF0aW9uc1tpXS5lbmRUaW1lIC0gYW5ub3RhdGlvbnNbaV0uYmVnaW5UaW1lO1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIHBvbHkgb2JqZWN0XG4gICAgICAgICAgICBsZXQgJHN2ZztcbiAgICAgICAgICAgIGlmICh0aGlzLnN2Z0VsZW1lbnRzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgJHN2ZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwic3ZnXCIpO1xuICAgICAgICAgICAgICAgICRzdmcuc2V0QXR0cmlidXRlKCd3aWR0aCcsICcxMDAlJyk7XG4gICAgICAgICAgICAgICAgJHN2Zy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICcxMDAlJyk7XG4gICAgICAgICAgICAgICAgJHN2Zy5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCAnMCAwIDEwMCAxMDAnKTtcbiAgICAgICAgICAgICAgICAkc3ZnLnNldEF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycsICdub25lJyk7XG5cbiAgICAgICAgICAgICAgICAvLyRzdmcuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuQ2xpY2tFdmVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kdmlkZW9PdmVybGF5LmFwcGVuZCgkc3ZnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN2Z0VsZW1lbnRzLnB1c2goJHN2Zyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRzdmcgPSB0aGlzLnN2Z0VsZW1lbnRzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG5cbiAgICAgICAgICAgIGxldCAkcG9seWdvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAncG9seWdvbicpO1xuICAgICAgICAgICAgJHBvbHlnb24uc2V0QXR0cmlidXRlKCdwb2ludHMnLCBzdmdQb2x5UG9pbnRzWzBdKTtcbiAgICAgICAgICAgICRwb2x5Z29uLnNldEF0dHJpYnV0ZSgnZmlsbCcsICdyZ2JhKDAsIDExOCwgMjU1LCAwLjU1KScpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAkc3ZnLmFwcGVuZENoaWxkKCRwb2x5Z29uKTtcblxuICAgICAgICAgICAgbGV0ICRhbmltYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdhbmltYXRlJyk7XG4gICAgICAgICAgICAkYW5pbWF0ZS5zZXRBdHRyaWJ1dGUoJ2F0dHJpYnV0ZU5hbWUnLCAncG9pbnRzJyk7XG4gICAgICAgICAgICAkYW5pbWF0ZS5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCAnZnJlZXplJyk7XG4gICAgICAgICAgICAkYW5pbWF0ZS5zZXRBdHRyaWJ1dGUoJ2Zyb20nLCBzdmdQb2x5UG9pbnRzWzBdKTtcbiAgICAgICAgICAgICRhbmltYXRlLnNldEF0dHJpYnV0ZSgndG8nLCBzdmdQb2x5UG9pbnRzWzFdKTtcbiAgICAgICAgICAgICRhbmltYXRlLnNldEF0dHJpYnV0ZSgnYmVnaW4nLCAnaW5kZWZpbml0ZScpO1xuICAgICAgICAgICAgJGFuaW1hdGUuc2V0QXR0cmlidXRlKCdkdXInLCBkdXJhdGlvbiArIFwic1wiKTtcbiAgICAgICAgICAgICRwb2x5Z29uLmFwcGVuZENoaWxkKCRhbmltYXRlKTtcblxuICAgICAgICAgICAgbGV0ICRzdmdIYXNoID0ge1xuICAgICAgICAgICAgICAgIHN2Z0VsZW1lbnQ6ICRzdmcsXG4gICAgICAgICAgICAgICAgcG9seWdvbjogJHBvbHlnb24sXG4gICAgICAgICAgICAgICAgYW5pbWF0ZTogJGFuaW1hdGUsXG4gICAgICAgICAgICAgICAgYmVnaW5UaW1lOiBhbm5vdGF0aW9uc1tpXS5iZWdpblRpbWVcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuc3ZnRWxlbWVudHNIYXNoW2Fubm90YXRpb25zW2ldLmlkXSA9ICRzdmdIYXNoO1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIHBvbHkgb2JqZWN0XG4gICAgICAgICAgICAvLyBsZXQgJHBvbHkgPSAkKFwiPGRpdiBjbGFzcz0nd2FsZG9yZi1vdmVybGF5LXBvbHknPjwvZGl2PlwiKS5hcHBlbmRUbyh0aGlzLiR2aWRlb092ZXJsYXkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyAkcG9seS5jbGlwUGF0aChhbm5vdGF0aW9uUG9seVBvaW50cywge1xuICAgICAgICAgICAgLy8gICAgIGlzUGVyY2VudGFnZTogdHJ1ZSxcbiAgICAgICAgICAgIC8vICAgICBzdmdEZWZJZDogJ2Fubm90YXRvclBvbHlTdmcnXG4gICAgICAgICAgICAvLyB9KTtcbiAgICAgICAgICAgIC8vICRwb2x5LmNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgIC8vICAgICB0aGlzLmFubm90YXRvci4kY29udGFpbmVyLnRyaWdnZXIoXCJPblBvbHlDbGlja2VkXCIsIGFubm90YXRpb25zW2ldKTtcbiAgICAgICAgICAgIC8vIH0pO1xuICAgICAgICAgICAgLy8gdGhpcy5BZGRUb29sdGlwKCRwb2x5LCBhbm5vdGF0aW9uc1tpXSk7XG4gICAgICAgICAgICAvLyB0aGlzLnBvbHlFbGVtZW50cy5wdXNoKCRwb2x5KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5wb2x5RWxlbWVudHMucHVzaCgkcG9seWdvbik7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGVFbGVtZW50cy5wdXNoKCRhbmltYXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vdGhpcy5sYXN0QW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucztcbiAgICB9XG5cbiAgICBDbGlja0V2ZW50KGV2ZW50KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiYW5pbWF0ZSBpcyBjbGlja2VkXCIpO1xuICAgIH1cblxuICAgIEFkZFRvb2x0aXAoJHBvbHksIGFubm90YXRpb24pe1xuICAgICAgICAkLmZuLnF0aXAuemluZGV4ID0gdGhpcy5iYXNlWisgMTtcbiAgICAgICAgJHBvbHkucXRpcCh7XG4gICAgICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IGFubm90YXRpb24uaWQsXG4gICAgICAgICAgICAgICAgdGV4dDogYW5ub3RhdGlvbi5ib2R5LmZpbHRlcihpdGVtID0+IGl0ZW0ucHVycG9zZSA9PT0gXCJkZXNjcmliaW5nXCIpWzBdLnZhbHVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICBteTogJ2JvdHRvbSByaWdodCcsXG4gICAgICAgICAgICAgICAgYXQ6ICd0b3AgbGVmdCcsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiAnbW91c2UnLCAvLyBGb2xsb3cgdGhlIG1vdXNlXG4gICAgICAgICAgICAgICAgYWRqdXN0OiB7XG4gICAgICAgICAgICAgICAgICAgIG1vdXNlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwic2hpZnQgc2hpZnRcIiAvLyBob3Jpem9udGFsLCB2ZXJ0aWNhbFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdmlld3BvcnQ6IHRoaXMuYW5ub3RhdG9yLnBsYXllci4kY29udGFpbmVyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGlkZToge1xuICAgICAgICAgICAgICAgIGRlbGF5OiAwIC8vIE5vIGhpZGUgZGVsYXkgYnkgZGVmYXVsdFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgY2xhc3NlczogJ3F0aXAtZGFyayBxdGlwLXJvdW5kZWQgYW5ub3RhdG9yLXF0aXAnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIENsZWFyKCl7XG4gICAgICAgIC8vIENsZWFyIGFsbCAgYW5pbWF0ZSBlbGVtZW50IGZyb20gdGhlIERPTVxuICAgICAgICBmb3IobGV0IGFpID0gMDsgYWkgPCB0aGlzLmFuaW1hdGVFbGVtZW50cy5sZW5ndGg7IGFpKyspe1xuICAgICAgICAgICAgLy90aGlzLnBvbHlFbGVtZW50c1tpXS5kYXRhKFwicXRpcFwiKS5kZXN0cm95KHRydWUpO1xuICAgICAgICAgICAgdGhpcy5hbmltYXRlRWxlbWVudHNbYWldLnJlbW92ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2xlYXIgYWxsIHBvbHlnb25zIFxuICAgICAgICBmb3IobGV0IHBpID0gMDsgcGkgPCB0aGlzLnBvbHlFbGVtZW50cy5sZW5ndGg7IHBpKyspIHtcbiAgICAgICAgICAgIHRoaXMucG9seUVsZW1lbnRzW3BpXS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ2xlYXIgYWxsICBzdmcgZWxlbWVudHMgZnJvbSB0aGUgRE9NXG4gICAgICAgIGZvcihsZXQgc2kgPSAwOyBzaSA8IHRoaXMuc3ZnRWxlbWVudHMubGVuZ3RoOyBzaSsrKXtcbiAgICAgICAgICAgIHRoaXMuc3ZnRWxlbWVudHNbc2ldLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBNYXJrIHRoZSBhcnJheSBhcyBlbXB0eVxuICAgICAgICB0aGlzLmFuaW1hdGVFbGVtZW50cyA9IFtdO1xuICAgICAgICB0aGlzLnBvbHlFbGVtZW50cyA9IFtdO1xuICAgICAgICB0aGlzLnN2Z0VsZW1lbnRzID0gW107XG4gICAgICAgIHRoaXMuc3ZnRWxlbWVudHNIYXNoID0ge307XG5cbiAgICB9XG5cbiAgICBSZXNpemVPdmVybGF5KCl7XG4gICAgICAgIC8vIFJlc2l6ZSB2aWRlbyBvdmVybGF5IHRvIGZpdCBhY3R1YWwgdmlkZW8gZGltZW5zaW9uc1xuICAgICAgICBsZXQgdmlkZW9EaW1zID0gdGhpcy5hbm5vdGF0b3IucGxheWVyLkdldFZpZGVvRGltZW5zaW9ucygpO1xuICAgICAgICB0aGlzLiR2aWRlb092ZXJsYXkuY3NzKCd3aWR0aCcsIHZpZGVvRGltcy53aWR0aCk7XG4gICAgICAgIHRoaXMuJHZpZGVvT3ZlcmxheS5jc3MoJ2hlaWdodCcsIHZpZGVvRGltcy5oZWlnaHQpO1xuXG4gICAgICAgIGxldCBoZWlnaHREaWZmID0gKHRoaXMuYW5ub3RhdG9yLnBsYXllci4kdmlkZW8uaGVpZ2h0KCkgLSB2aWRlb0RpbXMuaGVpZ2h0KSAvIDI7XG4gICAgICAgIHRoaXMuJHZpZGVvT3ZlcmxheS5jc3MoJ3RvcCcsIGhlaWdodERpZmYpO1xuXG4gICAgICAgIGxldCB3aWR0aERpZmYgPSAodGhpcy5hbm5vdGF0b3IucGxheWVyLiR2aWRlby53aWR0aCgpIC0gdmlkZW9EaW1zLndpZHRoKSAvIDI7XG4gICAgICAgIHRoaXMuJHZpZGVvT3ZlcmxheS5jc3MoJ2xlZnQnLCB3aWR0aERpZmYpO1xuICAgIH1cblxuICAgIGdldFBsYXllclNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFubm90YXRvci5wbGF5ZXIuR2V0VmlkZW9EaW1lbnNpb25zKCk7XG4gICAgfVxuXG59XG5cbmV4cG9ydCB7IFBvbHlnb25PdmVybGF5IH07IiwiXG5jbGFzcyBUaWNrQmFyIHtcbiAgICBjb25zdHJ1Y3Rvcihhbm5vdGF0b3Ipe1xuICAgICAgICB0aGlzLmFubm90YXRvciA9IGFubm90YXRvcjtcblxuICAgICAgICB0aGlzLnRpY2tzID0gW107XG5cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBlbGVtZW50XG4gICAgICAgIHRoaXMuJHRpY2tCYXIgPSAkKFwiPGRpdiBjbGFzcz0nd2FsZG9yZi10aWNrYmFyJz48L2Rpdj5cIik7XG4gICAgICAgIHRoaXMuYW5ub3RhdG9yLnBsYXllci5jb250cm9sQmFyLiRjb250YWluZXIuYXBwZW5kKHRoaXMuJHRpY2tCYXIpO1xuXG4gICAgICAgIC8vIEF0dGFjaCBldmVudCBoYW5kbGVyc1xuICAgICAgICB0aGlzLmFubm90YXRvci4kY29udGFpbmVyLm9uKFwiT25Bbm5vdGF0aW9uc0xvYWRlZFwiLCBcbiAgICAgICAgICAgIChldmVudCwgYW5ub3RhdGlvbk1hbmFnZXIpID0+IHRoaXMuTG9hZEFubm90YXRpb25zKGFubm90YXRpb25NYW5hZ2VyKSk7XG5cbiAgICAgICAgdGhpcy5hbm5vdGF0b3IuJGNvbnRhaW5lci5vbihcIk9uQW5ub3RhdGlvblJlZ2lzdGVyZWRcIixcbiAgICAgICAgICAgIChldmVudCwgYW5ub3RhdGlvbikgPT4gdGhpcy5Mb2FkQW5ub3RhdGlvbihhbm5vdGF0aW9uKSk7XG5cbiAgICAgICAgdGhpcy5hbm5vdGF0b3IuJGNvbnRhaW5lci5vbihcIk9uQW5ub3RhdGlvblJlbW92ZWRcIixcbiAgICAgICAgICAgIChldmVudCwgaWQpID0+IHRoaXMuUmVtb3ZlQW5ub3RhdGlvbihpZCkpO1xuICAgICAgICAgICAgXG4gICAgfVxuXG4gICAgTG9hZEFubm90YXRpb25zKGFubm90YXRpb25NYW5hZ2VyKXtcbiAgICAgICAgdGhpcy5DbGVhcigpO1xuXG4gICAgICAgIGZvcihsZXQgYW5ub3RhdGlvbiBvZiBhbm5vdGF0aW9uTWFuYWdlci5hbm5vdGF0aW9ucyl7XG4gICAgICAgICAgICB0aGlzLkxvYWRBbm5vdGF0aW9uKGFubm90YXRpb24pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgTG9hZEFubm90YXRpb24oYW5ub3RhdGlvbil7XG4gICAgICAgIGxldCAkdGljayA9ICQoXCI8ZGl2IGNsYXNzPSd3YWxkb3JmLXRpY2tiYXItdGljayc+PC9kaXY+XCIpLmFwcGVuZFRvKHRoaXMuJHRpY2tCYXIpO1xuXG4gICAgICAgIC8vIEFkZCB0aGUgSUQgb2YgdGhlIGFubm90YXRpb24gdG8gaXRzIGNvcnJlc3BvbmRpbmcgdGljayBzbyB3ZSBjYW4gcmVmZXJlbmNlIGl0IGxhdGVyXG4gICAgICAgIGlmICgndW5kZWZpbmVkJyA9PSB0eXBlb2YoYW5ub3RhdGlvbi5pdGVtcykpIHsgLy8gVmVyIDFcbiAgICAgICAgICAgICR0aWNrLmRhdGEoXCJhbm5vdGF0aW9uLWlkXCIsIGFubm90YXRpb24uaWQpO1xuICAgICAgICB9IGVsc2UgeyAvLyBWZXIgMlxuICAgICAgICAgICAgJHRpY2suZGF0YShcImFubm90YXRpb24taWRcIiwgYW5ub3RhdGlvbi5pdGVtc1swXS5pdGVtc1swXS5pdGVtc1swXS5pZCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgYmVnaW5UaW1lID0gYW5ub3RhdGlvbi5iZWdpblRpbWU7XG4gICAgICAgIGxldCBiZWdpblBlcmNlbnQgPSBiZWdpblRpbWUgLyB0aGlzLmFubm90YXRvci5wbGF5ZXIudmlkZW9FbGVtZW50LmR1cmF0aW9uO1xuICAgICAgICAkdGljay5jc3MoJ2xlZnQnLCAoYmVnaW5QZXJjZW50ICogMTAwKS50b1N0cmluZygpICsgXCIlXCIpO1xuXG4gICAgICAgIGxldCBlbmRUaW1lID0gYW5ub3RhdGlvbi5lbmRUaW1lO1xuICAgICAgICBsZXQgZW5kUGVyY2VudCA9IGVuZFRpbWUgLyB0aGlzLmFubm90YXRvci5wbGF5ZXIudmlkZW9FbGVtZW50LmR1cmF0aW9uO1xuICAgICAgICAkdGljay5jc3MoJ3dpZHRoJywgKChlbmRQZXJjZW50IC0gYmVnaW5QZXJjZW50KSAqIDEwMCkudG9TdHJpbmcoKSArIFwiJVwiKTtcblxuICAgICAgICB0aGlzLnRpY2tzLnB1c2goJHRpY2spO1xuICAgIH1cblxuICAgIFJlbW92ZUFubm90YXRpb24oaWQpe1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiUmVtb3ZpbmcgdGljayBcIiArIGlkKTtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBvYmplY3QgZnJvbSB0aGUgZG9jdW1lbnQsIGFuZCB0aGUgYXJyYXlcbiAgICAgICAgbGV0IG5ld1RpY2tzID0gW107XG4gICAgICAgIGZvcihsZXQgJHRpY2sgb2YgdGhpcy50aWNrcyl7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnVGljazogJyArICR0aWNrLmRhdGEoXCJhbm5vdGF0aW9uLWlkXCIpKTtcbiAgICAgICAgICAgIGlmKCR0aWNrLmRhdGEoXCJhbm5vdGF0aW9uLWlkXCIpID09IGlkKXtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgUmVtb3ZlZCB0aWNrICR7aWR9YCk7XG4gICAgICAgICAgICAgICAgJHRpY2sucmVtb3ZlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1RpY2tzLnB1c2goJHRpY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudGlja3MgPSBuZXdUaWNrcztcbiAgICB9XG5cbiAgICBDbGVhcigpe1xuICAgICAgICBmb3IobGV0ICR0aWNrIG9mIHRoaXMudGlja3Mpe1xuICAgICAgICAgICAgJHRpY2sucmVtb3ZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRpY2tzID0gW107XG4gICAgfVxuXG59XG5cblxuZXhwb3J0IHsgVGlja0JhciB9OyIsImxldCBzaGExID0gcmVxdWlyZSgnc2hhMScpO1xuXG5jbGFzcyBTZXJ2ZXJJbnRlcmZhY2Uge1xuICAgIGNvbnN0cnVjdG9yKGFubm90YXRvcil7XG4gICAgICAgIHRoaXMuYW5ub3RhdG9yID0gYW5ub3RhdG9yO1xuICAgICAgICAvL2xvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCd3YWxkb3JmX2F1dGhfdG9rZW4nKTtcbiAgICB9XG5cbiAgICBTZXRCYXNlVVJMKHVybCl7XG4gICAgICAgIHRoaXMuYmFzZVVSTCA9IHVybDtcbiAgICB9XG5cbiAgICBtYWtlX2Jhc2VfYXV0aCh1c2VyLCBwYXNzd29yZCkge1xuICAgICAgICB2YXIgdG9rID0gdXNlciArICc6JyArIHBhc3N3b3JkO1xuICAgICAgICB2YXIgaGFzaCA9IGJ0b2EodG9rKTtcbiAgICAgICAgcmV0dXJuICdCYXNpYyAnICsgaGFzaDtcbiAgICB9XG5cbiAgICBtYWtlX3dyaXRlX2F1dGgodGV4dCl7XG4gICAgICAgIGlmKHRoaXMuYW5ub3RhdG9yLmFwaUtleSl7XG4gICAgICAgICAgICByZXR1cm4gJ0FwaUtleSAnICsgdGV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnVG9rZW4gJyArIHRleHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBMb2dnZWRJbigpe1xuICAgICAgICBpZih0aGlzLmFubm90YXRvci5hcGlLZXkpe1xuICAgICAgICAgICAgLy8gUmV0dXJuIHRydWUgaWYgYW4gZW1haWwgaGFzIGJlZW4gZW50ZXJlZFxuICAgICAgICAgICAgbGV0IHVzZXJfZW1haWwgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnd2FsZG9yZl91c2VyX2VtYWlsJyk7XG4gICAgICAgICAgICByZXR1cm4gdXNlcl9lbWFpbCAhPT0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJldHVybiB0cnVlIGlmIGEgdG9rZW4gaGFzIGJlZW4gcmVnaXN0ZXJlZFxuICAgICAgICAgICAgbGV0IGF1dGhfdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnd2FsZG9yZl9hdXRoX3Rva2VuJyk7XG4gICAgICAgICAgICByZXR1cm4gYXV0aF90b2tlbiAhPT0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIExvZ0luKHVzZXJuYW1lLCBwYXNzd29yZCl7XG4gICAgICAgIC8vIElmIEFQSSBrZXkgaXMgdXNlZCwganVzdCBzdG9yZSB0aGUgZW1haWwgYWRkcmVzc1xuICAgICAgICBpZih0aGlzLmFubm90YXRvci5hcGlLZXkpe1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJbU2VydmVyIEludGVyZmFjZV0gU3VjY2Vzc2Z1bGx5IGxvZ2dlZCBpbi5cIik7XG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnd2FsZG9yZl91c2VyX2VtYWlsJywgcGFzc3dvcmQpO1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3dhbGRvcmZfdXNlcl9uYW1lJywgdXNlcm5hbWUpO1xuICAgICAgICAgICAgdGhpcy5hbm5vdGF0b3IubWVzc2FnZU92ZXJsYXkuU2hvd01lc3NhZ2UoXCJMb2dnZWQgaW4gYXMgXCIrdXNlcm5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuICQuRGVmZXJyZWQoKS5yZXNvbHZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJC5hamF4KHtcbiAgICAgICAgICAgIHVybDogdGhpcy5iYXNlVVJMICsgXCIvYXBpL2xvZ2luXCIsXG4gICAgICAgICAgICB0eXBlOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgICAgICAgY29udGV4dDogdGhpcyxcbiAgICAgICAgICAgIGJlZm9yZVNlbmQ6IGZ1bmN0aW9uICh4aHIpIHtcbiAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQXV0aG9yaXphdGlvbicsIHRoaXMubWFrZV9iYXNlX2F1dGgodXNlcm5hbWUsIHBhc3N3b3JkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmRvbmUoKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW1NlcnZlciBJbnRlcmZhY2VdIFN1Y2Nlc3NmdWxseSBsb2dnZWQgaW4uXCIpO1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3dhbGRvcmZfYXV0aF90b2tlbicsIGRhdGEuYXV0aF90b2tlbik7XG4gICAgICAgIH0pLmZhaWwoKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiW1NlcnZlciBJbnRlcmZhY2VdIENvdWxkIG5vdCBsb2cgaW4uXCIpO1xuICAgICAgICAgICAgdGhpcy5hbm5vdGF0b3IubWVzc2FnZU92ZXJsYXkuU2hvd0Vycm9yKFwiQ291bGQgbm90IGxvZyBpbiFcIik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIExvZ091dCgpe1xuICAgICAgICAvLyBJZiBBUEkga2V5IGlzIHVzZWQsIGp1c3QgcmVtb3ZlIHRoZSBlbWFpbCBmcm9tIGxvY2FsIHN0b3JhZ2UuXG4gICAgICAgIGlmKHRoaXMuYW5ub3RhdG9yLmFwaUtleSl7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIltTZXJ2ZXIgSW50ZXJmYWNlXSBTdWNjZXNzZnVsbHkgbG9nZ2VkIG91dC5cIik7XG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnd2FsZG9yZl91c2VyX2VtYWlsJyk7XG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnd2FsZG9yZl91c2VyX25hbWUnKTtcbiAgICAgICAgICAgIHJldHVybiAkLkRlZmVycmVkKCkucmVzb2x2ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICQuYWpheCh7XG4gICAgICAgICAgICB1cmw6IHRoaXMuYmFzZVVSTCArIFwiL2FwaS9sb2dvdXRcIixcbiAgICAgICAgICAgIHR5cGU6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICBhc3luYzogdHJ1ZSxcbiAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMsXG4gICAgICAgICAgICBiZWZvcmVTZW5kOiBmdW5jdGlvbiAoeGhyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGF1dGhfdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnd2FsZG9yZl9hdXRoX3Rva2VuJykgfHwgXCJcIjtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW1NlcnZlciBJbnRlcmZhY2VdIHRva2VuOiAke2F1dGhfdG9rZW59YCk7XG4gICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0F1dGhvcml6YXRpb24nLCB0aGlzLm1ha2Vfd3JpdGVfYXV0aChhdXRoX3Rva2VuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmRvbmUoKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW1NlcnZlciBJbnRlcmZhY2VdIFN1Y2Nlc3NmdWxseSBsb2dnZWQgb3V0LlwiKTtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCd3YWxkb3JmX2F1dGhfdG9rZW4nKTtcbiAgICAgICAgfSkuZmFpbCgocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJbU2VydmVyIEludGVyZmFjZV0gQ291bGQgbm90IGxvZyBvdXQuXCIpO1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3dhbGRvcmZfYXV0aF90b2tlbicpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBGZXRjaEFubm90YXRpb25zKHNlYXJjaEtleSwgc2VhcmNoUGFyYW0pIHtcbiAgICAgICAgLy9UaGlzIGlzIHJlcGxhY2VkIGJ5IHRoaXMuYmFzZVVSTCwgd2hpY2ggaXMgZGVmaW5lZCBpbiBjb25maWdcbiAgICAgICAgLy92YXIgYm9va191cmwgPSAnaHR0cDovL3NjYWxhci51c2MuZWR1L2Rldi9zZW1hbnRpYy1hbm5vdGF0aW9uLXRvb2wvJzsgIC8vIFRoaXMgd2lsbCBiZSBkZWZpbmVkIGluIHRoZSBCb29rJ3MgSlNcbiAgICAgICAgLy9odHRwczovL3NjYWxhci51c2MuZWR1L2Rldi9zZW1hbnRpYy1hbm5vdGF0aW9uLXRvb2wvcmRmL2ZpbGUvbWVkaWEvSW5jZXB0aW9uJTIwQ29yZ2klMjBGbG9wLm1wND9mb3JtYXQ9b2FjJnByb3Y9MSZyZWM9MlxuICAgICAgIC8vIHZhciBhamF4X3VybCA9IHRoaXMuYmFzZVVSTCArICdyZGYvZmlsZS8nICsgc2VhcmNoUGFyYW0ucmVwbGFjZSh0aGlzLmJhc2VVUkwsICcnKSArICc/Zm9ybWF0PW9hYyZwcm92PTEmcmVjPTInO1xuICAgICAgICB2YXIgYWpheF91cmwgPSB0aGlzLmJhc2VVUkwgKyAncmRmL2ZpbGUvJyArIHNlYXJjaFBhcmFtLnJlcGxhY2UodGhpcy5iYXNlVVJMLCcnKSArICc/Zm9ybWF0PWlpaWYmcHJvdj0xJnJlYz0yJztcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcImFqYXhfdXJsOiBcIiArIGFqYXhfdXJsKTtcbiAgICAgICAgcmV0dXJuICQuYWpheCh7XG4gICAgICAgICAgICB1cmw6IGFqYXhfdXJsLFxuICAgICAgICAgICAgdHlwZTogXCJHRVRcIixcbiAgICAgICAgICAgIGpzb25wOiBcImNhbGxiYWNrXCIsXG4gICAgICAgICAgICBkYXRhVHlwZTogXCJqc29ucFwiLFxuICAgICAgICAgICAgYXN5bmM6IHRydWVcbiAgICAgICAgfSkuZG9uZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tTZXJ2ZXIgSW50ZXJmYWNlXSBGZXRjaGVkICcgKyAoKCd1bmRlZmluZWQnPT10eXBlb2YoZGF0YS5pdGVtcykpP2RhdGEubGVuZ3RoLTE6ZGF0YS5pdGVtc1swXS5pdGVtcy5sZW5ndGgpICsgJyBhbm5vdGF0aW9ucyBmb3IgJyArIHNlYXJjaEtleSArICc6IFwiJyArIHNlYXJjaFBhcmFtICsgJ1wiLicpO1xuICAgICAgICB9KS5mYWlsKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgdmFyIHJldHVybmVkX3Jlc3BvbnNlID0gcmVzcG9uc2UucmVzcG9uc2VKU09OLmVycm9yLmNvZGVbMF0udmFsdWUgKyBcIiA6IFwiICsgcmVzcG9uc2UucmVzcG9uc2VKU09OLmVycm9yLm1lc3NhZ2VbMF0udmFsdWUgO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignW1NlcnZlciBJbnRlcmZhY2VdIEVycm9yIGZldGNoaW5nIGFubm90YXRpb25zIGZvciAnICsgc2VhcmNoS2V5ICsgJzogXCInICsgc2VhcmNoUGFyYW0gKyAnXCJcXG4gJyArIHJldHVybmVkX3Jlc3BvbnNlKTtcbiAgICAgICAgICAgIF90aGlzMi5hbm5vdGF0b3IubWVzc2FnZU92ZXJsYXkuU2hvd0Vycm9yKCdDb3VsZCBub3QgcmV0cmlldmUgYW5ub3RhdGlvbnMhPGJyPignICsgcmV0dXJuZWRfcmVzcG9uc2UgKyAnKScpO1xuXG4gICAgICAgIH0pOyAgXG4gICAgfVxuXG4gICAgUG9zdEFubm90YXRpb24oY2FsbGJhY2spe1xuICAgICAgICBjb25zb2xlLmxvZyhcIlBvc3RpbmcgYW5ub3RhdGlvbi4uLlwiKTtcbiAgICAgICAgbGV0IGFubm90YXRpb24gPSB0aGlzLmFubm90YXRvci5ndWkuR2V0QW5ub3RhdGlvbk9iamVjdCgpO1xuICAgICAgICBjb25zb2xlLmxvZyhhbm5vdGF0aW9uKTtcblxuICAgICAgICBsZXQga2V5O1xuICAgICAgICBpZiAodGhpcy5hbm5vdGF0b3IuYXBpS2V5KXtcbiAgICAgICAgICAgIGtleSA9IHRoaXMuYW5ub3RhdG9yLmFwaUtleTtcbiAgICAgICAgICAgIGxldCBlbWFpbF9zdG9yYWdlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3dhbGRvcmZfdXNlcl9lbWFpbCcpO1xuICAgICAgICAgICAgbGV0IG5hbWVfc3RvcmFnZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd3YWxkb3JmX3VzZXJfbmFtZScpO1xuICAgICAgICAgICAgaWYobmFtZV9zdG9yYWdlID09IG51bGwpIG5hbWVfc3RvcmFnZSA9IGVtYWlsX3N0b3JhZ2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBrZXkgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnd2FsZG9yZl9hdXRoX3Rva2VuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLmFubm90YXRvci5hcGlLZXkpe1xuICAgICAgICAgICAgaWYoYW5ub3RhdGlvbltcImNyZWF0b3JcIl0gPT0gbnVsbCkgYW5ub3RhdGlvbltcImNyZWF0b3JcIl0gPSB7fTtcbiAgICAgICAgICAgIGFubm90YXRpb25bXCJjcmVhdG9yXCJdW1wiZW1haWxcIl0gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnd2FsZG9yZl91c2VyX2VtYWlsJyk7XG4gICAgICAgICAgICBhbm5vdGF0aW9uW1wiY3JlYXRvclwiXVtcIm5pY2tuYW1lXCJdID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3dhbGRvcmZfdXNlcl9uYW1lJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYW5ub3RhdGlvbltcImFubm90YXRpb25fdmVyc2lvblwiXSA9PSBcInYxXCIpIHtcbiAgICAgICAgICAgIGFubm90YXRpb25bXCJyZXF1ZXN0XCJdW1wiaXRlbXNcIl1bXCJhY3Rpb25cIl0gPSBcImFkZFwiO1xuICAgICAgICAgICAgZGVsZXRlIGFubm90YXRpb25bXCJpdGVtc1wiXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFubm90YXRpb25bXCJzZXJ2aWNlXCJdWzBdW1wiaXRlbXNcIl1bXCJhY3Rpb25cIl0gPSBcImFkZFwiO1xuICAgICAgICAgICAgZGVsZXRlIGFubm90YXRpb25bXCJ0YXJnZXRcIl07XG4gICAgICAgICAgICBkZWxldGUgYW5ub3RhdGlvbltcImJvZHlcIl07XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIGFubm90YXRpb25bXCJhbm5vdGF0aW9uX3ZlcnNpb25cIl07XG5cbiAgICAgICAgYW5ub3RhdGlvbltcImlkXCJdID0gdGhpcy5iYXNlVVJMICsgXCJhcGkvYWRkXCI7XG5cbiAgICAgICAgY29uc29sZS5sb2coXCJQb3N0QW5ub3RhdGlvbiBwYXlsb2FkOiBcIiArIEpTT04uc3RyaW5naWZ5KGFubm90YXRpb24pKTtcbiAgICAgICAgXG4gICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAvL3VybDogdGhpcy5iYXNlVVJMICsgXCIvYXBpL2FkZEFubm90YXRpb25cIixcbiAgICAgICAgICAgIHVybDogdGhpcy5iYXNlVVJMICsgXCJhcGkvYWRkXCIsXG4gICAgICAgICAgICB0eXBlOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsIC8vIE5lY2Vzc2FyeSBmb3IgUmFpbHMgdG8gc2VlIHRoaXMgZGF0YSB0eXBlIGNvcnJlY3RseVxuICAgICAgICAgICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJywgIC8vIE5lY2Vzc2FyeSBmb3IgUmFpbHMgdG8gc2VlIHRoaXMgZGF0YSB0eXBlIGNvcnJlY3RseVxuICAgICAgICAgICAgZGF0YTogSlNPTi5zdHJpbmdpZnkoYW5ub3RhdGlvbiksICAvLyBTdHJpbmdpZnkgbmVjZXNzYXJ5IGZvciBSYWlscyB0byBzZWUgdGhpcyBkYXRhIHR5cGUgY29ycmVjdGx5XG4gICAgICAgICAgICBhc3luYzogdHJ1ZSxcbiAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMsXG4gICAgICAgICAgICBiZWZvcmVTZW5kOiBmdW5jdGlvbiAoeGhyKSB7XG4gICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0F1dGhvcml6YXRpb24nLCB0aGlzLm1ha2Vfd3JpdGVfYXV0aChrZXkpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdWNjZXNzOiAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU3VjY2Vzc2Z1bGx5IHBvc3RlZCBuZXcgYW5ub3RhdGlvbi5cIik7XG4gICAgICAgICAgICAgICAgdGhpcy5hbm5vdGF0b3IubWVzc2FnZU92ZXJsYXkuU2hvd01lc3NhZ2UoXCJTdWNjZXNzZnVsbHkgY3JlYXRlZCBuZXcgYW5ub3RhdGlvbi5cIik7XG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbi5pZCA9IGRhdGEuaWQ7IC8vIEFwcGVuZCB0aGUgSUQgZ2l2ZW4gYnkgdGhlIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgaWYoY2FsbGJhY2spIGNhbGxiYWNrKGFubm90YXRpb24pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0dXJuZWRfcmVzcG9uc2UgPSBcInVuZGVmaW5lZCBlcnJvciB3aGlsZSBlZGl0aW5nIHRoZSBhbm5vdGF0aW9uXCI7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnJlc3BvbnNlSlNPTikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5lZF9yZXNwb25zZSA9IHJlc3BvbnNlLnJlc3BvbnNlSlNPTi5lcnJvci5jb2RlWzBdLnZhbHVlICsgXCIgOiBcIiArIHJlc3BvbnNlLnJlc3BvbnNlSlNPTi5lcnJvci5tZXNzYWdlWzBdLnZhbHVlIDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQ291bGQgbm90IGVkaXQgdGhlIGFubm90YXRpb24hIE1lc3NhZ2U6XFxuICR7cmV0dXJuZWRfcmVzcG9uc2V9YCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hbm5vdGF0b3IubWVzc2FnZU92ZXJsYXkuU2hvd0Vycm9yKGBDb3VsZCBub3QgZWRpdCB0aGUgYW5ub3RhdGlvbiE8YnI+KCR7cmV0dXJuZWRfcmVzcG9uc2V9KWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBFZGl0QW5ub3RhdGlvbihjYWxsYmFjayl7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiRWRpdGluZyBhbm5vdGF0aW9uLi4uXCIpO1xuICAgICAgICBsZXQgYW5ub3RhdGlvbiA9IHRoaXMuYW5ub3RhdG9yLmd1aS5HZXRBbm5vdGF0aW9uT2JqZWN0KCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGFubm90YXRpb24pO1xuXG4gICAgICAgIGxldCBrZXk7XG4gICAgICAgIGlmICh0aGlzLmFubm90YXRvci5hcGlLZXkpe1xuICAgICAgICAgICAga2V5ID0gdGhpcy5hbm5vdGF0b3IuYXBpS2V5O1xuICAgICAgICAgICAgbGV0IGVtYWlsX3N0b3JhZ2UgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnd2FsZG9yZl91c2VyX2VtYWlsJyk7XG4gICAgICAgICAgICBsZXQgbmFtZV9zdG9yYWdlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3dhbGRvcmZfdXNlcl9uYW1lJyk7XG4gICAgICAgICAgICBpZihuYW1lX3N0b3JhZ2UgPT0gbnVsbCkgbmFtZV9zdG9yYWdlID0gZW1haWxfc3RvcmFnZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGtleSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd3YWxkb3JmX2F1dGhfdG9rZW4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuYW5ub3RhdG9yLmFwaUtleSl7XG4gICAgICAgICAgICBpZihhbm5vdGF0aW9uW1wiY3JlYXRvclwiXSA9PSBudWxsKSBhbm5vdGF0aW9uW1wiY3JlYXRvclwiXSA9IHt9O1xuICAgICAgICAgICAgYW5ub3RhdGlvbltcImNyZWF0b3JcIl1bXCJlbWFpbFwiXSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd3YWxkb3JmX3VzZXJfZW1haWwnKTtcbiAgICAgICAgICAgIGFubm90YXRpb25bXCJjcmVhdG9yXCJdW1wibmlja25hbWVcIl0gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnd2FsZG9yZl91c2VyX25hbWUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhbm5vdGF0aW9uW1wiYW5ub3RhdGlvbl92ZXJzaW9uXCJdID09IFwidjFcIikge1xuICAgICAgICAgICAgYW5ub3RhdGlvbltcInJlcXVlc3RcIl1bXCJpdGVtc1wiXVtcImFjdGlvblwiXSA9IFwidXBkYXRlXCI7XG4gICAgICAgICAgICBkZWxldGUgYW5ub3RhdGlvbltcIml0ZW1zXCJdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5ub3RhdGlvbltcInNlcnZpY2VcIl1bMF1bXCJpdGVtc1wiXVtcImFjdGlvblwiXSA9IFwidXBkYXRlXCI7XG4gICAgICAgICAgICBkZWxldGUgYW5ub3RhdGlvbltcInRhcmdldFwiXTtcbiAgICAgICAgICAgIGRlbGV0ZSBhbm5vdGF0aW9uW1wiYm9keVwiXTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgYW5ub3RhdGlvbltcImFubm90YXRpb25fdmVyc2lvblwiXTtcblxuICAgICAgICB2YXIgb2xkSUQgPSAnJztcbiAgICAgICAgaWYgKCd1bmRlZmluZWQnID09IHR5cGVvZihhbm5vdGF0aW9uLml0ZW1zKSkgeyAvLyBWZXJzaW9uIDFcbiAgICAgICAgICAgIG9sZElEID0gYW5ub3RhdGlvbi5pZDtcbiAgICAgICAgfSBlbHNlIHsgLy8gVmVyc2lvbiAyXG4gICAgICAgICAgICBvbGRJRCA9IGFubm90YXRpb24uaXRlbXNbMF0uaXRlbXNbMF0uaXRlbXNbMF0uaWQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZyhcIk1vZGlmeWluZyBhbm5vdGF0aW9uOiBcIiArIG9sZElEKTtcbiAgICAgICAgXG4gICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICB1cmw6IHRoaXMuYmFzZVVSTCArIFwiYXBpL3VwZGF0ZVwiLFxuICAgICAgICAgICAgdHlwZTogXCJQT1NUXCIsXG4gICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5KGFubm90YXRpb24pLFxuICAgICAgICAgICAgYXN5bmM6IHRydWUsXG4gICAgICAgICAgICBjb250ZXh0OiB0aGlzLFxuICAgICAgICAgICAgYmVmb3JlU2VuZDogZnVuY3Rpb24gKHhocikge1xuICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBdXRob3JpemF0aW9uJywgdGhpcy5tYWtlX3dyaXRlX2F1dGgoa2V5KSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3VjY2VzczogKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGFubm90YXRpb24pO1xuICAgICAgICAgICAgICAgIGFubm90YXRpb24uaWQgPSBkYXRhLmlkOyAvLyBBcHBlbmQgdGhlIElEIGdpdmVuIGJ5IHRoZSByZXNwb25zZVxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJTdWNjZXNzZnVsbHkgZWRpdGVkIHRoZSBhbm5vdGF0aW9uLiAoSUQgaXMgbm93IFwiICsgZGF0YS5pZCArIFwiKVwiKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuYW5ub3RhdG9yLm1lc3NhZ2VPdmVybGF5LlNob3dNZXNzYWdlKFwiU3VjY2Vzc2Z1bGx5IGVkaXRlZCB0aGUgYW5vdGF0aW9uLlwiKTtcbiAgICAgICAgICAgICAgICBpZihjYWxsYmFjaykgY2FsbGJhY2soYW5ub3RhdGlvbiwgb2xkSUQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUuZXJyb3IoYENvdWxkIG5vdCBlZGl0IHRoZSBhbm5vdGF0aW9uISBNZXNzYWdlOlxcbiAke3Jlc3BvbnNlLnJlc3BvbnNlSlNPTi5kZXRhaWx9YCk7XG4gICAgICAgICAgICAgICAgLy90aGlzLmFubm90YXRvci5tZXNzYWdlT3ZlcmxheS5TaG93RXJyb3IoYENvdWxkIG5vdCBlZGl0IHRoZSBhbm5vdGF0aW9uITxicj4oJHtyZXNwb25zZS5yZXNwb25zZUpTT04uZGV0YWlsfSlgKTtcbiAgICAgICAgICAgICAgICB2YXIgcmV0dXJuZWRfcmVzcG9uc2UgPSBcInVuZGVmaW5lZCBlcnJvciB3aGlsZSBlZGl0aW5nIHRoZSBhbm5vdGF0aW9uXCI7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnJlc3BvbnNlSlNPTikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5lZF9yZXNwb25zZSA9IHJlc3BvbnNlLnJlc3BvbnNlSlNPTi5lcnJvci5jb2RlWzBdLnZhbHVlICsgXCIgOiBcIiArIHJlc3BvbnNlLnJlc3BvbnNlSlNPTi5lcnJvci5tZXNzYWdlWzBdLnZhbHVlIDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQ291bGQgbm90IGVkaXQgdGhlIGFubm90YXRpb24hIE1lc3NhZ2U6XFxuICR7cmV0dXJuZWRfcmVzcG9uc2V9YCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hbm5vdGF0b3IubWVzc2FnZU92ZXJsYXkuU2hvd0Vycm9yKGBDb3VsZCBub3QgZWRpdCB0aGUgYW5ub3RhdGlvbiE8YnI+KCR7cmV0dXJuZWRfcmVzcG9uc2V9KWApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIERlbGV0ZUFubm90YXRpb24oYW5ub3RhdGlvbiwgY2FsbGJhY2spe1xuICAgICAgICBpZiAoIWNvbmZpcm0oJ0FyZSB5b3Ugc3VyZSB5b3Ugd2lzaCB0byBkZWxldGUgdGhpcyBhbm5vdGF0aW9uPycpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQga2V5O1xuICAgICAgICBpZiAodGhpcy5hbm5vdGF0b3IuYXBpS2V5KXtcbiAgICAgICAgICAgIGtleSA9IHRoaXMuYW5ub3RhdG9yLmFwaUtleTtcbiAgICAgICAgICAgIGxldCBlbWFpbF9zdG9yYWdlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3dhbGRvcmZfdXNlcl9lbWFpbCcpO1xuICAgICAgICAgICAgbGV0IG5hbWVfc3RvcmFnZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd3YWxkb3JmX3VzZXJfbmFtZScpO1xuICAgICAgICAgICAgaWYobmFtZV9zdG9yYWdlID09IG51bGwpIG5hbWVfc3RvcmFnZSA9IGVtYWlsX3N0b3JhZ2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBrZXkgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnd2FsZG9yZl9hdXRoX3Rva2VuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLmFubm90YXRvci5hcGlLZXkpe1xuICAgICAgICAgICAgaWYoYW5ub3RhdGlvbltcImNyZWF0b3JcIl0gPT0gbnVsbCkgYW5ub3RhdGlvbltcImNyZWF0b3JcIl0gPSB7fTtcbiAgICAgICAgICAgIGFubm90YXRpb25bXCJjcmVhdG9yXCJdW1wiZW1haWxcIl0gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnd2FsZG9yZl91c2VyX2VtYWlsJyk7XG4gICAgICAgICAgICBhbm5vdGF0aW9uW1wiY3JlYXRvclwiXVtcIm5pY2tuYW1lXCJdID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3dhbGRvcmZfdXNlcl9uYW1lJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYW5ub3RhdGlvbltcImFubm90YXRpb25fdmVyc2lvblwiXSA9PSBcInYxXCIpIHtcbiAgICAgICAgICAgIGFubm90YXRpb25bXCJyZXF1ZXN0XCJdW1wiaXRlbXNcIl1bXCJhY3Rpb25cIl0gPSBcInVwZGF0ZVwiO1xuICAgICAgICAgICAgZGVsZXRlIGFubm90YXRpb25bXCJpdGVtc1wiXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFubm90YXRpb25bXCJzZXJ2aWNlXCJdWzBdW1wiaXRlbXNcIl1bXCJhY3Rpb25cIl0gPSBcInVwZGF0ZVwiO1xuICAgICAgICAgICAgZGVsZXRlIGFubm90YXRpb25bXCJ0YXJnZXRcIl07XG4gICAgICAgICAgICBkZWxldGUgYW5ub3RhdGlvbltcImJvZHlcIl07XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIGFubm90YXRpb25bXCJhbm5vdGF0aW9uX3ZlcnNpb25cIl07XG5cbiAgICAgICAgdmFyIG9sZElEID0gJyc7XG4gICAgICAgIGlmICgndW5kZWZpbmVkJyA9PSB0eXBlb2YoYW5ub3RhdGlvbi5pdGVtcykpIHsgLy8gVmVyc2lvbiAxXG4gICAgICAgICAgICBvbGRJRCA9IGFubm90YXRpb24uaWQ7XG4gICAgICAgIH0gZWxzZSB7IC8vIFZlcnNpb24gMlxuICAgICAgICAgICAgb2xkSUQgPSBhbm5vdGF0aW9uLml0ZW1zWzBdLml0ZW1zWzBdLml0ZW1zWzBdLmlkO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coXCJEZWxldGluZyBhbm5vdGF0aW9uOiBcIiArIG9sZElEKVxuXG4gICAgICAgIGlmICgndW5kZWZpbmVkJyA9PSB0eXBlb2YoYW5ub3RhdGlvbi5pdGVtcykpIHsgLy8gVmVyc2lvbiAxXG4gICAgICAgICAgICB2YXIgZGVsX2RhdGEgPSB7XG4gICAgICAgICAgICAgICAgXCJzY2FsYXI6dXJuXCI6IFwidXJuOnNjYWxhcjp2ZXJzaW9uOlwiICsgYW5ub3RhdGlvbi5pZCxcbiAgICAgICAgICAgICAgICBcIm5hdGl2ZVwiOiBhbm5vdGF0aW9uLnJlcXVlc3QuaXRlbXMubmF0aXZlLFxuICAgICAgICAgICAgICAgIFwiYWN0aW9uXCI6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICAgICAgXCJhcGlfa2V5XCI6IGFubm90YXRpb24ucmVxdWVzdC5pdGVtcy5hcGlfa2V5LFxuICAgICAgICAgICAgICAgIFwiaWRcIjogYW5ub3RhdGlvbi5yZXF1ZXN0Lml0ZW1zLmlkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuICQucG9zdCh0aGlzLmJhc2VVUkwgKyBcImFwaS9kZWxldGVcIiwgZGVsX2RhdGEsIGZ1bmN0aW9uKHJlc3BvbnNlKXtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRGVsZXRlIGVycm9yIHJlc3BvbnNlXCIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgfSAgXG4gICAgICAgICAgICB9KS5kb25lKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU3VjY2Vzc2Z1bGx5IGRlbGV0ZWQgdGhlIGFubm90YXRpb24uXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuYW5ub3RhdG9yLm1lc3NhZ2VPdmVybGF5LlNob3dNZXNzYWdlKFwiU3VjY2Vzc2Z1bGx5IGRlbGV0ZWQgdGhlIGFubm90YXRpb24uXCIpO1xuICAgICAgICAgICAgICAgIGlmKGNhbGxiYWNrKSBjYWxsYmFjayhhbm5vdGF0aW9uLCBvbGRJRCk7XG4gICAgICAgICAgICB9KS5mYWlsKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciByZXR1cm5lZF9yZXNwb25zZSA9IFwidW5kZWZpbmVkIGZhaWx1cmUgd2hpbGUgZGVsZXRpbmcgdGhlIGFubm90YXRpb25cIjtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UucmVzcG9uc2VKU09OKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnJlc3BvbnNlSlNPTi5lcnJvci5jb2RlWzBdLnZhbHVlICsgXCIgOiBcIiArIHJlc3BvbnNlLnJlc3BvbnNlSlNPTi5lcnJvci5tZXNzYWdlWzBdLnZhbHVlIDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQ291bGQgbm90IGRlbGV0ZSB0aGUgYW5ub3RhdGlvbi4gTWVzc2FnZTpcXG4gJHtyZXR1cm5lZF9yZXNwb25zZX1gKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFubm90YXRvci5tZXNzYWdlT3ZlcmxheS5TaG93RXJyb3IoYENvdWxkIG5vdCBkZWxldGUgdGhlIGFubm90YXRpb24hPGJyPigke3JldHVybmVkX3Jlc3BvbnNlfSlgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgeyAvLyBWZXJzaW9uIDJcbiAgICAgICAgICAgIGFubm90YXRpb25bXCJzZXJ2aWNlXCJdWzBdW1wiaXRlbXNcIl1bXCJhY3Rpb25cIl0gPSBcImRlbGV0ZVwiO1xuICAgICAgICAgICAgZGVsZXRlIGFubm90YXRpb25bXCJ0YXJnZXRcIl07XG4gICAgICAgICAgICBkZWxldGUgYW5ub3RhdGlvbltcImJvZHlcIl07XG4gICAgICAgICAgICBkZWxldGUgYW5ub3RhdGlvbltcImFubm90YXRpb25fdmVyc2lvblwiXTtcbiAgICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgICAgdXJsOiB0aGlzLmJhc2VVUkwgKyBcImFwaS9kZWxldGVcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgZGF0YTogSlNPTi5zdHJpbmdpZnkoYW5ub3RhdGlvbiksXG4gICAgICAgICAgICAgICAgYXN5bmM6IHRydWUsXG4gICAgICAgICAgICAgICAgY29udGV4dDogdGhpcyxcbiAgICAgICAgICAgICAgICBiZWZvcmVTZW5kOiBmdW5jdGlvbiAoeGhyKSB7XG4gICAgICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBdXRob3JpemF0aW9uJywgdGhpcy5tYWtlX3dyaXRlX2F1dGgoa2V5KSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFubm90YXRvci5tZXNzYWdlT3ZlcmxheS5TaG93TWVzc2FnZShcIlN1Y2Nlc3NmdWxseSBkZWxldGVkIHRoZSBhbm90YXRpb24uXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZihjYWxsYmFjaykgY2FsbGJhY2soYW5ub3RhdGlvbiwgb2xkSUQpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3I6IChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dXJuZWRfcmVzcG9uc2UgPSBcInVuZGVmaW5lZCBlcnJvciB3aGlsZSBkZWxldGluZyB0aGUgYW5ub3RhdGlvblwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UucmVzcG9uc2VKU09OKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5lZF9yZXNwb25zZSA9IHJlc3BvbnNlLnJlc3BvbnNlSlNPTi5lcnJvci5jb2RlWzBdLnZhbHVlICsgXCIgOiBcIiArIHJlc3BvbnNlLnJlc3BvbnNlSlNPTi5lcnJvci5tZXNzYWdlWzBdLnZhbHVlIDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBDb3VsZCBub3QgZGVsZXRlIHRoZSBhbm5vdGF0aW9uISBNZXNzYWdlOlxcbiAke3JldHVybmVkX3Jlc3BvbnNlfWApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFubm90YXRvci5tZXNzYWdlT3ZlcmxheS5TaG93RXJyb3IoYENvdWxkIG5vdCBkZWxldGUgdGhlIGFubm90YXRpb24hPGJyPigke3JldHVybmVkX3Jlc3BvbnNlfSlgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBcblxuICAgIH1cblxufVxuXG5cbmV4cG9ydCB7IFNlcnZlckludGVyZmFjZSB9OyIsImxldCBzaGExID0gcmVxdWlyZSgnc2hhMScpO1xuXG4vKipcbiAqIE1hbmFnZXMgdGhlIHVzZXIgc2Vzc2lvbiBmb3IgY29tbXVuaWNhdGluZyB3aXRoIHRoZSBiYWNrZW5kLlxuICovXG5jbGFzcyBTZXNzaW9uTWFuYWdlciB7XG5cbiAgICBjb25zdHJ1Y3Rvcihhbm5vdGF0b3Ipe1xuICAgICAgICBjb25zb2xlLmxvZyhcIltTZXNzaW9uIE1hbmFnZXJdIENyZWF0aW5nIFNlc3Npb25NYW5hZ2VyLi4uXCIpO1xuICAgICAgICB0aGlzLmFubm90YXRvciA9IGFubm90YXRvcjtcbiAgICAgICAgdGhpcy5tb2RhbE9wZW4gPSBmYWxzZTtcblxuICAgICAgICAvLyBJbmplY3QgdGhlIGJ1dHRvbiBmb3IgbG9nZ2luZyBpbi9vdXQgaW50byB0aGUgdG9vbGJhclxuICAgICAgICBpZighYW5ub3RhdG9yLmtpb3NrTW9kZSAmJiBhbm5vdGF0b3IuY21zRW1haWwgPT0gJycpe1xuICAgICAgICAgICAgdGhpcy4kdXNlckJ1dHRvbiA9ICQoXCI8YnV0dG9uPlNlc3Npb248L2J1dHRvbj5cIikuYnV0dG9uKHtcbiAgICAgICAgICAgICAgICBpY29uOiBcImZhIGZhLXVzZXJcIixcbiAgICAgICAgICAgICAgICBzaG93TGFiZWw6IGZhbHNlXG4gICAgICAgICAgICB9KS5jbGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5QcmVzZW50TW9kYWwoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5hbm5vdGF0b3IucGxheWVyLmNvbnRyb2xCYXIuUmVnaXN0ZXJFbGVtZW50KHRoaXMuJHVzZXJCdXR0b24sIDEsICdmbGV4LWVuZCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vdGhpcy4kZGlhbG9nLmRpYWxvZyhcIm9wZW5cIik7XG5cbiAgICAgICAgY29uc29sZS5sb2coXCJbU2Vzc2lvbiBNYW5hZ2VyXSBTZXNzaW9uTWFuYWdlciBjcmVhdGVkLlwiKTtcblxuICAgIH1cblxuICAgIFNob3dMb2dpbk1vZGFsKCl7XG5cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBkaWFsb2dcbiAgICAgICAgbGV0ICRjb250YWluZXIgPSAkKFwiPGRpdiBjbGFzcz0nd2FsZG9yZi1zZXNzaW9uLW1vZGFsJyB0aXRsZT0nTG9nIEluJz48L2Rpdj5cIik7IC8vIE91dGVybW9zdCBIVE1MXG4gICAgICAgIGxldCAkaGVhZFRleHQgPSAkKFwiPHAgY2xhc3M9J3ZhbGlkYXRlVGlwcyc+QWxsIGZpZWxkcyBhcmUgcmVxdWlyZWQuPC9wPlwiKS5hcHBlbmRUbygkY29udGFpbmVyKTtcbiAgICAgICAgbGV0ICRmb3JtID0gJChcIjxmb3JtPjwvZm9ybT5cIikuYXBwZW5kVG8oJGNvbnRhaW5lcik7XG5cbiAgICAgICAgbGV0ICRuaWNrbmFtZUZpZWxkO1xuICAgICAgICBsZXQgJHVzZXJuYW1lRmllbGQ7XG4gICAgICAgIGxldCAkcGFzc3dvcmRGaWVsZDtcblxuICAgICAgICBpZiAodGhpcy5hbm5vdGF0b3IuYXBpS2V5KXtcbiAgICAgICAgICAgICQoXCI8bGFiZWwgZm9yPSd1c2VybmFtZSc+TmFtZTwvbGFiZWw+XCIpLmFwcGVuZFRvKCRmb3JtKTtcbiAgICAgICAgICAgICRuaWNrbmFtZUZpZWxkID0gJChcIjxpbnB1dCB0eXBlPSd0ZXh0JyBuYW1lPSd1c2VybmFtZScgdmFsdWU9JycgY2xhc3M9J3RleHQgdWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWFsbCc+XCIpLmFwcGVuZFRvKCRmb3JtKTtcbiAgICAgICAgICAgICQoXCI8bGFiZWwgZm9yPSd1c2VybmFtZSc+RW1haWwgQWRkcmVzczwvbGFiZWw+XCIpLmFwcGVuZFRvKCRmb3JtKTtcbiAgICAgICAgICAgICR1c2VybmFtZUZpZWxkID0gJChcIjxpbnB1dCB0eXBlPSd0ZXh0JyBuYW1lPSdlbWFpbCcgdmFsdWU9JycgY2xhc3M9J3RleHQgdWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWFsbCc+XCIpLmFwcGVuZFRvKCRmb3JtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICQoXCI8bGFiZWwgZm9yPSd1c2VybmFtZSc+VXNlcm5hbWU8L2xhYmVsPlwiKS5hcHBlbmRUbygkZm9ybSk7XG4gICAgICAgICAgICAkdXNlcm5hbWVGaWVsZCA9ICQoXCI8aW5wdXQgdHlwZT0ndGV4dCcgbmFtZT0ndXNlcm5hbWUnIHZhbHVlPScnIGNsYXNzPSd0ZXh0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGwnPlwiKS5hcHBlbmRUbygkZm9ybSk7XG4gICAgICAgICAgICAkKFwiPGxhYmVsIGZvcj0ncGFzc3dvcmQnPlBhc3N3b3JkPC9sYWJlbD5cIikuYXBwZW5kVG8oJGZvcm0pO1xuICAgICAgICAgICAgJHBhc3N3b3JkRmllbGQgPSAkKFwiPGlucHV0IHR5cGU9J3Bhc3N3b3JkJyBuYW1lPSdwYXNzd29yZCcgdmFsdWU9JycgY2xhc3M9J3RleHQgdWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWFsbCc+XCIpLmFwcGVuZFRvKCRmb3JtKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgJGZvcm0ud3JhcElubmVyKFwiPGZpZWxkc2V0IC8+XCIpO1xuXG4gICAgICAgIGxldCBsb2dpbiA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmKHRoaXMuYW5ub3RhdG9yLmFwaUtleSl7XG4gICAgICAgICAgICAgICAgbGV0IG5pY2tOYW1lID0gJG5pY2tuYW1lRmllbGQudmFsKCk7XG4gICAgICAgICAgICAgICAgbGV0IHVzZXJOYW1lID0gc2hhMSgkdXNlcm5hbWVGaWVsZC52YWwoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hbm5vdGF0b3Iuc2VydmVyLkxvZ0luKG5pY2tOYW1lLCB1c2VyTmFtZSkuZG9uZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQVBJIGtleSBsb2dpbiBzdWNjZXNzXCIpO1xuICAgICAgICAgICAgICAgICAgICAkZGlhbG9nLmRpYWxvZyhcImNsb3NlXCIpO1xuICAgICAgICAgICAgICAgIH0pLmZhaWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAkaGVhZFRleHQuaHRtbChcIjxwPkludmFsaWQgZW1haWwgYWRkcmVzcy48L3A+XCIpO1xuICAgICAgICAgICAgICAgICAgICAkaGVhZFRleHQuY3NzKFwiY29sb3JcIiwgXCJyZWRcIik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgdXNlclBhc3MgPSBzaGExKCRwYXNzd29yZEZpZWxkLnZhbCgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFubm90YXRvci5zZXJ2ZXIuTG9nSW4oJHVzZXJuYW1lRmllbGQudmFsKCksIHVzZXJQYXNzKS5kb25lKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgJGRpYWxvZy5kaWFsb2coXCJjbG9zZVwiKTtcbiAgICAgICAgICAgICAgICB9KS5mYWlsKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgJGhlYWRUZXh0Lmh0bWwoXCI8cD5JbnZhbGlkIHVzZXJuYW1lIG9yIHBhc3N3b3JkLjwvcD5cIik7XG4gICAgICAgICAgICAgICAgICAgICRoZWFkVGV4dC5jc3MoXCJjb2xvclwiLCBcInJlZFwiKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgbGV0ICRkaWFsb2cgPSAkY29udGFpbmVyLmRpYWxvZyh7XG4gICAgICAgICAgICBhdXRvT3BlbjogdHJ1ZSxcbiAgICAgICAgICAgIGRyYWdnYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBtb2RhbDogdHJ1ZSxcbiAgICAgICAgICAgIGJ1dHRvbnM6IHtcbiAgICAgICAgICAgICAgICBcIkxvZyBJblwiOiBsb2dpbixcbiAgICAgICAgICAgICAgICBDYW5jZWw6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgJGRpYWxvZy5kaWFsb2coXCJjbG9zZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2U6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAkZGlhbG9nLmZpbmQoXCJmb3JtXCIpWyAwIF0ucmVzZXQoKTtcbiAgICAgICAgICAgICAgICAkZGlhbG9nLmZpbmQoXCJpbnB1dFwiKS5yZW1vdmVDbGFzcyggXCJ1aS1zdGF0ZS1lcnJvclwiICk7XG4gICAgICAgICAgICAgICAgdGhpcy5Pbk1vZGFsQ2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgU2hvd0xvZ291dE1vZGFsKCl7XG4gICAgICAgIGxldCAkY29udGFpbmVyID0gJChcIjxkaXYgdGl0bGU9J0xvZyBPdXQnPjwvZGl2PlwiKTtcbiAgICAgICAgbGV0ICRoZWFkVGV4dCA9ICRjb250YWluZXIuaHRtbChcIjxwIGNsYXNzPSd2YWxpZGF0ZVRpcHMnPkFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBsb2cgb3V0PzwvcD5cIik7XG4gICAgICAgIGxldCAkZGlhbG9nID0gJGNvbnRhaW5lci5kaWFsb2coe1xuICAgICAgICAgICAgYXV0b09wZW46IHRydWUsXG4gICAgICAgICAgICBkcmFnZ2FibGU6IGZhbHNlLFxuICAgICAgICAgICAgbW9kYWw6IHRydWUsXG4gICAgICAgICAgICBidXR0b25zOiB7XG4gICAgICAgICAgICAgICAgXCJMb2cgT3V0XCI6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbm5vdGF0b3Iuc2VydmVyLkxvZ091dCgpLmRvbmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGRpYWxvZy5kaWFsb2coXCJjbG9zZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBDYW5jZWw6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgJGRpYWxvZy5kaWFsb2coXCJjbG9zZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2U6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLk9uTW9kYWxDbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBQcmVzZW50TW9kYWwoKXtcbiAgICAgICAgLy8gRWFybHkgb3V0IGlmIHRoZSBtb2RhbCBpcyBhbHJlYWR5IG9wZW5cbiAgICAgICAgaWYodGhpcy5tb2RhbE9wZW4pIHJldHVybjtcblxuICAgICAgICAvLyBUdXJuIG9mZiBmdWxsc2NyZWVuIGlmIGl0J3Mgb25cbiAgICAgICAgdGhpcy5hbm5vdGF0b3IucGxheWVyLlNldEZ1bGxzY3JlZW4oZmFsc2UpO1xuXG4gICAgICAgIGlmKHRoaXMuYW5ub3RhdG9yLnNlcnZlci5Mb2dnZWRJbigpKXtcbiAgICAgICAgICAgIHRoaXMuU2hvd0xvZ291dE1vZGFsKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLlNob3dMb2dpbk1vZGFsKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLk9uTW9kYWxPcGVuKCk7XG4gICAgfVxuXG4gICAgT25Nb2RhbE9wZW4oKXtcbiAgICAgICAgdGhpcy4kdXNlckJ1dHRvbi5idXR0b24oXCJkaXNhYmxlXCIpO1xuICAgICAgICB0aGlzLm1vZGFsT3BlbiA9IHRydWU7XG4gICAgfVxuXG4gICAgT25Nb2RhbENsb3NlKCl7XG4gICAgICAgIHRoaXMuJHVzZXJCdXR0b24uYnV0dG9uKFwiZW5hYmxlXCIpO1xuICAgICAgICB0aGlzLm1vZGFsT3BlbiA9IGZhbHNlO1xuICAgIH1cblxufVxuXG5leHBvcnQgeyBTZXNzaW9uTWFuYWdlciB9OyIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcImNvbmZpZ0ZpbGVcIjogXCJhbm5vdGF0b3ItY29uZmlnLmpzb25cIlxufSIsIi8qXG5FbnRyeSBwb2ludCBmb3IgdGhlIHdob2xlIHByb2plY3QuIEFueSBqUXVlcnkgZXh0ZW5zaW9ucyBzaG91bGRcbmJlIHJlZ2lzdGVyZWQgaGVyZS5cbiovXG5cbi8vIEltcG9ydCBucG0gbW9kdWxlIGRlcGVuZGVuY2llc1xuaW1wb3J0IFwiLi92ZW5kb3IuanNcIjtcblxuaW1wb3J0IFwiLi91dGlscy9hcnJheS1leHRlbnNpb25zLmpzXCI7XG5pbXBvcnQgXCIuL3V0aWxzL2pxdWVyeS1leHRlbnNpb25zLmpzXCI7XG5pbXBvcnQgXCIuL3V0aWxzL3N0cmluZy1leHRlbnNpb25zLmpzXCI7XG5cbmltcG9ydCB7IHByZWZlcmVuY2VzIH0gZnJvbSBcIi4vdXRpbHMvcHJlZmVyZW5jZS1tYW5hZ2VyLmpzXCI7XG5pbXBvcnQgeyBWZXJpZnlSZXF1aXJlbWVudHMgfSBmcm9tIFwiLi91dGlscy9yZXF1aXJlbWVudHMuanNcIjtcbmltcG9ydCB7IEFubm90YXRvclZpZGVvUGxheWVyIH0gZnJvbSBcIi4vdmlkZW8tcGxheWVyL3ZpZGVvLXBsYXllci5qc1wiO1xuXG5cbiQuZm4uYW5ub3RhdGUgPSBmdW5jdGlvbihhcmdzKXsgXG5cbiAgICAvLyBsZXQgc2VydmVyVVJMID0gYXJncy5zZXJ2ZXJVUkwgfHwgJyc7XG4gICAgLy8gbGV0IHRhZ3NVUkwgPSBhcmdzLnRhZ3NVUkwgfHwgJyc7XG4gICAgLy8gbGV0IGFwaUtleSA9IGFyZ3MuYXBpS2V5IHx8ICcnO1xuICAgIC8vIGxldCBraW9za01vZGUgPSBhcmdzLmtpb3NrTW9kZSB8fCBmYWxzZTtcbiAgICAvLyBsZXQgbG9jYWxVUkwgPSBhcmdzLmxvY2FsVVJMIHx8ICcnO1xuICAgIC8vIGxldCByZW5kZXJlciA9IGZ1bmN0aW9uKC4uLikgfHwgZmFsc2U7XG5cbiAgICAvLyBFcnJvciBvdXQgZWFybHkgaWYgXCJ0aGlzXCIgaXMgbm90IGEgdmlkZW9cbiAgICBpZigkKHRoaXMpLnByb3AoJ3RhZ05hbWUnKS50b0xvd2VyQ2FzZSgpICE9IFwidmlkZW9cIil7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDYW5ub3Qgd3JhcCBhIG5vbi12aWRlbyBlbGVtZW50IVwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmKCFWZXJpZnlSZXF1aXJlbWVudHMoKSl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBwcmVmZXJlbmNlcy5HZXRKU09OKChkYXRhKSA9PiB7XG4gICAgLy8gICAgIC8vY29uc29sZS5sb2coZGF0YSk7XG4gICAgLy8gfSk7XG4gICAgXG4gICAgbmV3IEFubm90YXRvclZpZGVvUGxheWVyKCQodGhpcyksIGFyZ3MpO1xuXG59OyIsIi8vIEZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTQ4NTM5NzQvNzEzODc5MlxuXG4vLyBXYXJuIGlmIG92ZXJyaWRpbmcgZXhpc3RpbmcgbWV0aG9kXG5pZihBcnJheS5wcm90b3R5cGUuZXF1YWxzKVxuICAgIGNvbnNvbGUud2FybihcIk92ZXJyaWRpbmcgZXhpc3RpbmcgQXJyYXkucHJvdG90eXBlLmVxdWFscy4gUG9zc2libGUgY2F1c2VzOiBOZXcgQVBJIGRlZmluZXMgdGhlIG1ldGhvZCwgXFxcbiAgICB0aGVyZSdzIGEgZnJhbWV3b3JrIGNvbmZsaWN0IG9yIHlvdSd2ZSBnb3QgZG91YmxlIGluY2x1c2lvbnMgaW4geW91ciBjb2RlLlwiKTtcbiAgICBcbi8vIGF0dGFjaCB0aGUgLmVxdWFscyBtZXRob2QgdG8gQXJyYXkncyBwcm90b3R5cGUgdG8gY2FsbCBpdCBvbiBhbnkgYXJyYXlcbkFycmF5LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAvLyBpZiB0aGUgb3RoZXIgYXJyYXkgaXMgYSBmYWxzeSB2YWx1ZSwgcmV0dXJuXG4gICAgaWYgKCFhcnJheSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gY29tcGFyZSBsZW5ndGhzIC0gY2FuIHNhdmUgYSBsb3Qgb2YgdGltZSBcbiAgICBpZiAodGhpcy5sZW5ndGggIT0gYXJyYXkubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbD10aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIG5lc3RlZCBhcnJheXNcbiAgICAgICAgaWYgKHRoaXNbaV0gaW5zdGFuY2VvZiBBcnJheSAmJiBhcnJheVtpXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAvLyByZWN1cnNlIGludG8gdGhlIG5lc3RlZCBhcnJheXNcbiAgICAgICAgICAgIGlmICghdGhpc1tpXS5lcXVhbHMoYXJyYXlbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgICAgICAgXG4gICAgICAgIH0gICAgICAgICAgIFxuICAgICAgICBlbHNlIGlmICh0aGlzW2ldICE9IGFycmF5W2ldKSB7IFxuICAgICAgICAgICAgLy8gV2FybmluZyAtIHR3byBkaWZmZXJlbnQgb2JqZWN0IGluc3RhbmNlcyB3aWxsIG5ldmVyIGJlIGVxdWFsOiB7eDoyMH0gIT0ge3g6MjB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7ICAgXG4gICAgICAgIH0gICAgICAgICAgIFxuICAgIH0gICAgICAgXG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyBIaWRlIG1ldGhvZCBmcm9tIGZvci1pbiBsb29wc1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEFycmF5LnByb3RvdHlwZSwgXCJlcXVhbHNcIiwge2VudW1lcmFibGU6IGZhbHNlfSk7IiwiLyohXHJcbiAqIGpRdWVyeSBjbGlwLXBhdGgtcG9seWdvbiBQbHVnaW4gdjAuMS4xNSAoMjAyMC0wNi0yNClcclxuICogalF1ZXJ5IHBsdWdpbiB0aGF0IG1ha2VzIGVhc3kgdG8gdXNlIGNsaXAtcGF0aCBvbiB3aGF0ZXZlciB0YWcgdW5kZXIgZGlmZmVyZW50IGJyb3dzZXJzXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmRydXNpZWN6a28vY2xpcC1wYXRoLXBvbHlnb25cclxuICogXHJcbiAqIENvcHlyaWdodCAyMDIwIEthcm9sIEFuZHJ1c2llY3prb1xyXG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZVxyXG4gKi9cclxuXHJcbnZhciBnbG9iYWxWYXJpYWJsZSA9IHdpbmRvdyB8fCByb290O1xyXG52YXIgalF1ZXJ5ID0galF1ZXJ5IHx8IGdsb2JhbFZhcmlhYmxlLmpRdWVyeSB8fCByZXF1aXJlKFwianF1ZXJ5XCIpO1xyXG5cclxuKGZ1bmN0aW9uKCQpIHtcclxuICB2YXIgaWQgPSAwO1xyXG5cclxuICB2YXIgQ2xpcFBhdGggPSBmdW5jdGlvbihqUXVlcnksICRlbCwgcG9pbnRzLCBvcHRpb25zKSB7XHJcbiAgICB0aGlzLiQgPSBqUXVlcnk7XHJcbiAgICB0aGlzLiRlbCA9ICRlbDtcclxuICAgIHRoaXMucG9pbnRzID0gcG9pbnRzO1xyXG4gICAgdGhpcy5zdmdEZWZJZCA9ICdjbGlwUGF0aFBvbHlnb25HZW5JZCcgKyBpZCsrO1xyXG5cclxuICAgIHRoaXMucHJvY2Vzc09wdGlvbnMob3B0aW9ucyk7XHJcbiAgfTtcclxuXHJcbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XHJcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IENsaXBQYXRoO1xyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5DbGlwUGF0aCA9IENsaXBQYXRoO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBnbG9iYWxWYXJpYWJsZS5DbGlwUGF0aCA9IENsaXBQYXRoO1xyXG4gIH1cclxuXHJcbiAgQ2xpcFBhdGgucHJvdG90eXBlID0ge1xyXG5cclxuICAgICQ6IG51bGwsXHJcbiAgICAkZWw6IG51bGwsXHJcbiAgICBwb2ludHM6IG51bGwsXHJcblxyXG4gICAgaXNGb3JXZWJraXQ6IHRydWUsXHJcbiAgICBpc0ZvclN2ZzogdHJ1ZSxcclxuICAgIHN2Z0RlZklkOiBudWxsLFxyXG4gICAgaXNQZXJjZW50YWdlOiBmYWxzZSxcclxuXHJcbiAgICBjcmVhdGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB0aGlzLl9jcmVhdGVDbGlwUGF0aCh0aGlzLnBvaW50cyk7XHJcbiAgICB9LFxyXG5cclxuICAgIF9jcmVhdGVDbGlwUGF0aDogZnVuY3Rpb24ocG9pbnRzKSB7XHJcbiAgICAgIHRoaXMuX2NyZWF0ZVN2Z0RlZnMoKTtcclxuICAgICAgaWYgKHRoaXMuaXNGb3JTdmcpIHtcclxuICAgICAgICB0aGlzLl9jcmVhdGVTdmdCYXNlZENsaXBQYXRoKHBvaW50cyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMuaXNGb3JXZWJraXQpIHtcclxuICAgICAgICB0aGlzLl9jcmVhdGVXZWJraXRDbGlwUGF0aChwb2ludHMpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIF9jcmVhdGVXZWJraXRDbGlwUGF0aDogZnVuY3Rpb24ocG9pbnRzKSB7XHJcbiAgICAgIHZhciBjbGlwUGF0aCA9IFwicG9seWdvbihcIiArIHRoaXMuX3RyYW5zbGF0ZVBvaW50cyhwb2ludHMsIHRydWUsIHRoaXMuaXNQZXJjZW50YWdlKSArIFwiKVwiO1xyXG4gICAgICB0aGlzLiRlbC5jc3MoJy13ZWJraXQtY2xpcC1wYXRoJywgY2xpcFBhdGgpO1xyXG4gICAgfSxcclxuXHJcbiAgICBfY3JlYXRlU3ZnQmFzZWRDbGlwUGF0aDogZnVuY3Rpb24ocG9pbnRzKSB7XHJcbiAgICAgIHZhciBjbGlwUGF0aCA9IFwicG9seWdvbihcIiArIHRoaXMuX3RyYW5zbGF0ZVBvaW50cyhwb2ludHMsIHRydWUsIHRoaXMuaXNQZXJjZW50YWdlKSArIFwiKVwiO1xyXG4gICAgICB0aGlzLiRlbC5jc3MoJ2NsaXAtcGF0aCcsIGNsaXBQYXRoKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gRmlyZWZveCBubyBsb25nZXIgc2VlbXMgdG8gd29yayB3aXRoIHRoaXMgYnV0IGRvZXMgd2l0aCB0aGUgd2Via2l0IHZlcnNpb24sIHNvIEkgY29waWVkIGl0IGFib3ZlLlxyXG4gICAgLy8gX2NyZWF0ZVN2Z0Jhc2VkQ2xpcFBhdGg6IGZ1bmN0aW9uKHBvaW50cykge1xyXG4gICAgLy8gICB0aGlzLiQoJyMnICsgdGhpcy5zdmdEZWZJZCArICcnKS5maW5kKCdwb2x5Z29uJykuYXR0cigncG9pbnRzJywgdGhpcy5fdHJhbnNsYXRlUG9pbnRzKHBvaW50cywgZmFsc2UsIHRoaXMuaXNQZXJjZW50YWdlKSk7XHJcbiAgICAvLyAgIHRoaXMuJGVsLmNzcygnY2xpcC1wYXRoJywgJ3VybCgjJyArIHRoaXMuc3ZnRGVmSWQgKyAnKScpO1xyXG4gICAgLy8gfSxcclxuXHJcblxyXG4gICAgX3RyYW5zbGF0ZVBvaW50czogZnVuY3Rpb24ocG9pbnRzLCB3aXRoVW5pdCwgaXNQZXJjZW50YWdlKSB7XHJcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgICAgZm9yICh2YXIgaSBpbiBwb2ludHMpIHtcclxuICAgICAgICB2YXIgeCA9IHRoaXMuX2hhbmRsZVB4cyhwb2ludHNbaV1bMF0sIHdpdGhVbml0LCBpc1BlcmNlbnRhZ2UpO1xyXG4gICAgICAgIHZhciB5ID0gdGhpcy5faGFuZGxlUHhzKHBvaW50c1tpXVsxXSwgd2l0aFVuaXQsIGlzUGVyY2VudGFnZSk7XHJcbiAgICAgICAgcmVzdWx0LnB1c2goeCArICcgJyArIHkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXN1bHQuam9pbignLCAnKTtcclxuICAgIH0sXHJcblxyXG4gICAgX2hhbmRsZVB4czogZnVuY3Rpb24obnVtYmVyLCB3aXRoVW5pdCwgaXNQZXJjZW50YWdlKSB7XHJcbiAgICAgIGlmIChudW1iZXIgPT09IDApIHtcclxuICAgICAgICByZXR1cm4gbnVtYmVyO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghd2l0aFVuaXQpIHtcclxuICAgICAgICBpZiAoaXNQZXJjZW50YWdlKSB7XHJcbiAgICAgICAgICByZXR1cm4gbnVtYmVyIC8gMTAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVtYmVyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbnVtYmVyICsgKGlzUGVyY2VudGFnZSA/IFwiJVwiIDogXCJweFwiKTtcclxuICAgIH0sXHJcblxyXG4gICAgX2NyZWF0ZVN2Z0VsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnROYW1lKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLiQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIGVsZW1lbnROYW1lKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIF9jcmVhdGVTdmdEZWZzOiBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKHRoaXMuJCgnIycgKyB0aGlzLnN2Z0RlZklkICsgJycpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHZhciAkc3ZnID0gdGhpcy5fY3JlYXRlU3ZnRWxlbWVudCgnc3ZnJykuYXR0cignd2lkdGgnLCAwKS5hdHRyKCdoZWlnaHQnLCAwKS5jc3Moe1xyXG4gICAgICAgICAgJ3Bvc2l0aW9uJzogJ2Fic29sdXRlJyxcclxuICAgICAgICAgICd2aXNpYmlsaXR5JzogJ2hpZGRlbicsXHJcbiAgICAgICAgICAnd2lkdGgnOiAwLFxyXG4gICAgICAgICAgJ2hlaWdodCc6IDBcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgJGRlZnMgPSB0aGlzLl9jcmVhdGVTdmdFbGVtZW50KCdkZWZzJyk7XHJcbiAgICAgICAgJHN2Zy5hcHBlbmQoJGRlZnMpO1xyXG4gICAgICAgIHZhciAkY2xpcHBhdGggPSB0aGlzLl9jcmVhdGVTdmdFbGVtZW50KCdjbGlwUGF0aCcpLmF0dHIoJ2lkJywgdGhpcy5zdmdEZWZJZCk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNQZXJjZW50YWdlKSB7XHJcbiAgICAgICAgICAkY2xpcHBhdGguZ2V0KDApLnNldEF0dHJpYnV0ZSgnY2xpcFBhdGhVbml0cycsICdvYmplY3RCb3VuZGluZ0JveCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAkZGVmcy5hcHBlbmQoJGNsaXBwYXRoKTtcclxuICAgICAgICB2YXIgJHBvbHlnb24gPSB0aGlzLl9jcmVhdGVTdmdFbGVtZW50KCdwb2x5Z29uJyk7XHJcbiAgICAgICAgJGNsaXBwYXRoLmFwcGVuZCgkcG9seWdvbik7XHJcbiAgICAgICAgdGhpcy4kKCdib2R5JykuYXBwZW5kKCRzdmcpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHByb2Nlc3NPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICAgIHRoaXMuaXNGb3JXZWJraXQgPSAob3B0aW9ucyAmJiB0eXBlb2Yob3B0aW9ucy5pc0ZvcldlYmtpdCkgIT09IFwidW5kZWZpbmVkXCIpID8gb3B0aW9ucy5pc0ZvcldlYmtpdCA6IHRoaXMuaXNGb3JXZWJraXQ7XHJcbiAgICAgIHRoaXMuaXNGb3JTdmcgPSAob3B0aW9ucyAmJiB0eXBlb2Yob3B0aW9ucy5pc0ZvclN2ZykgIT09IFwidW5kZWZpbmVkXCIpID8gb3B0aW9ucy5pc0ZvclN2ZyA6IHRoaXMuaXNGb3JTdmc7XHJcbiAgICAgIHRoaXMuaXNQZXJjZW50YWdlID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5pc1BlcmNlbnRhZ2UgfHwgdGhpcy5pc1BlcmNlbnRhZ2UpO1xyXG4gICAgICB0aGlzLnN2Z0RlZklkID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5zdmdEZWZJZCkgfHwgdGhpcy5zdmdEZWZJZDtcclxuICAgIH1cclxuICB9O1xyXG4gIFxyXG4gICQuZm4uY2xpcFBhdGggPSBmdW5jdGlvbihwb2ludHMsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciAkZWwgPSAkKHRoaXMpO1xyXG4gICAgICB2YXIgY2xpcFBhdGggPSBuZXcgQ2xpcFBhdGgoJCwgJGVsLCBwb2ludHMsIG9wdGlvbnMpO1xyXG4gICAgICBjbGlwUGF0aC5jcmVhdGUoKTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG59KS5jYWxsKHRoaXMsIGpRdWVyeSk7IiwiLyoqXG4gKiBTZXRzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBlbGVtZW50IHdoaWxlIGRpc2FibGluZyBpbnRlcmFjdGlvbi5cbiAqIERvZXNuJ3QgbWVzcyB3aXRoIGpRdWVyeSdzIHBvc2l0aW9uaW5nIGNhbGN1bGF0aW9ucyBsaWtlIHNob3coKVxuICogYW5kIGhpZGUoKS5cbiAqL1xuJC5mbi5tYWtlVmlzaWJsZSA9IGZ1bmN0aW9uKHNob3cpIHtcbiAgICBpZihzaG93KXtcbiAgICAgICAgJCh0aGlzKS5jc3Moe1xuICAgICAgICAgICAgXCJ2aXNpYmlsaXR5XCI6IFwidmlzaWJsZVwiLFxuICAgICAgICAgICAgXCJwb2ludGVyLWV2ZW50c1wiOiBcIlwiXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgICQodGhpcykuY3NzKHtcbiAgICAgICAgICAgIFwidmlzaWJpbGl0eVwiOiBcImhpZGRlblwiLFxuICAgICAgICAgICAgXCJwb2ludGVyLWV2ZW50c1wiOiBcIm5vbmVcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgXG59XG5cbi8qXG5Db3B5cmlnaHQgMjAxNCBNaWtlIER1bm5cbmh0dHA6Ly91cHNob3RzLm9yZy9cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xuYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG5cIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbndpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbmRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xucGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXG50aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG5NRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRVxuTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTlxuT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG5XSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuaHR0cHM6Ly9naXRodWIuY29tL21vYWdyaXVzL2NvcHljc3NcblxuKi9cblx0XG4kLmZuLmdldFN0eWxlcyA9IGZ1bmN0aW9uKG9ubHksIGV4Y2VwdCkge1xuICAgIFxuICAgIC8vIHRoZSBtYXAgdG8gcmV0dXJuIHdpdGggcmVxdWVzdGVkIHN0eWxlcyBhbmQgdmFsdWVzIGFzIEtWUFxuICAgIHZhciBwcm9kdWN0ID0ge307XG4gICAgXG4gICAgLy8gdGhlIHN0eWxlIG9iamVjdCBmcm9tIHRoZSBET00gZWxlbWVudCB3ZSBuZWVkIHRvIGl0ZXJhdGUgdGhyb3VnaFxuICAgIHZhciBzdHlsZTtcbiAgICBcbiAgICAvLyByZWN5Y2xlIHRoZSBuYW1lIG9mIHRoZSBzdHlsZSBhdHRyaWJ1dGVcbiAgICB2YXIgbmFtZTtcbiAgICBcbiAgICAvLyBpZiBpdCdzIGEgbGltaXRlZCBsaXN0LCBubyBuZWVkIHRvIHJ1biB0aHJvdWdoIHRoZSBlbnRpcmUgc3R5bGUgb2JqZWN0XG4gICAgaWYgKG9ubHkgJiYgb25seSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9ubHkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBzaW5jZSB3ZSBoYXZlIHRoZSBuYW1lIGFscmVhZHksIGp1c3QgcmV0dXJuIHZpYSBidWlsdC1pbiAuY3NzIG1ldGhvZFxuICAgICAgICAgICAgbmFtZSA9IG9ubHlbaV07XG4gICAgICAgICAgICBwcm9kdWN0W25hbWVdID0gdGhpcy5jc3MobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgfSBlbHNlIHtcbiAgICBcbiAgICAgICAgLy8gcHJldmVudCBmcm9tIGVtcHR5IHNlbGVjdG9yXG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UsIHdlIG5lZWQgdG8gZ2V0IGV2ZXJ5dGhpbmdcbiAgICAgICAgICAgIHZhciBkb20gPSB0aGlzLmdldCgwKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gc3RhbmRhcmRzXG4gICAgICAgICAgICBpZiAod2luZG93LmdldENvbXB1dGVkU3R5bGUpIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBjb252ZW5pZW5jZSBtZXRob2RzIHRvIHR1cm4gY3NzIGNhc2UgKCdiYWNrZ3JvdW5kLWltYWdlJykgdG8gY2FtZWwgKCdiYWNrZ3JvdW5kSW1hZ2UnKVxuICAgICAgICAgICAgICAgIHZhciBwYXR0ZXJuID0gL1xcLShbYS16XSkvZztcbiAgICAgICAgICAgICAgICB2YXIgdWMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGIudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB9O1x0XHRcdFxuICAgICAgICAgICAgICAgIHZhciBjYW1lbGl6ZSA9IGZ1bmN0aW9uKHN0cmluZyl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShwYXR0ZXJuLCB1Yyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgd2UncmUgZ2V0dGluZyBhIGdvb2QgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9tLCBudWxsKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2FtZWwsIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBvcGVyYSBkb2Vzbid0IGdpdmUgYmFjayBzdHlsZS5sZW5ndGggLSB1c2UgdHJ1dGh5IHNpbmNlIGEgMCBsZW5ndGggbWF5IGFzIHdlbGwgYmUgc2tpcHBlZCBhbnl3YXlzXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gc3R5bGUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHN0eWxlW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbWVsID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RbY2FtZWxdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvcGVyYVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChuYW1lIGluIHN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FtZWwgPSBjYW1lbGl6ZShuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHN0eWxlLmdldFByb3BlcnR5VmFsdWUobmFtZSkgfHwgc3R5bGVbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdFtjYW1lbF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElFIC0gZmlyc3QgdHJ5IGN1cnJlbnRTdHlsZSwgdGhlbiBub3JtYWwgc3R5bGUgb2JqZWN0IC0gZG9uJ3QgYm90aGVyIHdpdGggcnVudGltZVN0eWxlXG4gICAgICAgICAgICBlbHNlIGlmIChzdHlsZSA9IGRvbS5jdXJyZW50U3R5bGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKG5hbWUgaW4gc3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvZHVjdFtuYW1lXSA9IHN0eWxlW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0eWxlID0gZG9tLnN0eWxlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChuYW1lIGluIHN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3R5bGVbbmFtZV0gIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZHVjdFtuYW1lXSA9IHN0eWxlW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIHJlbW92ZSBhbnkgc3R5bGVzIHNwZWNpZmllZC4uLlxuICAgIC8vIGJlIGNhcmVmdWwgb24gYmxhY2tsaXN0IC0gc29tZXRpbWVzIHZlbmRvci1zcGVjaWZpYyB2YWx1ZXMgYXJlbid0IG9idmlvdXMgYnV0IHdpbGwgYmUgdmlzaWJsZS4uLiAgZS5nLiwgZXhjZXB0aW5nICdjb2xvcicgd2lsbCBzdGlsbCBsZXQgJy13ZWJraXQtdGV4dC1maWxsLWNvbG9yJyB0aHJvdWdoLCB3aGljaCB3aWxsIGluIGZhY3QgY29sb3IgdGhlIHRleHRcbiAgICBpZiAoZXhjZXB0ICYmIGV4Y2VwdCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXhjZXB0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgbmFtZSA9IGV4Y2VwdFtpXTtcbiAgICAgICAgICAgIGRlbGV0ZSBwcm9kdWN0W25hbWVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIG9uZSB3YXkgb3V0IHNvIHdlIGNhbiBwcm9jZXNzIGJsYWNrbGlzdCBpbiBvbmUgc3BvdFxuICAgIHJldHVybiBwcm9kdWN0O1xuXG59O1xuXG4vLyBzdWdhciAtIHNvdXJjZSBpcyB0aGUgc2VsZWN0b3IsIGRvbSBlbGVtZW50IG9yIGpRdWVyeSBpbnN0YW5jZSB0byBjb3B5IGZyb20gLSBvbmx5IGFuZCBleGNlcHQgYXJlIG9wdGlvbmFsXG4kLmZuLmNvcHlDU1MgPSBmdW5jdGlvbihzb3VyY2UsIG9ubHksIGV4Y2VwdCkge1xuICAgIHZhciBzdHlsZXMgPSBzb3VyY2UuZ2V0U3R5bGVzKG9ubHksIGV4Y2VwdCk7XG4gICAgdGhpcy5jc3Moc3R5bGVzKTtcbiAgICBcbiAgICByZXR1cm4gdGhpcztcbn07IiwiLy8gQnJpbmcgaW4gYnVpbGQgY29uZmlnIG9wdGlvbnNcbmxldCBtZXRhY29uZmlnID0gcmVxdWlyZShcIi4uL2NvbmZpZy5qc29uXCIpO1xuXG5jbGFzcyBQcmVmZXJlbmNlTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICB9XG5cbiAgICBHZXRKU09OKGNhbGxiYWNrKXtcblxuICAgICAgICAvL2xldCBsb2MgPSB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWU7XG4gICAgICAgIC8vbGV0IGRpciA9IGxvYy5zdWJzdHJpbmcoMCwgbG9jLmxhc3RJbmRleE9mKCcvJykpO1xuICAgICAgICBcbiAgICAgICAgbGV0IGRpciA9IFwiLi9kaXN0L1wiO1xuICAgICAgICAvL2NvbnNvbGUubG9nKGRpciArIG1ldGFjb25maWcuY29uZmlnRmlsZSk7XG5cbiAgICAgICAgaWYodGhpcy5jYWNoZWRKU09OICE9IG51bGwpe1xuICAgICAgICAgICAgY2FsbGJhY2sodGhpcy5jYWNoZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiBcImpzb25cIixcbiAgICAgICAgICAgICAgICB1cmw6IGRpciArIG1ldGFjb25maWcuY29uZmlnRmlsZSxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiAoZGF0YSk9PntcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWNoZWRKU09OID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodGhpcy5jYWNoZWRKU09OKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG59XG5cbmV4cG9ydCBsZXQgcHJlZmVyZW5jZXMgPSBuZXcgUHJlZmVyZW5jZU1hbmFnZXIoKTsiLCIvKipcbiAqIFJldHVybnMgZmFsc2UgaWYgcnVubmluZyBvbiBhbiB1bnN1cHBvcnRlZCBwbGF0Zm9ybSBvciBtaXNzaW5nIGpRdWVyeSwgb3RoZXJ3aXNlIHRydWUuXG4gKiBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFZlcmlmeVJlcXVpcmVtZW50cygpIHtcbiAgICBcbiAgICAvLyBTdG9wIHJ1bm5pbmcgaWYgd2UncmUgb24gYW4gdW5zdXBwb3J0ZWQgcGxhdGZvcm0gKG1vYmlsZSBmb3Igbm93KVxuICAgIC8vIGlmKCAvQW5kcm9pZHx3ZWJPU3xpUGhvbmV8aVBhZHxpUG9kfEJsYWNrQmVycnl8SUVNb2JpbGV8T3BlcmEgTWluaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgKSB7XG4gICAgLy8gICAgIGNvbnNvbGUuZXJyb3IoXCJQbGF0Zm9ybSBpcyB1bnN1cHBvcnRlZCFcIik7XG4gICAgLy8gICAgIC8vbGV0IHVuc3VwcG9ydGVkRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAvLyAgICAgLy91bnN1cHBvcnRlZERpdi5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIllvdXIgcGxhdGZvcm0gaXMgdW5zdXBwb3J0ZWQhXCIpKTtcbiAgICAvLyAgICAgLy9kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHVuc3VwcG9ydGVkRGl2KTtcbiAgICAvLyAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIH1cblxuICAgIC8vIENoZWNrIGlmIHdlIGRvbid0IGhhdmUgalF1ZXJ5IGxvYWRlZFxuICAgIGlmKCF3aW5kb3cualF1ZXJ5KXtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkpRdWVyeSBtdXN0IGJlIHByZXNlbnQhXCIpO1xuICAgICAgICAvL2xldCB1bnN1cHBvcnRlZERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIC8vdW5zdXBwb3J0ZWREaXYuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJZb3VyIHBsYXRmb3JtIGlzIHVuc3VwcG9ydGVkIVwiKSk7XG4gICAgICAgIC8vZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh1bnN1cHBvcnRlZERpdik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgICBcbn0iLCJcbi8qKlxuICogRXNjYXBlcyB0aGUgc3RyaW5nIHNvIGl0IGNhbiBlbWJlZCBkaXJlY3RseSBpbiBhbiBIVE1MIGRvY3VtZW50LlxuICovXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMjAzNDMzNFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cmluZy5wcm90b3R5cGUsICdlc2NhcGVIVE1MJywge1xuICAgIHZhbHVlKCkge1xuICAgICAgICB2YXIgZW50aXR5TWFwID0ge1xuICAgICAgICAgICAgJyYnOiAnJmFtcDsnLCAnPCc6ICcmbHQ7JywgJz4nOiAnJmd0OycsICdcIic6ICcmcXVvdDsnLFxuICAgICAgICAgICAgXCInXCI6ICcmIzM5OycsICcvJzogJyYjeDJGOycsICdgJzogJyYjeDYwOycsICc9JzogJyYjeDNEOydcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFN0cmluZyh0aGlzKS5yZXBsYWNlKC9bJjw+XCInYD1cXC9dL2csIGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICByZXR1cm4gZW50aXR5TWFwW3NdO1xuICAgICAgICB9KTtcbiAgICB9XG59KTsiLCIvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zNDg0MTAyNlxuZnVuY3Rpb24gR2V0Rm9ybWF0dGVkVGltZSh0aW1lSW5TZWNvbmRzKXtcbiAgICBpZihpc05hTih0aW1lSW5TZWNvbmRzKSkgcmV0dXJuIDA7XG4gICAgbGV0IHRpbWUgPSB0aW1lSW5TZWNvbmRzIHwgMDsgLy9UcnVuY2F0ZSB0byBpbnRlZ2VyXG4gICAgbGV0IGhvdXJzICAgPSBNYXRoLmZsb29yKHRpbWUgLyAzNjAwKSAlIDI0XG4gICAgbGV0IG1pbnV0ZXMgPSBNYXRoLmZsb29yKHRpbWUgLyA2MCkgJSA2MFxuICAgIGxldCBzZWNvbmRzID0gdGltZSAlIDYwXG4gICAgbGV0IGZvcm1hdHRlZCA9IFtob3VycyxtaW51dGVzLHNlY29uZHNdXG4gICAgICAgIC5tYXAodiA9PiB2IDwgMTAgPyBcIjBcIiArIHYgOiB2KVxuICAgICAgICAuZmlsdGVyKCh2LGkpID0+IHYgIT09IFwiMDBcIiB8fCBpID4gMClcbiAgICAgICAgLmpvaW4oXCI6XCIpXG5cbiAgICBpZiAoZm9ybWF0dGVkLmNoYXJBdCgwKSA9PSBcIjBcIikge1xuICAgICAgICBmb3JtYXR0ZWQgPSBmb3JtYXR0ZWQuc3Vic3RyKDEpO1xuICAgIH1cblxuICAgIGxldCBtcyA9ICh0aW1lSW5TZWNvbmRzICUgMSkudG9GaXhlZCgyKTtcbiAgICBmb3JtYXR0ZWQgKz0gbXMudG9TdHJpbmcoKS5zdWJzdHIoMSk7XG5cbiAgICByZXR1cm4gZm9ybWF0dGVkO1xufVxuXG4vLyBGcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzk2NDA0MTcvNzEzODc5MlxuZnVuY3Rpb24gR2V0U2Vjb25kc0Zyb21ITVMoaG1zKXtcbiAgICBsZXQgcGFydHMgPSBobXMuc3BsaXQoJy4nKTtcbiAgICBsZXQgbXMgPSBcIjBcIjtcbiAgICBpZihwYXJ0cy5sZW5ndGggPiAxKSBtcyA9ICcuJytwYXJ0c1sxXTtcblxuICAgIGxldCBwID0gcGFydHNbMF0uc3BsaXQoJzonKSxcbiAgICAgICAgcyA9IDAsIG0gPSAxO1xuXG4gICAgd2hpbGUgKHAubGVuZ3RoID4gMCkge1xuICAgICAgICBzICs9IG0gKiBwYXJzZUludChwLnBvcCgpLCAxMCk7XG4gICAgICAgIG0gKj0gNjA7XG4gICAgfVxuXG4gICAgcyArPSBwYXJzZUZsb2F0KG1zKTtcbiAgICByZXR1cm4gcztcbn1cblxuZXhwb3J0IHsgR2V0Rm9ybWF0dGVkVGltZSwgR2V0U2Vjb25kc0Zyb21ITVMgfTsiLCIvKipcbiAqIFVzZSB0aGlzIGZpbGUgdG8gaW1wb3J0IHdoYXQgeW91IG5lZWQgZnJvbSB0aGUgYnVuZGxlZCBucG0gbW9kdWxlcy5cbiAqL1xuXG4vLyBNdXN0IGltcG9ydCBmcm9tIG5vZGVfbW9kdWxlcyBmb2xkZXIgb3IgaXQgd29uJ3Qgc2VlIHRoZSBzaGltbWVkIGpxdWVyeSBpbnN0YW5jZVxuLy8gUmVtb3ZlZCBmcm9tIGhlcmUgYmVjYXVzZSB0aGV5IHdlcmVuJ3QgYmVpbmcgbG9hZGVkIGluIHRoZSByaWdodCBvcmRlciAtIEpQQlxuLy8gaW1wb3J0ICcuLi9ub2RlX21vZHVsZXMvc2VsZWN0Mi9kaXN0L2pzL3NlbGVjdDIuanMnO1xuLy8gaW1wb3J0IFwiLi4vbm9kZV9tb2R1bGVzL3NlbGVjdDIvZGlzdC9jc3Mvc2VsZWN0Mi5jc3NcIjtcblxuaW1wb3J0IFwicXRpcDJcIjtcbi8vcmVxdWlyZShcIi4uL25vZGVfbW9kdWxlcy9xdGlwMi9kaXN0L2pxdWVyeS5xdGlwLm1pbi5qc1wiKTtcbi8vaW1wb3J0IFwiLi4vbm9kZV9tb2R1bGVzL3F0aXAyL2Rpc3QvanF1ZXJ5LnF0aXAubWluLmNzc1wiO1xuXG5yZXF1aXJlKFwiLi91dGlscy9jbGlwLXBhdGgtcG9seWdvbi0xLjAuMTUuanNcIik7XG5cbi8vbGV0IHNjcmVlbmZ1bGwgPSByZXF1aXJlKCdzY3JlZW5mdWxsJyk7XG4vL2ltcG9ydCBzY3JlZW5mdWxsIGZyb20gXCJzY3JlZW5mdWxsXCI7XG5cbi8vIENETiByZXNvdXJjZXNcbi8vIEZvbnQtQXdlc29tZVxuLy8kKFwiaGVhZFwiKS5hcHBlbmQoJChcIjxzY3JpcHQgc3JjPSdodHRwczovL3VzZS5mb250YXdlc29tZS5jb20vYTcwM2UyZTViZi5qcyc+PC9zY3JpcHQ+XCIpKTsiLCJpbXBvcnQgeyBHZXRGb3JtYXR0ZWRUaW1lIH0gZnJvbSBcIi4uL3V0aWxzL3RpbWUuanNcIjtcblxuY2xhc3MgU2Vla2JhclRvb2x0aXAge1xuICAgIGNvbnN0cnVjdG9yKCRwYXJlbnQsIHBsYXllcil7XG4gICAgICAgIHRoaXMuJHBhcmVudCA9ICRwYXJlbnQ7XG4gICAgICAgIHRoaXMucGxheWVyID0gcGxheWVyO1xuXG4gICAgICAgIHRoaXMuJHRvb2x0aXAgPSAkKFwiPGRpdiBjbGFzcz0nd2FsZG9yZi1zZWVrYmFyLXRvb2x0aXAnPjwvZGl2PlwiKS5hcHBlbmRUbygkcGFyZW50KTtcbiAgICAgICAgdGhpcy50ZXh0ID0gXCJUZXN0XCI7XG4gICAgICAgIHRoaXMuJGNvbnRlbnQgPSAkKFwiPHA+XCIgKyB0aGlzLnRleHQgKyBcIjwvcD5cIikuYXBwZW5kVG8odGhpcy4kdG9vbHRpcCk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLmhvdmVyT2Zmc2V0ID0gLTEwO1xuICAgICAgICB0aGlzLnBhZGRpbmcgPSA1O1xuICAgICAgICBcbiAgICAgICAgdGhpcy5IaWRlKCk7XG5cbiAgICAgICAgdGhpcy4kcGFyZW50Lm1vdXNlbW92ZSgoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuU2hvdygpO1xuXG4gICAgICAgICAgICAvL0FkZCBhbmQgdXBkYXRlIHRvb2x0aXAgb24gbW91c2UgbW92ZW1lbnQgdG8gc2hvdyB3aGVyZSB0aGUgbW91c2UgaXMgaG92ZXJpbmcuXG4gICAgICAgICAgICBsZXQgbW91c2VYID0gZXZlbnQucGFnZVggLSBwbGF5ZXIuJGNvbnRhaW5lci5vZmZzZXQoKS5sZWZ0O1xuICAgICAgICAgICAgbGV0IHBlcmNlbnQgPSBtb3VzZVggLyB0aGlzLiRwYXJlbnQud2lkdGgoKTtcbiAgICAgICAgICAgIGxldCB0aW1lQXRDdXJzb3IgPSBwZXJjZW50ICogcGxheWVyLnZpZGVvRWxlbWVudC5kdXJhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuTW92ZShtb3VzZVgsIDApO1xuICAgICAgICAgICAgdGhpcy5TZXRDb250ZW50KEdldEZvcm1hdHRlZFRpbWUodGltZUF0Q3Vyc29yKSk7XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy4kcGFyZW50Lm1vdXNlb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuSGlkZSgpO1xuICAgICAgICB9KTtcblxuICAgIH1cblxuICAgIE1vdmUoeCwgeSkge1xuXG4gICAgICAgIC8vIEdldCBpbml0aWFsIHBvc2l0aW9uc1xuICAgICAgICBsZXQgbGVmdCA9IHggLSAodGhpcy5HZXRXaWR0aCgpIC8gMik7XG4gICAgICAgIGxldCB0b3AgPSB5IC0gKHRoaXMuR2V0SGVpZ2h0KCkpICsgdGhpcy5ob3Zlck9mZnNldDtcbiAgICAgICAgXG4gICAgICAgIC8vIE9mZnNldCBpZiBuZWNlc3NhcnkgKGtlZXAgb24tc2NyZWVuKVxuICAgICAgICBpZiAobGVmdCAtIHRoaXMucGFkZGluZyA8IDApIHtcbiAgICAgICAgICAgIGxlZnQgPSB0aGlzLnBhZGRpbmc7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICggKGxlZnQgKyB0aGlzLnBhZGRpbmcgKyB0aGlzLkdldFdpZHRoKCkpID4gdGhpcy4kcGFyZW50LndpZHRoKCkgKSB7XG4gICAgICAgICAgICBsZWZ0ID0gdGhpcy4kcGFyZW50LndpZHRoKCkgLSB0aGlzLkdldFdpZHRoKCkgLSB0aGlzLnBhZGRpbmc7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEFwcGx5IHBvc2l0aW9uc1xuICAgICAgICB0aGlzLiR0b29sdGlwLmNzcyh7XG4gICAgICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgICAgIGxlZnQ6IGxlZnRcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgR2V0V2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiR0b29sdGlwLndpZHRoKCk7XG4gICAgfVxuXG4gICAgR2V0SGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kdG9vbHRpcC5oZWlnaHQoKTtcbiAgICB9XG5cbiAgICBTaG93KCkge1xuICAgICAgICB0aGlzLiR0b29sdGlwLm1ha2VWaXNpYmxlKHRydWUpO1xuICAgIH1cblxuICAgIEhpZGUoKSB7XG4gICAgICAgIHRoaXMuJHRvb2x0aXAubWFrZVZpc2libGUoZmFsc2UpO1xuICAgIH1cblxuICAgIFNldENvbnRlbnQodGV4dCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKHRleHQpO1xuICAgICAgICB0aGlzLiRjb250ZW50LnRleHQodGV4dCk7XG4gICAgfVxuXG5cblxufVxuXG5leHBvcnQgeyBTZWVrYmFyVG9vbHRpcCB9OyIsImltcG9ydCB7IEdldEZvcm1hdHRlZFRpbWUgfSBmcm9tIFwiLi4vdXRpbHMvdGltZS5qc1wiO1xuaW1wb3J0IHsgU2Vla2JhclRvb2x0aXAgfSBmcm9tIFwiLi9zZWVrYmFyLXRvb2x0aXAuanNcIjtcblxuY2xhc3MgVmlkZW9QbGF5ZXJCYXIge1xuXG4gICAgY29uc3RydWN0b3IocGxheWVyKXtcbiAgICAgICAgdGhpcy5wbGF5ZXIgPSBwbGF5ZXI7IFxuICAgICAgICB0aGlzLiRjb250YWluZXIgPSAkKFwiPGRpdiBjbGFzcz0nd2FsZG9yZi1wbGF5ZXItdG9vbGJhciBmbGV4LXRvb2xiYXInPjwvZGl2PlwiKS5hcHBlbmRUbyhwbGF5ZXIuJGNvbnRhaW5lcik7XG5cbiAgICAgICAgdGhpcy5Qb3B1bGF0ZUVsZW1lbnRzKCk7XG5cbiAgICAgICAgdGhpcy5zY3J1YmJpbmdUaW1lU2xpZGVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmlkZW9QbGF5aW5nQmVmb3JlVGltZVNjcnViID0gZmFsc2U7XG5cbiAgICAgICAgLy8gSG9vayB1cCB0byBldmVudHMgZnJvbSB2aWRlbyBwbGF5ZXJcbiAgICAgICAgdGhpcy5wbGF5ZXIuJGNvbnRhaW5lci5vbihcIk9uVmlzaWJpbGl0eUNoYW5nZVwiLCBcbiAgICAgICAgICAgIChldmVudCwgaXNWaXNpYmxlLCBkdXJhdGlvbikgPT4gdGhpcy5TZXRWaXNpYmxlKGlzVmlzaWJsZSwgZHVyYXRpb24pXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5wbGF5ZXIuJGNvbnRhaW5lci5vbihcIk9uUGxheVN0YXRlQ2hhbmdlXCIsIFxuICAgICAgICAgICAgKGV2ZW50LCBwbGF5aW5nKSA9PiB0aGlzLk9uUGxheVN0YXRlQ2hhbmdlKHBsYXlpbmcpXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5wbGF5ZXIuJGNvbnRhaW5lci5vbihcIk9uVGltZVVwZGF0ZVwiLCBcbiAgICAgICAgICAgIChldmVudCwgdGltZSkgPT4gdGhpcy5PblRpbWVVcGRhdGUodGltZSlcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLnBsYXllci4kY29udGFpbmVyLm9uKFwiT25NdXRlU3RhdGVDaGFuZ2VcIiwgXG4gICAgICAgICAgICAoZXZlbnQsIG11dGVkKSA9PiB0aGlzLk9uTXV0ZVN0YXRlQ2hhbmdlKG11dGVkKVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMucGxheWVyLiRjb250YWluZXIub24oXCJPblZvbHVtZUNoYW5nZVwiLCBcbiAgICAgICAgICAgIChldmVudCwgdm9sdW1lKSA9PiB0aGlzLk9uVm9sdW1lQ2hhbmdlKHZvbHVtZSlcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgfVxuXG4gICAgUG9wdWxhdGVFbGVtZW50cygpe1xuXG4gICAgICAgIHRoaXMuJHNlZWtCYXIgPSAkKFwiPGRpdiBpZD0nc2Vlay1iYXInPjxkaXYgaWQ9J3NlZWstaGFuZGxlJyBjbGFzcz0ndWktc2xpZGVyLWhhbmRsZSc+PC9kaXY+PC9kaXY+XCIpO1xuICAgICAgICBsZXQgJHNlZWtTbGlkZXIgPSB0aGlzLiRzZWVrQmFyLnNsaWRlcih7XG4gICAgICAgICAgICBtaW46IDAuMCxcbiAgICAgICAgICAgIG1heDogMS4wLFxuICAgICAgICAgICAgc3RlcDogMC4wMDFcbiAgICAgICAgfSk7XG4gICAgICAgICRzZWVrU2xpZGVyLm9uKFwic2xpZGVcIiwgKCkgPT4gdGhpcy5VcGRhdGVWaWRlb1RpbWUoKSk7XG4gICAgICAgICRzZWVrU2xpZGVyLm9uKFwic2xpZGVzdGFydFwiLCAoKSA9PiB0aGlzLlRpbWVEcmFnU3RhcnRlZCgpKTtcbiAgICAgICAgJHNlZWtTbGlkZXIub24oXCJzbGlkZXN0b3BcIiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5UaW1lRHJhZ0ZpbmlzaGVkKCk7XG4gICAgICAgICAgICB0aGlzLlVwZGF0ZVZpZGVvVGltZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4kY29udGFpbmVyLmFwcGVuZCh0aGlzLiRzZWVrQmFyKTtcbiAgICAgICAgdGhpcy5zZWVrYmFyVG9vbHRpcCA9IG5ldyBTZWVrYmFyVG9vbHRpcCh0aGlzLiRzZWVrQmFyLCB0aGlzLnBsYXllcik7XG5cbiAgICAgICAgdGhpcy4kc2Vla1Byb2dyZXNzID0gJChcIjxkaXYgaWQ9J3NlZWstZmlsbCc+PC9kaXY+XCIpO1xuICAgICAgICB0aGlzLiRjb250YWluZXIuYXBwZW5kKHRoaXMuJHNlZWtQcm9ncmVzcyk7XG5cbiAgICAgICAgLy9KdW1wIEJhY2sgYnV0dG9uXG4gICAgICAgIHRoaXMuJGp1bXBCYWNrQnV0dG9uID0gJChcIjxidXR0b24+SnVtcCBCYWNrPC9idXR0b24+XCIpLmJ1dHRvbih7XG4gICAgICAgICAgICBpY29uOiBcImZhIGZhLWZhc3QtYmFja3dhcmRcIixcbiAgICAgICAgICAgIHNob3dMYWJlbDogZmFsc2VcbiAgICAgICAgfSkuY2xpY2soKCkgPT4gdGhpcy5wbGF5ZXIuSnVtcEJhY2t3YXJkKCkpO1xuICAgICAgICB0aGlzLlJlZ2lzdGVyRWxlbWVudCh0aGlzLiRqdW1wQmFja0J1dHRvbiwgLTgpOyAgIFxuICAgICAgICBcbiAgICAgICAgLy9OdWRnZSBCYWNrIGJ1dHRvblxuICAgICAgICB0aGlzLiRudWRnZUJhY2tCdXR0b24gPSAkKFwiPGJ1dHRvbj5OdWRnZSBCYWNrPC9idXR0b24+XCIpLmJ1dHRvbih7XG4gICAgICAgICAgICBpY29uOiBcImZhIGZhLXN0ZXAtYmFja3dhcmRcIixcbiAgICAgICAgICAgIHNob3dMYWJlbDogZmFsc2VcbiAgICAgICAgfSkuY2xpY2soKCkgPT4gdGhpcy5wbGF5ZXIuU3RlcEJhY2t3YXJkKCkpO1xuICAgICAgICB0aGlzLlJlZ2lzdGVyRWxlbWVudCh0aGlzLiRudWRnZUJhY2tCdXR0b24sIC03KTtcblxuICAgICAgICAvLyBQbGF5IGJ1dHRvblxuICAgICAgICB0aGlzLiRwbGF5QnV0dG9uID0gJChcIjxidXR0b24+UGxheTwvYnV0dG9uPlwiKS5idXR0b24oe1xuICAgICAgICAgICAgaWNvbjogXCJmYSBmYS1wbGF5XCIsXG4gICAgICAgICAgICBzaG93TGFiZWw6IGZhbHNlXG4gICAgICAgIH0pLmNsaWNrKCgpID0+IHRoaXMucGxheWVyLlRvZ2dsZVBsYXlTdGF0ZSgpKTtcbiAgICAgICAgdGhpcy5SZWdpc3RlckVsZW1lbnQodGhpcy4kcGxheUJ1dHRvbiwgLTYpO1xuXG4gICAgICAgIC8vTnVkZ2UgYnV0dG9uXG4gICAgICAgIHRoaXMuJG51ZGdlQnV0dG9uID0gJChcIjxidXR0b24+TnVkZ2U8L2J1dHRvbj5cIikuYnV0dG9uKHtcbiAgICAgICAgICAgIGljb246IFwiZmEgZmEtc3RlcC1mb3J3YXJkXCIsXG4gICAgICAgICAgICBzaG93TGFiZWw6IGZhbHNlXG4gICAgICAgIH0pLmNsaWNrKCgpID0+IHRoaXMucGxheWVyLlN0ZXBGb3J3YXJkKCkpO1xuICAgICAgICB0aGlzLlJlZ2lzdGVyRWxlbWVudCh0aGlzLiRudWRnZUJ1dHRvbiwgLTUpOyAgIFxuICAgICAgICBcbiAgICAgICAgLy9KdW1wIGJ1dHRvblxuICAgICAgICB0aGlzLiRqdW1wQnV0dG9uID0gJChcIjxidXR0b24+TnVkZ2U8L2J1dHRvbj5cIikuYnV0dG9uKHtcbiAgICAgICAgICAgIGljb246IFwiZmEgZmEtZmFzdC1mb3J3YXJkXCIsXG4gICAgICAgICAgICBzaG93TGFiZWw6IGZhbHNlXG4gICAgICAgIH0pLmNsaWNrKCgpID0+IHRoaXMucGxheWVyLkp1bXBGb3J3YXJkKCkpO1xuICAgICAgICB0aGlzLlJlZ2lzdGVyRWxlbWVudCh0aGlzLiRqdW1wQnV0dG9uLCAtNCk7ICAgICAgICAgIFxuXG4gICAgICAgIC8vIFRpbWUgdGV4dFxuICAgICAgICBsZXQgemVybyA9IEdldEZvcm1hdHRlZFRpbWUoMC4wMDApO1xuICAgICAgICB0aGlzLiR0aW1lVGV4dCA9ICQoXCI8cD4ke3plcm99LyR7emVyb308L3A+XCIpO1xuICAgICAgICB0aGlzLlJlZ2lzdGVyRWxlbWVudCh0aGlzLiR0aW1lVGV4dCwgLTMpO1xuXG4gICAgICAgIC8vIE11dGUgYnV0dG9uXG4gICAgICAgIHRoaXMuJG11dGVCdXR0b24gPSAkKFwiPGJ1dHRvbj5NdXRlPC9idXR0b24+XCIpLmJ1dHRvbih7XG4gICAgICAgICAgICBpY29uOiBcImZhIGZhLXZvbHVtZS11cFwiLFxuICAgICAgICAgICAgc2hvd0xhYmVsOiBmYWxzZSxcbiAgICAgICAgfSkuY2xpY2soKCkgPT4gdGhpcy5wbGF5ZXIuVG9nZ2xlTXV0ZVN0YXRlKCkpO1xuICAgICAgICB0aGlzLlJlZ2lzdGVyRWxlbWVudCh0aGlzLiRtdXRlQnV0dG9uLCAtMik7XG5cbiAgICAgICAgLy8gVm9sdW1lIGJhclxuICAgICAgICB0aGlzLiR2b2x1bWVCYXIgPSAkKFwiPGRpdiBpZD0ndm9sdW1lLWJhcic+PGRpdiBpZD0ndm9sdW1lLWhhbmRsZScgY2xhc3M9J3VpLXNsaWRlci1oYW5kbGUnPjwvZGl2PjwvZGl2PlwiKTtcbiAgICAgICAgdGhpcy4kdm9sdW1lQmFyLnNsaWRlcih7XG4gICAgICAgICAgICByYW5nZTogXCJtaW5cIixcbiAgICAgICAgICAgIG1heDogMS4wLFxuICAgICAgICAgICAgdmFsdWU6IDEuMCxcbiAgICAgICAgICAgIHN0ZXA6IDAuMDVcbiAgICAgICAgfSkub24oXCJzbGlkZVwiLCAoZXZlbnQsIHVpKSA9PiB0aGlzLnBsYXllci5TZXRWb2x1bWUodWkudmFsdWUpKTtcbiAgICAgICAgdGhpcy5SZWdpc3RlckVsZW1lbnQodGhpcy4kdm9sdW1lQmFyLCAtMSk7XG5cbiAgICAgICAgLy8gRnVsbHNjcmVlbiBidXR0b25cbiAgICAgICAgdGhpcy4kZnVsbFNjcmVlbkJ1dHRvbiA9ICQoXCI8YnV0dG9uPkZ1bGxzY3JlZW48L2J1dHRvbj5cIikuYnV0dG9uKHtcbiAgICAgICAgICAgIGljb246IFwiZmEgZmEtYXJyb3dzLWFsdFwiLFxuICAgICAgICAgICAgc2hvd0xhYmVsOiBmYWxzZVxuICAgICAgICB9KS5jbGljaygoKSA9PiB0aGlzLnBsYXllci5Ub2dnbGVGdWxsc2NyZWVuKCkpO1xuICAgICAgICB0aGlzLlJlZ2lzdGVyRWxlbWVudCh0aGlzLiRmdWxsU2NyZWVuQnV0dG9uLCA5OTksICdmbGV4LWVuZCcpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGVtcHR5IGVsZW1lbnQgYmV0d2VlbiBsZWZ0IGZsb2F0aW5nIGFuZCByaWdodCBmbG9hdGluZyB0b29sYmFyIGl0ZW1zIHRvIHNwYWNlIHRoZW0gb3V0IHByb3Blcmx5XG4gICAgICAgIHRoaXMuJGNvbnRhaW5lci5hcHBlbmQoJChcIjxkaXY+PC9kaXY+XCIpLmNzcyhcImZsZXgtZ3Jvd1wiLCAxKS5jc3MoXCJvcmRlclwiLCAwKSk7XG5cbiAgICAgICAgLy9Jbml0aWFsaXplIGNvbnRyb2xzXG4gICAgICAgIHRoaXMuT25UaW1lVXBkYXRlKCk7XG4gICAgICAgIHRoaXMuJHZvbHVtZUJhci5zbGlkZXIoXCJ2YWx1ZVwiLCB0aGlzLnBsYXllci52aWRlb0VsZW1lbnQudm9sdW1lKTtcbiAgICB9XG5cbiAgICBSZWdpc3RlckVsZW1lbnQoJGVsZW1lbnQsIG9yZGVyLCBqdXN0aWZpY2F0aW9uID0gJ2ZsZXgtc3RhcnQnKXtcbiAgICAgICAgJGVsZW1lbnQuY3NzKCdvcmRlcicsIG9yZGVyKTtcbiAgICAgICAgJGVsZW1lbnQuY3NzKCdhbGlnbi1zZWxmJywganVzdGlmaWNhdGlvbik7XG4gICAgICAgIC8vIFNldHMgZ3JvdyBbc2hyaW5rXSBbYmFzaXNdXG4gICAgICAgIC8vJGVsZW1lbnQuY3NzKCdmbGV4JywgJzAgMCBhdXRvJyk7XG4gICAgICAgIHRoaXMuJGNvbnRhaW5lci5hcHBlbmQoJGVsZW1lbnQpO1xuICAgIH1cblxuICAgIFNldFZpc2libGUoaXNWaXNpYmxlLCBkdXJhdGlvbil7XG4gICAgICAgIC8vY29uc29sZS5sb2coaXNWaXNpYmxlICsgXCIgXCIgKyBkdXJhdGlvbik7XG4gICAgICAgIHRoaXMuJGNvbnRhaW5lci5zdG9wKHRydWUsIHRydWUpO1xuICAgICAgICBpZihpc1Zpc2libGUpe1xuICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyLmZhZGVUbyhkdXJhdGlvbiwgMS4wLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyLm1ha2VWaXNpYmxlKHRydWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiRjb250YWluZXIuZmFkZVRvKGR1cmF0aW9uLCAwLjAsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiRjb250YWluZXIubWFrZVZpc2libGUoZmFsc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBVcGRhdGVWaWRlb1RpbWUoKXtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBuZXcgdGltZVxuICAgICAgICBsZXQgdGltZSA9IHRoaXMucGxheWVyLnZpZGVvRWxlbWVudC5kdXJhdGlvbiAqIHRoaXMuJHNlZWtCYXIuc2xpZGVyKFwidmFsdWVcIik7XG4gICAgICAgIHRoaXMucGxheWVyLmVuZFRpbWUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wbGF5ZXIudmlkZW9FbGVtZW50LmN1cnJlbnRUaW1lID0gdGltZTtcbiAgICB9XG5cbiAgICBUaW1lRHJhZ1N0YXJ0ZWQoKXtcbiAgICAgICAgdGhpcy52aWRlb1BsYXlpbmdCZWZvcmVUaW1lU2NydWIgPSAhdGhpcy5wbGF5ZXIudmlkZW9FbGVtZW50LnBhdXNlZDtcbiAgICAgICAgdGhpcy5wbGF5ZXIudmlkZW9FbGVtZW50LnBhdXNlKCk7XG4gICAgfVxuXG4gICAgVGltZURyYWdGaW5pc2hlZCgpe1xuICAgICAgICAvLyBTdGFydCBwbGF5aW5nIHRoZSB2aWRlbyBhZ2FpbiBpZiBpdCB3YXMgcGxheWluZyBiZWZvcmUgdGhlIHNjcnViIHN0YXJ0ZWRcbiAgICAgICAgaWYgKHRoaXMudmlkZW9QbGF5aW5nQmVmb3JlVGltZVNjcnViKXtcbiAgICAgICAgICAgIHRoaXMucGxheWVyLnZpZGVvRWxlbWVudC5wbGF5KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLy9cbiAgICAvLy8gLS0tLS0gRXZlbnQgTGlzdGVuZXJzIC0tLS0tXG4gICAgLy8vIFRoZSBmb2xsb3dpbmcgdXBkYXRlIHRoZSB2aXN1YWwgc3RhdGUgb2YgdGhlIGJhclxuICAgIC8vLyB1cG9uIGNoYW5nZXMgdG8gdGhlIHZpZGVvIHBsYXllci4gVGhlc2UgYXJlIGhvb2tlZFxuICAgIC8vLyB1cCBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgLy8vXG5cbiAgICBPblBsYXlTdGF0ZUNoYW5nZShwbGF5aW5nKXtcbiAgICAgICAgdGhpcy4kcGxheUJ1dHRvbi5idXR0b24oXCJvcHRpb25cIiwge1xuICAgICAgICAgICAgaWNvbjogcGxheWluZyA/IFwiZmEgZmEtcGF1c2VcIiA6IFwiZmEgZmEtcGxheVwiXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIE9uVGltZVVwZGF0ZSh0aW1lKXtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcInZpZGVvLXBsYXllci1iYXIuanM6MTg1IE9uVGltZVVwZGF0ZSBpcyBjYWxsZWRcIik7XG4gICAgICAgIGxldCBkdXJhdGlvbiA9IHRoaXMucGxheWVyLnZpZGVvRWxlbWVudC5kdXJhdGlvbjtcblxuICAgICAgICAvLyBVcGRhdGUgdGhlIHRpbWUgdGV4dFxuICAgICAgICB0aGlzLiR0aW1lVGV4dC50ZXh0KEdldEZvcm1hdHRlZFRpbWUodGltZSkgKyBcIi9cIiArIEdldEZvcm1hdHRlZFRpbWUoZHVyYXRpb24pKTtcblxuICAgICAgICBsZXQgcHJvZ3Jlc3MgPSB0aW1lIC8gZHVyYXRpb247XG4gICAgICAgIHRoaXMuJHNlZWtQcm9ncmVzcy53aWR0aCgocHJvZ3Jlc3MgKiAxMDApLnRvU3RyaW5nKCkgKyBcIiVcIik7XG4gICAgfVxuXG4gICAgT25Wb2x1bWVDaGFuZ2Uodm9sdW1lKXtcbiAgICAgICAgdGhpcy4kdm9sdW1lQmFyLnNsaWRlcihcInZhbHVlXCIsIHZvbHVtZSk7XG4gICAgfVxuXG4gICAgT25NdXRlU3RhdGVDaGFuZ2UobXV0ZWQpe1xuICAgICAgICB0aGlzLiRtdXRlQnV0dG9uLmJ1dHRvbihcIm9wdGlvblwiLCB7XG4gICAgICAgICAgICBpY29uOiBtdXRlZCA/IFwiZmEgZmEtdm9sdW1lLXVwXCIgOiBcImZhIGZhLXZvbHVtZS1vZmZcIlxuICAgICAgICB9KTtcbiAgICB9XG5cbn1cblxuZXhwb3J0IHsgVmlkZW9QbGF5ZXJCYXIgfSIsImltcG9ydCB7IFZpZGVvUGxheWVyQmFyIH0gZnJvbSBcIi4vdmlkZW8tcGxheWVyLWJhci5qc1wiO1xuaW1wb3J0IHsgVmlkZW9Bbm5vdGF0b3IgfSBmcm9tIFwiLi4vYW5ub3RhdG9yL2Fubm90YXRvci5qc1wiO1xuLy9pbXBvcnQgKiBhcyBzY3JlZW5mdWxsIGZyb20gXCJzY3JlZW5mdWxsXCI7XG5cbi8vaW1wb3J0ICdqcXVlcnktdWkvZGlzdC9qcXVlcnktdWkuanMnO1xubGV0IHNjcmVlbmZ1bGwgPSByZXF1aXJlKCdzY3JlZW5mdWxsJyk7XG5cbmNsYXNzIEFubm90YXRvclZpZGVvUGxheWVyIHtcbiAgICBjb25zdHJ1Y3RvcigkdmlkZW8sIGFubm90YXRvckFyZ3Mpe1xuICAgICAgICBjb25zb2xlLmxvZyhcIltBbm5vdGF0b3JWaWRlb1BsYXllcl0gQ3JlYXRpbmcgQW5ub3RhdG9yVmlkZW9QbGF5ZXIgZm9yIHZpZGVvLi4uXCIpO1xuICAgICAgICB0aGlzLiR2aWRlbyA9ICR2aWRlbztcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnQgPSB0aGlzLiR2aWRlby5nZXQoMCk7XG5cbiAgICAgICAgLy8gU3RvcmUgdGhlIG9yaWdpbmFsIHN0eWxpbmcgb2YgdGhlIHZpZGVvIGVsZW1lbnQgYmVmb3JlIHdlIGFsdGVyIGl0XG4gICAgICAgIHRoaXMub3JpZ2luYWxTdHlsZXMgPSB0aGlzLiR2aWRlby5nZXRTdHlsZXMobnVsbCwgW1wiaGVpZ2h0XCIsIFwiV2Via2l0VGV4dEZpbGxDb2xvclwiLCBcImNvbG9yXCJdKTsgLy9bXCJ3aWR0aFwiLCBcInRvcFwiLCBcImxlZnRcIiwgXCJtYXJnaW5cIiwgXCJwYWRkaW5nXCJdXG5cbiAgICAgICAgdGhpcy5XcmFwKCk7XG4gICAgICAgIHRoaXMuUG9wdWxhdGVDb250cm9scygpO1xuICAgICAgICB0aGlzLlNldFZpc2libGUodHJ1ZSk7XG5cbiAgICAgICAgLy8gSG9vayB1cCBldmVudHNcbiAgICAgICAgdGhpcy5Ib29rVXBFdmVudHMoKTtcblxuICAgICAgICAvLyBQbGF5IC8gcGF1c2UgdGhlIHZpZGVvIHdoZW4gY2xpY2tlZC5cbiAgICAgICAgdGhpcy4kdmlkZW8ub24oXCJjbGlja1wiLCAoKSA9PiB0aGlzLlRvZ2dsZVBsYXlTdGF0ZSgpKTtcblxuICAgICAgICB0aGlzLmFsbG93QXV0b0ZhZGUgPSB0cnVlO1xuICAgICAgICAvLy8gSW5hY3Rpdml0eSB0aW1lciBmb3IgdGhlIG1vdXNlLlxuICAgICAgICB0aGlzLm1vdXNlVGltZXIgPSBudWxsO1xuICAgICAgICAvLy8gU2V0IHRvIHRydWUgaWYgdGhlIHRpbWUgc2xpZGVyIGlzIGN1cnJlbnRseSBiZWluZyBkcmFnZ2VkIGJ5IHRoZSB1c2VyLlxuICAgICAgICB0aGlzLmRyYWdnaW5nVGltZVNsaWRlciA9IGZhbHNlO1xuICAgICAgICAvLy8gU2Vjb25kcyBiZWZvcmUgdGhlIFVJIGZhZGVzIGR1ZSB0byBtb3VzZSBpbmFjdGl2aXR5LlxuICAgICAgICB0aGlzLmlkbGVTZWNvbmRzQmVmb3JlRmFkZSA9IDM7XG4gICAgICAgIHRoaXMuZmFkZUR1cmF0aW9uID0gMzAwO1xuICAgICAgICB0aGlzLmVuZFRpbWUgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLiRjb250YWluZXIubW91c2Vtb3ZlKCgpID0+IHRoaXMuT25Nb3VzZU1vdmUoKSk7XG4gICAgICAgIHRoaXMuU2V0QXV0b0ZhZGUodHJ1ZSk7XG5cbiAgICAgICAgLy8gSWYgc2NyZWVuZnVsbCBpcyBlbmFibGVkLCBjcmVhdGUgdGhlIGV2ZW50IHRvIGhhbmRsZSBpdC5cbiAgICAgICAgaWYoc2NyZWVuZnVsbCAhPT0gJ3VuZGVmaW5lZCcpe1xuICAgICAgICAgICAgc2NyZWVuZnVsbC5vbmNoYW5nZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5PbkZ1bGxzY3JlZW5DaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRjb250YWluZXIudHJpZ2dlcihcIk9uRnVsbHNjcmVlbkNoYW5nZVwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnQub250aW1ldXBkYXRlID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5PblRpbWVVcGRhdGUodGhpcy52aWRlb0VsZW1lbnQuY3VycmVudFRpbWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuJGNvbnRhaW5lci5vbihcIk9uVmlkZW9SZWFkeVwiLCAoKSA9PiB7XG4gICAgICAgICAgICBpZihhbm5vdGF0b3JBcmdzLmFubm90YXRvcj09bnVsbCl7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJbQW5ub3RhdG9yVmlkZW9QbGF5ZXJdIFBsYXllciBzZW50IE9uVmlkZW9SZWFkeSwgYXR0ZW1wdGluZyB0byB3cmFwIHdpdGggYW5ub3RhdG9yLi4uXCIpO1xuICAgICAgICAgICAgICAgIC8vIEFkZCBhbm5vdGF0b3Igb25jZSB2aWRlbyBoYXMgbG9hZGVkXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJbQW5ub3RhdG9yVmlkZW9QbGF5ZXJdIFdyYXBwaW5nIHZpZGVvIHdpdGggYW5ub3RhdG9yLi4uXCIpO1xuICAgICAgICAgICAgICAgIGFubm90YXRvckFyZ3MucGxheWVyID0gdGhpcztcbiAgICAgICAgICAgICAgICBhbm5vdGF0b3JBcmdzLmFubm90YXRvciA9IG5ldyBWaWRlb0Fubm90YXRvcihhbm5vdGF0b3JBcmdzKTtcbiAgICAgICAgICAgICAgICBpZih0eXBlb2YgYW5ub3RhdG9yQXJncy5jYWxsYmFjayA9PSBcImZ1bmN0aW9uXCIpIGFubm90YXRvckFyZ3MuY2FsbGJhY2soYW5ub3RhdG9yQXJncy5hbm5vdGF0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudC5vbmxvYWRlZG1ldGFkYXRhID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyLnRyaWdnZXIoXCJPblZpZGVvUmVhZHlcIik7XG4gICAgICAgIH07XG4gICAgICAgIGlmKHRoaXMudmlkZW9FbGVtZW50LmR1cmF0aW9uICE9IG51bGwpe1xuICAgICAgICAgICAgLy8gSWYgdGhlIG1ldGFkYXRhIGlzIGFscmVhZHkgcHJlcGFyZWQsIHRocm93IHRoZSBldmVudCBzaW5jZVxuICAgICAgICAgICAgLy8gb25sb2FkZWRtZXRhZGF0YSB3b24ndCBiZSBmaXJlZFxuICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyLnRyaWdnZXIoXCJPblZpZGVvUmVhZHlcIik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKFwiW0Fubm90YXRvclZpZGVvUGxheWVyXSBBbm5vdGF0b3JWaWRlb1BsYXllciBjcmVhdGVkIGZvciB2aWRlby5cIik7XG4gICAgICAgIFxuICAgIH1cblxuICAgIFdyYXAoKXtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBkZWZhdWx0IGNvbnRyb2xzIGZyb20gdGhlIHZpZGVvXG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImNvbnRyb2xzXCIpO1xuXG4gICAgICAgIC8vIFdyYXAgdGhlIHZpZGVvIGVsZW1lbnQgd2l0aCB0aGUgY29udGFpbmVyXG4gICAgICAgIHRoaXMuJGNvbnRhaW5lciA9IHRoaXMuJHZpZGVvLndyYXAoXCI8ZGl2IGNsYXNzPSd3YWxkb3JmLXZpZGVvLXBsYXllcic+PC9kaXY+XCIpLnBhcmVudCgpO1xuICAgICAgICAvLyBSZXNpemUgY29udGFpbmVyIHRvIGZpdCB0aGUgZGltZW5zaW9ucyBvZiB0aGUgdmlkZW9cbiAgICAgICAgdGhpcy4kY29udGFpbmVyLndpZHRoKHRoaXMuJHZpZGVvLndpZHRoKCkpO1xuICAgICAgICB0aGlzLiRjb250YWluZXIuaGVpZ2h0KHRoaXMuJHZpZGVvLmhlaWdodCgpKTtcbiAgICB9XG5cbiAgICBQb3B1bGF0ZUNvbnRyb2xzKCl7XG4gICAgICAgIHRoaXMuY29udHJvbEJhciA9IG5ldyBWaWRlb1BsYXllckJhcih0aGlzKTtcbiAgICB9XG5cbiAgICBTZXRWaXNpYmxlKGlzVmlzaWJsZSwgZHVyYXRpb24gPSAwKXtcbiAgICAgICAgdGhpcy4kY29udGFpbmVyLnRyaWdnZXIoXCJPblZpc2liaWxpdHlDaGFuZ2VcIiwgW2lzVmlzaWJsZSwgZHVyYXRpb25dKTtcbiAgICB9XG5cbiAgICBIb29rVXBFdmVudHMoKXtcbiAgICAgICAgXG4gICAgfVxuXG4gICAgVG9nZ2xlUGxheVN0YXRlKCl7XG4gICAgICAgIGlmKHRoaXMudmlkZW9FbGVtZW50LnBhdXNlZCl7XG4gICAgICAgICAgICB0aGlzLlBsYXkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuUGF1c2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIFN0ZXBGb3J3YXJkKCl7XG4gICAgICAgIHZhciBuZXdUaW1lID0gdGhpcy52aWRlb0VsZW1lbnQuY3VycmVudFRpbWUgKyAwLjE7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50LmN1cnJlbnRUaW1lID0gbmV3VGltZSA+IHRoaXMudmlkZW9FbGVtZW50LmR1cmF0aW9uID8gdGhpcy52aWRlb0VsZW1lbnQuZHVyYXRpb24gOiBuZXdUaW1lO1xuICAgIH1cblxuICAgIEp1bXBGb3J3YXJkKCl7XG4gICAgICAgIHZhciBuZXdUaW1lID0gdGhpcy52aWRlb0VsZW1lbnQuY3VycmVudFRpbWUgKyAxO1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudC5jdXJyZW50VGltZSA9IG5ld1RpbWUgPiB0aGlzLnZpZGVvRWxlbWVudC5kdXJhdGlvbiA/IHRoaXMudmlkZW9FbGVtZW50LmR1cmF0aW9uIDogbmV3VGltZTtcbiAgICB9ICBcbiAgICBcbiAgICBTdGVwQmFja3dhcmQoKXtcbiAgICAgICAgdmFyIG5ld1RpbWUgPSB0aGlzLnZpZGVvRWxlbWVudC5jdXJyZW50VGltZSAtIDAuMTtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnQuY3VycmVudFRpbWUgPSBuZXdUaW1lIDwgMCA/IDAgOiBuZXdUaW1lO1xuICAgIH1cblxuICAgIEp1bXBCYWNrd2FyZCgpe1xuICAgICAgICB2YXIgbmV3VGltZSA9IHRoaXMudmlkZW9FbGVtZW50LmN1cnJlbnRUaW1lIC0gMTtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnQuY3VycmVudFRpbWUgPSBuZXdUaW1lIDwgMCA/IDAgOiBuZXdUaW1lO1xuICAgIH0gICAgIFxuXG4gICAgUGxheSgpe1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudC5wbGF5KCk7XG4gICAgICAgIGlmKHRoaXMuZW5kVGltZSkgdGhpcy5lbmRUaW1lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuU2V0QXV0b0ZhZGUodHJ1ZSk7XG4gICAgICAgIHRoaXMuJGNvbnRhaW5lci50cmlnZ2VyKFwiT25QbGF5U3RhdGVDaGFuZ2VcIiwgIXRoaXMudmlkZW9FbGVtZW50LnBhdXNlZCk7XG4gICAgfVxuXG4gICAgUGF1c2UoKXtcbiAgICAgICAgaWYodGhpcy5lbmRUaW1lKSB0aGlzLmVuZFRpbWUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnQucGF1c2UoKTtcbiAgICAgICAgdGhpcy5TZXRBdXRvRmFkZShmYWxzZSk7XG4gICAgICAgIHRoaXMuJGNvbnRhaW5lci50cmlnZ2VyKFwiT25QbGF5U3RhdGVDaGFuZ2VcIiwgIXRoaXMudmlkZW9FbGVtZW50LnBhdXNlZCk7XG4gICAgfVxuXG4gICAgVG9nZ2xlTXV0ZVN0YXRlKCl7XG4gICAgICAgIGxldCBtdXRlZCA9IHRoaXMudmlkZW9FbGVtZW50Lm11dGVkO1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudC5tdXRlZCA9ICFtdXRlZDtcbiAgICAgICAgdGhpcy4kY29udGFpbmVyLnRyaWdnZXIoXCJPbk11dGVTdGF0ZUNoYW5nZVwiLCBtdXRlZCk7XG4gICAgfVxuXG4gICAgU2V0Vm9sdW1lKHZvbHVtZSl7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50LnZvbHVtZSA9IHZvbHVtZTtcbiAgICAgICAgdGhpcy4kY29udGFpbmVyLnRyaWdnZXIoXCJPblZvbHVtZUNoYW5nZVwiLCB2b2x1bWUpO1xuICAgIH1cblxuICAgIFRvZ2dsZUZ1bGxzY3JlZW4oKXtcbiAgICAgICAgaWYgKHNjcmVlbmZ1bGwgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gICAgICAgIHNjcmVlbmZ1bGwudG9nZ2xlKHRoaXMuJGNvbnRhaW5lclswXSk7XG4gICAgfVxuXG4gICAgT25GdWxsc2NyZWVuQ2hhbmdlKCl7XG4gICAgICAgIGlmKHNjcmVlbmZ1bGwuaXNGdWxsc2NyZWVuKXtcbiAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci5hZGRDbGFzcyhcIndhbGRvcmYtZnVsbHNjcmVlblwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNle1xuICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyLnJlbW92ZUNsYXNzKFwid2FsZG9yZi1mdWxsc2NyZWVuXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgU2V0RnVsbHNjcmVlbihmdWxsc2NyZWVuKXtcbiAgICAgICAgaWYgKHNjcmVlbmZ1bGwgPT09ICd1bmRlZmluZWQnIHx8ICFzY3JlZW5mdWxsLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGZ1bGxzY3JlZW4pe1xuICAgICAgICAgICAgc2NyZWVuZnVsbC5yZXF1ZXN0KHRoaXMuJGNvbnRhaW5lclswXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY3JlZW5mdWxsLmV4aXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBtb3VzZSBtb3ZlcyBpbiB0aGUgdmlkZW8gY29udGFpbmVyLlxuICAgICAqL1xuICAgIE9uTW91c2VNb3ZlKCl7XG4gICAgICAgIC8vIFJlc2V0IHRoZSB0aW1lclxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5tb3VzZVRpbWVyKTtcbiAgICAgICAgdGhpcy5tb3VzZVRpbWVyID0gMDtcblxuICAgICAgICAvLyBSZXN0YXJ0IGZhZGluZyBpZiBhbGxvd2VkIHRvXG4gICAgICAgIGlmKHRoaXMuYWxsb3dBdXRvRmFkZSl7XG4gICAgICAgICAgICAgdGhpcy5SZXN0YXJ0RmFkaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBPblRpbWVVcGRhdGUodGltZSl7XG4gICAgICAgIGlmKHRoaXMuZW5kVGltZSAmJiB0aGlzLmVuZFRpbWUgPD0gdGhpcy52aWRlb0VsZW1lbnQuY3VycmVudFRpbWUpe1xuICAgICAgICAgICAgdGhpcy5QYXVzZSgpOyAgIFxuICAgICAgICAgICAgdGhpcy5lbmRUaW1lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kY29udGFpbmVyLnRyaWdnZXIoXCJPblRpbWVVcGRhdGVcIiwgdGltZSk7XG4gICAgfVxuXG4gICAgUmVzdGFydEZhZGluZygpe1xuICAgICAgICAvLyBSZXN0b3JlIHZpc2liaWxpdHlcbiAgICAgICAgdGhpcy5TZXRWaXNpYmxlKHRydWUsIHRoaXMuZmFkZUR1cmF0aW9uKTtcblxuICAgICAgICAvLyBTdGFydCB0aGUgdGltZXIgb3ZlciBhZ2FpblxuICAgICAgICB0aGlzLm1vdXNlVGltZXIgPSBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICB0aGlzLlNldFZpc2libGUoZmFsc2UsIHRoaXMuZmFkZUR1cmF0aW9uKTtcbiAgICAgICAgfSwgdGhpcy5pZGxlU2Vjb25kc0JlZm9yZUZhZGUgKiAxMDAwKTtcbiAgICB9XG5cbiAgICBTZXRBdXRvRmFkZShhbGxvdykge1xuICAgICAgICB0aGlzLmFsbG93QXV0b0ZhZGUgPSBhbGxvdztcbiAgICAgICAgXG4gICAgICAgIC8vIFJlc2V0IHRoZSBtb3VzZSB0aW1lclxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5tb3VzZVRpbWVyKTtcbiAgICAgICAgdGhpcy5tb3VzZVRpbWVyID0gMDtcblxuICAgICAgICAvLyBNYWtlIGVsZW1lbnRzIHZpc2libGVcbiAgICAgICAgdGhpcy5TZXRWaXNpYmxlKHRydWUpO1xuXG4gICAgICAgIC8vIFJlc3RhcnQgdGhlIGZhZGluZyBiZWhhdmlvciBpZiBkZXNpcmVkXG4gICAgICAgIGlmKGFsbG93KXtcbiAgICAgICAgICAgIHRoaXMuUmVzdGFydEZhZGluZygpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgIH1cblxuICAgIC8vIElzUGxheWluZygpe1xuICAgIC8vICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zMTEzMzQwMVxuICAgIC8vICAgICByZXR1cm4gISEodGhpcy52aWRlb0VsZW1lbnQuY3VycmVudFRpbWUgPiAwICYmICF0aGlzLnZpZGVvRWxlbWVudC5wYXVzZWQgJiYgXG4gICAgLy8gICAgICAgICAgICAgICAhdGhpcy52aWRlb0VsZW1lbnQuZW5kZWQgJiYgdGhpcy52aWRlb0VsZW1lbnQucmVhZHlTdGF0ZSA+IDIpO1xuICAgIC8vIH1cblxuICAgIC8vIEZyb20gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vTmF0ZW93YW1pLzdhOTQ3ZTkzZjA5YzQ1YTEwOTdlNzgzZGMwMDU2MGUxXG4gICAgR2V0VmlkZW9EaW1lbnNpb25zKCkge1xuICAgICAgICBsZXQgdmlkZW8gPSB0aGlzLnZpZGVvRWxlbWVudDtcbiAgICAgICAgLy8gUmF0aW8gb2YgdGhlIHZpZGVvJ3MgaW50cmlzaWMgZGltZW5zaW9uc1xuICAgICAgICBsZXQgdmlkZW9SYXRpbyA9IHZpZGVvLnZpZGVvV2lkdGggLyB2aWRlby52aWRlb0hlaWdodDtcbiAgICAgICAgLy8gVGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIHZpZGVvIGVsZW1lbnRcbiAgICAgICAgbGV0IHdpZHRoID0gdmlkZW8ub2Zmc2V0V2lkdGg7XG4gICAgICAgIGxldCBoZWlnaHQgPSB2aWRlby5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIC8vIFRoZSByYXRpbyBvZiB0aGUgZWxlbWVudCdzIHdpZHRoIHRvIGl0cyBoZWlnaHRcbiAgICAgICAgbGV0IGVsZW1lbnRSYXRpbyA9IHdpZHRoIC8gaGVpZ2h0O1xuICAgICAgICAvLyBJZiB0aGUgdmlkZW8gZWxlbWVudCBpcyBzaG9ydCBhbmQgd2lkZVxuICAgICAgICBpZihlbGVtZW50UmF0aW8gPiB2aWRlb1JhdGlvKSB3aWR0aCA9IGhlaWdodCAqIHZpZGVvUmF0aW87XG4gICAgICAgIC8vIEl0IG11c3QgYmUgdGFsbCBhbmQgdGhpbiwgb3IgZXhhY3RseSBlcXVhbCB0byB0aGUgb3JpZ2luYWwgcmF0aW9cbiAgICAgICAgZWxzZSBoZWlnaHQgPSB3aWR0aCAvIHZpZGVvUmF0aW87XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgIH07XG4gICAgfVxuXG59XG5cbmV4cG9ydCB7IEFubm90YXRvclZpZGVvUGxheWVyIH07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmlzSWRlbnRpZmllclN0YXJ0ID0gaXNJZGVudGlmaWVyU3RhcnQ7XG5leHBvcnRzLmlzSWRlbnRpZmllckNoYXIgPSBpc0lkZW50aWZpZXJDaGFyO1xuZXhwb3J0cy5pc0lkZW50aWZpZXJOYW1lID0gaXNJZGVudGlmaWVyTmFtZTtcbmxldCBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzID0gXCJcXHhhYVxceGI1XFx4YmFcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDJjMVxcdTAyYzYtXFx1MDJkMVxcdTAyZTAtXFx1MDJlNFxcdTAyZWNcXHUwMmVlXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdhLVxcdTAzN2RcXHUwMzdmXFx1MDM4NlxcdTAzODgtXFx1MDM4YVxcdTAzOGNcXHUwMzhlLVxcdTAzYTFcXHUwM2EzLVxcdTAzZjVcXHUwM2Y3LVxcdTA0ODFcXHUwNDhhLVxcdTA1MmZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MC1cXHUwNTg4XFx1MDVkMC1cXHUwNWVhXFx1MDVlZi1cXHUwNWYyXFx1MDYyMC1cXHUwNjRhXFx1MDY2ZVxcdTA2NmZcXHUwNjcxLVxcdTA2ZDNcXHUwNmQ1XFx1MDZlNVxcdTA2ZTZcXHUwNmVlXFx1MDZlZlxcdTA2ZmEtXFx1MDZmY1xcdTA2ZmZcXHUwNzEwXFx1MDcxMi1cXHUwNzJmXFx1MDc0ZC1cXHUwN2E1XFx1MDdiMVxcdTA3Y2EtXFx1MDdlYVxcdTA3ZjRcXHUwN2Y1XFx1MDdmYVxcdTA4MDAtXFx1MDgxNVxcdTA4MWFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4NjAtXFx1MDg2YVxcdTA4YTAtXFx1MDhiNFxcdTA4YjYtXFx1MDhjN1xcdTA5MDQtXFx1MDkzOVxcdTA5M2RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTgwXFx1MDk4NS1cXHUwOThjXFx1MDk4ZlxcdTA5OTBcXHUwOTkzLVxcdTA5YThcXHUwOWFhLVxcdTA5YjBcXHUwOWIyXFx1MDliNi1cXHUwOWI5XFx1MDliZFxcdTA5Y2VcXHUwOWRjXFx1MDlkZFxcdTA5ZGYtXFx1MDllMVxcdTA5ZjBcXHUwOWYxXFx1MDlmY1xcdTBhMDUtXFx1MGEwYVxcdTBhMGZcXHUwYTEwXFx1MGExMy1cXHUwYTI4XFx1MGEyYS1cXHUwYTMwXFx1MGEzMlxcdTBhMzNcXHUwYTM1XFx1MGEzNlxcdTBhMzhcXHUwYTM5XFx1MGE1OS1cXHUwYTVjXFx1MGE1ZVxcdTBhNzItXFx1MGE3NFxcdTBhODUtXFx1MGE4ZFxcdTBhOGYtXFx1MGE5MVxcdTBhOTMtXFx1MGFhOFxcdTBhYWEtXFx1MGFiMFxcdTBhYjJcXHUwYWIzXFx1MGFiNS1cXHUwYWI5XFx1MGFiZFxcdTBhZDBcXHUwYWUwXFx1MGFlMVxcdTBhZjlcXHUwYjA1LVxcdTBiMGNcXHUwYjBmXFx1MGIxMFxcdTBiMTMtXFx1MGIyOFxcdTBiMmEtXFx1MGIzMFxcdTBiMzJcXHUwYjMzXFx1MGIzNS1cXHUwYjM5XFx1MGIzZFxcdTBiNWNcXHUwYjVkXFx1MGI1Zi1cXHUwYjYxXFx1MGI3MVxcdTBiODNcXHUwYjg1LVxcdTBiOGFcXHUwYjhlLVxcdTBiOTBcXHUwYjkyLVxcdTBiOTVcXHUwYjk5XFx1MGI5YVxcdTBiOWNcXHUwYjllXFx1MGI5ZlxcdTBiYTNcXHUwYmE0XFx1MGJhOC1cXHUwYmFhXFx1MGJhZS1cXHUwYmI5XFx1MGJkMFxcdTBjMDUtXFx1MGMwY1xcdTBjMGUtXFx1MGMxMFxcdTBjMTItXFx1MGMyOFxcdTBjMmEtXFx1MGMzOVxcdTBjM2RcXHUwYzU4LVxcdTBjNWFcXHUwYzYwXFx1MGM2MVxcdTBjODBcXHUwYzg1LVxcdTBjOGNcXHUwYzhlLVxcdTBjOTBcXHUwYzkyLVxcdTBjYThcXHUwY2FhLVxcdTBjYjNcXHUwY2I1LVxcdTBjYjlcXHUwY2JkXFx1MGNkZVxcdTBjZTBcXHUwY2UxXFx1MGNmMVxcdTBjZjJcXHUwZDA0LVxcdTBkMGNcXHUwZDBlLVxcdTBkMTBcXHUwZDEyLVxcdTBkM2FcXHUwZDNkXFx1MGQ0ZVxcdTBkNTQtXFx1MGQ1NlxcdTBkNWYtXFx1MGQ2MVxcdTBkN2EtXFx1MGQ3ZlxcdTBkODUtXFx1MGQ5NlxcdTBkOWEtXFx1MGRiMVxcdTBkYjMtXFx1MGRiYlxcdTBkYmRcXHUwZGMwLVxcdTBkYzZcXHUwZTAxLVxcdTBlMzBcXHUwZTMyXFx1MGUzM1xcdTBlNDAtXFx1MGU0NlxcdTBlODFcXHUwZTgyXFx1MGU4NFxcdTBlODYtXFx1MGU4YVxcdTBlOGMtXFx1MGVhM1xcdTBlYTVcXHUwZWE3LVxcdTBlYjBcXHUwZWIyXFx1MGViM1xcdTBlYmRcXHUwZWMwLVxcdTBlYzRcXHUwZWM2XFx1MGVkYy1cXHUwZWRmXFx1MGYwMFxcdTBmNDAtXFx1MGY0N1xcdTBmNDktXFx1MGY2Y1xcdTBmODgtXFx1MGY4Y1xcdTEwMDAtXFx1MTAyYVxcdTEwM2ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVhLVxcdTEwNWRcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZlLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhlXFx1MTBhMC1cXHUxMGM1XFx1MTBjN1xcdTEwY2RcXHUxMGQwLVxcdTEwZmFcXHUxMGZjLVxcdTEyNDhcXHUxMjRhLVxcdTEyNGRcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1YS1cXHUxMjVkXFx1MTI2MC1cXHUxMjg4XFx1MTI4YS1cXHUxMjhkXFx1MTI5MC1cXHUxMmIwXFx1MTJiMi1cXHUxMmI1XFx1MTJiOC1cXHUxMmJlXFx1MTJjMFxcdTEyYzItXFx1MTJjNVxcdTEyYzgtXFx1MTJkNlxcdTEyZDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1YVxcdTEzODAtXFx1MTM4ZlxcdTEzYTAtXFx1MTNmNVxcdTEzZjgtXFx1MTNmZFxcdTE0MDEtXFx1MTY2Y1xcdTE2NmYtXFx1MTY3ZlxcdTE2ODEtXFx1MTY5YVxcdTE2YTAtXFx1MTZlYVxcdTE2ZWUtXFx1MTZmOFxcdTE3MDAtXFx1MTcwY1xcdTE3MGUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Y1xcdTE3NmUtXFx1MTc3MFxcdTE3ODAtXFx1MTdiM1xcdTE3ZDdcXHUxN2RjXFx1MTgyMC1cXHUxODc4XFx1MTg4MC1cXHUxOGE4XFx1MThhYVxcdTE4YjAtXFx1MThmNVxcdTE5MDAtXFx1MTkxZVxcdTE5NTAtXFx1MTk2ZFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlhYlxcdTE5YjAtXFx1MTljOVxcdTFhMDAtXFx1MWExNlxcdTFhMjAtXFx1MWE1NFxcdTFhYTdcXHUxYjA1LVxcdTFiMzNcXHUxYjQ1LVxcdTFiNGJcXHUxYjgzLVxcdTFiYTBcXHUxYmFlXFx1MWJhZlxcdTFiYmEtXFx1MWJlNVxcdTFjMDAtXFx1MWMyM1xcdTFjNGQtXFx1MWM0ZlxcdTFjNWEtXFx1MWM3ZFxcdTFjODAtXFx1MWM4OFxcdTFjOTAtXFx1MWNiYVxcdTFjYmQtXFx1MWNiZlxcdTFjZTktXFx1MWNlY1xcdTFjZWUtXFx1MWNmM1xcdTFjZjVcXHUxY2Y2XFx1MWNmYVxcdTFkMDAtXFx1MWRiZlxcdTFlMDAtXFx1MWYxNVxcdTFmMTgtXFx1MWYxZFxcdTFmMjAtXFx1MWY0NVxcdTFmNDgtXFx1MWY0ZFxcdTFmNTAtXFx1MWY1N1xcdTFmNTlcXHUxZjViXFx1MWY1ZFxcdTFmNWYtXFx1MWY3ZFxcdTFmODAtXFx1MWZiNFxcdTFmYjYtXFx1MWZiY1xcdTFmYmVcXHUxZmMyLVxcdTFmYzRcXHUxZmM2LVxcdTFmY2NcXHUxZmQwLVxcdTFmZDNcXHUxZmQ2LVxcdTFmZGJcXHUxZmUwLVxcdTFmZWNcXHUxZmYyLVxcdTFmZjRcXHUxZmY2LVxcdTFmZmNcXHUyMDcxXFx1MjA3ZlxcdTIwOTAtXFx1MjA5Y1xcdTIxMDJcXHUyMTA3XFx1MjEwYS1cXHUyMTEzXFx1MjExNVxcdTIxMTgtXFx1MjExZFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMmEtXFx1MjEzOVxcdTIxM2MtXFx1MjEzZlxcdTIxNDUtXFx1MjE0OVxcdTIxNGVcXHUyMTYwLVxcdTIxODhcXHUyYzAwLVxcdTJjMmVcXHUyYzMwLVxcdTJjNWVcXHUyYzYwLVxcdTJjZTRcXHUyY2ViLVxcdTJjZWVcXHUyY2YyXFx1MmNmM1xcdTJkMDAtXFx1MmQyNVxcdTJkMjdcXHUyZDJkXFx1MmQzMC1cXHUyZDY3XFx1MmQ2ZlxcdTJkODAtXFx1MmQ5NlxcdTJkYTAtXFx1MmRhNlxcdTJkYTgtXFx1MmRhZVxcdTJkYjAtXFx1MmRiNlxcdTJkYjgtXFx1MmRiZVxcdTJkYzAtXFx1MmRjNlxcdTJkYzgtXFx1MmRjZVxcdTJkZDAtXFx1MmRkNlxcdTJkZDgtXFx1MmRkZVxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzY1xcdTMwNDEtXFx1MzA5NlxcdTMwOWItXFx1MzA5ZlxcdTMwYTEtXFx1MzBmYVxcdTMwZmMtXFx1MzBmZlxcdTMxMDUtXFx1MzEyZlxcdTMxMzEtXFx1MzE4ZVxcdTMxYTAtXFx1MzFiZlxcdTMxZjAtXFx1MzFmZlxcdTM0MDAtXFx1NGRiZlxcdTRlMDAtXFx1OWZmY1xcdWEwMDAtXFx1YTQ4Y1xcdWE0ZDAtXFx1YTRmZFxcdWE1MDAtXFx1YTYwY1xcdWE2MTAtXFx1YTYxZlxcdWE2MmFcXHVhNjJiXFx1YTY0MC1cXHVhNjZlXFx1YTY3Zi1cXHVhNjlkXFx1YTZhMC1cXHVhNmVmXFx1YTcxNy1cXHVhNzFmXFx1YTcyMi1cXHVhNzg4XFx1YTc4Yi1cXHVhN2JmXFx1YTdjMi1cXHVhN2NhXFx1YTdmNS1cXHVhODAxXFx1YTgwMy1cXHVhODA1XFx1YTgwNy1cXHVhODBhXFx1YTgwYy1cXHVhODIyXFx1YTg0MC1cXHVhODczXFx1YTg4Mi1cXHVhOGIzXFx1YThmMi1cXHVhOGY3XFx1YThmYlxcdWE4ZmRcXHVhOGZlXFx1YTkwYS1cXHVhOTI1XFx1YTkzMC1cXHVhOTQ2XFx1YTk2MC1cXHVhOTdjXFx1YTk4NC1cXHVhOWIyXFx1YTljZlxcdWE5ZTAtXFx1YTllNFxcdWE5ZTYtXFx1YTllZlxcdWE5ZmEtXFx1YTlmZVxcdWFhMDAtXFx1YWEyOFxcdWFhNDAtXFx1YWE0MlxcdWFhNDQtXFx1YWE0YlxcdWFhNjAtXFx1YWE3NlxcdWFhN2FcXHVhYTdlLVxcdWFhYWZcXHVhYWIxXFx1YWFiNVxcdWFhYjZcXHVhYWI5LVxcdWFhYmRcXHVhYWMwXFx1YWFjMlxcdWFhZGItXFx1YWFkZFxcdWFhZTAtXFx1YWFlYVxcdWFhZjItXFx1YWFmNFxcdWFiMDEtXFx1YWIwNlxcdWFiMDktXFx1YWIwZVxcdWFiMTEtXFx1YWIxNlxcdWFiMjAtXFx1YWIyNlxcdWFiMjgtXFx1YWIyZVxcdWFiMzAtXFx1YWI1YVxcdWFiNWMtXFx1YWI2OVxcdWFiNzAtXFx1YWJlMlxcdWFjMDAtXFx1ZDdhM1xcdWQ3YjAtXFx1ZDdjNlxcdWQ3Y2ItXFx1ZDdmYlxcdWY5MDAtXFx1ZmE2ZFxcdWZhNzAtXFx1ZmFkOVxcdWZiMDAtXFx1ZmIwNlxcdWZiMTMtXFx1ZmIxN1xcdWZiMWRcXHVmYjFmLVxcdWZiMjhcXHVmYjJhLVxcdWZiMzZcXHVmYjM4LVxcdWZiM2NcXHVmYjNlXFx1ZmI0MFxcdWZiNDFcXHVmYjQzXFx1ZmI0NFxcdWZiNDYtXFx1ZmJiMVxcdWZiZDMtXFx1ZmQzZFxcdWZkNTAtXFx1ZmQ4ZlxcdWZkOTItXFx1ZmRjN1xcdWZkZjAtXFx1ZmRmYlxcdWZlNzAtXFx1ZmU3NFxcdWZlNzYtXFx1ZmVmY1xcdWZmMjEtXFx1ZmYzYVxcdWZmNDEtXFx1ZmY1YVxcdWZmNjYtXFx1ZmZiZVxcdWZmYzItXFx1ZmZjN1xcdWZmY2EtXFx1ZmZjZlxcdWZmZDItXFx1ZmZkN1xcdWZmZGEtXFx1ZmZkY1wiO1xubGV0IG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzID0gXCJcXHUyMDBjXFx1MjAwZFxceGI3XFx1MDMwMC1cXHUwMzZmXFx1MDM4N1xcdTA0ODMtXFx1MDQ4N1xcdTA1OTEtXFx1MDViZFxcdTA1YmZcXHUwNWMxXFx1MDVjMlxcdTA1YzRcXHUwNWM1XFx1MDVjN1xcdTA2MTAtXFx1MDYxYVxcdTA2NGItXFx1MDY2OVxcdTA2NzBcXHUwNmQ2LVxcdTA2ZGNcXHUwNmRmLVxcdTA2ZTRcXHUwNmU3XFx1MDZlOFxcdTA2ZWEtXFx1MDZlZFxcdTA2ZjAtXFx1MDZmOVxcdTA3MTFcXHUwNzMwLVxcdTA3NGFcXHUwN2E2LVxcdTA3YjBcXHUwN2MwLVxcdTA3YzlcXHUwN2ViLVxcdTA3ZjNcXHUwN2ZkXFx1MDgxNi1cXHUwODE5XFx1MDgxYi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJkXFx1MDg1OS1cXHUwODViXFx1MDhkMy1cXHUwOGUxXFx1MDhlMy1cXHUwOTAzXFx1MDkzYS1cXHUwOTNjXFx1MDkzZS1cXHUwOTRmXFx1MDk1MS1cXHUwOTU3XFx1MDk2MlxcdTA5NjNcXHUwOTY2LVxcdTA5NmZcXHUwOTgxLVxcdTA5ODNcXHUwOWJjXFx1MDliZS1cXHUwOWM0XFx1MDljN1xcdTA5YzhcXHUwOWNiLVxcdTA5Y2RcXHUwOWQ3XFx1MDllMlxcdTA5ZTNcXHUwOWU2LVxcdTA5ZWZcXHUwOWZlXFx1MGEwMS1cXHUwYTAzXFx1MGEzY1xcdTBhM2UtXFx1MGE0MlxcdTBhNDdcXHUwYTQ4XFx1MGE0Yi1cXHUwYTRkXFx1MGE1MVxcdTBhNjYtXFx1MGE3MVxcdTBhNzVcXHUwYTgxLVxcdTBhODNcXHUwYWJjXFx1MGFiZS1cXHUwYWM1XFx1MGFjNy1cXHUwYWM5XFx1MGFjYi1cXHUwYWNkXFx1MGFlMlxcdTBhZTNcXHUwYWU2LVxcdTBhZWZcXHUwYWZhLVxcdTBhZmZcXHUwYjAxLVxcdTBiMDNcXHUwYjNjXFx1MGIzZS1cXHUwYjQ0XFx1MGI0N1xcdTBiNDhcXHUwYjRiLVxcdTBiNGRcXHUwYjU1LVxcdTBiNTdcXHUwYjYyXFx1MGI2M1xcdTBiNjYtXFx1MGI2ZlxcdTBiODJcXHUwYmJlLVxcdTBiYzJcXHUwYmM2LVxcdTBiYzhcXHUwYmNhLVxcdTBiY2RcXHUwYmQ3XFx1MGJlNi1cXHUwYmVmXFx1MGMwMC1cXHUwYzA0XFx1MGMzZS1cXHUwYzQ0XFx1MGM0Ni1cXHUwYzQ4XFx1MGM0YS1cXHUwYzRkXFx1MGM1NVxcdTBjNTZcXHUwYzYyXFx1MGM2M1xcdTBjNjYtXFx1MGM2ZlxcdTBjODEtXFx1MGM4M1xcdTBjYmNcXHUwY2JlLVxcdTBjYzRcXHUwY2M2LVxcdTBjYzhcXHUwY2NhLVxcdTBjY2RcXHUwY2Q1XFx1MGNkNlxcdTBjZTJcXHUwY2UzXFx1MGNlNi1cXHUwY2VmXFx1MGQwMC1cXHUwZDAzXFx1MGQzYlxcdTBkM2NcXHUwZDNlLVxcdTBkNDRcXHUwZDQ2LVxcdTBkNDhcXHUwZDRhLVxcdTBkNGRcXHUwZDU3XFx1MGQ2MlxcdTBkNjNcXHUwZDY2LVxcdTBkNmZcXHUwZDgxLVxcdTBkODNcXHUwZGNhXFx1MGRjZi1cXHUwZGQ0XFx1MGRkNlxcdTBkZDgtXFx1MGRkZlxcdTBkZTYtXFx1MGRlZlxcdTBkZjJcXHUwZGYzXFx1MGUzMVxcdTBlMzQtXFx1MGUzYVxcdTBlNDctXFx1MGU0ZVxcdTBlNTAtXFx1MGU1OVxcdTBlYjFcXHUwZWI0LVxcdTBlYmNcXHUwZWM4LVxcdTBlY2RcXHUwZWQwLVxcdTBlZDlcXHUwZjE4XFx1MGYxOVxcdTBmMjAtXFx1MGYyOVxcdTBmMzVcXHUwZjM3XFx1MGYzOVxcdTBmM2VcXHUwZjNmXFx1MGY3MS1cXHUwZjg0XFx1MGY4NlxcdTBmODdcXHUwZjhkLVxcdTBmOTdcXHUwZjk5LVxcdTBmYmNcXHUwZmM2XFx1MTAyYi1cXHUxMDNlXFx1MTA0MC1cXHUxMDQ5XFx1MTA1Ni1cXHUxMDU5XFx1MTA1ZS1cXHUxMDYwXFx1MTA2Mi1cXHUxMDY0XFx1MTA2Ny1cXHUxMDZkXFx1MTA3MS1cXHUxMDc0XFx1MTA4Mi1cXHUxMDhkXFx1MTA4Zi1cXHUxMDlkXFx1MTM1ZC1cXHUxMzVmXFx1MTM2OS1cXHUxMzcxXFx1MTcxMi1cXHUxNzE0XFx1MTczMi1cXHUxNzM0XFx1MTc1MlxcdTE3NTNcXHUxNzcyXFx1MTc3M1xcdTE3YjQtXFx1MTdkM1xcdTE3ZGRcXHUxN2UwLVxcdTE3ZTlcXHUxODBiLVxcdTE4MGRcXHUxODEwLVxcdTE4MTlcXHUxOGE5XFx1MTkyMC1cXHUxOTJiXFx1MTkzMC1cXHUxOTNiXFx1MTk0Ni1cXHUxOTRmXFx1MTlkMC1cXHUxOWRhXFx1MWExNy1cXHUxYTFiXFx1MWE1NS1cXHUxYTVlXFx1MWE2MC1cXHUxYTdjXFx1MWE3Zi1cXHUxYTg5XFx1MWE5MC1cXHUxYTk5XFx1MWFiMC1cXHUxYWJkXFx1MWFiZlxcdTFhYzBcXHUxYjAwLVxcdTFiMDRcXHUxYjM0LVxcdTFiNDRcXHUxYjUwLVxcdTFiNTlcXHUxYjZiLVxcdTFiNzNcXHUxYjgwLVxcdTFiODJcXHUxYmExLVxcdTFiYWRcXHUxYmIwLVxcdTFiYjlcXHUxYmU2LVxcdTFiZjNcXHUxYzI0LVxcdTFjMzdcXHUxYzQwLVxcdTFjNDlcXHUxYzUwLVxcdTFjNTlcXHUxY2QwLVxcdTFjZDJcXHUxY2Q0LVxcdTFjZThcXHUxY2VkXFx1MWNmNFxcdTFjZjctXFx1MWNmOVxcdTFkYzAtXFx1MWRmOVxcdTFkZmItXFx1MWRmZlxcdTIwM2ZcXHUyMDQwXFx1MjA1NFxcdTIwZDAtXFx1MjBkY1xcdTIwZTFcXHUyMGU1LVxcdTIwZjBcXHUyY2VmLVxcdTJjZjFcXHUyZDdmXFx1MmRlMC1cXHUyZGZmXFx1MzAyYS1cXHUzMDJmXFx1MzA5OVxcdTMwOWFcXHVhNjIwLVxcdWE2MjlcXHVhNjZmXFx1YTY3NC1cXHVhNjdkXFx1YTY5ZVxcdWE2OWZcXHVhNmYwXFx1YTZmMVxcdWE4MDJcXHVhODA2XFx1YTgwYlxcdWE4MjMtXFx1YTgyN1xcdWE4MmNcXHVhODgwXFx1YTg4MVxcdWE4YjQtXFx1YThjNVxcdWE4ZDAtXFx1YThkOVxcdWE4ZTAtXFx1YThmMVxcdWE4ZmYtXFx1YTkwOVxcdWE5MjYtXFx1YTkyZFxcdWE5NDctXFx1YTk1M1xcdWE5ODAtXFx1YTk4M1xcdWE5YjMtXFx1YTljMFxcdWE5ZDAtXFx1YTlkOVxcdWE5ZTVcXHVhOWYwLVxcdWE5ZjlcXHVhYTI5LVxcdWFhMzZcXHVhYTQzXFx1YWE0Y1xcdWFhNGRcXHVhYTUwLVxcdWFhNTlcXHVhYTdiLVxcdWFhN2RcXHVhYWIwXFx1YWFiMi1cXHVhYWI0XFx1YWFiN1xcdWFhYjhcXHVhYWJlXFx1YWFiZlxcdWFhYzFcXHVhYWViLVxcdWFhZWZcXHVhYWY1XFx1YWFmNlxcdWFiZTMtXFx1YWJlYVxcdWFiZWNcXHVhYmVkXFx1YWJmMC1cXHVhYmY5XFx1ZmIxZVxcdWZlMDAtXFx1ZmUwZlxcdWZlMjAtXFx1ZmUyZlxcdWZlMzNcXHVmZTM0XFx1ZmU0ZC1cXHVmZTRmXFx1ZmYxMC1cXHVmZjE5XFx1ZmYzZlwiO1xuY29uc3Qgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnQgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIFwiXVwiKTtcbmNvbnN0IG5vbkFTQ0lJaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoXCJbXCIgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgKyBcIl1cIik7XG5ub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzID0gbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgPSBudWxsO1xuY29uc3QgYXN0cmFsSWRlbnRpZmllclN0YXJ0Q29kZXMgPSBbMCwgMTEsIDIsIDI1LCAyLCAxOCwgMiwgMSwgMiwgMTQsIDMsIDEzLCAzNSwgMTIyLCA3MCwgNTIsIDI2OCwgMjgsIDQsIDQ4LCA0OCwgMzEsIDE0LCAyOSwgNiwgMzcsIDExLCAyOSwgMywgMzUsIDUsIDcsIDIsIDQsIDQzLCAxNTcsIDE5LCAzNSwgNSwgMzUsIDUsIDM5LCA5LCA1MSwgMTU3LCAzMTAsIDEwLCAyMSwgMTEsIDcsIDE1MywgNSwgMywgMCwgMiwgNDMsIDIsIDEsIDQsIDAsIDMsIDIyLCAxMSwgMjIsIDEwLCAzMCwgNjYsIDE4LCAyLCAxLCAxMSwgMjEsIDExLCAyNSwgNzEsIDU1LCA3LCAxLCA2NSwgMCwgMTYsIDMsIDIsIDIsIDIsIDI4LCA0MywgMjgsIDQsIDI4LCAzNiwgNywgMiwgMjcsIDI4LCA1MywgMTEsIDIxLCAxMSwgMTgsIDE0LCAxNywgMTExLCA3MiwgNTYsIDUwLCAxNCwgNTAsIDE0LCAzNSwgMzQ5LCA0MSwgNywgMSwgNzksIDI4LCAxMSwgMCwgOSwgMjEsIDEwNywgMjAsIDI4LCAyMiwgMTMsIDUyLCA3NiwgNDQsIDMzLCAyNCwgMjcsIDM1LCAzMCwgMCwgMywgMCwgOSwgMzQsIDQsIDAsIDEzLCA0NywgMTUsIDMsIDIyLCAwLCAyLCAwLCAzNiwgMTcsIDIsIDI0LCA4NSwgNiwgMiwgMCwgMiwgMywgMiwgMTQsIDIsIDksIDgsIDQ2LCAzOSwgNywgMywgMSwgMywgMjEsIDIsIDYsIDIsIDEsIDIsIDQsIDQsIDAsIDE5LCAwLCAxMywgNCwgMTU5LCA1MiwgMTksIDMsIDIxLCAyLCAzMSwgNDcsIDIxLCAxLCAyLCAwLCAxODUsIDQ2LCA0MiwgMywgMzcsIDQ3LCAyMSwgMCwgNjAsIDQyLCAxNCwgMCwgNzIsIDI2LCAyMzAsIDQzLCAxMTcsIDYzLCAzMiwgNywgMywgMCwgMywgNywgMiwgMSwgMiwgMjMsIDE2LCAwLCAyLCAwLCA5NSwgNywgMywgMzgsIDE3LCAwLCAyLCAwLCAyOSwgMCwgMTEsIDM5LCA4LCAwLCAyMiwgMCwgMTIsIDQ1LCAyMCwgMCwgMzUsIDU2LCAyNjQsIDgsIDIsIDM2LCAxOCwgMCwgNTAsIDI5LCAxMTMsIDYsIDIsIDEsIDIsIDM3LCAyMiwgMCwgMjYsIDUsIDIsIDEsIDIsIDMxLCAxNSwgMCwgMzI4LCAxOCwgMTkwLCAwLCA4MCwgOTIxLCAxMDMsIDExMCwgMTgsIDE5NSwgMjc0OSwgMTA3MCwgNDA1MCwgNTgyLCA4NjM0LCA1NjgsIDgsIDMwLCAxMTQsIDI5LCAxOSwgNDcsIDE3LCAzLCAzMiwgMjAsIDYsIDE4LCA2ODksIDYzLCAxMjksIDc0LCA2LCAwLCA2NywgMTIsIDY1LCAxLCAyLCAwLCAyOSwgNjEzNSwgOSwgMTIzNywgNDMsIDgsIDg5NTIsIDI4NiwgNTAsIDIsIDE4LCAzLCA5LCAzOTUsIDIzMDksIDEwNiwgNiwgMTIsIDQsIDgsIDgsIDksIDU5OTEsIDg0LCAyLCA3MCwgMiwgMSwgMywgMCwgMywgMSwgMywgMywgMiwgMTEsIDIsIDAsIDIsIDYsIDIsIDY0LCAyLCAzLCAzLCA3LCAyLCA2LCAyLCAyNywgMiwgMywgMiwgNCwgMiwgMCwgNCwgNiwgMiwgMzM5LCAzLCAyNCwgMiwgMjQsIDIsIDMwLCAyLCAyNCwgMiwgMzAsIDIsIDI0LCAyLCAzMCwgMiwgMjQsIDIsIDMwLCAyLCAyNCwgMiwgNywgMjM1NywgNDQsIDExLCA2LCAxNywgMCwgMzcwLCA0MywgMTMwMSwgMTk2LCA2MCwgNjcsIDgsIDAsIDEyMDUsIDMsIDIsIDI2LCAyLCAxLCAyLCAwLCAzLCAwLCAyLCA5LCAyLCAzLCAyLCAwLCAyLCAwLCA3LCAwLCA1LCAwLCAyLCAwLCAyLCAwLCAyLCAyLCAyLCAxLCAyLCAwLCAzLCAwLCAyLCAwLCAyLCAwLCAyLCAwLCAyLCAwLCAyLCAxLCAyLCAwLCAzLCAzLCAyLCA2LCAyLCAzLCAyLCAzLCAyLCAwLCAyLCA5LCAyLCAxNiwgNiwgMiwgMiwgNCwgMiwgMTYsIDQ0MjEsIDQyNzE3LCAzNSwgNDE0OCwgMTIsIDIyMSwgMywgNTc2MSwgMTUsIDc0NzIsIDMxMDQsIDU0MSwgMTUwNywgNDkzOF07XG5jb25zdCBhc3RyYWxJZGVudGlmaWVyQ29kZXMgPSBbNTA5LCAwLCAyMjcsIDAsIDE1MCwgNCwgMjk0LCA5LCAxMzY4LCAyLCAyLCAxLCA2LCAzLCA0MSwgMiwgNSwgMCwgMTY2LCAxLCA1NzQsIDMsIDksIDksIDM3MCwgMSwgMTU0LCAxMCwgMTc2LCAyLCA1NCwgMTQsIDMyLCA5LCAxNiwgMywgNDYsIDEwLCA1NCwgOSwgNywgMiwgMzcsIDEzLCAyLCA5LCA2LCAxLCA0NSwgMCwgMTMsIDIsIDQ5LCAxMywgOSwgMywgMiwgMTEsIDgzLCAxMSwgNywgMCwgMTYxLCAxMSwgNiwgOSwgNywgMywgNTYsIDEsIDIsIDYsIDMsIDEsIDMsIDIsIDEwLCAwLCAxMSwgMSwgMywgNiwgNCwgNCwgMTkzLCAxNywgMTAsIDksIDUsIDAsIDgyLCAxOSwgMTMsIDksIDIxNCwgNiwgMywgOCwgMjgsIDEsIDgzLCAxNiwgMTYsIDksIDgyLCAxMiwgOSwgOSwgODQsIDE0LCA1LCA5LCAyNDMsIDE0LCAxNjYsIDksIDcxLCA1LCAyLCAxLCAzLCAzLCAyLCAwLCAyLCAxLCAxMywgOSwgMTIwLCA2LCAzLCA2LCA0LCAwLCAyOSwgOSwgNDEsIDYsIDIsIDMsIDksIDAsIDEwLCAxMCwgNDcsIDE1LCA0MDYsIDcsIDIsIDcsIDE3LCA5LCA1NywgMjEsIDIsIDEzLCAxMjMsIDUsIDQsIDAsIDIsIDEsIDIsIDYsIDIsIDAsIDksIDksIDQ5LCA0LCAyLCAxLCAyLCA0LCA5LCA5LCAzMzAsIDMsIDE5MzA2LCA5LCAxMzUsIDQsIDYwLCA2LCAyNiwgOSwgMTAxNCwgMCwgMiwgNTQsIDgsIDMsIDgyLCAwLCAxMiwgMSwgMTk2MjgsIDEsIDUzMTksIDQsIDQsIDUsIDksIDcsIDMsIDYsIDMxLCAzLCAxNDksIDIsIDE0MTgsIDQ5LCA1MTMsIDU0LCA1LCA0OSwgOSwgMCwgMTUsIDAsIDIzLCA0LCAyLCAxNCwgMTM2MSwgNiwgMiwgMTYsIDMsIDYsIDIsIDEsIDIsIDQsIDI2MiwgNiwgMTAsIDksIDQxOSwgMTMsIDE0OTUsIDYsIDExMCwgNiwgNiwgOSwgNDc1OSwgOSwgNzg3NzE5LCAyMzldO1xuXG5mdW5jdGlvbiBpc0luQXN0cmFsU2V0KGNvZGUsIHNldCkge1xuICBsZXQgcG9zID0gMHgxMDAwMDtcblxuICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gc2V0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAyKSB7XG4gICAgcG9zICs9IHNldFtpXTtcbiAgICBpZiAocG9zID4gY29kZSkgcmV0dXJuIGZhbHNlO1xuICAgIHBvcyArPSBzZXRbaSArIDFdO1xuICAgIGlmIChwb3MgPj0gY29kZSkgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzSWRlbnRpZmllclN0YXJ0KGNvZGUpIHtcbiAgaWYgKGNvZGUgPCA2NSkgcmV0dXJuIGNvZGUgPT09IDM2O1xuICBpZiAoY29kZSA8PSA5MCkgcmV0dXJuIHRydWU7XG4gIGlmIChjb2RlIDwgOTcpIHJldHVybiBjb2RlID09PSA5NTtcbiAgaWYgKGNvZGUgPD0gMTIyKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAoY29kZSA8PSAweGZmZmYpIHtcbiAgICByZXR1cm4gY29kZSA+PSAweGFhICYmIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSk7XG4gIH1cblxuICByZXR1cm4gaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2Rlcyk7XG59XG5cbmZ1bmN0aW9uIGlzSWRlbnRpZmllckNoYXIoY29kZSkge1xuICBpZiAoY29kZSA8IDQ4KSByZXR1cm4gY29kZSA9PT0gMzY7XG4gIGlmIChjb2RlIDwgNTgpIHJldHVybiB0cnVlO1xuICBpZiAoY29kZSA8IDY1KSByZXR1cm4gZmFsc2U7XG4gIGlmIChjb2RlIDw9IDkwKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGNvZGUgPCA5NykgcmV0dXJuIGNvZGUgPT09IDk1O1xuICBpZiAoY29kZSA8PSAxMjIpIHJldHVybiB0cnVlO1xuXG4gIGlmIChjb2RlIDw9IDB4ZmZmZikge1xuICAgIHJldHVybiBjb2RlID49IDB4YWEgJiYgbm9uQVNDSUlpZGVudGlmaWVyLnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSk7XG4gIH1cblxuICByZXR1cm4gaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2RlcykgfHwgaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyQ29kZXMpO1xufVxuXG5mdW5jdGlvbiBpc0lkZW50aWZpZXJOYW1lKG5hbWUpIHtcbiAgbGV0IGlzRmlyc3QgPSB0cnVlO1xuXG4gIGZvciAobGV0IF9pID0gMCwgX0FycmF5JGZyb20gPSBBcnJheS5mcm9tKG5hbWUpOyBfaSA8IF9BcnJheSRmcm9tLmxlbmd0aDsgX2krKykge1xuICAgIGNvbnN0IGNoYXIgPSBfQXJyYXkkZnJvbVtfaV07XG4gICAgY29uc3QgY3AgPSBjaGFyLmNvZGVQb2ludEF0KDApO1xuXG4gICAgaWYgKGlzRmlyc3QpIHtcbiAgICAgIGlmICghaXNJZGVudGlmaWVyU3RhcnQoY3ApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaXNGaXJzdCA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoIWlzSWRlbnRpZmllckNoYXIoY3ApKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICFpc0ZpcnN0O1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNJZGVudGlmaWVyTmFtZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaWRlbnRpZmllci5pc0lkZW50aWZpZXJOYW1lO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzSWRlbnRpZmllckNoYXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2lkZW50aWZpZXIuaXNJZGVudGlmaWVyQ2hhcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0lkZW50aWZpZXJTdGFydFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaWRlbnRpZmllci5pc0lkZW50aWZpZXJTdGFydDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1Jlc2VydmVkV29yZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfa2V5d29yZC5pc1Jlc2VydmVkV29yZDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1N0cmljdEJpbmRPbmx5UmVzZXJ2ZWRXb3JkXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9rZXl3b3JkLmlzU3RyaWN0QmluZE9ubHlSZXNlcnZlZFdvcmQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNTdHJpY3RCaW5kUmVzZXJ2ZWRXb3JkXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9rZXl3b3JkLmlzU3RyaWN0QmluZFJlc2VydmVkV29yZDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1N0cmljdFJlc2VydmVkV29yZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfa2V5d29yZC5pc1N0cmljdFJlc2VydmVkV29yZDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0tleXdvcmRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2tleXdvcmQuaXNLZXl3b3JkO1xuICB9XG59KTtcblxudmFyIF9pZGVudGlmaWVyID0gcmVxdWlyZShcIi4vaWRlbnRpZmllclwiKTtcblxudmFyIF9rZXl3b3JkID0gcmVxdWlyZShcIi4va2V5d29yZFwiKTsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuaXNSZXNlcnZlZFdvcmQgPSBpc1Jlc2VydmVkV29yZDtcbmV4cG9ydHMuaXNTdHJpY3RSZXNlcnZlZFdvcmQgPSBpc1N0cmljdFJlc2VydmVkV29yZDtcbmV4cG9ydHMuaXNTdHJpY3RCaW5kT25seVJlc2VydmVkV29yZCA9IGlzU3RyaWN0QmluZE9ubHlSZXNlcnZlZFdvcmQ7XG5leHBvcnRzLmlzU3RyaWN0QmluZFJlc2VydmVkV29yZCA9IGlzU3RyaWN0QmluZFJlc2VydmVkV29yZDtcbmV4cG9ydHMuaXNLZXl3b3JkID0gaXNLZXl3b3JkO1xuY29uc3QgcmVzZXJ2ZWRXb3JkcyA9IHtcbiAga2V5d29yZDogW1wiYnJlYWtcIiwgXCJjYXNlXCIsIFwiY2F0Y2hcIiwgXCJjb250aW51ZVwiLCBcImRlYnVnZ2VyXCIsIFwiZGVmYXVsdFwiLCBcImRvXCIsIFwiZWxzZVwiLCBcImZpbmFsbHlcIiwgXCJmb3JcIiwgXCJmdW5jdGlvblwiLCBcImlmXCIsIFwicmV0dXJuXCIsIFwic3dpdGNoXCIsIFwidGhyb3dcIiwgXCJ0cnlcIiwgXCJ2YXJcIiwgXCJjb25zdFwiLCBcIndoaWxlXCIsIFwid2l0aFwiLCBcIm5ld1wiLCBcInRoaXNcIiwgXCJzdXBlclwiLCBcImNsYXNzXCIsIFwiZXh0ZW5kc1wiLCBcImV4cG9ydFwiLCBcImltcG9ydFwiLCBcIm51bGxcIiwgXCJ0cnVlXCIsIFwiZmFsc2VcIiwgXCJpblwiLCBcImluc3RhbmNlb2ZcIiwgXCJ0eXBlb2ZcIiwgXCJ2b2lkXCIsIFwiZGVsZXRlXCJdLFxuICBzdHJpY3Q6IFtcImltcGxlbWVudHNcIiwgXCJpbnRlcmZhY2VcIiwgXCJsZXRcIiwgXCJwYWNrYWdlXCIsIFwicHJpdmF0ZVwiLCBcInByb3RlY3RlZFwiLCBcInB1YmxpY1wiLCBcInN0YXRpY1wiLCBcInlpZWxkXCJdLFxuICBzdHJpY3RCaW5kOiBbXCJldmFsXCIsIFwiYXJndW1lbnRzXCJdXG59O1xuY29uc3Qga2V5d29yZHMgPSBuZXcgU2V0KHJlc2VydmVkV29yZHMua2V5d29yZCk7XG5jb25zdCByZXNlcnZlZFdvcmRzU3RyaWN0U2V0ID0gbmV3IFNldChyZXNlcnZlZFdvcmRzLnN0cmljdCk7XG5jb25zdCByZXNlcnZlZFdvcmRzU3RyaWN0QmluZFNldCA9IG5ldyBTZXQocmVzZXJ2ZWRXb3Jkcy5zdHJpY3RCaW5kKTtcblxuZnVuY3Rpb24gaXNSZXNlcnZlZFdvcmQod29yZCwgaW5Nb2R1bGUpIHtcbiAgcmV0dXJuIGluTW9kdWxlICYmIHdvcmQgPT09IFwiYXdhaXRcIiB8fCB3b3JkID09PSBcImVudW1cIjtcbn1cblxuZnVuY3Rpb24gaXNTdHJpY3RSZXNlcnZlZFdvcmQod29yZCwgaW5Nb2R1bGUpIHtcbiAgcmV0dXJuIGlzUmVzZXJ2ZWRXb3JkKHdvcmQsIGluTW9kdWxlKSB8fCByZXNlcnZlZFdvcmRzU3RyaWN0U2V0Lmhhcyh3b3JkKTtcbn1cblxuZnVuY3Rpb24gaXNTdHJpY3RCaW5kT25seVJlc2VydmVkV29yZCh3b3JkKSB7XG4gIHJldHVybiByZXNlcnZlZFdvcmRzU3RyaWN0QmluZFNldC5oYXMod29yZCk7XG59XG5cbmZ1bmN0aW9uIGlzU3RyaWN0QmluZFJlc2VydmVkV29yZCh3b3JkLCBpbk1vZHVsZSkge1xuICByZXR1cm4gaXNTdHJpY3RSZXNlcnZlZFdvcmQod29yZCwgaW5Nb2R1bGUpIHx8IGlzU3RyaWN0QmluZE9ubHlSZXNlcnZlZFdvcmQod29yZCk7XG59XG5cbmZ1bmN0aW9uIGlzS2V5d29yZCh3b3JkKSB7XG4gIHJldHVybiBrZXl3b3Jkcy5oYXMod29yZCk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBhc3NlcnROb2RlO1xuXG52YXIgX2lzTm9kZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3ZhbGlkYXRvcnMvaXNOb2RlXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gYXNzZXJ0Tm9kZShub2RlKSB7XG4gIGlmICghKDAsIF9pc05vZGUuZGVmYXVsdCkobm9kZSkpIHtcbiAgICB2YXIgX25vZGUkdHlwZTtcblxuICAgIGNvbnN0IHR5cGUgPSAoX25vZGUkdHlwZSA9IG5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IG5vZGUudHlwZSkgIT0gbnVsbCA/IF9ub2RlJHR5cGUgOiBKU09OLnN0cmluZ2lmeShub2RlKTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBOb3QgYSB2YWxpZCBub2RlIG9mIHR5cGUgXCIke3R5cGV9XCJgKTtcbiAgfVxufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5hc3NlcnRBcnJheUV4cHJlc3Npb24gPSBhc3NlcnRBcnJheUV4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydEFzc2lnbm1lbnRFeHByZXNzaW9uID0gYXNzZXJ0QXNzaWdubWVudEV4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydEJpbmFyeUV4cHJlc3Npb24gPSBhc3NlcnRCaW5hcnlFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRJbnRlcnByZXRlckRpcmVjdGl2ZSA9IGFzc2VydEludGVycHJldGVyRGlyZWN0aXZlO1xuZXhwb3J0cy5hc3NlcnREaXJlY3RpdmUgPSBhc3NlcnREaXJlY3RpdmU7XG5leHBvcnRzLmFzc2VydERpcmVjdGl2ZUxpdGVyYWwgPSBhc3NlcnREaXJlY3RpdmVMaXRlcmFsO1xuZXhwb3J0cy5hc3NlcnRCbG9ja1N0YXRlbWVudCA9IGFzc2VydEJsb2NrU3RhdGVtZW50O1xuZXhwb3J0cy5hc3NlcnRCcmVha1N0YXRlbWVudCA9IGFzc2VydEJyZWFrU3RhdGVtZW50O1xuZXhwb3J0cy5hc3NlcnRDYWxsRXhwcmVzc2lvbiA9IGFzc2VydENhbGxFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRDYXRjaENsYXVzZSA9IGFzc2VydENhdGNoQ2xhdXNlO1xuZXhwb3J0cy5hc3NlcnRDb25kaXRpb25hbEV4cHJlc3Npb24gPSBhc3NlcnRDb25kaXRpb25hbEV4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydENvbnRpbnVlU3RhdGVtZW50ID0gYXNzZXJ0Q29udGludWVTdGF0ZW1lbnQ7XG5leHBvcnRzLmFzc2VydERlYnVnZ2VyU3RhdGVtZW50ID0gYXNzZXJ0RGVidWdnZXJTdGF0ZW1lbnQ7XG5leHBvcnRzLmFzc2VydERvV2hpbGVTdGF0ZW1lbnQgPSBhc3NlcnREb1doaWxlU3RhdGVtZW50O1xuZXhwb3J0cy5hc3NlcnRFbXB0eVN0YXRlbWVudCA9IGFzc2VydEVtcHR5U3RhdGVtZW50O1xuZXhwb3J0cy5hc3NlcnRFeHByZXNzaW9uU3RhdGVtZW50ID0gYXNzZXJ0RXhwcmVzc2lvblN0YXRlbWVudDtcbmV4cG9ydHMuYXNzZXJ0RmlsZSA9IGFzc2VydEZpbGU7XG5leHBvcnRzLmFzc2VydEZvckluU3RhdGVtZW50ID0gYXNzZXJ0Rm9ySW5TdGF0ZW1lbnQ7XG5leHBvcnRzLmFzc2VydEZvclN0YXRlbWVudCA9IGFzc2VydEZvclN0YXRlbWVudDtcbmV4cG9ydHMuYXNzZXJ0RnVuY3Rpb25EZWNsYXJhdGlvbiA9IGFzc2VydEZ1bmN0aW9uRGVjbGFyYXRpb247XG5leHBvcnRzLmFzc2VydEZ1bmN0aW9uRXhwcmVzc2lvbiA9IGFzc2VydEZ1bmN0aW9uRXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0SWRlbnRpZmllciA9IGFzc2VydElkZW50aWZpZXI7XG5leHBvcnRzLmFzc2VydElmU3RhdGVtZW50ID0gYXNzZXJ0SWZTdGF0ZW1lbnQ7XG5leHBvcnRzLmFzc2VydExhYmVsZWRTdGF0ZW1lbnQgPSBhc3NlcnRMYWJlbGVkU3RhdGVtZW50O1xuZXhwb3J0cy5hc3NlcnRTdHJpbmdMaXRlcmFsID0gYXNzZXJ0U3RyaW5nTGl0ZXJhbDtcbmV4cG9ydHMuYXNzZXJ0TnVtZXJpY0xpdGVyYWwgPSBhc3NlcnROdW1lcmljTGl0ZXJhbDtcbmV4cG9ydHMuYXNzZXJ0TnVsbExpdGVyYWwgPSBhc3NlcnROdWxsTGl0ZXJhbDtcbmV4cG9ydHMuYXNzZXJ0Qm9vbGVhbkxpdGVyYWwgPSBhc3NlcnRCb29sZWFuTGl0ZXJhbDtcbmV4cG9ydHMuYXNzZXJ0UmVnRXhwTGl0ZXJhbCA9IGFzc2VydFJlZ0V4cExpdGVyYWw7XG5leHBvcnRzLmFzc2VydExvZ2ljYWxFeHByZXNzaW9uID0gYXNzZXJ0TG9naWNhbEV4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydE1lbWJlckV4cHJlc3Npb24gPSBhc3NlcnRNZW1iZXJFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnROZXdFeHByZXNzaW9uID0gYXNzZXJ0TmV3RXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0UHJvZ3JhbSA9IGFzc2VydFByb2dyYW07XG5leHBvcnRzLmFzc2VydE9iamVjdEV4cHJlc3Npb24gPSBhc3NlcnRPYmplY3RFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRPYmplY3RNZXRob2QgPSBhc3NlcnRPYmplY3RNZXRob2Q7XG5leHBvcnRzLmFzc2VydE9iamVjdFByb3BlcnR5ID0gYXNzZXJ0T2JqZWN0UHJvcGVydHk7XG5leHBvcnRzLmFzc2VydFJlc3RFbGVtZW50ID0gYXNzZXJ0UmVzdEVsZW1lbnQ7XG5leHBvcnRzLmFzc2VydFJldHVyblN0YXRlbWVudCA9IGFzc2VydFJldHVyblN0YXRlbWVudDtcbmV4cG9ydHMuYXNzZXJ0U2VxdWVuY2VFeHByZXNzaW9uID0gYXNzZXJ0U2VxdWVuY2VFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRQYXJlbnRoZXNpemVkRXhwcmVzc2lvbiA9IGFzc2VydFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRTd2l0Y2hDYXNlID0gYXNzZXJ0U3dpdGNoQ2FzZTtcbmV4cG9ydHMuYXNzZXJ0U3dpdGNoU3RhdGVtZW50ID0gYXNzZXJ0U3dpdGNoU3RhdGVtZW50O1xuZXhwb3J0cy5hc3NlcnRUaGlzRXhwcmVzc2lvbiA9IGFzc2VydFRoaXNFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRUaHJvd1N0YXRlbWVudCA9IGFzc2VydFRocm93U3RhdGVtZW50O1xuZXhwb3J0cy5hc3NlcnRUcnlTdGF0ZW1lbnQgPSBhc3NlcnRUcnlTdGF0ZW1lbnQ7XG5leHBvcnRzLmFzc2VydFVuYXJ5RXhwcmVzc2lvbiA9IGFzc2VydFVuYXJ5RXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0VXBkYXRlRXhwcmVzc2lvbiA9IGFzc2VydFVwZGF0ZUV4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydFZhcmlhYmxlRGVjbGFyYXRpb24gPSBhc3NlcnRWYXJpYWJsZURlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnRWYXJpYWJsZURlY2xhcmF0b3IgPSBhc3NlcnRWYXJpYWJsZURlY2xhcmF0b3I7XG5leHBvcnRzLmFzc2VydFdoaWxlU3RhdGVtZW50ID0gYXNzZXJ0V2hpbGVTdGF0ZW1lbnQ7XG5leHBvcnRzLmFzc2VydFdpdGhTdGF0ZW1lbnQgPSBhc3NlcnRXaXRoU3RhdGVtZW50O1xuZXhwb3J0cy5hc3NlcnRBc3NpZ25tZW50UGF0dGVybiA9IGFzc2VydEFzc2lnbm1lbnRQYXR0ZXJuO1xuZXhwb3J0cy5hc3NlcnRBcnJheVBhdHRlcm4gPSBhc3NlcnRBcnJheVBhdHRlcm47XG5leHBvcnRzLmFzc2VydEFycm93RnVuY3Rpb25FeHByZXNzaW9uID0gYXNzZXJ0QXJyb3dGdW5jdGlvbkV4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydENsYXNzQm9keSA9IGFzc2VydENsYXNzQm9keTtcbmV4cG9ydHMuYXNzZXJ0Q2xhc3NFeHByZXNzaW9uID0gYXNzZXJ0Q2xhc3NFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRDbGFzc0RlY2xhcmF0aW9uID0gYXNzZXJ0Q2xhc3NEZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0RXhwb3J0QWxsRGVjbGFyYXRpb24gPSBhc3NlcnRFeHBvcnRBbGxEZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0RXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uID0gYXNzZXJ0RXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnRFeHBvcnROYW1lZERlY2xhcmF0aW9uID0gYXNzZXJ0RXhwb3J0TmFtZWREZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0RXhwb3J0U3BlY2lmaWVyID0gYXNzZXJ0RXhwb3J0U3BlY2lmaWVyO1xuZXhwb3J0cy5hc3NlcnRGb3JPZlN0YXRlbWVudCA9IGFzc2VydEZvck9mU3RhdGVtZW50O1xuZXhwb3J0cy5hc3NlcnRJbXBvcnREZWNsYXJhdGlvbiA9IGFzc2VydEltcG9ydERlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnRJbXBvcnREZWZhdWx0U3BlY2lmaWVyID0gYXNzZXJ0SW1wb3J0RGVmYXVsdFNwZWNpZmllcjtcbmV4cG9ydHMuYXNzZXJ0SW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyID0gYXNzZXJ0SW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyO1xuZXhwb3J0cy5hc3NlcnRJbXBvcnRTcGVjaWZpZXIgPSBhc3NlcnRJbXBvcnRTcGVjaWZpZXI7XG5leHBvcnRzLmFzc2VydE1ldGFQcm9wZXJ0eSA9IGFzc2VydE1ldGFQcm9wZXJ0eTtcbmV4cG9ydHMuYXNzZXJ0Q2xhc3NNZXRob2QgPSBhc3NlcnRDbGFzc01ldGhvZDtcbmV4cG9ydHMuYXNzZXJ0T2JqZWN0UGF0dGVybiA9IGFzc2VydE9iamVjdFBhdHRlcm47XG5leHBvcnRzLmFzc2VydFNwcmVhZEVsZW1lbnQgPSBhc3NlcnRTcHJlYWRFbGVtZW50O1xuZXhwb3J0cy5hc3NlcnRTdXBlciA9IGFzc2VydFN1cGVyO1xuZXhwb3J0cy5hc3NlcnRUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24gPSBhc3NlcnRUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydFRlbXBsYXRlRWxlbWVudCA9IGFzc2VydFRlbXBsYXRlRWxlbWVudDtcbmV4cG9ydHMuYXNzZXJ0VGVtcGxhdGVMaXRlcmFsID0gYXNzZXJ0VGVtcGxhdGVMaXRlcmFsO1xuZXhwb3J0cy5hc3NlcnRZaWVsZEV4cHJlc3Npb24gPSBhc3NlcnRZaWVsZEV4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydEF3YWl0RXhwcmVzc2lvbiA9IGFzc2VydEF3YWl0RXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0SW1wb3J0ID0gYXNzZXJ0SW1wb3J0O1xuZXhwb3J0cy5hc3NlcnRCaWdJbnRMaXRlcmFsID0gYXNzZXJ0QmlnSW50TGl0ZXJhbDtcbmV4cG9ydHMuYXNzZXJ0RXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyID0gYXNzZXJ0RXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyO1xuZXhwb3J0cy5hc3NlcnRPcHRpb25hbE1lbWJlckV4cHJlc3Npb24gPSBhc3NlcnRPcHRpb25hbE1lbWJlckV4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydE9wdGlvbmFsQ2FsbEV4cHJlc3Npb24gPSBhc3NlcnRPcHRpb25hbENhbGxFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRBbnlUeXBlQW5ub3RhdGlvbiA9IGFzc2VydEFueVR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnRBcnJheVR5cGVBbm5vdGF0aW9uID0gYXNzZXJ0QXJyYXlUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0Qm9vbGVhblR5cGVBbm5vdGF0aW9uID0gYXNzZXJ0Qm9vbGVhblR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnRCb29sZWFuTGl0ZXJhbFR5cGVBbm5vdGF0aW9uID0gYXNzZXJ0Qm9vbGVhbkxpdGVyYWxUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0TnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvbiA9IGFzc2VydE51bGxMaXRlcmFsVHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydENsYXNzSW1wbGVtZW50cyA9IGFzc2VydENsYXNzSW1wbGVtZW50cztcbmV4cG9ydHMuYXNzZXJ0RGVjbGFyZUNsYXNzID0gYXNzZXJ0RGVjbGFyZUNsYXNzO1xuZXhwb3J0cy5hc3NlcnREZWNsYXJlRnVuY3Rpb24gPSBhc3NlcnREZWNsYXJlRnVuY3Rpb247XG5leHBvcnRzLmFzc2VydERlY2xhcmVJbnRlcmZhY2UgPSBhc3NlcnREZWNsYXJlSW50ZXJmYWNlO1xuZXhwb3J0cy5hc3NlcnREZWNsYXJlTW9kdWxlID0gYXNzZXJ0RGVjbGFyZU1vZHVsZTtcbmV4cG9ydHMuYXNzZXJ0RGVjbGFyZU1vZHVsZUV4cG9ydHMgPSBhc3NlcnREZWNsYXJlTW9kdWxlRXhwb3J0cztcbmV4cG9ydHMuYXNzZXJ0RGVjbGFyZVR5cGVBbGlhcyA9IGFzc2VydERlY2xhcmVUeXBlQWxpYXM7XG5leHBvcnRzLmFzc2VydERlY2xhcmVPcGFxdWVUeXBlID0gYXNzZXJ0RGVjbGFyZU9wYXF1ZVR5cGU7XG5leHBvcnRzLmFzc2VydERlY2xhcmVWYXJpYWJsZSA9IGFzc2VydERlY2xhcmVWYXJpYWJsZTtcbmV4cG9ydHMuYXNzZXJ0RGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uID0gYXNzZXJ0RGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnREZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb24gPSBhc3NlcnREZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb247XG5leHBvcnRzLmFzc2VydERlY2xhcmVkUHJlZGljYXRlID0gYXNzZXJ0RGVjbGFyZWRQcmVkaWNhdGU7XG5leHBvcnRzLmFzc2VydEV4aXN0c1R5cGVBbm5vdGF0aW9uID0gYXNzZXJ0RXhpc3RzVHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydEZ1bmN0aW9uVHlwZUFubm90YXRpb24gPSBhc3NlcnRGdW5jdGlvblR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnRGdW5jdGlvblR5cGVQYXJhbSA9IGFzc2VydEZ1bmN0aW9uVHlwZVBhcmFtO1xuZXhwb3J0cy5hc3NlcnRHZW5lcmljVHlwZUFubm90YXRpb24gPSBhc3NlcnRHZW5lcmljVHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydEluZmVycmVkUHJlZGljYXRlID0gYXNzZXJ0SW5mZXJyZWRQcmVkaWNhdGU7XG5leHBvcnRzLmFzc2VydEludGVyZmFjZUV4dGVuZHMgPSBhc3NlcnRJbnRlcmZhY2VFeHRlbmRzO1xuZXhwb3J0cy5hc3NlcnRJbnRlcmZhY2VEZWNsYXJhdGlvbiA9IGFzc2VydEludGVyZmFjZURlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnRJbnRlcmZhY2VUeXBlQW5ub3RhdGlvbiA9IGFzc2VydEludGVyZmFjZVR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnRJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvbiA9IGFzc2VydEludGVyc2VjdGlvblR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnRNaXhlZFR5cGVBbm5vdGF0aW9uID0gYXNzZXJ0TWl4ZWRUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0RW1wdHlUeXBlQW5ub3RhdGlvbiA9IGFzc2VydEVtcHR5VHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydE51bGxhYmxlVHlwZUFubm90YXRpb24gPSBhc3NlcnROdWxsYWJsZVR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnROdW1iZXJMaXRlcmFsVHlwZUFubm90YXRpb24gPSBhc3NlcnROdW1iZXJMaXRlcmFsVHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydE51bWJlclR5cGVBbm5vdGF0aW9uID0gYXNzZXJ0TnVtYmVyVHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydE9iamVjdFR5cGVBbm5vdGF0aW9uID0gYXNzZXJ0T2JqZWN0VHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydE9iamVjdFR5cGVJbnRlcm5hbFNsb3QgPSBhc3NlcnRPYmplY3RUeXBlSW50ZXJuYWxTbG90O1xuZXhwb3J0cy5hc3NlcnRPYmplY3RUeXBlQ2FsbFByb3BlcnR5ID0gYXNzZXJ0T2JqZWN0VHlwZUNhbGxQcm9wZXJ0eTtcbmV4cG9ydHMuYXNzZXJ0T2JqZWN0VHlwZUluZGV4ZXIgPSBhc3NlcnRPYmplY3RUeXBlSW5kZXhlcjtcbmV4cG9ydHMuYXNzZXJ0T2JqZWN0VHlwZVByb3BlcnR5ID0gYXNzZXJ0T2JqZWN0VHlwZVByb3BlcnR5O1xuZXhwb3J0cy5hc3NlcnRPYmplY3RUeXBlU3ByZWFkUHJvcGVydHkgPSBhc3NlcnRPYmplY3RUeXBlU3ByZWFkUHJvcGVydHk7XG5leHBvcnRzLmFzc2VydE9wYXF1ZVR5cGUgPSBhc3NlcnRPcGFxdWVUeXBlO1xuZXhwb3J0cy5hc3NlcnRRdWFsaWZpZWRUeXBlSWRlbnRpZmllciA9IGFzc2VydFF1YWxpZmllZFR5cGVJZGVudGlmaWVyO1xuZXhwb3J0cy5hc3NlcnRTdHJpbmdMaXRlcmFsVHlwZUFubm90YXRpb24gPSBhc3NlcnRTdHJpbmdMaXRlcmFsVHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydFN0cmluZ1R5cGVBbm5vdGF0aW9uID0gYXNzZXJ0U3RyaW5nVHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydFN5bWJvbFR5cGVBbm5vdGF0aW9uID0gYXNzZXJ0U3ltYm9sVHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydFRoaXNUeXBlQW5ub3RhdGlvbiA9IGFzc2VydFRoaXNUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0VHVwbGVUeXBlQW5ub3RhdGlvbiA9IGFzc2VydFR1cGxlVHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydFR5cGVvZlR5cGVBbm5vdGF0aW9uID0gYXNzZXJ0VHlwZW9mVHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydFR5cGVBbGlhcyA9IGFzc2VydFR5cGVBbGlhcztcbmV4cG9ydHMuYXNzZXJ0VHlwZUFubm90YXRpb24gPSBhc3NlcnRUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0VHlwZUNhc3RFeHByZXNzaW9uID0gYXNzZXJ0VHlwZUNhc3RFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRUeXBlUGFyYW1ldGVyID0gYXNzZXJ0VHlwZVBhcmFtZXRlcjtcbmV4cG9ydHMuYXNzZXJ0VHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uID0gYXNzZXJ0VHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnRUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbiA9IGFzc2VydFR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uO1xuZXhwb3J0cy5hc3NlcnRVbmlvblR5cGVBbm5vdGF0aW9uID0gYXNzZXJ0VW5pb25UeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0VmFyaWFuY2UgPSBhc3NlcnRWYXJpYW5jZTtcbmV4cG9ydHMuYXNzZXJ0Vm9pZFR5cGVBbm5vdGF0aW9uID0gYXNzZXJ0Vm9pZFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnRFbnVtRGVjbGFyYXRpb24gPSBhc3NlcnRFbnVtRGVjbGFyYXRpb247XG5leHBvcnRzLmFzc2VydEVudW1Cb29sZWFuQm9keSA9IGFzc2VydEVudW1Cb29sZWFuQm9keTtcbmV4cG9ydHMuYXNzZXJ0RW51bU51bWJlckJvZHkgPSBhc3NlcnRFbnVtTnVtYmVyQm9keTtcbmV4cG9ydHMuYXNzZXJ0RW51bVN0cmluZ0JvZHkgPSBhc3NlcnRFbnVtU3RyaW5nQm9keTtcbmV4cG9ydHMuYXNzZXJ0RW51bVN5bWJvbEJvZHkgPSBhc3NlcnRFbnVtU3ltYm9sQm9keTtcbmV4cG9ydHMuYXNzZXJ0RW51bUJvb2xlYW5NZW1iZXIgPSBhc3NlcnRFbnVtQm9vbGVhbk1lbWJlcjtcbmV4cG9ydHMuYXNzZXJ0RW51bU51bWJlck1lbWJlciA9IGFzc2VydEVudW1OdW1iZXJNZW1iZXI7XG5leHBvcnRzLmFzc2VydEVudW1TdHJpbmdNZW1iZXIgPSBhc3NlcnRFbnVtU3RyaW5nTWVtYmVyO1xuZXhwb3J0cy5hc3NlcnRFbnVtRGVmYXVsdGVkTWVtYmVyID0gYXNzZXJ0RW51bURlZmF1bHRlZE1lbWJlcjtcbmV4cG9ydHMuYXNzZXJ0SlNYQXR0cmlidXRlID0gYXNzZXJ0SlNYQXR0cmlidXRlO1xuZXhwb3J0cy5hc3NlcnRKU1hDbG9zaW5nRWxlbWVudCA9IGFzc2VydEpTWENsb3NpbmdFbGVtZW50O1xuZXhwb3J0cy5hc3NlcnRKU1hFbGVtZW50ID0gYXNzZXJ0SlNYRWxlbWVudDtcbmV4cG9ydHMuYXNzZXJ0SlNYRW1wdHlFeHByZXNzaW9uID0gYXNzZXJ0SlNYRW1wdHlFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRKU1hFeHByZXNzaW9uQ29udGFpbmVyID0gYXNzZXJ0SlNYRXhwcmVzc2lvbkNvbnRhaW5lcjtcbmV4cG9ydHMuYXNzZXJ0SlNYU3ByZWFkQ2hpbGQgPSBhc3NlcnRKU1hTcHJlYWRDaGlsZDtcbmV4cG9ydHMuYXNzZXJ0SlNYSWRlbnRpZmllciA9IGFzc2VydEpTWElkZW50aWZpZXI7XG5leHBvcnRzLmFzc2VydEpTWE1lbWJlckV4cHJlc3Npb24gPSBhc3NlcnRKU1hNZW1iZXJFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRKU1hOYW1lc3BhY2VkTmFtZSA9IGFzc2VydEpTWE5hbWVzcGFjZWROYW1lO1xuZXhwb3J0cy5hc3NlcnRKU1hPcGVuaW5nRWxlbWVudCA9IGFzc2VydEpTWE9wZW5pbmdFbGVtZW50O1xuZXhwb3J0cy5hc3NlcnRKU1hTcHJlYWRBdHRyaWJ1dGUgPSBhc3NlcnRKU1hTcHJlYWRBdHRyaWJ1dGU7XG5leHBvcnRzLmFzc2VydEpTWFRleHQgPSBhc3NlcnRKU1hUZXh0O1xuZXhwb3J0cy5hc3NlcnRKU1hGcmFnbWVudCA9IGFzc2VydEpTWEZyYWdtZW50O1xuZXhwb3J0cy5hc3NlcnRKU1hPcGVuaW5nRnJhZ21lbnQgPSBhc3NlcnRKU1hPcGVuaW5nRnJhZ21lbnQ7XG5leHBvcnRzLmFzc2VydEpTWENsb3NpbmdGcmFnbWVudCA9IGFzc2VydEpTWENsb3NpbmdGcmFnbWVudDtcbmV4cG9ydHMuYXNzZXJ0Tm9vcCA9IGFzc2VydE5vb3A7XG5leHBvcnRzLmFzc2VydFBsYWNlaG9sZGVyID0gYXNzZXJ0UGxhY2Vob2xkZXI7XG5leHBvcnRzLmFzc2VydFY4SW50cmluc2ljSWRlbnRpZmllciA9IGFzc2VydFY4SW50cmluc2ljSWRlbnRpZmllcjtcbmV4cG9ydHMuYXNzZXJ0QXJndW1lbnRQbGFjZWhvbGRlciA9IGFzc2VydEFyZ3VtZW50UGxhY2Vob2xkZXI7XG5leHBvcnRzLmFzc2VydEJpbmRFeHByZXNzaW9uID0gYXNzZXJ0QmluZEV4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydENsYXNzUHJvcGVydHkgPSBhc3NlcnRDbGFzc1Byb3BlcnR5O1xuZXhwb3J0cy5hc3NlcnRQaXBlbGluZVRvcGljRXhwcmVzc2lvbiA9IGFzc2VydFBpcGVsaW5lVG9waWNFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRQaXBlbGluZUJhcmVGdW5jdGlvbiA9IGFzc2VydFBpcGVsaW5lQmFyZUZ1bmN0aW9uO1xuZXhwb3J0cy5hc3NlcnRQaXBlbGluZVByaW1hcnlUb3BpY1JlZmVyZW5jZSA9IGFzc2VydFBpcGVsaW5lUHJpbWFyeVRvcGljUmVmZXJlbmNlO1xuZXhwb3J0cy5hc3NlcnRDbGFzc1ByaXZhdGVQcm9wZXJ0eSA9IGFzc2VydENsYXNzUHJpdmF0ZVByb3BlcnR5O1xuZXhwb3J0cy5hc3NlcnRDbGFzc1ByaXZhdGVNZXRob2QgPSBhc3NlcnRDbGFzc1ByaXZhdGVNZXRob2Q7XG5leHBvcnRzLmFzc2VydEltcG9ydEF0dHJpYnV0ZSA9IGFzc2VydEltcG9ydEF0dHJpYnV0ZTtcbmV4cG9ydHMuYXNzZXJ0RGVjb3JhdG9yID0gYXNzZXJ0RGVjb3JhdG9yO1xuZXhwb3J0cy5hc3NlcnREb0V4cHJlc3Npb24gPSBhc3NlcnREb0V4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydEV4cG9ydERlZmF1bHRTcGVjaWZpZXIgPSBhc3NlcnRFeHBvcnREZWZhdWx0U3BlY2lmaWVyO1xuZXhwb3J0cy5hc3NlcnRQcml2YXRlTmFtZSA9IGFzc2VydFByaXZhdGVOYW1lO1xuZXhwb3J0cy5hc3NlcnRSZWNvcmRFeHByZXNzaW9uID0gYXNzZXJ0UmVjb3JkRXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0VHVwbGVFeHByZXNzaW9uID0gYXNzZXJ0VHVwbGVFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnREZWNpbWFsTGl0ZXJhbCA9IGFzc2VydERlY2ltYWxMaXRlcmFsO1xuZXhwb3J0cy5hc3NlcnRUU1BhcmFtZXRlclByb3BlcnR5ID0gYXNzZXJ0VFNQYXJhbWV0ZXJQcm9wZXJ0eTtcbmV4cG9ydHMuYXNzZXJ0VFNEZWNsYXJlRnVuY3Rpb24gPSBhc3NlcnRUU0RlY2xhcmVGdW5jdGlvbjtcbmV4cG9ydHMuYXNzZXJ0VFNEZWNsYXJlTWV0aG9kID0gYXNzZXJ0VFNEZWNsYXJlTWV0aG9kO1xuZXhwb3J0cy5hc3NlcnRUU1F1YWxpZmllZE5hbWUgPSBhc3NlcnRUU1F1YWxpZmllZE5hbWU7XG5leHBvcnRzLmFzc2VydFRTQ2FsbFNpZ25hdHVyZURlY2xhcmF0aW9uID0gYXNzZXJ0VFNDYWxsU2lnbmF0dXJlRGVjbGFyYXRpb247XG5leHBvcnRzLmFzc2VydFRTQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb24gPSBhc3NlcnRUU0NvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnRUU1Byb3BlcnR5U2lnbmF0dXJlID0gYXNzZXJ0VFNQcm9wZXJ0eVNpZ25hdHVyZTtcbmV4cG9ydHMuYXNzZXJ0VFNNZXRob2RTaWduYXR1cmUgPSBhc3NlcnRUU01ldGhvZFNpZ25hdHVyZTtcbmV4cG9ydHMuYXNzZXJ0VFNJbmRleFNpZ25hdHVyZSA9IGFzc2VydFRTSW5kZXhTaWduYXR1cmU7XG5leHBvcnRzLmFzc2VydFRTQW55S2V5d29yZCA9IGFzc2VydFRTQW55S2V5d29yZDtcbmV4cG9ydHMuYXNzZXJ0VFNCb29sZWFuS2V5d29yZCA9IGFzc2VydFRTQm9vbGVhbktleXdvcmQ7XG5leHBvcnRzLmFzc2VydFRTQmlnSW50S2V5d29yZCA9IGFzc2VydFRTQmlnSW50S2V5d29yZDtcbmV4cG9ydHMuYXNzZXJ0VFNOZXZlcktleXdvcmQgPSBhc3NlcnRUU05ldmVyS2V5d29yZDtcbmV4cG9ydHMuYXNzZXJ0VFNOdWxsS2V5d29yZCA9IGFzc2VydFRTTnVsbEtleXdvcmQ7XG5leHBvcnRzLmFzc2VydFRTTnVtYmVyS2V5d29yZCA9IGFzc2VydFRTTnVtYmVyS2V5d29yZDtcbmV4cG9ydHMuYXNzZXJ0VFNPYmplY3RLZXl3b3JkID0gYXNzZXJ0VFNPYmplY3RLZXl3b3JkO1xuZXhwb3J0cy5hc3NlcnRUU1N0cmluZ0tleXdvcmQgPSBhc3NlcnRUU1N0cmluZ0tleXdvcmQ7XG5leHBvcnRzLmFzc2VydFRTU3ltYm9sS2V5d29yZCA9IGFzc2VydFRTU3ltYm9sS2V5d29yZDtcbmV4cG9ydHMuYXNzZXJ0VFNVbmRlZmluZWRLZXl3b3JkID0gYXNzZXJ0VFNVbmRlZmluZWRLZXl3b3JkO1xuZXhwb3J0cy5hc3NlcnRUU1Vua25vd25LZXl3b3JkID0gYXNzZXJ0VFNVbmtub3duS2V5d29yZDtcbmV4cG9ydHMuYXNzZXJ0VFNWb2lkS2V5d29yZCA9IGFzc2VydFRTVm9pZEtleXdvcmQ7XG5leHBvcnRzLmFzc2VydFRTVGhpc1R5cGUgPSBhc3NlcnRUU1RoaXNUeXBlO1xuZXhwb3J0cy5hc3NlcnRUU0Z1bmN0aW9uVHlwZSA9IGFzc2VydFRTRnVuY3Rpb25UeXBlO1xuZXhwb3J0cy5hc3NlcnRUU0NvbnN0cnVjdG9yVHlwZSA9IGFzc2VydFRTQ29uc3RydWN0b3JUeXBlO1xuZXhwb3J0cy5hc3NlcnRUU1R5cGVSZWZlcmVuY2UgPSBhc3NlcnRUU1R5cGVSZWZlcmVuY2U7XG5leHBvcnRzLmFzc2VydFRTVHlwZVByZWRpY2F0ZSA9IGFzc2VydFRTVHlwZVByZWRpY2F0ZTtcbmV4cG9ydHMuYXNzZXJ0VFNUeXBlUXVlcnkgPSBhc3NlcnRUU1R5cGVRdWVyeTtcbmV4cG9ydHMuYXNzZXJ0VFNUeXBlTGl0ZXJhbCA9IGFzc2VydFRTVHlwZUxpdGVyYWw7XG5leHBvcnRzLmFzc2VydFRTQXJyYXlUeXBlID0gYXNzZXJ0VFNBcnJheVR5cGU7XG5leHBvcnRzLmFzc2VydFRTVHVwbGVUeXBlID0gYXNzZXJ0VFNUdXBsZVR5cGU7XG5leHBvcnRzLmFzc2VydFRTT3B0aW9uYWxUeXBlID0gYXNzZXJ0VFNPcHRpb25hbFR5cGU7XG5leHBvcnRzLmFzc2VydFRTUmVzdFR5cGUgPSBhc3NlcnRUU1Jlc3RUeXBlO1xuZXhwb3J0cy5hc3NlcnRUU05hbWVkVHVwbGVNZW1iZXIgPSBhc3NlcnRUU05hbWVkVHVwbGVNZW1iZXI7XG5leHBvcnRzLmFzc2VydFRTVW5pb25UeXBlID0gYXNzZXJ0VFNVbmlvblR5cGU7XG5leHBvcnRzLmFzc2VydFRTSW50ZXJzZWN0aW9uVHlwZSA9IGFzc2VydFRTSW50ZXJzZWN0aW9uVHlwZTtcbmV4cG9ydHMuYXNzZXJ0VFNDb25kaXRpb25hbFR5cGUgPSBhc3NlcnRUU0NvbmRpdGlvbmFsVHlwZTtcbmV4cG9ydHMuYXNzZXJ0VFNJbmZlclR5cGUgPSBhc3NlcnRUU0luZmVyVHlwZTtcbmV4cG9ydHMuYXNzZXJ0VFNQYXJlbnRoZXNpemVkVHlwZSA9IGFzc2VydFRTUGFyZW50aGVzaXplZFR5cGU7XG5leHBvcnRzLmFzc2VydFRTVHlwZU9wZXJhdG9yID0gYXNzZXJ0VFNUeXBlT3BlcmF0b3I7XG5leHBvcnRzLmFzc2VydFRTSW5kZXhlZEFjY2Vzc1R5cGUgPSBhc3NlcnRUU0luZGV4ZWRBY2Nlc3NUeXBlO1xuZXhwb3J0cy5hc3NlcnRUU01hcHBlZFR5cGUgPSBhc3NlcnRUU01hcHBlZFR5cGU7XG5leHBvcnRzLmFzc2VydFRTTGl0ZXJhbFR5cGUgPSBhc3NlcnRUU0xpdGVyYWxUeXBlO1xuZXhwb3J0cy5hc3NlcnRUU0V4cHJlc3Npb25XaXRoVHlwZUFyZ3VtZW50cyA9IGFzc2VydFRTRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzO1xuZXhwb3J0cy5hc3NlcnRUU0ludGVyZmFjZURlY2xhcmF0aW9uID0gYXNzZXJ0VFNJbnRlcmZhY2VEZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0VFNJbnRlcmZhY2VCb2R5ID0gYXNzZXJ0VFNJbnRlcmZhY2VCb2R5O1xuZXhwb3J0cy5hc3NlcnRUU1R5cGVBbGlhc0RlY2xhcmF0aW9uID0gYXNzZXJ0VFNUeXBlQWxpYXNEZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0VFNBc0V4cHJlc3Npb24gPSBhc3NlcnRUU0FzRXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0VFNUeXBlQXNzZXJ0aW9uID0gYXNzZXJ0VFNUeXBlQXNzZXJ0aW9uO1xuZXhwb3J0cy5hc3NlcnRUU0VudW1EZWNsYXJhdGlvbiA9IGFzc2VydFRTRW51bURlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnRUU0VudW1NZW1iZXIgPSBhc3NlcnRUU0VudW1NZW1iZXI7XG5leHBvcnRzLmFzc2VydFRTTW9kdWxlRGVjbGFyYXRpb24gPSBhc3NlcnRUU01vZHVsZURlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnRUU01vZHVsZUJsb2NrID0gYXNzZXJ0VFNNb2R1bGVCbG9jaztcbmV4cG9ydHMuYXNzZXJ0VFNJbXBvcnRUeXBlID0gYXNzZXJ0VFNJbXBvcnRUeXBlO1xuZXhwb3J0cy5hc3NlcnRUU0ltcG9ydEVxdWFsc0RlY2xhcmF0aW9uID0gYXNzZXJ0VFNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0VFNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZSA9IGFzc2VydFRTRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2U7XG5leHBvcnRzLmFzc2VydFRTTm9uTnVsbEV4cHJlc3Npb24gPSBhc3NlcnRUU05vbk51bGxFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRUU0V4cG9ydEFzc2lnbm1lbnQgPSBhc3NlcnRUU0V4cG9ydEFzc2lnbm1lbnQ7XG5leHBvcnRzLmFzc2VydFRTTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb24gPSBhc3NlcnRUU05hbWVzcGFjZUV4cG9ydERlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnRUU1R5cGVBbm5vdGF0aW9uID0gYXNzZXJ0VFNUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0VFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbiA9IGFzc2VydFRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb247XG5leHBvcnRzLmFzc2VydFRTVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uID0gYXNzZXJ0VFNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb247XG5leHBvcnRzLmFzc2VydFRTVHlwZVBhcmFtZXRlciA9IGFzc2VydFRTVHlwZVBhcmFtZXRlcjtcbmV4cG9ydHMuYXNzZXJ0RXhwcmVzc2lvbiA9IGFzc2VydEV4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydEJpbmFyeSA9IGFzc2VydEJpbmFyeTtcbmV4cG9ydHMuYXNzZXJ0U2NvcGFibGUgPSBhc3NlcnRTY29wYWJsZTtcbmV4cG9ydHMuYXNzZXJ0QmxvY2tQYXJlbnQgPSBhc3NlcnRCbG9ja1BhcmVudDtcbmV4cG9ydHMuYXNzZXJ0QmxvY2sgPSBhc3NlcnRCbG9jaztcbmV4cG9ydHMuYXNzZXJ0U3RhdGVtZW50ID0gYXNzZXJ0U3RhdGVtZW50O1xuZXhwb3J0cy5hc3NlcnRUZXJtaW5hdG9ybGVzcyA9IGFzc2VydFRlcm1pbmF0b3JsZXNzO1xuZXhwb3J0cy5hc3NlcnRDb21wbGV0aW9uU3RhdGVtZW50ID0gYXNzZXJ0Q29tcGxldGlvblN0YXRlbWVudDtcbmV4cG9ydHMuYXNzZXJ0Q29uZGl0aW9uYWwgPSBhc3NlcnRDb25kaXRpb25hbDtcbmV4cG9ydHMuYXNzZXJ0TG9vcCA9IGFzc2VydExvb3A7XG5leHBvcnRzLmFzc2VydFdoaWxlID0gYXNzZXJ0V2hpbGU7XG5leHBvcnRzLmFzc2VydEV4cHJlc3Npb25XcmFwcGVyID0gYXNzZXJ0RXhwcmVzc2lvbldyYXBwZXI7XG5leHBvcnRzLmFzc2VydEZvciA9IGFzc2VydEZvcjtcbmV4cG9ydHMuYXNzZXJ0Rm9yWFN0YXRlbWVudCA9IGFzc2VydEZvclhTdGF0ZW1lbnQ7XG5leHBvcnRzLmFzc2VydEZ1bmN0aW9uID0gYXNzZXJ0RnVuY3Rpb247XG5leHBvcnRzLmFzc2VydEZ1bmN0aW9uUGFyZW50ID0gYXNzZXJ0RnVuY3Rpb25QYXJlbnQ7XG5leHBvcnRzLmFzc2VydFB1cmVpc2ggPSBhc3NlcnRQdXJlaXNoO1xuZXhwb3J0cy5hc3NlcnREZWNsYXJhdGlvbiA9IGFzc2VydERlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnRQYXR0ZXJuTGlrZSA9IGFzc2VydFBhdHRlcm5MaWtlO1xuZXhwb3J0cy5hc3NlcnRMVmFsID0gYXNzZXJ0TFZhbDtcbmV4cG9ydHMuYXNzZXJ0VFNFbnRpdHlOYW1lID0gYXNzZXJ0VFNFbnRpdHlOYW1lO1xuZXhwb3J0cy5hc3NlcnRMaXRlcmFsID0gYXNzZXJ0TGl0ZXJhbDtcbmV4cG9ydHMuYXNzZXJ0SW1tdXRhYmxlID0gYXNzZXJ0SW1tdXRhYmxlO1xuZXhwb3J0cy5hc3NlcnRVc2VyV2hpdGVzcGFjYWJsZSA9IGFzc2VydFVzZXJXaGl0ZXNwYWNhYmxlO1xuZXhwb3J0cy5hc3NlcnRNZXRob2QgPSBhc3NlcnRNZXRob2Q7XG5leHBvcnRzLmFzc2VydE9iamVjdE1lbWJlciA9IGFzc2VydE9iamVjdE1lbWJlcjtcbmV4cG9ydHMuYXNzZXJ0UHJvcGVydHkgPSBhc3NlcnRQcm9wZXJ0eTtcbmV4cG9ydHMuYXNzZXJ0VW5hcnlMaWtlID0gYXNzZXJ0VW5hcnlMaWtlO1xuZXhwb3J0cy5hc3NlcnRQYXR0ZXJuID0gYXNzZXJ0UGF0dGVybjtcbmV4cG9ydHMuYXNzZXJ0Q2xhc3MgPSBhc3NlcnRDbGFzcztcbmV4cG9ydHMuYXNzZXJ0TW9kdWxlRGVjbGFyYXRpb24gPSBhc3NlcnRNb2R1bGVEZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0RXhwb3J0RGVjbGFyYXRpb24gPSBhc3NlcnRFeHBvcnREZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0TW9kdWxlU3BlY2lmaWVyID0gYXNzZXJ0TW9kdWxlU3BlY2lmaWVyO1xuZXhwb3J0cy5hc3NlcnRGbG93ID0gYXNzZXJ0RmxvdztcbmV4cG9ydHMuYXNzZXJ0Rmxvd1R5cGUgPSBhc3NlcnRGbG93VHlwZTtcbmV4cG9ydHMuYXNzZXJ0Rmxvd0Jhc2VBbm5vdGF0aW9uID0gYXNzZXJ0Rmxvd0Jhc2VBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnRGbG93RGVjbGFyYXRpb24gPSBhc3NlcnRGbG93RGVjbGFyYXRpb247XG5leHBvcnRzLmFzc2VydEZsb3dQcmVkaWNhdGUgPSBhc3NlcnRGbG93UHJlZGljYXRlO1xuZXhwb3J0cy5hc3NlcnRFbnVtQm9keSA9IGFzc2VydEVudW1Cb2R5O1xuZXhwb3J0cy5hc3NlcnRFbnVtTWVtYmVyID0gYXNzZXJ0RW51bU1lbWJlcjtcbmV4cG9ydHMuYXNzZXJ0SlNYID0gYXNzZXJ0SlNYO1xuZXhwb3J0cy5hc3NlcnRQcml2YXRlID0gYXNzZXJ0UHJpdmF0ZTtcbmV4cG9ydHMuYXNzZXJ0VFNUeXBlRWxlbWVudCA9IGFzc2VydFRTVHlwZUVsZW1lbnQ7XG5leHBvcnRzLmFzc2VydFRTVHlwZSA9IGFzc2VydFRTVHlwZTtcbmV4cG9ydHMuYXNzZXJ0VFNCYXNlVHlwZSA9IGFzc2VydFRTQmFzZVR5cGU7XG5leHBvcnRzLmFzc2VydE51bWJlckxpdGVyYWwgPSBhc3NlcnROdW1iZXJMaXRlcmFsO1xuZXhwb3J0cy5hc3NlcnRSZWdleExpdGVyYWwgPSBhc3NlcnRSZWdleExpdGVyYWw7XG5leHBvcnRzLmFzc2VydFJlc3RQcm9wZXJ0eSA9IGFzc2VydFJlc3RQcm9wZXJ0eTtcbmV4cG9ydHMuYXNzZXJ0U3ByZWFkUHJvcGVydHkgPSBhc3NlcnRTcHJlYWRQcm9wZXJ0eTtcblxudmFyIF9pcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uL3ZhbGlkYXRvcnMvaXNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBhc3NlcnQodHlwZSwgbm9kZSwgb3B0cykge1xuICBpZiAoISgwLCBfaXMuZGVmYXVsdCkodHlwZSwgbm9kZSwgb3B0cykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIHR5cGUgXCIke3R5cGV9XCIgd2l0aCBvcHRpb24gJHtKU09OLnN0cmluZ2lmeShvcHRzKX0sIGAgKyBgYnV0IGluc3RlYWQgZ290IFwiJHtub2RlLnR5cGV9XCIuYCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0QXJyYXlFeHByZXNzaW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJBcnJheUV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEFzc2lnbm1lbnRFeHByZXNzaW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0QmluYXJ5RXhwcmVzc2lvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiQmluYXJ5RXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SW50ZXJwcmV0ZXJEaXJlY3RpdmUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkludGVycHJldGVyRGlyZWN0aXZlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnREaXJlY3RpdmUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkRpcmVjdGl2ZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RGlyZWN0aXZlTGl0ZXJhbChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRGlyZWN0aXZlTGl0ZXJhbFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0QmxvY2tTdGF0ZW1lbnQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkJsb2NrU3RhdGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRCcmVha1N0YXRlbWVudChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiQnJlYWtTdGF0ZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydENhbGxFeHByZXNzaW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJDYWxsRXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Q2F0Y2hDbGF1c2Uobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkNhdGNoQ2xhdXNlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRDb25kaXRpb25hbEV4cHJlc3Npb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Q29udGludWVTdGF0ZW1lbnQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkNvbnRpbnVlU3RhdGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnREZWJ1Z2dlclN0YXRlbWVudChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRGVidWdnZXJTdGF0ZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydERvV2hpbGVTdGF0ZW1lbnQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkRvV2hpbGVTdGF0ZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEVtcHR5U3RhdGVtZW50KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJFbXB0eVN0YXRlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RXhwcmVzc2lvblN0YXRlbWVudChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRXhwcmVzc2lvblN0YXRlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RmlsZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRmlsZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Rm9ySW5TdGF0ZW1lbnQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkZvckluU3RhdGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRGb3JTdGF0ZW1lbnQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkZvclN0YXRlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RnVuY3Rpb25EZWNsYXJhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RnVuY3Rpb25FeHByZXNzaW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJGdW5jdGlvbkV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydElkZW50aWZpZXIobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIklkZW50aWZpZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydElmU3RhdGVtZW50KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJJZlN0YXRlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0TGFiZWxlZFN0YXRlbWVudChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiTGFiZWxlZFN0YXRlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0U3RyaW5nTGl0ZXJhbChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiU3RyaW5nTGl0ZXJhbFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0TnVtZXJpY0xpdGVyYWwobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIk51bWVyaWNMaXRlcmFsXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnROdWxsTGl0ZXJhbChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiTnVsbExpdGVyYWxcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEJvb2xlYW5MaXRlcmFsKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJCb29sZWFuTGl0ZXJhbFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0UmVnRXhwTGl0ZXJhbChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiUmVnRXhwTGl0ZXJhbFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0TG9naWNhbEV4cHJlc3Npb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkxvZ2ljYWxFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRNZW1iZXJFeHByZXNzaW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJNZW1iZXJFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnROZXdFeHByZXNzaW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJOZXdFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRQcm9ncmFtKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJQcm9ncmFtXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRPYmplY3RFeHByZXNzaW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJPYmplY3RFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRPYmplY3RNZXRob2Qobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIk9iamVjdE1ldGhvZFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0UHJvcGVydHkobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIk9iamVjdFByb3BlcnR5XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRSZXN0RWxlbWVudChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiUmVzdEVsZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFJldHVyblN0YXRlbWVudChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiUmV0dXJuU3RhdGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRTZXF1ZW5jZUV4cHJlc3Npb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlNlcXVlbmNlRXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0UGFyZW50aGVzaXplZEV4cHJlc3Npb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRTd2l0Y2hDYXNlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJTd2l0Y2hDYXNlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRTd2l0Y2hTdGF0ZW1lbnQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlN3aXRjaFN0YXRlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VGhpc0V4cHJlc3Npb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRoaXNFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUaHJvd1N0YXRlbWVudChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVGhyb3dTdGF0ZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRyeVN0YXRlbWVudChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVHJ5U3RhdGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRVbmFyeUV4cHJlc3Npb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlVuYXJ5RXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VXBkYXRlRXhwcmVzc2lvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVXBkYXRlRXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VmFyaWFibGVEZWNsYXJhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVmFyaWFibGVEZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VmFyaWFibGVEZWNsYXJhdG9yKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJWYXJpYWJsZURlY2xhcmF0b3JcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFdoaWxlU3RhdGVtZW50KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJXaGlsZVN0YXRlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0V2l0aFN0YXRlbWVudChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiV2l0aFN0YXRlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0QXNzaWdubWVudFBhdHRlcm4obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkFzc2lnbm1lbnRQYXR0ZXJuXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRBcnJheVBhdHRlcm4obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkFycmF5UGF0dGVyblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0QXJyb3dGdW5jdGlvbkV4cHJlc3Npb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRDbGFzc0JvZHkobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkNsYXNzQm9keVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Q2xhc3NFeHByZXNzaW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJDbGFzc0V4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydENsYXNzRGVjbGFyYXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkNsYXNzRGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEV4cG9ydEFsbERlY2xhcmF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEV4cG9ydE5hbWVkRGVjbGFyYXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEV4cG9ydFNwZWNpZmllcihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRXhwb3J0U3BlY2lmaWVyXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRGb3JPZlN0YXRlbWVudChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRm9yT2ZTdGF0ZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEltcG9ydERlY2xhcmF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJJbXBvcnREZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SW1wb3J0RGVmYXVsdFNwZWNpZmllcihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiSW1wb3J0RGVmYXVsdFNwZWNpZmllclwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEltcG9ydFNwZWNpZmllcihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiSW1wb3J0U3BlY2lmaWVyXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRNZXRhUHJvcGVydHkobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIk1ldGFQcm9wZXJ0eVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Q2xhc3NNZXRob2Qobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkNsYXNzTWV0aG9kXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRPYmplY3RQYXR0ZXJuKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJPYmplY3RQYXR0ZXJuXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRTcHJlYWRFbGVtZW50KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJTcHJlYWRFbGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRTdXBlcihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiU3VwZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUZW1wbGF0ZUVsZW1lbnQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRlbXBsYXRlRWxlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VGVtcGxhdGVMaXRlcmFsKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUZW1wbGF0ZUxpdGVyYWxcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFlpZWxkRXhwcmVzc2lvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiWWllbGRFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRBd2FpdEV4cHJlc3Npb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkF3YWl0RXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SW1wb3J0KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJJbXBvcnRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEJpZ0ludExpdGVyYWwobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkJpZ0ludExpdGVyYWxcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEV4cG9ydE5hbWVzcGFjZVNwZWNpZmllcihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRPcHRpb25hbE1lbWJlckV4cHJlc3Npb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0T3B0aW9uYWxDYWxsRXhwcmVzc2lvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0QW55VHlwZUFubm90YXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkFueVR5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRBcnJheVR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJBcnJheVR5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRCb29sZWFuVHlwZUFubm90YXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkJvb2xlYW5UeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Qm9vbGVhbkxpdGVyYWxUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiQm9vbGVhbkxpdGVyYWxUeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0TnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiTnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Q2xhc3NJbXBsZW1lbnRzKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJDbGFzc0ltcGxlbWVudHNcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydERlY2xhcmVDbGFzcyhub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRGVjbGFyZUNsYXNzXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnREZWNsYXJlRnVuY3Rpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkRlY2xhcmVGdW5jdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RGVjbGFyZUludGVyZmFjZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRGVjbGFyZUludGVyZmFjZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RGVjbGFyZU1vZHVsZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRGVjbGFyZU1vZHVsZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RGVjbGFyZU1vZHVsZUV4cG9ydHMobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkRlY2xhcmVNb2R1bGVFeHBvcnRzXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnREZWNsYXJlVHlwZUFsaWFzKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJEZWNsYXJlVHlwZUFsaWFzXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnREZWNsYXJlT3BhcXVlVHlwZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRGVjbGFyZU9wYXF1ZVR5cGVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydERlY2xhcmVWYXJpYWJsZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRGVjbGFyZVZhcmlhYmxlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnREZWNsYXJlRXhwb3J0RGVjbGFyYXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkRlY2xhcmVFeHBvcnREZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJEZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydERlY2xhcmVkUHJlZGljYXRlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJEZWNsYXJlZFByZWRpY2F0ZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RXhpc3RzVHlwZUFubm90YXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkV4aXN0c1R5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRGdW5jdGlvblR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRGdW5jdGlvblR5cGVQYXJhbShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRnVuY3Rpb25UeXBlUGFyYW1cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEdlbmVyaWNUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiR2VuZXJpY1R5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRJbmZlcnJlZFByZWRpY2F0ZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiSW5mZXJyZWRQcmVkaWNhdGVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEludGVyZmFjZUV4dGVuZHMobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkludGVyZmFjZUV4dGVuZHNcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEludGVyZmFjZURlY2xhcmF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJJbnRlcmZhY2VEZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SW50ZXJmYWNlVHlwZUFubm90YXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkludGVyZmFjZVR5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiSW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE1peGVkVHlwZUFubm90YXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIk1peGVkVHlwZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEVtcHR5VHlwZUFubm90YXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkVtcHR5VHlwZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE51bGxhYmxlVHlwZUFubm90YXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIk51bGxhYmxlVHlwZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE51bWJlckxpdGVyYWxUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiTnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnROdW1iZXJUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiTnVtYmVyVHlwZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE9iamVjdFR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJPYmplY3RUeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0VHlwZUludGVybmFsU2xvdChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiT2JqZWN0VHlwZUludGVybmFsU2xvdFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0VHlwZUNhbGxQcm9wZXJ0eShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0VHlwZUluZGV4ZXIobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIk9iamVjdFR5cGVJbmRleGVyXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRPYmplY3RUeXBlUHJvcGVydHkobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIk9iamVjdFR5cGVQcm9wZXJ0eVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0VHlwZVNwcmVhZFByb3BlcnR5KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJPYmplY3RUeXBlU3ByZWFkUHJvcGVydHlcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE9wYXF1ZVR5cGUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIk9wYXF1ZVR5cGVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFF1YWxpZmllZFR5cGVJZGVudGlmaWVyKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJRdWFsaWZpZWRUeXBlSWRlbnRpZmllclwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0U3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJTdHJpbmdMaXRlcmFsVHlwZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFN0cmluZ1R5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJTdHJpbmdUeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0U3ltYm9sVHlwZUFubm90YXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlN5bWJvbFR5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUaGlzVHlwZUFubm90YXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRoaXNUeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VHVwbGVUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVHVwbGVUeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VHlwZW9mVHlwZUFubm90YXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlR5cGVvZlR5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUeXBlQWxpYXMobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlR5cGVBbGlhc1wiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VHlwZUFubm90YXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlR5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUeXBlQ2FzdEV4cHJlc3Npb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlR5cGVDYXN0RXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VHlwZVBhcmFtZXRlcihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVHlwZVBhcmFtZXRlclwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VW5pb25UeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVW5pb25UeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VmFyaWFuY2Uobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlZhcmlhbmNlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRWb2lkVHlwZUFubm90YXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlZvaWRUeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RW51bURlY2xhcmF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJFbnVtRGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEVudW1Cb29sZWFuQm9keShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRW51bUJvb2xlYW5Cb2R5XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRFbnVtTnVtYmVyQm9keShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRW51bU51bWJlckJvZHlcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEVudW1TdHJpbmdCb2R5KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJFbnVtU3RyaW5nQm9keVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RW51bVN5bWJvbEJvZHkobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkVudW1TeW1ib2xCb2R5XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRFbnVtQm9vbGVhbk1lbWJlcihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRW51bUJvb2xlYW5NZW1iZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEVudW1OdW1iZXJNZW1iZXIobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkVudW1OdW1iZXJNZW1iZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEVudW1TdHJpbmdNZW1iZXIobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkVudW1TdHJpbmdNZW1iZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEVudW1EZWZhdWx0ZWRNZW1iZXIobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkVudW1EZWZhdWx0ZWRNZW1iZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEpTWEF0dHJpYnV0ZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiSlNYQXR0cmlidXRlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRKU1hDbG9zaW5nRWxlbWVudChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiSlNYQ2xvc2luZ0VsZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEpTWEVsZW1lbnQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkpTWEVsZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEpTWEVtcHR5RXhwcmVzc2lvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiSlNYRW1wdHlFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRKU1hFeHByZXNzaW9uQ29udGFpbmVyKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJKU1hFeHByZXNzaW9uQ29udGFpbmVyXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRKU1hTcHJlYWRDaGlsZChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiSlNYU3ByZWFkQ2hpbGRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEpTWElkZW50aWZpZXIobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkpTWElkZW50aWZpZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEpTWE1lbWJlckV4cHJlc3Npb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkpTWE1lbWJlckV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEpTWE5hbWVzcGFjZWROYW1lKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJKU1hOYW1lc3BhY2VkTmFtZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SlNYT3BlbmluZ0VsZW1lbnQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkpTWE9wZW5pbmdFbGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRKU1hTcHJlYWRBdHRyaWJ1dGUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkpTWFNwcmVhZEF0dHJpYnV0ZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SlNYVGV4dChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiSlNYVGV4dFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SlNYRnJhZ21lbnQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkpTWEZyYWdtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRKU1hPcGVuaW5nRnJhZ21lbnQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkpTWE9wZW5pbmdGcmFnbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SlNYQ2xvc2luZ0ZyYWdtZW50KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJKU1hDbG9zaW5nRnJhZ21lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE5vb3Aobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIk5vb3BcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFBsYWNlaG9sZGVyKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJQbGFjZWhvbGRlclwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VjhJbnRyaW5zaWNJZGVudGlmaWVyKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJWOEludHJpbnNpY0lkZW50aWZpZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEFyZ3VtZW50UGxhY2Vob2xkZXIobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkFyZ3VtZW50UGxhY2Vob2xkZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEJpbmRFeHByZXNzaW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJCaW5kRXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Q2xhc3NQcm9wZXJ0eShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiQ2xhc3NQcm9wZXJ0eVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0UGlwZWxpbmVUb3BpY0V4cHJlc3Npb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlBpcGVsaW5lVG9waWNFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRQaXBlbGluZUJhcmVGdW5jdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiUGlwZWxpbmVCYXJlRnVuY3Rpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFBpcGVsaW5lUHJpbWFyeVRvcGljUmVmZXJlbmNlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJQaXBlbGluZVByaW1hcnlUb3BpY1JlZmVyZW5jZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Q2xhc3NQcml2YXRlUHJvcGVydHkobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkNsYXNzUHJpdmF0ZVByb3BlcnR5XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRDbGFzc1ByaXZhdGVNZXRob2Qobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkNsYXNzUHJpdmF0ZU1ldGhvZFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SW1wb3J0QXR0cmlidXRlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJJbXBvcnRBdHRyaWJ1dGVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydERlY29yYXRvcihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRGVjb3JhdG9yXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnREb0V4cHJlc3Npb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkRvRXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RXhwb3J0RGVmYXVsdFNwZWNpZmllcihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRXhwb3J0RGVmYXVsdFNwZWNpZmllclwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0UHJpdmF0ZU5hbWUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlByaXZhdGVOYW1lXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRSZWNvcmRFeHByZXNzaW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJSZWNvcmRFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUdXBsZUV4cHJlc3Npb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlR1cGxlRXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RGVjaW1hbExpdGVyYWwobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkRlY2ltYWxMaXRlcmFsXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU1BhcmFtZXRlclByb3BlcnR5KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU1BhcmFtZXRlclByb3BlcnR5XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU0RlY2xhcmVGdW5jdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNEZWNsYXJlRnVuY3Rpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTRGVjbGFyZU1ldGhvZChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNEZWNsYXJlTWV0aG9kXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU1F1YWxpZmllZE5hbWUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTUXVhbGlmaWVkTmFtZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNDYWxsU2lnbmF0dXJlRGVjbGFyYXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTQ2FsbFNpZ25hdHVyZURlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU0NvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU0NvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU1Byb3BlcnR5U2lnbmF0dXJlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU1Byb3BlcnR5U2lnbmF0dXJlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU01ldGhvZFNpZ25hdHVyZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNNZXRob2RTaWduYXR1cmVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTSW5kZXhTaWduYXR1cmUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTSW5kZXhTaWduYXR1cmVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTQW55S2V5d29yZChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNBbnlLZXl3b3JkXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU0Jvb2xlYW5LZXl3b3JkKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU0Jvb2xlYW5LZXl3b3JkXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU0JpZ0ludEtleXdvcmQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTQmlnSW50S2V5d29yZFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNOZXZlcktleXdvcmQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTTmV2ZXJLZXl3b3JkXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU051bGxLZXl3b3JkKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU051bGxLZXl3b3JkXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU051bWJlcktleXdvcmQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTTnVtYmVyS2V5d29yZFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNPYmplY3RLZXl3b3JkKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU09iamVjdEtleXdvcmRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTU3RyaW5nS2V5d29yZChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNTdHJpbmdLZXl3b3JkXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU1N5bWJvbEtleXdvcmQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTU3ltYm9sS2V5d29yZFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNVbmRlZmluZWRLZXl3b3JkKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU1VuZGVmaW5lZEtleXdvcmRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTVW5rbm93bktleXdvcmQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTVW5rbm93bktleXdvcmRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTVm9pZEtleXdvcmQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTVm9pZEtleXdvcmRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTVGhpc1R5cGUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTVGhpc1R5cGVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTRnVuY3Rpb25UeXBlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU0Z1bmN0aW9uVHlwZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNDb25zdHJ1Y3RvclR5cGUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTQ29uc3RydWN0b3JUeXBlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU1R5cGVSZWZlcmVuY2Uobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTVHlwZVJlZmVyZW5jZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNUeXBlUHJlZGljYXRlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU1R5cGVQcmVkaWNhdGVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTVHlwZVF1ZXJ5KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU1R5cGVRdWVyeVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNUeXBlTGl0ZXJhbChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNUeXBlTGl0ZXJhbFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNBcnJheVR5cGUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTQXJyYXlUeXBlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU1R1cGxlVHlwZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNUdXBsZVR5cGVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTT3B0aW9uYWxUeXBlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU09wdGlvbmFsVHlwZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNSZXN0VHlwZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNSZXN0VHlwZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNOYW1lZFR1cGxlTWVtYmVyKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU05hbWVkVHVwbGVNZW1iZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTVW5pb25UeXBlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU1VuaW9uVHlwZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNJbnRlcnNlY3Rpb25UeXBlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU0ludGVyc2VjdGlvblR5cGVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTQ29uZGl0aW9uYWxUeXBlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU0NvbmRpdGlvbmFsVHlwZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNJbmZlclR5cGUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTSW5mZXJUeXBlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU1BhcmVudGhlc2l6ZWRUeXBlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU1BhcmVudGhlc2l6ZWRUeXBlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU1R5cGVPcGVyYXRvcihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNUeXBlT3BlcmF0b3JcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTSW5kZXhlZEFjY2Vzc1R5cGUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTSW5kZXhlZEFjY2Vzc1R5cGVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTTWFwcGVkVHlwZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNNYXBwZWRUeXBlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU0xpdGVyYWxUeXBlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU0xpdGVyYWxUeXBlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU0V4cHJlc3Npb25XaXRoVHlwZUFyZ3VtZW50cyhub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNFeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHNcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTSW50ZXJmYWNlRGVjbGFyYXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTSW50ZXJmYWNlRGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTSW50ZXJmYWNlQm9keShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNJbnRlcmZhY2VCb2R5XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU1R5cGVBbGlhc0RlY2xhcmF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU1R5cGVBbGlhc0RlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU0FzRXhwcmVzc2lvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNBc0V4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTVHlwZUFzc2VydGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNUeXBlQXNzZXJ0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU0VudW1EZWNsYXJhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNFbnVtRGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTRW51bU1lbWJlcihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNFbnVtTWVtYmVyXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU01vZHVsZURlY2xhcmF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU01vZHVsZURlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU01vZHVsZUJsb2NrKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU01vZHVsZUJsb2NrXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU0ltcG9ydFR5cGUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTSW1wb3J0VHlwZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNOb25OdWxsRXhwcmVzc2lvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNOb25OdWxsRXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNFeHBvcnRBc3NpZ25tZW50KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU0V4cG9ydEFzc2lnbm1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTVHlwZUFubm90YXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTVHlwZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNUeXBlUGFyYW1ldGVyKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU1R5cGVQYXJhbWV0ZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEV4cHJlc3Npb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEJpbmFyeShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiQmluYXJ5XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRTY29wYWJsZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiU2NvcGFibGVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEJsb2NrUGFyZW50KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJCbG9ja1BhcmVudFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0QmxvY2sobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkJsb2NrXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRTdGF0ZW1lbnQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlN0YXRlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VGVybWluYXRvcmxlc3Mobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRlcm1pbmF0b3JsZXNzXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRDb21wbGV0aW9uU3RhdGVtZW50KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJDb21wbGV0aW9uU3RhdGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRDb25kaXRpb25hbChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiQ29uZGl0aW9uYWxcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydExvb3Aobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkxvb3BcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFdoaWxlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJXaGlsZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RXhwcmVzc2lvbldyYXBwZXIobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkV4cHJlc3Npb25XcmFwcGVyXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRGb3Iobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkZvclwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Rm9yWFN0YXRlbWVudChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRm9yWFN0YXRlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RnVuY3Rpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkZ1bmN0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRGdW5jdGlvblBhcmVudChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRnVuY3Rpb25QYXJlbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFB1cmVpc2gobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlB1cmVpc2hcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydERlY2xhcmF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJEZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0UGF0dGVybkxpa2Uobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlBhdHRlcm5MaWtlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRMVmFsKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJMVmFsXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU0VudGl0eU5hbWUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTRW50aXR5TmFtZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0TGl0ZXJhbChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiTGl0ZXJhbFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SW1tdXRhYmxlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJJbW11dGFibGVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFVzZXJXaGl0ZXNwYWNhYmxlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJVc2VyV2hpdGVzcGFjYWJsZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0TWV0aG9kKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJNZXRob2RcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE9iamVjdE1lbWJlcihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiT2JqZWN0TWVtYmVyXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRQcm9wZXJ0eShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiUHJvcGVydHlcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFVuYXJ5TGlrZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVW5hcnlMaWtlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRQYXR0ZXJuKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJQYXR0ZXJuXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRDbGFzcyhub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiQ2xhc3NcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE1vZHVsZURlY2xhcmF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJNb2R1bGVEZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RXhwb3J0RGVjbGFyYXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkV4cG9ydERlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRNb2R1bGVTcGVjaWZpZXIobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIk1vZHVsZVNwZWNpZmllclwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Rmxvdyhub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRmxvd1wiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Rmxvd1R5cGUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkZsb3dUeXBlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRGbG93QmFzZUFubm90YXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkZsb3dCYXNlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Rmxvd0RlY2xhcmF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJGbG93RGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEZsb3dQcmVkaWNhdGUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkZsb3dQcmVkaWNhdGVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEVudW1Cb2R5KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJFbnVtQm9keVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RW51bU1lbWJlcihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRW51bU1lbWJlclwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SlNYKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJKU1hcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFByaXZhdGUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlByaXZhdGVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTVHlwZUVsZW1lbnQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTVHlwZUVsZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTVHlwZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNUeXBlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU0Jhc2VUeXBlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU0Jhc2VUeXBlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnROdW1iZXJMaXRlcmFsKG5vZGUsIG9wdHMpIHtcbiAgY29uc29sZS50cmFjZShcIlRoZSBub2RlIHR5cGUgTnVtYmVyTGl0ZXJhbCBoYXMgYmVlbiByZW5hbWVkIHRvIE51bWVyaWNMaXRlcmFsXCIpO1xuICBhc3NlcnQoXCJOdW1iZXJMaXRlcmFsXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRSZWdleExpdGVyYWwobm9kZSwgb3B0cykge1xuICBjb25zb2xlLnRyYWNlKFwiVGhlIG5vZGUgdHlwZSBSZWdleExpdGVyYWwgaGFzIGJlZW4gcmVuYW1lZCB0byBSZWdFeHBMaXRlcmFsXCIpO1xuICBhc3NlcnQoXCJSZWdleExpdGVyYWxcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFJlc3RQcm9wZXJ0eShub2RlLCBvcHRzKSB7XG4gIGNvbnNvbGUudHJhY2UoXCJUaGUgbm9kZSB0eXBlIFJlc3RQcm9wZXJ0eSBoYXMgYmVlbiByZW5hbWVkIHRvIFJlc3RFbGVtZW50XCIpO1xuICBhc3NlcnQoXCJSZXN0UHJvcGVydHlcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNwcmVhZFByb3BlcnR5KG5vZGUsIG9wdHMpIHtcbiAgY29uc29sZS50cmFjZShcIlRoZSBub2RlIHR5cGUgU3ByZWFkUHJvcGVydHkgaGFzIGJlZW4gcmVuYW1lZCB0byBTcHJlYWRFbGVtZW50XCIpO1xuICBhc3NlcnQoXCJTcHJlYWRQcm9wZXJ0eVwiLCBub2RlLCBvcHRzKTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGJ1aWxkZXI7XG5cbnZhciBfY2xvbmUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvY2xvbmVcIikpO1xuXG52YXIgX2RlZmluaXRpb25zID0gcmVxdWlyZShcIi4uL2RlZmluaXRpb25zXCIpO1xuXG52YXIgX3ZhbGlkYXRlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vdmFsaWRhdG9ycy92YWxpZGF0ZVwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGJ1aWxkZXIodHlwZSwgLi4uYXJncykge1xuICBjb25zdCBrZXlzID0gX2RlZmluaXRpb25zLkJVSUxERVJfS0VZU1t0eXBlXTtcbiAgY29uc3QgY291bnRBcmdzID0gYXJncy5sZW5ndGg7XG5cbiAgaWYgKGNvdW50QXJncyA+IGtleXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3R5cGV9OiBUb28gbWFueSBhcmd1bWVudHMgcGFzc2VkLiBSZWNlaXZlZCAke2NvdW50QXJnc30gYnV0IGNhbiByZWNlaXZlIG5vIG1vcmUgdGhhbiAke2tleXMubGVuZ3RofWApO1xuICB9XG5cbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlXG4gIH07XG4gIGxldCBpID0gMDtcbiAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgY29uc3QgZmllbGQgPSBfZGVmaW5pdGlvbnMuTk9ERV9GSUVMRFNbdHlwZV1ba2V5XTtcbiAgICBsZXQgYXJnO1xuICAgIGlmIChpIDwgY291bnRBcmdzKSBhcmcgPSBhcmdzW2ldO1xuICAgIGlmIChhcmcgPT09IHVuZGVmaW5lZCkgYXJnID0gKDAsIF9jbG9uZS5kZWZhdWx0KShmaWVsZC5kZWZhdWx0KTtcbiAgICBub2RlW2tleV0gPSBhcmc7XG4gICAgaSsrO1xuICB9KTtcblxuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhub2RlKSkge1xuICAgICgwLCBfdmFsaWRhdGUuZGVmYXVsdCkobm9kZSwga2V5LCBub2RlW2tleV0pO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVGbG93VW5pb25UeXBlO1xuXG52YXIgX2dlbmVyYXRlZCA9IHJlcXVpcmUoXCIuLi9nZW5lcmF0ZWRcIik7XG5cbnZhciBfcmVtb3ZlVHlwZUR1cGxpY2F0ZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9tb2RpZmljYXRpb25zL2Zsb3cvcmVtb3ZlVHlwZUR1cGxpY2F0ZXNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBjcmVhdGVGbG93VW5pb25UeXBlKHR5cGVzKSB7XG4gIGNvbnN0IGZsYXR0ZW5lZCA9ICgwLCBfcmVtb3ZlVHlwZUR1cGxpY2F0ZXMuZGVmYXVsdCkodHlwZXMpO1xuXG4gIGlmIChmbGF0dGVuZWQubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGZsYXR0ZW5lZFswXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKDAsIF9nZW5lcmF0ZWQudW5pb25UeXBlQW5ub3RhdGlvbikoZmxhdHRlbmVkKTtcbiAgfVxufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlVHlwZUFubm90YXRpb25CYXNlZE9uVHlwZW9mO1xuXG52YXIgX2dlbmVyYXRlZCA9IHJlcXVpcmUoXCIuLi9nZW5lcmF0ZWRcIik7XG5cbmZ1bmN0aW9uIGNyZWF0ZVR5cGVBbm5vdGF0aW9uQmFzZWRPblR5cGVvZih0eXBlKSB7XG4gIGlmICh0eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuICgwLCBfZ2VuZXJhdGVkLnN0cmluZ1R5cGVBbm5vdGF0aW9uKSgpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gKDAsIF9nZW5lcmF0ZWQubnVtYmVyVHlwZUFubm90YXRpb24pKCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiAoMCwgX2dlbmVyYXRlZC52b2lkVHlwZUFubm90YXRpb24pKCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICByZXR1cm4gKDAsIF9nZW5lcmF0ZWQuYm9vbGVhblR5cGVBbm5vdGF0aW9uKSgpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiAoMCwgX2dlbmVyYXRlZC5nZW5lcmljVHlwZUFubm90YXRpb24pKCgwLCBfZ2VuZXJhdGVkLmlkZW50aWZpZXIpKFwiRnVuY3Rpb25cIikpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gKDAsIF9nZW5lcmF0ZWQuZ2VuZXJpY1R5cGVBbm5vdGF0aW9uKSgoMCwgX2dlbmVyYXRlZC5pZGVudGlmaWVyKShcIk9iamVjdFwiKSk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJzeW1ib2xcIikge1xuICAgIHJldHVybiAoMCwgX2dlbmVyYXRlZC5nZW5lcmljVHlwZUFubm90YXRpb24pKCgwLCBfZ2VuZXJhdGVkLmlkZW50aWZpZXIpKFwiU3ltYm9sXCIpKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHR5cGVvZiB2YWx1ZVwiKTtcbiAgfVxufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5BcnJheUV4cHJlc3Npb24gPSBleHBvcnRzLmFycmF5RXhwcmVzc2lvbiA9IGFycmF5RXhwcmVzc2lvbjtcbmV4cG9ydHMuQXNzaWdubWVudEV4cHJlc3Npb24gPSBleHBvcnRzLmFzc2lnbm1lbnRFeHByZXNzaW9uID0gYXNzaWdubWVudEV4cHJlc3Npb247XG5leHBvcnRzLkJpbmFyeUV4cHJlc3Npb24gPSBleHBvcnRzLmJpbmFyeUV4cHJlc3Npb24gPSBiaW5hcnlFeHByZXNzaW9uO1xuZXhwb3J0cy5JbnRlcnByZXRlckRpcmVjdGl2ZSA9IGV4cG9ydHMuaW50ZXJwcmV0ZXJEaXJlY3RpdmUgPSBpbnRlcnByZXRlckRpcmVjdGl2ZTtcbmV4cG9ydHMuRGlyZWN0aXZlID0gZXhwb3J0cy5kaXJlY3RpdmUgPSBkaXJlY3RpdmU7XG5leHBvcnRzLkRpcmVjdGl2ZUxpdGVyYWwgPSBleHBvcnRzLmRpcmVjdGl2ZUxpdGVyYWwgPSBkaXJlY3RpdmVMaXRlcmFsO1xuZXhwb3J0cy5CbG9ja1N0YXRlbWVudCA9IGV4cG9ydHMuYmxvY2tTdGF0ZW1lbnQgPSBibG9ja1N0YXRlbWVudDtcbmV4cG9ydHMuQnJlYWtTdGF0ZW1lbnQgPSBleHBvcnRzLmJyZWFrU3RhdGVtZW50ID0gYnJlYWtTdGF0ZW1lbnQ7XG5leHBvcnRzLkNhbGxFeHByZXNzaW9uID0gZXhwb3J0cy5jYWxsRXhwcmVzc2lvbiA9IGNhbGxFeHByZXNzaW9uO1xuZXhwb3J0cy5DYXRjaENsYXVzZSA9IGV4cG9ydHMuY2F0Y2hDbGF1c2UgPSBjYXRjaENsYXVzZTtcbmV4cG9ydHMuQ29uZGl0aW9uYWxFeHByZXNzaW9uID0gZXhwb3J0cy5jb25kaXRpb25hbEV4cHJlc3Npb24gPSBjb25kaXRpb25hbEV4cHJlc3Npb247XG5leHBvcnRzLkNvbnRpbnVlU3RhdGVtZW50ID0gZXhwb3J0cy5jb250aW51ZVN0YXRlbWVudCA9IGNvbnRpbnVlU3RhdGVtZW50O1xuZXhwb3J0cy5EZWJ1Z2dlclN0YXRlbWVudCA9IGV4cG9ydHMuZGVidWdnZXJTdGF0ZW1lbnQgPSBkZWJ1Z2dlclN0YXRlbWVudDtcbmV4cG9ydHMuRG9XaGlsZVN0YXRlbWVudCA9IGV4cG9ydHMuZG9XaGlsZVN0YXRlbWVudCA9IGRvV2hpbGVTdGF0ZW1lbnQ7XG5leHBvcnRzLkVtcHR5U3RhdGVtZW50ID0gZXhwb3J0cy5lbXB0eVN0YXRlbWVudCA9IGVtcHR5U3RhdGVtZW50O1xuZXhwb3J0cy5FeHByZXNzaW9uU3RhdGVtZW50ID0gZXhwb3J0cy5leHByZXNzaW9uU3RhdGVtZW50ID0gZXhwcmVzc2lvblN0YXRlbWVudDtcbmV4cG9ydHMuRmlsZSA9IGV4cG9ydHMuZmlsZSA9IGZpbGU7XG5leHBvcnRzLkZvckluU3RhdGVtZW50ID0gZXhwb3J0cy5mb3JJblN0YXRlbWVudCA9IGZvckluU3RhdGVtZW50O1xuZXhwb3J0cy5Gb3JTdGF0ZW1lbnQgPSBleHBvcnRzLmZvclN0YXRlbWVudCA9IGZvclN0YXRlbWVudDtcbmV4cG9ydHMuRnVuY3Rpb25EZWNsYXJhdGlvbiA9IGV4cG9ydHMuZnVuY3Rpb25EZWNsYXJhdGlvbiA9IGZ1bmN0aW9uRGVjbGFyYXRpb247XG5leHBvcnRzLkZ1bmN0aW9uRXhwcmVzc2lvbiA9IGV4cG9ydHMuZnVuY3Rpb25FeHByZXNzaW9uID0gZnVuY3Rpb25FeHByZXNzaW9uO1xuZXhwb3J0cy5JZGVudGlmaWVyID0gZXhwb3J0cy5pZGVudGlmaWVyID0gaWRlbnRpZmllcjtcbmV4cG9ydHMuSWZTdGF0ZW1lbnQgPSBleHBvcnRzLmlmU3RhdGVtZW50ID0gaWZTdGF0ZW1lbnQ7XG5leHBvcnRzLkxhYmVsZWRTdGF0ZW1lbnQgPSBleHBvcnRzLmxhYmVsZWRTdGF0ZW1lbnQgPSBsYWJlbGVkU3RhdGVtZW50O1xuZXhwb3J0cy5TdHJpbmdMaXRlcmFsID0gZXhwb3J0cy5zdHJpbmdMaXRlcmFsID0gc3RyaW5nTGl0ZXJhbDtcbmV4cG9ydHMuTnVtZXJpY0xpdGVyYWwgPSBleHBvcnRzLm51bWVyaWNMaXRlcmFsID0gbnVtZXJpY0xpdGVyYWw7XG5leHBvcnRzLk51bGxMaXRlcmFsID0gZXhwb3J0cy5udWxsTGl0ZXJhbCA9IG51bGxMaXRlcmFsO1xuZXhwb3J0cy5Cb29sZWFuTGl0ZXJhbCA9IGV4cG9ydHMuYm9vbGVhbkxpdGVyYWwgPSBib29sZWFuTGl0ZXJhbDtcbmV4cG9ydHMuUmVnRXhwTGl0ZXJhbCA9IGV4cG9ydHMucmVnRXhwTGl0ZXJhbCA9IHJlZ0V4cExpdGVyYWw7XG5leHBvcnRzLkxvZ2ljYWxFeHByZXNzaW9uID0gZXhwb3J0cy5sb2dpY2FsRXhwcmVzc2lvbiA9IGxvZ2ljYWxFeHByZXNzaW9uO1xuZXhwb3J0cy5NZW1iZXJFeHByZXNzaW9uID0gZXhwb3J0cy5tZW1iZXJFeHByZXNzaW9uID0gbWVtYmVyRXhwcmVzc2lvbjtcbmV4cG9ydHMuTmV3RXhwcmVzc2lvbiA9IGV4cG9ydHMubmV3RXhwcmVzc2lvbiA9IG5ld0V4cHJlc3Npb247XG5leHBvcnRzLlByb2dyYW0gPSBleHBvcnRzLnByb2dyYW0gPSBwcm9ncmFtO1xuZXhwb3J0cy5PYmplY3RFeHByZXNzaW9uID0gZXhwb3J0cy5vYmplY3RFeHByZXNzaW9uID0gb2JqZWN0RXhwcmVzc2lvbjtcbmV4cG9ydHMuT2JqZWN0TWV0aG9kID0gZXhwb3J0cy5vYmplY3RNZXRob2QgPSBvYmplY3RNZXRob2Q7XG5leHBvcnRzLk9iamVjdFByb3BlcnR5ID0gZXhwb3J0cy5vYmplY3RQcm9wZXJ0eSA9IG9iamVjdFByb3BlcnR5O1xuZXhwb3J0cy5SZXN0RWxlbWVudCA9IGV4cG9ydHMucmVzdEVsZW1lbnQgPSByZXN0RWxlbWVudDtcbmV4cG9ydHMuUmV0dXJuU3RhdGVtZW50ID0gZXhwb3J0cy5yZXR1cm5TdGF0ZW1lbnQgPSByZXR1cm5TdGF0ZW1lbnQ7XG5leHBvcnRzLlNlcXVlbmNlRXhwcmVzc2lvbiA9IGV4cG9ydHMuc2VxdWVuY2VFeHByZXNzaW9uID0gc2VxdWVuY2VFeHByZXNzaW9uO1xuZXhwb3J0cy5QYXJlbnRoZXNpemVkRXhwcmVzc2lvbiA9IGV4cG9ydHMucGFyZW50aGVzaXplZEV4cHJlc3Npb24gPSBwYXJlbnRoZXNpemVkRXhwcmVzc2lvbjtcbmV4cG9ydHMuU3dpdGNoQ2FzZSA9IGV4cG9ydHMuc3dpdGNoQ2FzZSA9IHN3aXRjaENhc2U7XG5leHBvcnRzLlN3aXRjaFN0YXRlbWVudCA9IGV4cG9ydHMuc3dpdGNoU3RhdGVtZW50ID0gc3dpdGNoU3RhdGVtZW50O1xuZXhwb3J0cy5UaGlzRXhwcmVzc2lvbiA9IGV4cG9ydHMudGhpc0V4cHJlc3Npb24gPSB0aGlzRXhwcmVzc2lvbjtcbmV4cG9ydHMuVGhyb3dTdGF0ZW1lbnQgPSBleHBvcnRzLnRocm93U3RhdGVtZW50ID0gdGhyb3dTdGF0ZW1lbnQ7XG5leHBvcnRzLlRyeVN0YXRlbWVudCA9IGV4cG9ydHMudHJ5U3RhdGVtZW50ID0gdHJ5U3RhdGVtZW50O1xuZXhwb3J0cy5VbmFyeUV4cHJlc3Npb24gPSBleHBvcnRzLnVuYXJ5RXhwcmVzc2lvbiA9IHVuYXJ5RXhwcmVzc2lvbjtcbmV4cG9ydHMuVXBkYXRlRXhwcmVzc2lvbiA9IGV4cG9ydHMudXBkYXRlRXhwcmVzc2lvbiA9IHVwZGF0ZUV4cHJlc3Npb247XG5leHBvcnRzLlZhcmlhYmxlRGVjbGFyYXRpb24gPSBleHBvcnRzLnZhcmlhYmxlRGVjbGFyYXRpb24gPSB2YXJpYWJsZURlY2xhcmF0aW9uO1xuZXhwb3J0cy5WYXJpYWJsZURlY2xhcmF0b3IgPSBleHBvcnRzLnZhcmlhYmxlRGVjbGFyYXRvciA9IHZhcmlhYmxlRGVjbGFyYXRvcjtcbmV4cG9ydHMuV2hpbGVTdGF0ZW1lbnQgPSBleHBvcnRzLndoaWxlU3RhdGVtZW50ID0gd2hpbGVTdGF0ZW1lbnQ7XG5leHBvcnRzLldpdGhTdGF0ZW1lbnQgPSBleHBvcnRzLndpdGhTdGF0ZW1lbnQgPSB3aXRoU3RhdGVtZW50O1xuZXhwb3J0cy5Bc3NpZ25tZW50UGF0dGVybiA9IGV4cG9ydHMuYXNzaWdubWVudFBhdHRlcm4gPSBhc3NpZ25tZW50UGF0dGVybjtcbmV4cG9ydHMuQXJyYXlQYXR0ZXJuID0gZXhwb3J0cy5hcnJheVBhdHRlcm4gPSBhcnJheVBhdHRlcm47XG5leHBvcnRzLkFycm93RnVuY3Rpb25FeHByZXNzaW9uID0gZXhwb3J0cy5hcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGFycm93RnVuY3Rpb25FeHByZXNzaW9uO1xuZXhwb3J0cy5DbGFzc0JvZHkgPSBleHBvcnRzLmNsYXNzQm9keSA9IGNsYXNzQm9keTtcbmV4cG9ydHMuQ2xhc3NFeHByZXNzaW9uID0gZXhwb3J0cy5jbGFzc0V4cHJlc3Npb24gPSBjbGFzc0V4cHJlc3Npb247XG5leHBvcnRzLkNsYXNzRGVjbGFyYXRpb24gPSBleHBvcnRzLmNsYXNzRGVjbGFyYXRpb24gPSBjbGFzc0RlY2xhcmF0aW9uO1xuZXhwb3J0cy5FeHBvcnRBbGxEZWNsYXJhdGlvbiA9IGV4cG9ydHMuZXhwb3J0QWxsRGVjbGFyYXRpb24gPSBleHBvcnRBbGxEZWNsYXJhdGlvbjtcbmV4cG9ydHMuRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uID0gZXhwb3J0cy5leHBvcnREZWZhdWx0RGVjbGFyYXRpb24gPSBleHBvcnREZWZhdWx0RGVjbGFyYXRpb247XG5leHBvcnRzLkV4cG9ydE5hbWVkRGVjbGFyYXRpb24gPSBleHBvcnRzLmV4cG9ydE5hbWVkRGVjbGFyYXRpb24gPSBleHBvcnROYW1lZERlY2xhcmF0aW9uO1xuZXhwb3J0cy5FeHBvcnRTcGVjaWZpZXIgPSBleHBvcnRzLmV4cG9ydFNwZWNpZmllciA9IGV4cG9ydFNwZWNpZmllcjtcbmV4cG9ydHMuRm9yT2ZTdGF0ZW1lbnQgPSBleHBvcnRzLmZvck9mU3RhdGVtZW50ID0gZm9yT2ZTdGF0ZW1lbnQ7XG5leHBvcnRzLkltcG9ydERlY2xhcmF0aW9uID0gZXhwb3J0cy5pbXBvcnREZWNsYXJhdGlvbiA9IGltcG9ydERlY2xhcmF0aW9uO1xuZXhwb3J0cy5JbXBvcnREZWZhdWx0U3BlY2lmaWVyID0gZXhwb3J0cy5pbXBvcnREZWZhdWx0U3BlY2lmaWVyID0gaW1wb3J0RGVmYXVsdFNwZWNpZmllcjtcbmV4cG9ydHMuSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyID0gZXhwb3J0cy5pbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIgPSBpbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI7XG5leHBvcnRzLkltcG9ydFNwZWNpZmllciA9IGV4cG9ydHMuaW1wb3J0U3BlY2lmaWVyID0gaW1wb3J0U3BlY2lmaWVyO1xuZXhwb3J0cy5NZXRhUHJvcGVydHkgPSBleHBvcnRzLm1ldGFQcm9wZXJ0eSA9IG1ldGFQcm9wZXJ0eTtcbmV4cG9ydHMuQ2xhc3NNZXRob2QgPSBleHBvcnRzLmNsYXNzTWV0aG9kID0gY2xhc3NNZXRob2Q7XG5leHBvcnRzLk9iamVjdFBhdHRlcm4gPSBleHBvcnRzLm9iamVjdFBhdHRlcm4gPSBvYmplY3RQYXR0ZXJuO1xuZXhwb3J0cy5TcHJlYWRFbGVtZW50ID0gZXhwb3J0cy5zcHJlYWRFbGVtZW50ID0gc3ByZWFkRWxlbWVudDtcbmV4cG9ydHMuc3VwZXIgPSBleHBvcnRzLlN1cGVyID0gX3N1cGVyO1xuZXhwb3J0cy5UYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24gPSBleHBvcnRzLnRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbiA9IHRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbjtcbmV4cG9ydHMuVGVtcGxhdGVFbGVtZW50ID0gZXhwb3J0cy50ZW1wbGF0ZUVsZW1lbnQgPSB0ZW1wbGF0ZUVsZW1lbnQ7XG5leHBvcnRzLlRlbXBsYXRlTGl0ZXJhbCA9IGV4cG9ydHMudGVtcGxhdGVMaXRlcmFsID0gdGVtcGxhdGVMaXRlcmFsO1xuZXhwb3J0cy5ZaWVsZEV4cHJlc3Npb24gPSBleHBvcnRzLnlpZWxkRXhwcmVzc2lvbiA9IHlpZWxkRXhwcmVzc2lvbjtcbmV4cG9ydHMuQXdhaXRFeHByZXNzaW9uID0gZXhwb3J0cy5hd2FpdEV4cHJlc3Npb24gPSBhd2FpdEV4cHJlc3Npb247XG5leHBvcnRzLmltcG9ydCA9IGV4cG9ydHMuSW1wb3J0ID0gX2ltcG9ydDtcbmV4cG9ydHMuQmlnSW50TGl0ZXJhbCA9IGV4cG9ydHMuYmlnSW50TGl0ZXJhbCA9IGJpZ0ludExpdGVyYWw7XG5leHBvcnRzLkV4cG9ydE5hbWVzcGFjZVNwZWNpZmllciA9IGV4cG9ydHMuZXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyID0gZXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyO1xuZXhwb3J0cy5PcHRpb25hbE1lbWJlckV4cHJlc3Npb24gPSBleHBvcnRzLm9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbiA9IG9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbjtcbmV4cG9ydHMuT3B0aW9uYWxDYWxsRXhwcmVzc2lvbiA9IGV4cG9ydHMub3B0aW9uYWxDYWxsRXhwcmVzc2lvbiA9IG9wdGlvbmFsQ2FsbEV4cHJlc3Npb247XG5leHBvcnRzLkFueVR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5hbnlUeXBlQW5ub3RhdGlvbiA9IGFueVR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5BcnJheVR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5hcnJheVR5cGVBbm5vdGF0aW9uID0gYXJyYXlUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuQm9vbGVhblR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5ib29sZWFuVHlwZUFubm90YXRpb24gPSBib29sZWFuVHlwZUFubm90YXRpb247XG5leHBvcnRzLkJvb2xlYW5MaXRlcmFsVHlwZUFubm90YXRpb24gPSBleHBvcnRzLmJvb2xlYW5MaXRlcmFsVHlwZUFubm90YXRpb24gPSBib29sZWFuTGl0ZXJhbFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5OdWxsTGl0ZXJhbFR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5udWxsTGl0ZXJhbFR5cGVBbm5vdGF0aW9uID0gbnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuQ2xhc3NJbXBsZW1lbnRzID0gZXhwb3J0cy5jbGFzc0ltcGxlbWVudHMgPSBjbGFzc0ltcGxlbWVudHM7XG5leHBvcnRzLkRlY2xhcmVDbGFzcyA9IGV4cG9ydHMuZGVjbGFyZUNsYXNzID0gZGVjbGFyZUNsYXNzO1xuZXhwb3J0cy5EZWNsYXJlRnVuY3Rpb24gPSBleHBvcnRzLmRlY2xhcmVGdW5jdGlvbiA9IGRlY2xhcmVGdW5jdGlvbjtcbmV4cG9ydHMuRGVjbGFyZUludGVyZmFjZSA9IGV4cG9ydHMuZGVjbGFyZUludGVyZmFjZSA9IGRlY2xhcmVJbnRlcmZhY2U7XG5leHBvcnRzLkRlY2xhcmVNb2R1bGUgPSBleHBvcnRzLmRlY2xhcmVNb2R1bGUgPSBkZWNsYXJlTW9kdWxlO1xuZXhwb3J0cy5EZWNsYXJlTW9kdWxlRXhwb3J0cyA9IGV4cG9ydHMuZGVjbGFyZU1vZHVsZUV4cG9ydHMgPSBkZWNsYXJlTW9kdWxlRXhwb3J0cztcbmV4cG9ydHMuRGVjbGFyZVR5cGVBbGlhcyA9IGV4cG9ydHMuZGVjbGFyZVR5cGVBbGlhcyA9IGRlY2xhcmVUeXBlQWxpYXM7XG5leHBvcnRzLkRlY2xhcmVPcGFxdWVUeXBlID0gZXhwb3J0cy5kZWNsYXJlT3BhcXVlVHlwZSA9IGRlY2xhcmVPcGFxdWVUeXBlO1xuZXhwb3J0cy5EZWNsYXJlVmFyaWFibGUgPSBleHBvcnRzLmRlY2xhcmVWYXJpYWJsZSA9IGRlY2xhcmVWYXJpYWJsZTtcbmV4cG9ydHMuRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uID0gZXhwb3J0cy5kZWNsYXJlRXhwb3J0RGVjbGFyYXRpb24gPSBkZWNsYXJlRXhwb3J0RGVjbGFyYXRpb247XG5leHBvcnRzLkRlY2xhcmVFeHBvcnRBbGxEZWNsYXJhdGlvbiA9IGV4cG9ydHMuZGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uID0gZGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uO1xuZXhwb3J0cy5EZWNsYXJlZFByZWRpY2F0ZSA9IGV4cG9ydHMuZGVjbGFyZWRQcmVkaWNhdGUgPSBkZWNsYXJlZFByZWRpY2F0ZTtcbmV4cG9ydHMuRXhpc3RzVHlwZUFubm90YXRpb24gPSBleHBvcnRzLmV4aXN0c1R5cGVBbm5vdGF0aW9uID0gZXhpc3RzVHlwZUFubm90YXRpb247XG5leHBvcnRzLkZ1bmN0aW9uVHlwZUFubm90YXRpb24gPSBleHBvcnRzLmZ1bmN0aW9uVHlwZUFubm90YXRpb24gPSBmdW5jdGlvblR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5GdW5jdGlvblR5cGVQYXJhbSA9IGV4cG9ydHMuZnVuY3Rpb25UeXBlUGFyYW0gPSBmdW5jdGlvblR5cGVQYXJhbTtcbmV4cG9ydHMuR2VuZXJpY1R5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5nZW5lcmljVHlwZUFubm90YXRpb24gPSBnZW5lcmljVHlwZUFubm90YXRpb247XG5leHBvcnRzLkluZmVycmVkUHJlZGljYXRlID0gZXhwb3J0cy5pbmZlcnJlZFByZWRpY2F0ZSA9IGluZmVycmVkUHJlZGljYXRlO1xuZXhwb3J0cy5JbnRlcmZhY2VFeHRlbmRzID0gZXhwb3J0cy5pbnRlcmZhY2VFeHRlbmRzID0gaW50ZXJmYWNlRXh0ZW5kcztcbmV4cG9ydHMuSW50ZXJmYWNlRGVjbGFyYXRpb24gPSBleHBvcnRzLmludGVyZmFjZURlY2xhcmF0aW9uID0gaW50ZXJmYWNlRGVjbGFyYXRpb247XG5leHBvcnRzLkludGVyZmFjZVR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5pbnRlcmZhY2VUeXBlQW5ub3RhdGlvbiA9IGludGVyZmFjZVR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5JbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMuaW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb24gPSBpbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuTWl4ZWRUeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMubWl4ZWRUeXBlQW5ub3RhdGlvbiA9IG1peGVkVHlwZUFubm90YXRpb247XG5leHBvcnRzLkVtcHR5VHlwZUFubm90YXRpb24gPSBleHBvcnRzLmVtcHR5VHlwZUFubm90YXRpb24gPSBlbXB0eVR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5OdWxsYWJsZVR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5udWxsYWJsZVR5cGVBbm5vdGF0aW9uID0gbnVsbGFibGVUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuTnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5udW1iZXJMaXRlcmFsVHlwZUFubm90YXRpb24gPSBudW1iZXJMaXRlcmFsVHlwZUFubm90YXRpb247XG5leHBvcnRzLk51bWJlclR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5udW1iZXJUeXBlQW5ub3RhdGlvbiA9IG51bWJlclR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5PYmplY3RUeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMub2JqZWN0VHlwZUFubm90YXRpb24gPSBvYmplY3RUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuT2JqZWN0VHlwZUludGVybmFsU2xvdCA9IGV4cG9ydHMub2JqZWN0VHlwZUludGVybmFsU2xvdCA9IG9iamVjdFR5cGVJbnRlcm5hbFNsb3Q7XG5leHBvcnRzLk9iamVjdFR5cGVDYWxsUHJvcGVydHkgPSBleHBvcnRzLm9iamVjdFR5cGVDYWxsUHJvcGVydHkgPSBvYmplY3RUeXBlQ2FsbFByb3BlcnR5O1xuZXhwb3J0cy5PYmplY3RUeXBlSW5kZXhlciA9IGV4cG9ydHMub2JqZWN0VHlwZUluZGV4ZXIgPSBvYmplY3RUeXBlSW5kZXhlcjtcbmV4cG9ydHMuT2JqZWN0VHlwZVByb3BlcnR5ID0gZXhwb3J0cy5vYmplY3RUeXBlUHJvcGVydHkgPSBvYmplY3RUeXBlUHJvcGVydHk7XG5leHBvcnRzLk9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eSA9IGV4cG9ydHMub2JqZWN0VHlwZVNwcmVhZFByb3BlcnR5ID0gb2JqZWN0VHlwZVNwcmVhZFByb3BlcnR5O1xuZXhwb3J0cy5PcGFxdWVUeXBlID0gZXhwb3J0cy5vcGFxdWVUeXBlID0gb3BhcXVlVHlwZTtcbmV4cG9ydHMuUXVhbGlmaWVkVHlwZUlkZW50aWZpZXIgPSBleHBvcnRzLnF1YWxpZmllZFR5cGVJZGVudGlmaWVyID0gcXVhbGlmaWVkVHlwZUlkZW50aWZpZXI7XG5leHBvcnRzLlN0cmluZ0xpdGVyYWxUeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMuc3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uID0gc3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5TdHJpbmdUeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMuc3RyaW5nVHlwZUFubm90YXRpb24gPSBzdHJpbmdUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuU3ltYm9sVHlwZUFubm90YXRpb24gPSBleHBvcnRzLnN5bWJvbFR5cGVBbm5vdGF0aW9uID0gc3ltYm9sVHlwZUFubm90YXRpb247XG5leHBvcnRzLlRoaXNUeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMudGhpc1R5cGVBbm5vdGF0aW9uID0gdGhpc1R5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5UdXBsZVR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy50dXBsZVR5cGVBbm5vdGF0aW9uID0gdHVwbGVUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuVHlwZW9mVHlwZUFubm90YXRpb24gPSBleHBvcnRzLnR5cGVvZlR5cGVBbm5vdGF0aW9uID0gdHlwZW9mVHlwZUFubm90YXRpb247XG5leHBvcnRzLlR5cGVBbGlhcyA9IGV4cG9ydHMudHlwZUFsaWFzID0gdHlwZUFsaWFzO1xuZXhwb3J0cy5UeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMudHlwZUFubm90YXRpb24gPSB0eXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuVHlwZUNhc3RFeHByZXNzaW9uID0gZXhwb3J0cy50eXBlQ2FzdEV4cHJlc3Npb24gPSB0eXBlQ2FzdEV4cHJlc3Npb247XG5leHBvcnRzLlR5cGVQYXJhbWV0ZXIgPSBleHBvcnRzLnR5cGVQYXJhbWV0ZXIgPSB0eXBlUGFyYW1ldGVyO1xuZXhwb3J0cy5UeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24gPSBleHBvcnRzLnR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbiA9IHR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbjtcbmV4cG9ydHMuVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24gPSBleHBvcnRzLnR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uID0gdHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb247XG5leHBvcnRzLlVuaW9uVHlwZUFubm90YXRpb24gPSBleHBvcnRzLnVuaW9uVHlwZUFubm90YXRpb24gPSB1bmlvblR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5WYXJpYW5jZSA9IGV4cG9ydHMudmFyaWFuY2UgPSB2YXJpYW5jZTtcbmV4cG9ydHMuVm9pZFR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy52b2lkVHlwZUFubm90YXRpb24gPSB2b2lkVHlwZUFubm90YXRpb247XG5leHBvcnRzLkVudW1EZWNsYXJhdGlvbiA9IGV4cG9ydHMuZW51bURlY2xhcmF0aW9uID0gZW51bURlY2xhcmF0aW9uO1xuZXhwb3J0cy5FbnVtQm9vbGVhbkJvZHkgPSBleHBvcnRzLmVudW1Cb29sZWFuQm9keSA9IGVudW1Cb29sZWFuQm9keTtcbmV4cG9ydHMuRW51bU51bWJlckJvZHkgPSBleHBvcnRzLmVudW1OdW1iZXJCb2R5ID0gZW51bU51bWJlckJvZHk7XG5leHBvcnRzLkVudW1TdHJpbmdCb2R5ID0gZXhwb3J0cy5lbnVtU3RyaW5nQm9keSA9IGVudW1TdHJpbmdCb2R5O1xuZXhwb3J0cy5FbnVtU3ltYm9sQm9keSA9IGV4cG9ydHMuZW51bVN5bWJvbEJvZHkgPSBlbnVtU3ltYm9sQm9keTtcbmV4cG9ydHMuRW51bUJvb2xlYW5NZW1iZXIgPSBleHBvcnRzLmVudW1Cb29sZWFuTWVtYmVyID0gZW51bUJvb2xlYW5NZW1iZXI7XG5leHBvcnRzLkVudW1OdW1iZXJNZW1iZXIgPSBleHBvcnRzLmVudW1OdW1iZXJNZW1iZXIgPSBlbnVtTnVtYmVyTWVtYmVyO1xuZXhwb3J0cy5FbnVtU3RyaW5nTWVtYmVyID0gZXhwb3J0cy5lbnVtU3RyaW5nTWVtYmVyID0gZW51bVN0cmluZ01lbWJlcjtcbmV4cG9ydHMuRW51bURlZmF1bHRlZE1lbWJlciA9IGV4cG9ydHMuZW51bURlZmF1bHRlZE1lbWJlciA9IGVudW1EZWZhdWx0ZWRNZW1iZXI7XG5leHBvcnRzLmpTWEF0dHJpYnV0ZSA9IGV4cG9ydHMuSlNYQXR0cmlidXRlID0gZXhwb3J0cy5qc3hBdHRyaWJ1dGUgPSBqc3hBdHRyaWJ1dGU7XG5leHBvcnRzLmpTWENsb3NpbmdFbGVtZW50ID0gZXhwb3J0cy5KU1hDbG9zaW5nRWxlbWVudCA9IGV4cG9ydHMuanN4Q2xvc2luZ0VsZW1lbnQgPSBqc3hDbG9zaW5nRWxlbWVudDtcbmV4cG9ydHMualNYRWxlbWVudCA9IGV4cG9ydHMuSlNYRWxlbWVudCA9IGV4cG9ydHMuanN4RWxlbWVudCA9IGpzeEVsZW1lbnQ7XG5leHBvcnRzLmpTWEVtcHR5RXhwcmVzc2lvbiA9IGV4cG9ydHMuSlNYRW1wdHlFeHByZXNzaW9uID0gZXhwb3J0cy5qc3hFbXB0eUV4cHJlc3Npb24gPSBqc3hFbXB0eUV4cHJlc3Npb247XG5leHBvcnRzLmpTWEV4cHJlc3Npb25Db250YWluZXIgPSBleHBvcnRzLkpTWEV4cHJlc3Npb25Db250YWluZXIgPSBleHBvcnRzLmpzeEV4cHJlc3Npb25Db250YWluZXIgPSBqc3hFeHByZXNzaW9uQ29udGFpbmVyO1xuZXhwb3J0cy5qU1hTcHJlYWRDaGlsZCA9IGV4cG9ydHMuSlNYU3ByZWFkQ2hpbGQgPSBleHBvcnRzLmpzeFNwcmVhZENoaWxkID0ganN4U3ByZWFkQ2hpbGQ7XG5leHBvcnRzLmpTWElkZW50aWZpZXIgPSBleHBvcnRzLkpTWElkZW50aWZpZXIgPSBleHBvcnRzLmpzeElkZW50aWZpZXIgPSBqc3hJZGVudGlmaWVyO1xuZXhwb3J0cy5qU1hNZW1iZXJFeHByZXNzaW9uID0gZXhwb3J0cy5KU1hNZW1iZXJFeHByZXNzaW9uID0gZXhwb3J0cy5qc3hNZW1iZXJFeHByZXNzaW9uID0ganN4TWVtYmVyRXhwcmVzc2lvbjtcbmV4cG9ydHMualNYTmFtZXNwYWNlZE5hbWUgPSBleHBvcnRzLkpTWE5hbWVzcGFjZWROYW1lID0gZXhwb3J0cy5qc3hOYW1lc3BhY2VkTmFtZSA9IGpzeE5hbWVzcGFjZWROYW1lO1xuZXhwb3J0cy5qU1hPcGVuaW5nRWxlbWVudCA9IGV4cG9ydHMuSlNYT3BlbmluZ0VsZW1lbnQgPSBleHBvcnRzLmpzeE9wZW5pbmdFbGVtZW50ID0ganN4T3BlbmluZ0VsZW1lbnQ7XG5leHBvcnRzLmpTWFNwcmVhZEF0dHJpYnV0ZSA9IGV4cG9ydHMuSlNYU3ByZWFkQXR0cmlidXRlID0gZXhwb3J0cy5qc3hTcHJlYWRBdHRyaWJ1dGUgPSBqc3hTcHJlYWRBdHRyaWJ1dGU7XG5leHBvcnRzLmpTWFRleHQgPSBleHBvcnRzLkpTWFRleHQgPSBleHBvcnRzLmpzeFRleHQgPSBqc3hUZXh0O1xuZXhwb3J0cy5qU1hGcmFnbWVudCA9IGV4cG9ydHMuSlNYRnJhZ21lbnQgPSBleHBvcnRzLmpzeEZyYWdtZW50ID0ganN4RnJhZ21lbnQ7XG5leHBvcnRzLmpTWE9wZW5pbmdGcmFnbWVudCA9IGV4cG9ydHMuSlNYT3BlbmluZ0ZyYWdtZW50ID0gZXhwb3J0cy5qc3hPcGVuaW5nRnJhZ21lbnQgPSBqc3hPcGVuaW5nRnJhZ21lbnQ7XG5leHBvcnRzLmpTWENsb3NpbmdGcmFnbWVudCA9IGV4cG9ydHMuSlNYQ2xvc2luZ0ZyYWdtZW50ID0gZXhwb3J0cy5qc3hDbG9zaW5nRnJhZ21lbnQgPSBqc3hDbG9zaW5nRnJhZ21lbnQ7XG5leHBvcnRzLk5vb3AgPSBleHBvcnRzLm5vb3AgPSBub29wO1xuZXhwb3J0cy5QbGFjZWhvbGRlciA9IGV4cG9ydHMucGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlcjtcbmV4cG9ydHMuVjhJbnRyaW5zaWNJZGVudGlmaWVyID0gZXhwb3J0cy52OEludHJpbnNpY0lkZW50aWZpZXIgPSB2OEludHJpbnNpY0lkZW50aWZpZXI7XG5leHBvcnRzLkFyZ3VtZW50UGxhY2Vob2xkZXIgPSBleHBvcnRzLmFyZ3VtZW50UGxhY2Vob2xkZXIgPSBhcmd1bWVudFBsYWNlaG9sZGVyO1xuZXhwb3J0cy5CaW5kRXhwcmVzc2lvbiA9IGV4cG9ydHMuYmluZEV4cHJlc3Npb24gPSBiaW5kRXhwcmVzc2lvbjtcbmV4cG9ydHMuQ2xhc3NQcm9wZXJ0eSA9IGV4cG9ydHMuY2xhc3NQcm9wZXJ0eSA9IGNsYXNzUHJvcGVydHk7XG5leHBvcnRzLlBpcGVsaW5lVG9waWNFeHByZXNzaW9uID0gZXhwb3J0cy5waXBlbGluZVRvcGljRXhwcmVzc2lvbiA9IHBpcGVsaW5lVG9waWNFeHByZXNzaW9uO1xuZXhwb3J0cy5QaXBlbGluZUJhcmVGdW5jdGlvbiA9IGV4cG9ydHMucGlwZWxpbmVCYXJlRnVuY3Rpb24gPSBwaXBlbGluZUJhcmVGdW5jdGlvbjtcbmV4cG9ydHMuUGlwZWxpbmVQcmltYXJ5VG9waWNSZWZlcmVuY2UgPSBleHBvcnRzLnBpcGVsaW5lUHJpbWFyeVRvcGljUmVmZXJlbmNlID0gcGlwZWxpbmVQcmltYXJ5VG9waWNSZWZlcmVuY2U7XG5leHBvcnRzLkNsYXNzUHJpdmF0ZVByb3BlcnR5ID0gZXhwb3J0cy5jbGFzc1ByaXZhdGVQcm9wZXJ0eSA9IGNsYXNzUHJpdmF0ZVByb3BlcnR5O1xuZXhwb3J0cy5DbGFzc1ByaXZhdGVNZXRob2QgPSBleHBvcnRzLmNsYXNzUHJpdmF0ZU1ldGhvZCA9IGNsYXNzUHJpdmF0ZU1ldGhvZDtcbmV4cG9ydHMuSW1wb3J0QXR0cmlidXRlID0gZXhwb3J0cy5pbXBvcnRBdHRyaWJ1dGUgPSBpbXBvcnRBdHRyaWJ1dGU7XG5leHBvcnRzLkRlY29yYXRvciA9IGV4cG9ydHMuZGVjb3JhdG9yID0gZGVjb3JhdG9yO1xuZXhwb3J0cy5Eb0V4cHJlc3Npb24gPSBleHBvcnRzLmRvRXhwcmVzc2lvbiA9IGRvRXhwcmVzc2lvbjtcbmV4cG9ydHMuRXhwb3J0RGVmYXVsdFNwZWNpZmllciA9IGV4cG9ydHMuZXhwb3J0RGVmYXVsdFNwZWNpZmllciA9IGV4cG9ydERlZmF1bHRTcGVjaWZpZXI7XG5leHBvcnRzLlByaXZhdGVOYW1lID0gZXhwb3J0cy5wcml2YXRlTmFtZSA9IHByaXZhdGVOYW1lO1xuZXhwb3J0cy5SZWNvcmRFeHByZXNzaW9uID0gZXhwb3J0cy5yZWNvcmRFeHByZXNzaW9uID0gcmVjb3JkRXhwcmVzc2lvbjtcbmV4cG9ydHMuVHVwbGVFeHByZXNzaW9uID0gZXhwb3J0cy50dXBsZUV4cHJlc3Npb24gPSB0dXBsZUV4cHJlc3Npb247XG5leHBvcnRzLkRlY2ltYWxMaXRlcmFsID0gZXhwb3J0cy5kZWNpbWFsTGl0ZXJhbCA9IGRlY2ltYWxMaXRlcmFsO1xuZXhwb3J0cy50U1BhcmFtZXRlclByb3BlcnR5ID0gZXhwb3J0cy5UU1BhcmFtZXRlclByb3BlcnR5ID0gZXhwb3J0cy50c1BhcmFtZXRlclByb3BlcnR5ID0gdHNQYXJhbWV0ZXJQcm9wZXJ0eTtcbmV4cG9ydHMudFNEZWNsYXJlRnVuY3Rpb24gPSBleHBvcnRzLlRTRGVjbGFyZUZ1bmN0aW9uID0gZXhwb3J0cy50c0RlY2xhcmVGdW5jdGlvbiA9IHRzRGVjbGFyZUZ1bmN0aW9uO1xuZXhwb3J0cy50U0RlY2xhcmVNZXRob2QgPSBleHBvcnRzLlRTRGVjbGFyZU1ldGhvZCA9IGV4cG9ydHMudHNEZWNsYXJlTWV0aG9kID0gdHNEZWNsYXJlTWV0aG9kO1xuZXhwb3J0cy50U1F1YWxpZmllZE5hbWUgPSBleHBvcnRzLlRTUXVhbGlmaWVkTmFtZSA9IGV4cG9ydHMudHNRdWFsaWZpZWROYW1lID0gdHNRdWFsaWZpZWROYW1lO1xuZXhwb3J0cy50U0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvbiA9IGV4cG9ydHMuVFNDYWxsU2lnbmF0dXJlRGVjbGFyYXRpb24gPSBleHBvcnRzLnRzQ2FsbFNpZ25hdHVyZURlY2xhcmF0aW9uID0gdHNDYWxsU2lnbmF0dXJlRGVjbGFyYXRpb247XG5leHBvcnRzLnRTQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb24gPSBleHBvcnRzLlRTQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb24gPSBleHBvcnRzLnRzQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb24gPSB0c0NvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uO1xuZXhwb3J0cy50U1Byb3BlcnR5U2lnbmF0dXJlID0gZXhwb3J0cy5UU1Byb3BlcnR5U2lnbmF0dXJlID0gZXhwb3J0cy50c1Byb3BlcnR5U2lnbmF0dXJlID0gdHNQcm9wZXJ0eVNpZ25hdHVyZTtcbmV4cG9ydHMudFNNZXRob2RTaWduYXR1cmUgPSBleHBvcnRzLlRTTWV0aG9kU2lnbmF0dXJlID0gZXhwb3J0cy50c01ldGhvZFNpZ25hdHVyZSA9IHRzTWV0aG9kU2lnbmF0dXJlO1xuZXhwb3J0cy50U0luZGV4U2lnbmF0dXJlID0gZXhwb3J0cy5UU0luZGV4U2lnbmF0dXJlID0gZXhwb3J0cy50c0luZGV4U2lnbmF0dXJlID0gdHNJbmRleFNpZ25hdHVyZTtcbmV4cG9ydHMudFNBbnlLZXl3b3JkID0gZXhwb3J0cy5UU0FueUtleXdvcmQgPSBleHBvcnRzLnRzQW55S2V5d29yZCA9IHRzQW55S2V5d29yZDtcbmV4cG9ydHMudFNCb29sZWFuS2V5d29yZCA9IGV4cG9ydHMuVFNCb29sZWFuS2V5d29yZCA9IGV4cG9ydHMudHNCb29sZWFuS2V5d29yZCA9IHRzQm9vbGVhbktleXdvcmQ7XG5leHBvcnRzLnRTQmlnSW50S2V5d29yZCA9IGV4cG9ydHMuVFNCaWdJbnRLZXl3b3JkID0gZXhwb3J0cy50c0JpZ0ludEtleXdvcmQgPSB0c0JpZ0ludEtleXdvcmQ7XG5leHBvcnRzLnRTTmV2ZXJLZXl3b3JkID0gZXhwb3J0cy5UU05ldmVyS2V5d29yZCA9IGV4cG9ydHMudHNOZXZlcktleXdvcmQgPSB0c05ldmVyS2V5d29yZDtcbmV4cG9ydHMudFNOdWxsS2V5d29yZCA9IGV4cG9ydHMuVFNOdWxsS2V5d29yZCA9IGV4cG9ydHMudHNOdWxsS2V5d29yZCA9IHRzTnVsbEtleXdvcmQ7XG5leHBvcnRzLnRTTnVtYmVyS2V5d29yZCA9IGV4cG9ydHMuVFNOdW1iZXJLZXl3b3JkID0gZXhwb3J0cy50c051bWJlcktleXdvcmQgPSB0c051bWJlcktleXdvcmQ7XG5leHBvcnRzLnRTT2JqZWN0S2V5d29yZCA9IGV4cG9ydHMuVFNPYmplY3RLZXl3b3JkID0gZXhwb3J0cy50c09iamVjdEtleXdvcmQgPSB0c09iamVjdEtleXdvcmQ7XG5leHBvcnRzLnRTU3RyaW5nS2V5d29yZCA9IGV4cG9ydHMuVFNTdHJpbmdLZXl3b3JkID0gZXhwb3J0cy50c1N0cmluZ0tleXdvcmQgPSB0c1N0cmluZ0tleXdvcmQ7XG5leHBvcnRzLnRTU3ltYm9sS2V5d29yZCA9IGV4cG9ydHMuVFNTeW1ib2xLZXl3b3JkID0gZXhwb3J0cy50c1N5bWJvbEtleXdvcmQgPSB0c1N5bWJvbEtleXdvcmQ7XG5leHBvcnRzLnRTVW5kZWZpbmVkS2V5d29yZCA9IGV4cG9ydHMuVFNVbmRlZmluZWRLZXl3b3JkID0gZXhwb3J0cy50c1VuZGVmaW5lZEtleXdvcmQgPSB0c1VuZGVmaW5lZEtleXdvcmQ7XG5leHBvcnRzLnRTVW5rbm93bktleXdvcmQgPSBleHBvcnRzLlRTVW5rbm93bktleXdvcmQgPSBleHBvcnRzLnRzVW5rbm93bktleXdvcmQgPSB0c1Vua25vd25LZXl3b3JkO1xuZXhwb3J0cy50U1ZvaWRLZXl3b3JkID0gZXhwb3J0cy5UU1ZvaWRLZXl3b3JkID0gZXhwb3J0cy50c1ZvaWRLZXl3b3JkID0gdHNWb2lkS2V5d29yZDtcbmV4cG9ydHMudFNUaGlzVHlwZSA9IGV4cG9ydHMuVFNUaGlzVHlwZSA9IGV4cG9ydHMudHNUaGlzVHlwZSA9IHRzVGhpc1R5cGU7XG5leHBvcnRzLnRTRnVuY3Rpb25UeXBlID0gZXhwb3J0cy5UU0Z1bmN0aW9uVHlwZSA9IGV4cG9ydHMudHNGdW5jdGlvblR5cGUgPSB0c0Z1bmN0aW9uVHlwZTtcbmV4cG9ydHMudFNDb25zdHJ1Y3RvclR5cGUgPSBleHBvcnRzLlRTQ29uc3RydWN0b3JUeXBlID0gZXhwb3J0cy50c0NvbnN0cnVjdG9yVHlwZSA9IHRzQ29uc3RydWN0b3JUeXBlO1xuZXhwb3J0cy50U1R5cGVSZWZlcmVuY2UgPSBleHBvcnRzLlRTVHlwZVJlZmVyZW5jZSA9IGV4cG9ydHMudHNUeXBlUmVmZXJlbmNlID0gdHNUeXBlUmVmZXJlbmNlO1xuZXhwb3J0cy50U1R5cGVQcmVkaWNhdGUgPSBleHBvcnRzLlRTVHlwZVByZWRpY2F0ZSA9IGV4cG9ydHMudHNUeXBlUHJlZGljYXRlID0gdHNUeXBlUHJlZGljYXRlO1xuZXhwb3J0cy50U1R5cGVRdWVyeSA9IGV4cG9ydHMuVFNUeXBlUXVlcnkgPSBleHBvcnRzLnRzVHlwZVF1ZXJ5ID0gdHNUeXBlUXVlcnk7XG5leHBvcnRzLnRTVHlwZUxpdGVyYWwgPSBleHBvcnRzLlRTVHlwZUxpdGVyYWwgPSBleHBvcnRzLnRzVHlwZUxpdGVyYWwgPSB0c1R5cGVMaXRlcmFsO1xuZXhwb3J0cy50U0FycmF5VHlwZSA9IGV4cG9ydHMuVFNBcnJheVR5cGUgPSBleHBvcnRzLnRzQXJyYXlUeXBlID0gdHNBcnJheVR5cGU7XG5leHBvcnRzLnRTVHVwbGVUeXBlID0gZXhwb3J0cy5UU1R1cGxlVHlwZSA9IGV4cG9ydHMudHNUdXBsZVR5cGUgPSB0c1R1cGxlVHlwZTtcbmV4cG9ydHMudFNPcHRpb25hbFR5cGUgPSBleHBvcnRzLlRTT3B0aW9uYWxUeXBlID0gZXhwb3J0cy50c09wdGlvbmFsVHlwZSA9IHRzT3B0aW9uYWxUeXBlO1xuZXhwb3J0cy50U1Jlc3RUeXBlID0gZXhwb3J0cy5UU1Jlc3RUeXBlID0gZXhwb3J0cy50c1Jlc3RUeXBlID0gdHNSZXN0VHlwZTtcbmV4cG9ydHMudFNOYW1lZFR1cGxlTWVtYmVyID0gZXhwb3J0cy5UU05hbWVkVHVwbGVNZW1iZXIgPSBleHBvcnRzLnRzTmFtZWRUdXBsZU1lbWJlciA9IHRzTmFtZWRUdXBsZU1lbWJlcjtcbmV4cG9ydHMudFNVbmlvblR5cGUgPSBleHBvcnRzLlRTVW5pb25UeXBlID0gZXhwb3J0cy50c1VuaW9uVHlwZSA9IHRzVW5pb25UeXBlO1xuZXhwb3J0cy50U0ludGVyc2VjdGlvblR5cGUgPSBleHBvcnRzLlRTSW50ZXJzZWN0aW9uVHlwZSA9IGV4cG9ydHMudHNJbnRlcnNlY3Rpb25UeXBlID0gdHNJbnRlcnNlY3Rpb25UeXBlO1xuZXhwb3J0cy50U0NvbmRpdGlvbmFsVHlwZSA9IGV4cG9ydHMuVFNDb25kaXRpb25hbFR5cGUgPSBleHBvcnRzLnRzQ29uZGl0aW9uYWxUeXBlID0gdHNDb25kaXRpb25hbFR5cGU7XG5leHBvcnRzLnRTSW5mZXJUeXBlID0gZXhwb3J0cy5UU0luZmVyVHlwZSA9IGV4cG9ydHMudHNJbmZlclR5cGUgPSB0c0luZmVyVHlwZTtcbmV4cG9ydHMudFNQYXJlbnRoZXNpemVkVHlwZSA9IGV4cG9ydHMuVFNQYXJlbnRoZXNpemVkVHlwZSA9IGV4cG9ydHMudHNQYXJlbnRoZXNpemVkVHlwZSA9IHRzUGFyZW50aGVzaXplZFR5cGU7XG5leHBvcnRzLnRTVHlwZU9wZXJhdG9yID0gZXhwb3J0cy5UU1R5cGVPcGVyYXRvciA9IGV4cG9ydHMudHNUeXBlT3BlcmF0b3IgPSB0c1R5cGVPcGVyYXRvcjtcbmV4cG9ydHMudFNJbmRleGVkQWNjZXNzVHlwZSA9IGV4cG9ydHMuVFNJbmRleGVkQWNjZXNzVHlwZSA9IGV4cG9ydHMudHNJbmRleGVkQWNjZXNzVHlwZSA9IHRzSW5kZXhlZEFjY2Vzc1R5cGU7XG5leHBvcnRzLnRTTWFwcGVkVHlwZSA9IGV4cG9ydHMuVFNNYXBwZWRUeXBlID0gZXhwb3J0cy50c01hcHBlZFR5cGUgPSB0c01hcHBlZFR5cGU7XG5leHBvcnRzLnRTTGl0ZXJhbFR5cGUgPSBleHBvcnRzLlRTTGl0ZXJhbFR5cGUgPSBleHBvcnRzLnRzTGl0ZXJhbFR5cGUgPSB0c0xpdGVyYWxUeXBlO1xuZXhwb3J0cy50U0V4cHJlc3Npb25XaXRoVHlwZUFyZ3VtZW50cyA9IGV4cG9ydHMuVFNFeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHMgPSBleHBvcnRzLnRzRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzID0gdHNFeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHM7XG5leHBvcnRzLnRTSW50ZXJmYWNlRGVjbGFyYXRpb24gPSBleHBvcnRzLlRTSW50ZXJmYWNlRGVjbGFyYXRpb24gPSBleHBvcnRzLnRzSW50ZXJmYWNlRGVjbGFyYXRpb24gPSB0c0ludGVyZmFjZURlY2xhcmF0aW9uO1xuZXhwb3J0cy50U0ludGVyZmFjZUJvZHkgPSBleHBvcnRzLlRTSW50ZXJmYWNlQm9keSA9IGV4cG9ydHMudHNJbnRlcmZhY2VCb2R5ID0gdHNJbnRlcmZhY2VCb2R5O1xuZXhwb3J0cy50U1R5cGVBbGlhc0RlY2xhcmF0aW9uID0gZXhwb3J0cy5UU1R5cGVBbGlhc0RlY2xhcmF0aW9uID0gZXhwb3J0cy50c1R5cGVBbGlhc0RlY2xhcmF0aW9uID0gdHNUeXBlQWxpYXNEZWNsYXJhdGlvbjtcbmV4cG9ydHMudFNBc0V4cHJlc3Npb24gPSBleHBvcnRzLlRTQXNFeHByZXNzaW9uID0gZXhwb3J0cy50c0FzRXhwcmVzc2lvbiA9IHRzQXNFeHByZXNzaW9uO1xuZXhwb3J0cy50U1R5cGVBc3NlcnRpb24gPSBleHBvcnRzLlRTVHlwZUFzc2VydGlvbiA9IGV4cG9ydHMudHNUeXBlQXNzZXJ0aW9uID0gdHNUeXBlQXNzZXJ0aW9uO1xuZXhwb3J0cy50U0VudW1EZWNsYXJhdGlvbiA9IGV4cG9ydHMuVFNFbnVtRGVjbGFyYXRpb24gPSBleHBvcnRzLnRzRW51bURlY2xhcmF0aW9uID0gdHNFbnVtRGVjbGFyYXRpb247XG5leHBvcnRzLnRTRW51bU1lbWJlciA9IGV4cG9ydHMuVFNFbnVtTWVtYmVyID0gZXhwb3J0cy50c0VudW1NZW1iZXIgPSB0c0VudW1NZW1iZXI7XG5leHBvcnRzLnRTTW9kdWxlRGVjbGFyYXRpb24gPSBleHBvcnRzLlRTTW9kdWxlRGVjbGFyYXRpb24gPSBleHBvcnRzLnRzTW9kdWxlRGVjbGFyYXRpb24gPSB0c01vZHVsZURlY2xhcmF0aW9uO1xuZXhwb3J0cy50U01vZHVsZUJsb2NrID0gZXhwb3J0cy5UU01vZHVsZUJsb2NrID0gZXhwb3J0cy50c01vZHVsZUJsb2NrID0gdHNNb2R1bGVCbG9jaztcbmV4cG9ydHMudFNJbXBvcnRUeXBlID0gZXhwb3J0cy5UU0ltcG9ydFR5cGUgPSBleHBvcnRzLnRzSW1wb3J0VHlwZSA9IHRzSW1wb3J0VHlwZTtcbmV4cG9ydHMudFNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvbiA9IGV4cG9ydHMuVFNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvbiA9IGV4cG9ydHMudHNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvbiA9IHRzSW1wb3J0RXF1YWxzRGVjbGFyYXRpb247XG5leHBvcnRzLnRTRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2UgPSBleHBvcnRzLlRTRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2UgPSBleHBvcnRzLnRzRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2UgPSB0c0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlO1xuZXhwb3J0cy50U05vbk51bGxFeHByZXNzaW9uID0gZXhwb3J0cy5UU05vbk51bGxFeHByZXNzaW9uID0gZXhwb3J0cy50c05vbk51bGxFeHByZXNzaW9uID0gdHNOb25OdWxsRXhwcmVzc2lvbjtcbmV4cG9ydHMudFNFeHBvcnRBc3NpZ25tZW50ID0gZXhwb3J0cy5UU0V4cG9ydEFzc2lnbm1lbnQgPSBleHBvcnRzLnRzRXhwb3J0QXNzaWdubWVudCA9IHRzRXhwb3J0QXNzaWdubWVudDtcbmV4cG9ydHMudFNOYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvbiA9IGV4cG9ydHMuVFNOYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvbiA9IGV4cG9ydHMudHNOYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvbiA9IHRzTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb247XG5leHBvcnRzLnRTVHlwZUFubm90YXRpb24gPSBleHBvcnRzLlRTVHlwZUFubm90YXRpb24gPSBleHBvcnRzLnRzVHlwZUFubm90YXRpb24gPSB0c1R5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy50U1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uID0gZXhwb3J0cy5UU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uID0gZXhwb3J0cy50c1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uID0gdHNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbjtcbmV4cG9ydHMudFNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24gPSBleHBvcnRzLlRTVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uID0gZXhwb3J0cy50c1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbiA9IHRzVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uO1xuZXhwb3J0cy50U1R5cGVQYXJhbWV0ZXIgPSBleHBvcnRzLlRTVHlwZVBhcmFtZXRlciA9IGV4cG9ydHMudHNUeXBlUGFyYW1ldGVyID0gdHNUeXBlUGFyYW1ldGVyO1xuZXhwb3J0cy5udW1iZXJMaXRlcmFsID0gZXhwb3J0cy5OdW1iZXJMaXRlcmFsID0gTnVtYmVyTGl0ZXJhbDtcbmV4cG9ydHMucmVnZXhMaXRlcmFsID0gZXhwb3J0cy5SZWdleExpdGVyYWwgPSBSZWdleExpdGVyYWw7XG5leHBvcnRzLnJlc3RQcm9wZXJ0eSA9IGV4cG9ydHMuUmVzdFByb3BlcnR5ID0gUmVzdFByb3BlcnR5O1xuZXhwb3J0cy5zcHJlYWRQcm9wZXJ0eSA9IGV4cG9ydHMuU3ByZWFkUHJvcGVydHkgPSBTcHJlYWRQcm9wZXJ0eTtcblxudmFyIF9idWlsZGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vYnVpbGRlclwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGFycmF5RXhwcmVzc2lvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJBcnJheUV4cHJlc3Npb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGFzc2lnbm1lbnRFeHByZXNzaW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBiaW5hcnlFeHByZXNzaW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkJpbmFyeUV4cHJlc3Npb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGludGVycHJldGVyRGlyZWN0aXZlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkludGVycHJldGVyRGlyZWN0aXZlXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBkaXJlY3RpdmUoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRGlyZWN0aXZlXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBkaXJlY3RpdmVMaXRlcmFsKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkRpcmVjdGl2ZUxpdGVyYWxcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGJsb2NrU3RhdGVtZW50KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkJsb2NrU3RhdGVtZW50XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBicmVha1N0YXRlbWVudCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJCcmVha1N0YXRlbWVudFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gY2FsbEV4cHJlc3Npb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiQ2FsbEV4cHJlc3Npb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGNhdGNoQ2xhdXNlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkNhdGNoQ2xhdXNlXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBjb25kaXRpb25hbEV4cHJlc3Npb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBjb250aW51ZVN0YXRlbWVudCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJDb250aW51ZVN0YXRlbWVudFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZGVidWdnZXJTdGF0ZW1lbnQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRGVidWdnZXJTdGF0ZW1lbnRcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGRvV2hpbGVTdGF0ZW1lbnQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRG9XaGlsZVN0YXRlbWVudFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZW1wdHlTdGF0ZW1lbnQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRW1wdHlTdGF0ZW1lbnRcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGV4cHJlc3Npb25TdGF0ZW1lbnQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRXhwcmVzc2lvblN0YXRlbWVudFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZmlsZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJGaWxlXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBmb3JJblN0YXRlbWVudCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJGb3JJblN0YXRlbWVudFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZm9yU3RhdGVtZW50KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkZvclN0YXRlbWVudFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZnVuY3Rpb25EZWNsYXJhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBmdW5jdGlvbkV4cHJlc3Npb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRnVuY3Rpb25FeHByZXNzaW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBpZGVudGlmaWVyKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIklkZW50aWZpZXJcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGlmU3RhdGVtZW50KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIklmU3RhdGVtZW50XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBsYWJlbGVkU3RhdGVtZW50KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkxhYmVsZWRTdGF0ZW1lbnRcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ0xpdGVyYWwoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiU3RyaW5nTGl0ZXJhbFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gbnVtZXJpY0xpdGVyYWwoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiTnVtZXJpY0xpdGVyYWxcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIG51bGxMaXRlcmFsKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIk51bGxMaXRlcmFsXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBib29sZWFuTGl0ZXJhbCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJCb29sZWFuTGl0ZXJhbFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gcmVnRXhwTGl0ZXJhbCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJSZWdFeHBMaXRlcmFsXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBsb2dpY2FsRXhwcmVzc2lvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJMb2dpY2FsRXhwcmVzc2lvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gbWVtYmVyRXhwcmVzc2lvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJNZW1iZXJFeHByZXNzaW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBuZXdFeHByZXNzaW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIk5ld0V4cHJlc3Npb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHByb2dyYW0oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiUHJvZ3JhbVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gb2JqZWN0RXhwcmVzc2lvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJPYmplY3RFeHByZXNzaW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBvYmplY3RNZXRob2QoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiT2JqZWN0TWV0aG9kXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBvYmplY3RQcm9wZXJ0eSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJPYmplY3RQcm9wZXJ0eVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gcmVzdEVsZW1lbnQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiUmVzdEVsZW1lbnRcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHJldHVyblN0YXRlbWVudCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJSZXR1cm5TdGF0ZW1lbnRcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHNlcXVlbmNlRXhwcmVzc2lvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJTZXF1ZW5jZUV4cHJlc3Npb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHBhcmVudGhlc2l6ZWRFeHByZXNzaW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBzd2l0Y2hDYXNlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlN3aXRjaENhc2VcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHN3aXRjaFN0YXRlbWVudCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJTd2l0Y2hTdGF0ZW1lbnRcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRoaXNFeHByZXNzaW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRoaXNFeHByZXNzaW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0aHJvd1N0YXRlbWVudCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUaHJvd1N0YXRlbWVudFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHJ5U3RhdGVtZW50KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRyeVN0YXRlbWVudFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdW5hcnlFeHByZXNzaW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlVuYXJ5RXhwcmVzc2lvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRXhwcmVzc2lvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJVcGRhdGVFeHByZXNzaW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB2YXJpYWJsZURlY2xhcmF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlZhcmlhYmxlRGVjbGFyYXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHZhcmlhYmxlRGVjbGFyYXRvciguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJWYXJpYWJsZURlY2xhcmF0b3JcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHdoaWxlU3RhdGVtZW50KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIldoaWxlU3RhdGVtZW50XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB3aXRoU3RhdGVtZW50KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIldpdGhTdGF0ZW1lbnRcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGFzc2lnbm1lbnRQYXR0ZXJuKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkFzc2lnbm1lbnRQYXR0ZXJuXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBhcnJheVBhdHRlcm4oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiQXJyYXlQYXR0ZXJuXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBhcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gY2xhc3NCb2R5KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkNsYXNzQm9keVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gY2xhc3NFeHByZXNzaW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkNsYXNzRXhwcmVzc2lvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gY2xhc3NEZWNsYXJhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJDbGFzc0RlY2xhcmF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBleHBvcnRBbGxEZWNsYXJhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZXhwb3J0TmFtZWREZWNsYXJhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBleHBvcnRTcGVjaWZpZXIoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRXhwb3J0U3BlY2lmaWVyXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBmb3JPZlN0YXRlbWVudCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJGb3JPZlN0YXRlbWVudFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gaW1wb3J0RGVjbGFyYXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiSW1wb3J0RGVjbGFyYXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGltcG9ydERlZmF1bHRTcGVjaWZpZXIoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiSW1wb3J0RGVmYXVsdFNwZWNpZmllclwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gaW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkltcG9ydE5hbWVzcGFjZVNwZWNpZmllclwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gaW1wb3J0U3BlY2lmaWVyKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkltcG9ydFNwZWNpZmllclwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gbWV0YVByb3BlcnR5KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIk1ldGFQcm9wZXJ0eVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gY2xhc3NNZXRob2QoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiQ2xhc3NNZXRob2RcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIG9iamVjdFBhdHRlcm4oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiT2JqZWN0UGF0dGVyblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gc3ByZWFkRWxlbWVudCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJTcHJlYWRFbGVtZW50XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBfc3VwZXIoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiU3VwZXJcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRlbXBsYXRlRWxlbWVudCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUZW1wbGF0ZUVsZW1lbnRcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRlbXBsYXRlTGl0ZXJhbCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUZW1wbGF0ZUxpdGVyYWxcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHlpZWxkRXhwcmVzc2lvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJZaWVsZEV4cHJlc3Npb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGF3YWl0RXhwcmVzc2lvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJBd2FpdEV4cHJlc3Npb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIF9pbXBvcnQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiSW1wb3J0XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBiaWdJbnRMaXRlcmFsKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkJpZ0ludExpdGVyYWxcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGV4cG9ydE5hbWVzcGFjZVNwZWNpZmllciguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIG9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIG9wdGlvbmFsQ2FsbEV4cHJlc3Npb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gYW55VHlwZUFubm90YXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiQW55VHlwZUFubm90YXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGFycmF5VHlwZUFubm90YXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiQXJyYXlUeXBlQW5ub3RhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gYm9vbGVhblR5cGVBbm5vdGF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkJvb2xlYW5UeXBlQW5ub3RhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gYm9vbGVhbkxpdGVyYWxUeXBlQW5ub3RhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJCb29sZWFuTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBudWxsTGl0ZXJhbFR5cGVBbm5vdGF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIk51bGxMaXRlcmFsVHlwZUFubm90YXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGNsYXNzSW1wbGVtZW50cyguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJDbGFzc0ltcGxlbWVudHNcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGRlY2xhcmVDbGFzcyguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJEZWNsYXJlQ2xhc3NcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGRlY2xhcmVGdW5jdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJEZWNsYXJlRnVuY3Rpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGRlY2xhcmVJbnRlcmZhY2UoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRGVjbGFyZUludGVyZmFjZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZGVjbGFyZU1vZHVsZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJEZWNsYXJlTW9kdWxlXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBkZWNsYXJlTW9kdWxlRXhwb3J0cyguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJEZWNsYXJlTW9kdWxlRXhwb3J0c1wiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZGVjbGFyZVR5cGVBbGlhcyguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJEZWNsYXJlVHlwZUFsaWFzXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBkZWNsYXJlT3BhcXVlVHlwZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJEZWNsYXJlT3BhcXVlVHlwZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZGVjbGFyZVZhcmlhYmxlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkRlY2xhcmVWYXJpYWJsZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkRlY2xhcmVFeHBvcnREZWNsYXJhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkRlY2xhcmVFeHBvcnRBbGxEZWNsYXJhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZGVjbGFyZWRQcmVkaWNhdGUoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRGVjbGFyZWRQcmVkaWNhdGVcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGV4aXN0c1R5cGVBbm5vdGF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkV4aXN0c1R5cGVBbm5vdGF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBmdW5jdGlvblR5cGVBbm5vdGF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkZ1bmN0aW9uVHlwZUFubm90YXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGZ1bmN0aW9uVHlwZVBhcmFtKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkZ1bmN0aW9uVHlwZVBhcmFtXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBnZW5lcmljVHlwZUFubm90YXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiR2VuZXJpY1R5cGVBbm5vdGF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBpbmZlcnJlZFByZWRpY2F0ZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJJbmZlcnJlZFByZWRpY2F0ZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJmYWNlRXh0ZW5kcyguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJJbnRlcmZhY2VFeHRlbmRzXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBpbnRlcmZhY2VEZWNsYXJhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJJbnRlcmZhY2VEZWNsYXJhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJmYWNlVHlwZUFubm90YXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiSW50ZXJmYWNlVHlwZUFubm90YXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdGlvblR5cGVBbm5vdGF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkludGVyc2VjdGlvblR5cGVBbm5vdGF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBtaXhlZFR5cGVBbm5vdGF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIk1peGVkVHlwZUFubm90YXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGVtcHR5VHlwZUFubm90YXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRW1wdHlUeXBlQW5ub3RhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gbnVsbGFibGVUeXBlQW5ub3RhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJOdWxsYWJsZVR5cGVBbm5vdGF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBudW1iZXJMaXRlcmFsVHlwZUFubm90YXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiTnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBudW1iZXJUeXBlQW5ub3RhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJOdW1iZXJUeXBlQW5ub3RhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gb2JqZWN0VHlwZUFubm90YXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiT2JqZWN0VHlwZUFubm90YXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIG9iamVjdFR5cGVJbnRlcm5hbFNsb3QoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiT2JqZWN0VHlwZUludGVybmFsU2xvdFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gb2JqZWN0VHlwZUNhbGxQcm9wZXJ0eSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJPYmplY3RUeXBlQ2FsbFByb3BlcnR5XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBvYmplY3RUeXBlSW5kZXhlciguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJPYmplY3RUeXBlSW5kZXhlclwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gb2JqZWN0VHlwZVByb3BlcnR5KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIk9iamVjdFR5cGVQcm9wZXJ0eVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gb2JqZWN0VHlwZVNwcmVhZFByb3BlcnR5KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIk9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gb3BhcXVlVHlwZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJPcGFxdWVUeXBlXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBxdWFsaWZpZWRUeXBlSWRlbnRpZmllciguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJRdWFsaWZpZWRUeXBlSWRlbnRpZmllclwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gc3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlN0cmluZ0xpdGVyYWxUeXBlQW5ub3RhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gc3RyaW5nVHlwZUFubm90YXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiU3RyaW5nVHlwZUFubm90YXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHN5bWJvbFR5cGVBbm5vdGF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlN5bWJvbFR5cGVBbm5vdGF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0aGlzVHlwZUFubm90YXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVGhpc1R5cGVBbm5vdGF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0dXBsZVR5cGVBbm5vdGF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlR1cGxlVHlwZUFubm90YXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHR5cGVvZlR5cGVBbm5vdGF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlR5cGVvZlR5cGVBbm5vdGF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0eXBlQWxpYXMoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVHlwZUFsaWFzXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0eXBlQW5ub3RhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUeXBlQW5ub3RhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHlwZUNhc3RFeHByZXNzaW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlR5cGVDYXN0RXhwcmVzc2lvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHlwZVBhcmFtZXRlciguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUeXBlUGFyYW1ldGVyXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0eXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0eXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdW5pb25UeXBlQW5ub3RhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJVbmlvblR5cGVBbm5vdGF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB2YXJpYW5jZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJWYXJpYW5jZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdm9pZFR5cGVBbm5vdGF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlZvaWRUeXBlQW5ub3RhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZW51bURlY2xhcmF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkVudW1EZWNsYXJhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZW51bUJvb2xlYW5Cb2R5KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkVudW1Cb29sZWFuQm9keVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZW51bU51bWJlckJvZHkoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRW51bU51bWJlckJvZHlcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGVudW1TdHJpbmdCb2R5KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkVudW1TdHJpbmdCb2R5XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBlbnVtU3ltYm9sQm9keSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJFbnVtU3ltYm9sQm9keVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZW51bUJvb2xlYW5NZW1iZXIoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRW51bUJvb2xlYW5NZW1iZXJcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGVudW1OdW1iZXJNZW1iZXIoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRW51bU51bWJlck1lbWJlclwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZW51bVN0cmluZ01lbWJlciguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJFbnVtU3RyaW5nTWVtYmVyXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBlbnVtRGVmYXVsdGVkTWVtYmVyKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkVudW1EZWZhdWx0ZWRNZW1iZXJcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGpzeEF0dHJpYnV0ZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJKU1hBdHRyaWJ1dGVcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGpzeENsb3NpbmdFbGVtZW50KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkpTWENsb3NpbmdFbGVtZW50XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBqc3hFbGVtZW50KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkpTWEVsZW1lbnRcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGpzeEVtcHR5RXhwcmVzc2lvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJKU1hFbXB0eUV4cHJlc3Npb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGpzeEV4cHJlc3Npb25Db250YWluZXIoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24ganN4U3ByZWFkQ2hpbGQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiSlNYU3ByZWFkQ2hpbGRcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGpzeElkZW50aWZpZXIoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiSlNYSWRlbnRpZmllclwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24ganN4TWVtYmVyRXhwcmVzc2lvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJKU1hNZW1iZXJFeHByZXNzaW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBqc3hOYW1lc3BhY2VkTmFtZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJKU1hOYW1lc3BhY2VkTmFtZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24ganN4T3BlbmluZ0VsZW1lbnQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiSlNYT3BlbmluZ0VsZW1lbnRcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGpzeFNwcmVhZEF0dHJpYnV0ZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJKU1hTcHJlYWRBdHRyaWJ1dGVcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGpzeFRleHQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiSlNYVGV4dFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24ganN4RnJhZ21lbnQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiSlNYRnJhZ21lbnRcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGpzeE9wZW5pbmdGcmFnbWVudCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJKU1hPcGVuaW5nRnJhZ21lbnRcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGpzeENsb3NpbmdGcmFnbWVudCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJKU1hDbG9zaW5nRnJhZ21lbnRcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIG5vb3AoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiTm9vcFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gcGxhY2Vob2xkZXIoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiUGxhY2Vob2xkZXJcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHY4SW50cmluc2ljSWRlbnRpZmllciguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJWOEludHJpbnNpY0lkZW50aWZpZXJcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGFyZ3VtZW50UGxhY2Vob2xkZXIoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiQXJndW1lbnRQbGFjZWhvbGRlclwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gYmluZEV4cHJlc3Npb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiQmluZEV4cHJlc3Npb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGNsYXNzUHJvcGVydHkoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiQ2xhc3NQcm9wZXJ0eVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gcGlwZWxpbmVUb3BpY0V4cHJlc3Npb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiUGlwZWxpbmVUb3BpY0V4cHJlc3Npb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHBpcGVsaW5lQmFyZUZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlBpcGVsaW5lQmFyZUZ1bmN0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBwaXBlbGluZVByaW1hcnlUb3BpY1JlZmVyZW5jZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJQaXBlbGluZVByaW1hcnlUb3BpY1JlZmVyZW5jZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gY2xhc3NQcml2YXRlUHJvcGVydHkoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiQ2xhc3NQcml2YXRlUHJvcGVydHlcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGNsYXNzUHJpdmF0ZU1ldGhvZCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJDbGFzc1ByaXZhdGVNZXRob2RcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGltcG9ydEF0dHJpYnV0ZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJJbXBvcnRBdHRyaWJ1dGVcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGRlY29yYXRvciguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJEZWNvcmF0b3JcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGRvRXhwcmVzc2lvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJEb0V4cHJlc3Npb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGV4cG9ydERlZmF1bHRTcGVjaWZpZXIoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRXhwb3J0RGVmYXVsdFNwZWNpZmllclwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gcHJpdmF0ZU5hbWUoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiUHJpdmF0ZU5hbWVcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHJlY29yZEV4cHJlc3Npb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiUmVjb3JkRXhwcmVzc2lvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHVwbGVFeHByZXNzaW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlR1cGxlRXhwcmVzc2lvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZGVjaW1hbExpdGVyYWwoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRGVjaW1hbExpdGVyYWxcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzUGFyYW1ldGVyUHJvcGVydHkoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNQYXJhbWV0ZXJQcm9wZXJ0eVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNEZWNsYXJlRnVuY3Rpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNEZWNsYXJlRnVuY3Rpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzRGVjbGFyZU1ldGhvZCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU0RlY2xhcmVNZXRob2RcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzUXVhbGlmaWVkTmFtZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU1F1YWxpZmllZE5hbWVcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzQ2FsbFNpZ25hdHVyZURlY2xhcmF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTQ2FsbFNpZ25hdHVyZURlY2xhcmF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c0NvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzUHJvcGVydHlTaWduYXR1cmUoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNQcm9wZXJ0eVNpZ25hdHVyZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNNZXRob2RTaWduYXR1cmUoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNNZXRob2RTaWduYXR1cmVcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzSW5kZXhTaWduYXR1cmUoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNJbmRleFNpZ25hdHVyZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNBbnlLZXl3b3JkKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTQW55S2V5d29yZFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNCb29sZWFuS2V5d29yZCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU0Jvb2xlYW5LZXl3b3JkXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c0JpZ0ludEtleXdvcmQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNCaWdJbnRLZXl3b3JkXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c05ldmVyS2V5d29yZCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU05ldmVyS2V5d29yZFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNOdWxsS2V5d29yZCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU051bGxLZXl3b3JkXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c051bWJlcktleXdvcmQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNOdW1iZXJLZXl3b3JkXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c09iamVjdEtleXdvcmQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNPYmplY3RLZXl3b3JkXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c1N0cmluZ0tleXdvcmQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNTdHJpbmdLZXl3b3JkXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c1N5bWJvbEtleXdvcmQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNTeW1ib2xLZXl3b3JkXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c1VuZGVmaW5lZEtleXdvcmQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNVbmRlZmluZWRLZXl3b3JkXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c1Vua25vd25LZXl3b3JkKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTVW5rbm93bktleXdvcmRcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzVm9pZEtleXdvcmQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNWb2lkS2V5d29yZFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNUaGlzVHlwZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU1RoaXNUeXBlXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c0Z1bmN0aW9uVHlwZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU0Z1bmN0aW9uVHlwZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNDb25zdHJ1Y3RvclR5cGUoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNDb25zdHJ1Y3RvclR5cGVcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzVHlwZVJlZmVyZW5jZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU1R5cGVSZWZlcmVuY2VcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzVHlwZVByZWRpY2F0ZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU1R5cGVQcmVkaWNhdGVcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzVHlwZVF1ZXJ5KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTVHlwZVF1ZXJ5XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c1R5cGVMaXRlcmFsKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTVHlwZUxpdGVyYWxcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzQXJyYXlUeXBlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTQXJyYXlUeXBlXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c1R1cGxlVHlwZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU1R1cGxlVHlwZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNPcHRpb25hbFR5cGUoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNPcHRpb25hbFR5cGVcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzUmVzdFR5cGUoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNSZXN0VHlwZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNOYW1lZFR1cGxlTWVtYmVyKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTTmFtZWRUdXBsZU1lbWJlclwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNVbmlvblR5cGUoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNVbmlvblR5cGVcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzSW50ZXJzZWN0aW9uVHlwZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU0ludGVyc2VjdGlvblR5cGVcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzQ29uZGl0aW9uYWxUeXBlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTQ29uZGl0aW9uYWxUeXBlXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c0luZmVyVHlwZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU0luZmVyVHlwZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNQYXJlbnRoZXNpemVkVHlwZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU1BhcmVudGhlc2l6ZWRUeXBlXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c1R5cGVPcGVyYXRvciguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU1R5cGVPcGVyYXRvclwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNJbmRleGVkQWNjZXNzVHlwZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU0luZGV4ZWRBY2Nlc3NUeXBlXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c01hcHBlZFR5cGUoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNNYXBwZWRUeXBlXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c0xpdGVyYWxUeXBlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTTGl0ZXJhbFR5cGVcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c0ludGVyZmFjZURlY2xhcmF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTSW50ZXJmYWNlRGVjbGFyYXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzSW50ZXJmYWNlQm9keSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU0ludGVyZmFjZUJvZHlcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzVHlwZUFsaWFzRGVjbGFyYXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNUeXBlQWxpYXNEZWNsYXJhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNBc0V4cHJlc3Npb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNBc0V4cHJlc3Npb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzVHlwZUFzc2VydGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU1R5cGVBc3NlcnRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzRW51bURlY2xhcmF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTRW51bURlY2xhcmF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c0VudW1NZW1iZXIoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNFbnVtTWVtYmVyXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c01vZHVsZURlY2xhcmF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTTW9kdWxlRGVjbGFyYXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzTW9kdWxlQmxvY2soLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNNb2R1bGVCbG9ja1wiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNJbXBvcnRUeXBlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTSW1wb3J0VHlwZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU0ltcG9ydEVxdWFsc0RlY2xhcmF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2VcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzTm9uTnVsbEV4cHJlc3Npb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNOb25OdWxsRXhwcmVzc2lvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNFeHBvcnRBc3NpZ25tZW50KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTRXhwb3J0QXNzaWdubWVudFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNOYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU05hbWVzcGFjZUV4cG9ydERlY2xhcmF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c1R5cGVBbm5vdGF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTVHlwZUFubm90YXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzVHlwZVBhcmFtZXRlciguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU1R5cGVQYXJhbWV0ZXJcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIE51bWJlckxpdGVyYWwoLi4uYXJncykge1xuICBjb25zb2xlLnRyYWNlKFwiVGhlIG5vZGUgdHlwZSBOdW1iZXJMaXRlcmFsIGhhcyBiZWVuIHJlbmFtZWQgdG8gTnVtZXJpY0xpdGVyYWxcIik7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJOdW1iZXJMaXRlcmFsXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBSZWdleExpdGVyYWwoLi4uYXJncykge1xuICBjb25zb2xlLnRyYWNlKFwiVGhlIG5vZGUgdHlwZSBSZWdleExpdGVyYWwgaGFzIGJlZW4gcmVuYW1lZCB0byBSZWdFeHBMaXRlcmFsXCIpO1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiUmVnZXhMaXRlcmFsXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBSZXN0UHJvcGVydHkoLi4uYXJncykge1xuICBjb25zb2xlLnRyYWNlKFwiVGhlIG5vZGUgdHlwZSBSZXN0UHJvcGVydHkgaGFzIGJlZW4gcmVuYW1lZCB0byBSZXN0RWxlbWVudFwiKTtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlJlc3RQcm9wZXJ0eVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gU3ByZWFkUHJvcGVydHkoLi4uYXJncykge1xuICBjb25zb2xlLnRyYWNlKFwiVGhlIG5vZGUgdHlwZSBTcHJlYWRQcm9wZXJ0eSBoYXMgYmVlbiByZW5hbWVkIHRvIFNwcmVhZEVsZW1lbnRcIik7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJTcHJlYWRQcm9wZXJ0eVwiLCAuLi5hcmdzKTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGJ1aWxkQ2hpbGRyZW47XG5cbnZhciBfZ2VuZXJhdGVkID0gcmVxdWlyZShcIi4uLy4uL3ZhbGlkYXRvcnMvZ2VuZXJhdGVkXCIpO1xuXG52YXIgX2NsZWFuSlNYRWxlbWVudExpdGVyYWxDaGlsZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uL3V0aWxzL3JlYWN0L2NsZWFuSlNYRWxlbWVudExpdGVyYWxDaGlsZFwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGJ1aWxkQ2hpbGRyZW4obm9kZSkge1xuICBjb25zdCBlbGVtZW50cyA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGxldCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG5cbiAgICBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNKU1hUZXh0KShjaGlsZCkpIHtcbiAgICAgICgwLCBfY2xlYW5KU1hFbGVtZW50TGl0ZXJhbENoaWxkLmRlZmF1bHQpKGNoaWxkLCBlbGVtZW50cyk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNKU1hFeHByZXNzaW9uQ29udGFpbmVyKShjaGlsZCkpIGNoaWxkID0gY2hpbGQuZXhwcmVzc2lvbjtcbiAgICBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNKU1hFbXB0eUV4cHJlc3Npb24pKGNoaWxkKSkgY29udGludWU7XG4gICAgZWxlbWVudHMucHVzaChjaGlsZCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudHM7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVUU1VuaW9uVHlwZTtcblxudmFyIF9nZW5lcmF0ZWQgPSByZXF1aXJlKFwiLi4vZ2VuZXJhdGVkXCIpO1xuXG52YXIgX3JlbW92ZVR5cGVEdXBsaWNhdGVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vbW9kaWZpY2F0aW9ucy90eXBlc2NyaXB0L3JlbW92ZVR5cGVEdXBsaWNhdGVzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gY3JlYXRlVFNVbmlvblR5cGUodHlwZUFubm90YXRpb25zKSB7XG4gIGNvbnN0IHR5cGVzID0gdHlwZUFubm90YXRpb25zLm1hcCh0eXBlID0+IHR5cGUudHlwZUFubm90YXRpb25zKTtcbiAgY29uc3QgZmxhdHRlbmVkID0gKDAsIF9yZW1vdmVUeXBlRHVwbGljYXRlcy5kZWZhdWx0KSh0eXBlcyk7XG5cbiAgaWYgKGZsYXR0ZW5lZC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZmxhdHRlbmVkWzBdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoMCwgX2dlbmVyYXRlZC50c1VuaW9uVHlwZSkoZmxhdHRlbmVkKTtcbiAgfVxufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gY2xvbmU7XG5cbnZhciBfY2xvbmVOb2RlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jbG9uZU5vZGVcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBjbG9uZShub2RlKSB7XG4gIHJldHVybiAoMCwgX2Nsb25lTm9kZS5kZWZhdWx0KShub2RlLCBmYWxzZSk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBjbG9uZURlZXA7XG5cbnZhciBfY2xvbmVOb2RlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jbG9uZU5vZGVcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBjbG9uZURlZXAobm9kZSkge1xuICByZXR1cm4gKDAsIF9jbG9uZU5vZGUuZGVmYXVsdCkobm9kZSk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBjbG9uZURlZXBXaXRob3V0TG9jO1xuXG52YXIgX2Nsb25lTm9kZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY2xvbmVOb2RlXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gY2xvbmVEZWVwV2l0aG91dExvYyhub2RlKSB7XG4gIHJldHVybiAoMCwgX2Nsb25lTm9kZS5kZWZhdWx0KShub2RlLCB0cnVlLCB0cnVlKTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNsb25lTm9kZTtcblxudmFyIF9kZWZpbml0aW9ucyA9IHJlcXVpcmUoXCIuLi9kZWZpbml0aW9uc1wiKTtcblxuY29uc3QgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuXG5mdW5jdGlvbiBjbG9uZUlmTm9kZShvYmosIGRlZXAsIHdpdGhvdXRMb2MpIHtcbiAgaWYgKG9iaiAmJiB0eXBlb2Ygb2JqLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gY2xvbmVOb2RlKG9iaiwgZGVlcCwgd2l0aG91dExvYyk7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBjbG9uZUlmTm9kZU9yQXJyYXkob2JqLCBkZWVwLCB3aXRob3V0TG9jKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqLm1hcChub2RlID0+IGNsb25lSWZOb2RlKG5vZGUsIGRlZXAsIHdpdGhvdXRMb2MpKTtcbiAgfVxuXG4gIHJldHVybiBjbG9uZUlmTm9kZShvYmosIGRlZXAsIHdpdGhvdXRMb2MpO1xufVxuXG5mdW5jdGlvbiBjbG9uZU5vZGUobm9kZSwgZGVlcCA9IHRydWUsIHdpdGhvdXRMb2MgPSBmYWxzZSkge1xuICBpZiAoIW5vZGUpIHJldHVybiBub2RlO1xuICBjb25zdCB7XG4gICAgdHlwZVxuICB9ID0gbm9kZTtcbiAgY29uc3QgbmV3Tm9kZSA9IHtcbiAgICB0eXBlXG4gIH07XG5cbiAgaWYgKHR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgbmV3Tm9kZS5uYW1lID0gbm9kZS5uYW1lO1xuXG4gICAgaWYgKGhhcyhub2RlLCBcIm9wdGlvbmFsXCIpICYmIHR5cGVvZiBub2RlLm9wdGlvbmFsID09PSBcImJvb2xlYW5cIikge1xuICAgICAgbmV3Tm9kZS5vcHRpb25hbCA9IG5vZGUub3B0aW9uYWw7XG4gICAgfVxuXG4gICAgaWYgKGhhcyhub2RlLCBcInR5cGVBbm5vdGF0aW9uXCIpKSB7XG4gICAgICBuZXdOb2RlLnR5cGVBbm5vdGF0aW9uID0gZGVlcCA/IGNsb25lSWZOb2RlT3JBcnJheShub2RlLnR5cGVBbm5vdGF0aW9uLCB0cnVlLCB3aXRob3V0TG9jKSA6IG5vZGUudHlwZUFubm90YXRpb247XG4gICAgfVxuICB9IGVsc2UgaWYgKCFoYXMoX2RlZmluaXRpb25zLk5PREVfRklFTERTLCB0eXBlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBub2RlIHR5cGU6IFwiJHt0eXBlfVwiYCk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiBPYmplY3Qua2V5cyhfZGVmaW5pdGlvbnMuTk9ERV9GSUVMRFNbdHlwZV0pKSB7XG4gICAgICBpZiAoaGFzKG5vZGUsIGZpZWxkKSkge1xuICAgICAgICBpZiAoZGVlcCkge1xuICAgICAgICAgIG5ld05vZGVbZmllbGRdID0gdHlwZSA9PT0gXCJGaWxlXCIgJiYgZmllbGQgPT09IFwiY29tbWVudHNcIiA/IG1heWJlQ2xvbmVDb21tZW50cyhub2RlLmNvbW1lbnRzLCBkZWVwLCB3aXRob3V0TG9jKSA6IGNsb25lSWZOb2RlT3JBcnJheShub2RlW2ZpZWxkXSwgdHJ1ZSwgd2l0aG91dExvYyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3Tm9kZVtmaWVsZF0gPSBub2RlW2ZpZWxkXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChoYXMobm9kZSwgXCJsb2NcIikpIHtcbiAgICBpZiAod2l0aG91dExvYykge1xuICAgICAgbmV3Tm9kZS5sb2MgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdOb2RlLmxvYyA9IG5vZGUubG9jO1xuICAgIH1cbiAgfVxuXG4gIGlmIChoYXMobm9kZSwgXCJsZWFkaW5nQ29tbWVudHNcIikpIHtcbiAgICBuZXdOb2RlLmxlYWRpbmdDb21tZW50cyA9IG1heWJlQ2xvbmVDb21tZW50cyhub2RlLmxlYWRpbmdDb21tZW50cywgZGVlcCwgd2l0aG91dExvYyk7XG4gIH1cblxuICBpZiAoaGFzKG5vZGUsIFwiaW5uZXJDb21tZW50c1wiKSkge1xuICAgIG5ld05vZGUuaW5uZXJDb21tZW50cyA9IG1heWJlQ2xvbmVDb21tZW50cyhub2RlLmlubmVyQ29tbWVudHMsIGRlZXAsIHdpdGhvdXRMb2MpO1xuICB9XG5cbiAgaWYgKGhhcyhub2RlLCBcInRyYWlsaW5nQ29tbWVudHNcIikpIHtcbiAgICBuZXdOb2RlLnRyYWlsaW5nQ29tbWVudHMgPSBtYXliZUNsb25lQ29tbWVudHMobm9kZS50cmFpbGluZ0NvbW1lbnRzLCBkZWVwLCB3aXRob3V0TG9jKTtcbiAgfVxuXG4gIGlmIChoYXMobm9kZSwgXCJleHRyYVwiKSkge1xuICAgIG5ld05vZGUuZXh0cmEgPSBPYmplY3QuYXNzaWduKHt9LCBub2RlLmV4dHJhKTtcbiAgfVxuXG4gIHJldHVybiBuZXdOb2RlO1xufVxuXG5mdW5jdGlvbiBjbG9uZUNvbW1lbnRzV2l0aG91dExvYyhjb21tZW50cykge1xuICByZXR1cm4gY29tbWVudHMubWFwKCh7XG4gICAgdHlwZSxcbiAgICB2YWx1ZVxuICB9KSA9PiAoe1xuICAgIHR5cGUsXG4gICAgdmFsdWUsXG4gICAgbG9jOiBudWxsXG4gIH0pKTtcbn1cblxuZnVuY3Rpb24gbWF5YmVDbG9uZUNvbW1lbnRzKGNvbW1lbnRzLCBkZWVwLCB3aXRob3V0TG9jKSB7XG4gIHJldHVybiBkZWVwICYmIHdpdGhvdXRMb2MgPyBjbG9uZUNvbW1lbnRzV2l0aG91dExvYyhjb21tZW50cykgOiBjb21tZW50cztcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNsb25lV2l0aG91dExvYztcblxudmFyIF9jbG9uZU5vZGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Nsb25lTm9kZVwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGNsb25lV2l0aG91dExvYyhub2RlKSB7XG4gIHJldHVybiAoMCwgX2Nsb25lTm9kZS5kZWZhdWx0KShub2RlLCBmYWxzZSwgdHJ1ZSk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBhZGRDb21tZW50O1xuXG52YXIgX2FkZENvbW1lbnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9hZGRDb21tZW50c1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGFkZENvbW1lbnQobm9kZSwgdHlwZSwgY29udGVudCwgbGluZSkge1xuICByZXR1cm4gKDAsIF9hZGRDb21tZW50cy5kZWZhdWx0KShub2RlLCB0eXBlLCBbe1xuICAgIHR5cGU6IGxpbmUgPyBcIkNvbW1lbnRMaW5lXCIgOiBcIkNvbW1lbnRCbG9ja1wiLFxuICAgIHZhbHVlOiBjb250ZW50XG4gIH1dKTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGFkZENvbW1lbnRzO1xuXG5mdW5jdGlvbiBhZGRDb21tZW50cyhub2RlLCB0eXBlLCBjb21tZW50cykge1xuICBpZiAoIWNvbW1lbnRzIHx8ICFub2RlKSByZXR1cm4gbm9kZTtcbiAgY29uc3Qga2V5ID0gYCR7dHlwZX1Db21tZW50c2A7XG5cbiAgaWYgKG5vZGVba2V5XSkge1xuICAgIGlmICh0eXBlID09PSBcImxlYWRpbmdcIikge1xuICAgICAgbm9kZVtrZXldID0gY29tbWVudHMuY29uY2F0KG5vZGVba2V5XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGVba2V5XSA9IG5vZGVba2V5XS5jb25jYXQoY29tbWVudHMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBub2RlW2tleV0gPSBjb21tZW50cztcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaW5oZXJpdElubmVyQ29tbWVudHM7XG5cbnZhciBfaW5oZXJpdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3V0aWxzL2luaGVyaXRcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBpbmhlcml0SW5uZXJDb21tZW50cyhjaGlsZCwgcGFyZW50KSB7XG4gICgwLCBfaW5oZXJpdC5kZWZhdWx0KShcImlubmVyQ29tbWVudHNcIiwgY2hpbGQsIHBhcmVudCk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpbmhlcml0TGVhZGluZ0NvbW1lbnRzO1xuXG52YXIgX2luaGVyaXQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi91dGlscy9pbmhlcml0XCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gaW5oZXJpdExlYWRpbmdDb21tZW50cyhjaGlsZCwgcGFyZW50KSB7XG4gICgwLCBfaW5oZXJpdC5kZWZhdWx0KShcImxlYWRpbmdDb21tZW50c1wiLCBjaGlsZCwgcGFyZW50KTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGluaGVyaXRUcmFpbGluZ0NvbW1lbnRzO1xuXG52YXIgX2luaGVyaXQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi91dGlscy9pbmhlcml0XCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gaW5oZXJpdFRyYWlsaW5nQ29tbWVudHMoY2hpbGQsIHBhcmVudCkge1xuICAoMCwgX2luaGVyaXQuZGVmYXVsdCkoXCJ0cmFpbGluZ0NvbW1lbnRzXCIsIGNoaWxkLCBwYXJlbnQpO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaW5oZXJpdHNDb21tZW50cztcblxudmFyIF9pbmhlcml0VHJhaWxpbmdDb21tZW50cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaW5oZXJpdFRyYWlsaW5nQ29tbWVudHNcIikpO1xuXG52YXIgX2luaGVyaXRMZWFkaW5nQ29tbWVudHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2luaGVyaXRMZWFkaW5nQ29tbWVudHNcIikpO1xuXG52YXIgX2luaGVyaXRJbm5lckNvbW1lbnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pbmhlcml0SW5uZXJDb21tZW50c1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGluaGVyaXRzQ29tbWVudHMoY2hpbGQsIHBhcmVudCkge1xuICAoMCwgX2luaGVyaXRUcmFpbGluZ0NvbW1lbnRzLmRlZmF1bHQpKGNoaWxkLCBwYXJlbnQpO1xuICAoMCwgX2luaGVyaXRMZWFkaW5nQ29tbWVudHMuZGVmYXVsdCkoY2hpbGQsIHBhcmVudCk7XG4gICgwLCBfaW5oZXJpdElubmVyQ29tbWVudHMuZGVmYXVsdCkoY2hpbGQsIHBhcmVudCk7XG4gIHJldHVybiBjaGlsZDtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHJlbW92ZUNvbW1lbnRzO1xuXG52YXIgX2NvbnN0YW50cyA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHNcIik7XG5cbmZ1bmN0aW9uIHJlbW92ZUNvbW1lbnRzKG5vZGUpIHtcbiAgX2NvbnN0YW50cy5DT01NRU5UX0tFWVMuZm9yRWFjaChrZXkgPT4ge1xuICAgIG5vZGVba2V5XSA9IG51bGw7XG4gIH0pO1xuXG4gIHJldHVybiBub2RlO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5UU0JBU0VUWVBFX1RZUEVTID0gZXhwb3J0cy5UU1RZUEVfVFlQRVMgPSBleHBvcnRzLlRTVFlQRUVMRU1FTlRfVFlQRVMgPSBleHBvcnRzLlBSSVZBVEVfVFlQRVMgPSBleHBvcnRzLkpTWF9UWVBFUyA9IGV4cG9ydHMuRU5VTU1FTUJFUl9UWVBFUyA9IGV4cG9ydHMuRU5VTUJPRFlfVFlQRVMgPSBleHBvcnRzLkZMT1dQUkVESUNBVEVfVFlQRVMgPSBleHBvcnRzLkZMT1dERUNMQVJBVElPTl9UWVBFUyA9IGV4cG9ydHMuRkxPV0JBU0VBTk5PVEFUSU9OX1RZUEVTID0gZXhwb3J0cy5GTE9XVFlQRV9UWVBFUyA9IGV4cG9ydHMuRkxPV19UWVBFUyA9IGV4cG9ydHMuTU9EVUxFU1BFQ0lGSUVSX1RZUEVTID0gZXhwb3J0cy5FWFBPUlRERUNMQVJBVElPTl9UWVBFUyA9IGV4cG9ydHMuTU9EVUxFREVDTEFSQVRJT05fVFlQRVMgPSBleHBvcnRzLkNMQVNTX1RZUEVTID0gZXhwb3J0cy5QQVRURVJOX1RZUEVTID0gZXhwb3J0cy5VTkFSWUxJS0VfVFlQRVMgPSBleHBvcnRzLlBST1BFUlRZX1RZUEVTID0gZXhwb3J0cy5PQkpFQ1RNRU1CRVJfVFlQRVMgPSBleHBvcnRzLk1FVEhPRF9UWVBFUyA9IGV4cG9ydHMuVVNFUldISVRFU1BBQ0FCTEVfVFlQRVMgPSBleHBvcnRzLklNTVVUQUJMRV9UWVBFUyA9IGV4cG9ydHMuTElURVJBTF9UWVBFUyA9IGV4cG9ydHMuVFNFTlRJVFlOQU1FX1RZUEVTID0gZXhwb3J0cy5MVkFMX1RZUEVTID0gZXhwb3J0cy5QQVRURVJOTElLRV9UWVBFUyA9IGV4cG9ydHMuREVDTEFSQVRJT05fVFlQRVMgPSBleHBvcnRzLlBVUkVJU0hfVFlQRVMgPSBleHBvcnRzLkZVTkNUSU9OUEFSRU5UX1RZUEVTID0gZXhwb3J0cy5GVU5DVElPTl9UWVBFUyA9IGV4cG9ydHMuRk9SWFNUQVRFTUVOVF9UWVBFUyA9IGV4cG9ydHMuRk9SX1RZUEVTID0gZXhwb3J0cy5FWFBSRVNTSU9OV1JBUFBFUl9UWVBFUyA9IGV4cG9ydHMuV0hJTEVfVFlQRVMgPSBleHBvcnRzLkxPT1BfVFlQRVMgPSBleHBvcnRzLkNPTkRJVElPTkFMX1RZUEVTID0gZXhwb3J0cy5DT01QTEVUSU9OU1RBVEVNRU5UX1RZUEVTID0gZXhwb3J0cy5URVJNSU5BVE9STEVTU19UWVBFUyA9IGV4cG9ydHMuU1RBVEVNRU5UX1RZUEVTID0gZXhwb3J0cy5CTE9DS19UWVBFUyA9IGV4cG9ydHMuQkxPQ0tQQVJFTlRfVFlQRVMgPSBleHBvcnRzLlNDT1BBQkxFX1RZUEVTID0gZXhwb3J0cy5CSU5BUllfVFlQRVMgPSBleHBvcnRzLkVYUFJFU1NJT05fVFlQRVMgPSB2b2lkIDA7XG5cbnZhciBfZGVmaW5pdGlvbnMgPSByZXF1aXJlKFwiLi4vLi4vZGVmaW5pdGlvbnNcIik7XG5cbmNvbnN0IEVYUFJFU1NJT05fVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiRXhwcmVzc2lvblwiXTtcbmV4cG9ydHMuRVhQUkVTU0lPTl9UWVBFUyA9IEVYUFJFU1NJT05fVFlQRVM7XG5jb25zdCBCSU5BUllfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiQmluYXJ5XCJdO1xuZXhwb3J0cy5CSU5BUllfVFlQRVMgPSBCSU5BUllfVFlQRVM7XG5jb25zdCBTQ09QQUJMRV9UWVBFUyA9IF9kZWZpbml0aW9ucy5GTElQUEVEX0FMSUFTX0tFWVNbXCJTY29wYWJsZVwiXTtcbmV4cG9ydHMuU0NPUEFCTEVfVFlQRVMgPSBTQ09QQUJMRV9UWVBFUztcbmNvbnN0IEJMT0NLUEFSRU5UX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIkJsb2NrUGFyZW50XCJdO1xuZXhwb3J0cy5CTE9DS1BBUkVOVF9UWVBFUyA9IEJMT0NLUEFSRU5UX1RZUEVTO1xuY29uc3QgQkxPQ0tfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiQmxvY2tcIl07XG5leHBvcnRzLkJMT0NLX1RZUEVTID0gQkxPQ0tfVFlQRVM7XG5jb25zdCBTVEFURU1FTlRfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiU3RhdGVtZW50XCJdO1xuZXhwb3J0cy5TVEFURU1FTlRfVFlQRVMgPSBTVEFURU1FTlRfVFlQRVM7XG5jb25zdCBURVJNSU5BVE9STEVTU19UWVBFUyA9IF9kZWZpbml0aW9ucy5GTElQUEVEX0FMSUFTX0tFWVNbXCJUZXJtaW5hdG9ybGVzc1wiXTtcbmV4cG9ydHMuVEVSTUlOQVRPUkxFU1NfVFlQRVMgPSBURVJNSU5BVE9STEVTU19UWVBFUztcbmNvbnN0IENPTVBMRVRJT05TVEFURU1FTlRfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiQ29tcGxldGlvblN0YXRlbWVudFwiXTtcbmV4cG9ydHMuQ09NUExFVElPTlNUQVRFTUVOVF9UWVBFUyA9IENPTVBMRVRJT05TVEFURU1FTlRfVFlQRVM7XG5jb25zdCBDT05ESVRJT05BTF9UWVBFUyA9IF9kZWZpbml0aW9ucy5GTElQUEVEX0FMSUFTX0tFWVNbXCJDb25kaXRpb25hbFwiXTtcbmV4cG9ydHMuQ09ORElUSU9OQUxfVFlQRVMgPSBDT05ESVRJT05BTF9UWVBFUztcbmNvbnN0IExPT1BfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiTG9vcFwiXTtcbmV4cG9ydHMuTE9PUF9UWVBFUyA9IExPT1BfVFlQRVM7XG5jb25zdCBXSElMRV9UWVBFUyA9IF9kZWZpbml0aW9ucy5GTElQUEVEX0FMSUFTX0tFWVNbXCJXaGlsZVwiXTtcbmV4cG9ydHMuV0hJTEVfVFlQRVMgPSBXSElMRV9UWVBFUztcbmNvbnN0IEVYUFJFU1NJT05XUkFQUEVSX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIkV4cHJlc3Npb25XcmFwcGVyXCJdO1xuZXhwb3J0cy5FWFBSRVNTSU9OV1JBUFBFUl9UWVBFUyA9IEVYUFJFU1NJT05XUkFQUEVSX1RZUEVTO1xuY29uc3QgRk9SX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIkZvclwiXTtcbmV4cG9ydHMuRk9SX1RZUEVTID0gRk9SX1RZUEVTO1xuY29uc3QgRk9SWFNUQVRFTUVOVF9UWVBFUyA9IF9kZWZpbml0aW9ucy5GTElQUEVEX0FMSUFTX0tFWVNbXCJGb3JYU3RhdGVtZW50XCJdO1xuZXhwb3J0cy5GT1JYU1RBVEVNRU5UX1RZUEVTID0gRk9SWFNUQVRFTUVOVF9UWVBFUztcbmNvbnN0IEZVTkNUSU9OX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIkZ1bmN0aW9uXCJdO1xuZXhwb3J0cy5GVU5DVElPTl9UWVBFUyA9IEZVTkNUSU9OX1RZUEVTO1xuY29uc3QgRlVOQ1RJT05QQVJFTlRfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiRnVuY3Rpb25QYXJlbnRcIl07XG5leHBvcnRzLkZVTkNUSU9OUEFSRU5UX1RZUEVTID0gRlVOQ1RJT05QQVJFTlRfVFlQRVM7XG5jb25zdCBQVVJFSVNIX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIlB1cmVpc2hcIl07XG5leHBvcnRzLlBVUkVJU0hfVFlQRVMgPSBQVVJFSVNIX1RZUEVTO1xuY29uc3QgREVDTEFSQVRJT05fVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiRGVjbGFyYXRpb25cIl07XG5leHBvcnRzLkRFQ0xBUkFUSU9OX1RZUEVTID0gREVDTEFSQVRJT05fVFlQRVM7XG5jb25zdCBQQVRURVJOTElLRV9UWVBFUyA9IF9kZWZpbml0aW9ucy5GTElQUEVEX0FMSUFTX0tFWVNbXCJQYXR0ZXJuTGlrZVwiXTtcbmV4cG9ydHMuUEFUVEVSTkxJS0VfVFlQRVMgPSBQQVRURVJOTElLRV9UWVBFUztcbmNvbnN0IExWQUxfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiTFZhbFwiXTtcbmV4cG9ydHMuTFZBTF9UWVBFUyA9IExWQUxfVFlQRVM7XG5jb25zdCBUU0VOVElUWU5BTUVfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiVFNFbnRpdHlOYW1lXCJdO1xuZXhwb3J0cy5UU0VOVElUWU5BTUVfVFlQRVMgPSBUU0VOVElUWU5BTUVfVFlQRVM7XG5jb25zdCBMSVRFUkFMX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIkxpdGVyYWxcIl07XG5leHBvcnRzLkxJVEVSQUxfVFlQRVMgPSBMSVRFUkFMX1RZUEVTO1xuY29uc3QgSU1NVVRBQkxFX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIkltbXV0YWJsZVwiXTtcbmV4cG9ydHMuSU1NVVRBQkxFX1RZUEVTID0gSU1NVVRBQkxFX1RZUEVTO1xuY29uc3QgVVNFUldISVRFU1BBQ0FCTEVfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiVXNlcldoaXRlc3BhY2FibGVcIl07XG5leHBvcnRzLlVTRVJXSElURVNQQUNBQkxFX1RZUEVTID0gVVNFUldISVRFU1BBQ0FCTEVfVFlQRVM7XG5jb25zdCBNRVRIT0RfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiTWV0aG9kXCJdO1xuZXhwb3J0cy5NRVRIT0RfVFlQRVMgPSBNRVRIT0RfVFlQRVM7XG5jb25zdCBPQkpFQ1RNRU1CRVJfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiT2JqZWN0TWVtYmVyXCJdO1xuZXhwb3J0cy5PQkpFQ1RNRU1CRVJfVFlQRVMgPSBPQkpFQ1RNRU1CRVJfVFlQRVM7XG5jb25zdCBQUk9QRVJUWV9UWVBFUyA9IF9kZWZpbml0aW9ucy5GTElQUEVEX0FMSUFTX0tFWVNbXCJQcm9wZXJ0eVwiXTtcbmV4cG9ydHMuUFJPUEVSVFlfVFlQRVMgPSBQUk9QRVJUWV9UWVBFUztcbmNvbnN0IFVOQVJZTElLRV9UWVBFUyA9IF9kZWZpbml0aW9ucy5GTElQUEVEX0FMSUFTX0tFWVNbXCJVbmFyeUxpa2VcIl07XG5leHBvcnRzLlVOQVJZTElLRV9UWVBFUyA9IFVOQVJZTElLRV9UWVBFUztcbmNvbnN0IFBBVFRFUk5fVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiUGF0dGVyblwiXTtcbmV4cG9ydHMuUEFUVEVSTl9UWVBFUyA9IFBBVFRFUk5fVFlQRVM7XG5jb25zdCBDTEFTU19UWVBFUyA9IF9kZWZpbml0aW9ucy5GTElQUEVEX0FMSUFTX0tFWVNbXCJDbGFzc1wiXTtcbmV4cG9ydHMuQ0xBU1NfVFlQRVMgPSBDTEFTU19UWVBFUztcbmNvbnN0IE1PRFVMRURFQ0xBUkFUSU9OX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIk1vZHVsZURlY2xhcmF0aW9uXCJdO1xuZXhwb3J0cy5NT0RVTEVERUNMQVJBVElPTl9UWVBFUyA9IE1PRFVMRURFQ0xBUkFUSU9OX1RZUEVTO1xuY29uc3QgRVhQT1JUREVDTEFSQVRJT05fVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiRXhwb3J0RGVjbGFyYXRpb25cIl07XG5leHBvcnRzLkVYUE9SVERFQ0xBUkFUSU9OX1RZUEVTID0gRVhQT1JUREVDTEFSQVRJT05fVFlQRVM7XG5jb25zdCBNT0RVTEVTUEVDSUZJRVJfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiTW9kdWxlU3BlY2lmaWVyXCJdO1xuZXhwb3J0cy5NT0RVTEVTUEVDSUZJRVJfVFlQRVMgPSBNT0RVTEVTUEVDSUZJRVJfVFlQRVM7XG5jb25zdCBGTE9XX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIkZsb3dcIl07XG5leHBvcnRzLkZMT1dfVFlQRVMgPSBGTE9XX1RZUEVTO1xuY29uc3QgRkxPV1RZUEVfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiRmxvd1R5cGVcIl07XG5leHBvcnRzLkZMT1dUWVBFX1RZUEVTID0gRkxPV1RZUEVfVFlQRVM7XG5jb25zdCBGTE9XQkFTRUFOTk9UQVRJT05fVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiRmxvd0Jhc2VBbm5vdGF0aW9uXCJdO1xuZXhwb3J0cy5GTE9XQkFTRUFOTk9UQVRJT05fVFlQRVMgPSBGTE9XQkFTRUFOTk9UQVRJT05fVFlQRVM7XG5jb25zdCBGTE9XREVDTEFSQVRJT05fVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiRmxvd0RlY2xhcmF0aW9uXCJdO1xuZXhwb3J0cy5GTE9XREVDTEFSQVRJT05fVFlQRVMgPSBGTE9XREVDTEFSQVRJT05fVFlQRVM7XG5jb25zdCBGTE9XUFJFRElDQVRFX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIkZsb3dQcmVkaWNhdGVcIl07XG5leHBvcnRzLkZMT1dQUkVESUNBVEVfVFlQRVMgPSBGTE9XUFJFRElDQVRFX1RZUEVTO1xuY29uc3QgRU5VTUJPRFlfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiRW51bUJvZHlcIl07XG5leHBvcnRzLkVOVU1CT0RZX1RZUEVTID0gRU5VTUJPRFlfVFlQRVM7XG5jb25zdCBFTlVNTUVNQkVSX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIkVudW1NZW1iZXJcIl07XG5leHBvcnRzLkVOVU1NRU1CRVJfVFlQRVMgPSBFTlVNTUVNQkVSX1RZUEVTO1xuY29uc3QgSlNYX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIkpTWFwiXTtcbmV4cG9ydHMuSlNYX1RZUEVTID0gSlNYX1RZUEVTO1xuY29uc3QgUFJJVkFURV9UWVBFUyA9IF9kZWZpbml0aW9ucy5GTElQUEVEX0FMSUFTX0tFWVNbXCJQcml2YXRlXCJdO1xuZXhwb3J0cy5QUklWQVRFX1RZUEVTID0gUFJJVkFURV9UWVBFUztcbmNvbnN0IFRTVFlQRUVMRU1FTlRfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiVFNUeXBlRWxlbWVudFwiXTtcbmV4cG9ydHMuVFNUWVBFRUxFTUVOVF9UWVBFUyA9IFRTVFlQRUVMRU1FTlRfVFlQRVM7XG5jb25zdCBUU1RZUEVfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiVFNUeXBlXCJdO1xuZXhwb3J0cy5UU1RZUEVfVFlQRVMgPSBUU1RZUEVfVFlQRVM7XG5jb25zdCBUU0JBU0VUWVBFX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIlRTQmFzZVR5cGVcIl07XG5leHBvcnRzLlRTQkFTRVRZUEVfVFlQRVMgPSBUU0JBU0VUWVBFX1RZUEVTOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5OT1RfTE9DQUxfQklORElORyA9IGV4cG9ydHMuQkxPQ0tfU0NPUEVEX1NZTUJPTCA9IGV4cG9ydHMuSU5IRVJJVF9LRVlTID0gZXhwb3J0cy5VTkFSWV9PUEVSQVRPUlMgPSBleHBvcnRzLlNUUklOR19VTkFSWV9PUEVSQVRPUlMgPSBleHBvcnRzLk5VTUJFUl9VTkFSWV9PUEVSQVRPUlMgPSBleHBvcnRzLkJPT0xFQU5fVU5BUllfT1BFUkFUT1JTID0gZXhwb3J0cy5BU1NJR05NRU5UX09QRVJBVE9SUyA9IGV4cG9ydHMuQklOQVJZX09QRVJBVE9SUyA9IGV4cG9ydHMuTlVNQkVSX0JJTkFSWV9PUEVSQVRPUlMgPSBleHBvcnRzLkJPT0xFQU5fQklOQVJZX09QRVJBVE9SUyA9IGV4cG9ydHMuQ09NUEFSSVNPTl9CSU5BUllfT1BFUkFUT1JTID0gZXhwb3J0cy5FUVVBTElUWV9CSU5BUllfT1BFUkFUT1JTID0gZXhwb3J0cy5CT09MRUFOX05VTUJFUl9CSU5BUllfT1BFUkFUT1JTID0gZXhwb3J0cy5VUERBVEVfT1BFUkFUT1JTID0gZXhwb3J0cy5MT0dJQ0FMX09QRVJBVE9SUyA9IGV4cG9ydHMuQ09NTUVOVF9LRVlTID0gZXhwb3J0cy5GT1JfSU5JVF9LRVlTID0gZXhwb3J0cy5GTEFUVEVOQUJMRV9LRVlTID0gZXhwb3J0cy5TVEFURU1FTlRfT1JfQkxPQ0tfS0VZUyA9IHZvaWQgMDtcbmNvbnN0IFNUQVRFTUVOVF9PUl9CTE9DS19LRVlTID0gW1wiY29uc2VxdWVudFwiLCBcImJvZHlcIiwgXCJhbHRlcm5hdGVcIl07XG5leHBvcnRzLlNUQVRFTUVOVF9PUl9CTE9DS19LRVlTID0gU1RBVEVNRU5UX09SX0JMT0NLX0tFWVM7XG5jb25zdCBGTEFUVEVOQUJMRV9LRVlTID0gW1wiYm9keVwiLCBcImV4cHJlc3Npb25zXCJdO1xuZXhwb3J0cy5GTEFUVEVOQUJMRV9LRVlTID0gRkxBVFRFTkFCTEVfS0VZUztcbmNvbnN0IEZPUl9JTklUX0tFWVMgPSBbXCJsZWZ0XCIsIFwiaW5pdFwiXTtcbmV4cG9ydHMuRk9SX0lOSVRfS0VZUyA9IEZPUl9JTklUX0tFWVM7XG5jb25zdCBDT01NRU5UX0tFWVMgPSBbXCJsZWFkaW5nQ29tbWVudHNcIiwgXCJ0cmFpbGluZ0NvbW1lbnRzXCIsIFwiaW5uZXJDb21tZW50c1wiXTtcbmV4cG9ydHMuQ09NTUVOVF9LRVlTID0gQ09NTUVOVF9LRVlTO1xuY29uc3QgTE9HSUNBTF9PUEVSQVRPUlMgPSBbXCJ8fFwiLCBcIiYmXCIsIFwiPz9cIl07XG5leHBvcnRzLkxPR0lDQUxfT1BFUkFUT1JTID0gTE9HSUNBTF9PUEVSQVRPUlM7XG5jb25zdCBVUERBVEVfT1BFUkFUT1JTID0gW1wiKytcIiwgXCItLVwiXTtcbmV4cG9ydHMuVVBEQVRFX09QRVJBVE9SUyA9IFVQREFURV9PUEVSQVRPUlM7XG5jb25zdCBCT09MRUFOX05VTUJFUl9CSU5BUllfT1BFUkFUT1JTID0gW1wiPlwiLCBcIjxcIiwgXCI+PVwiLCBcIjw9XCJdO1xuZXhwb3J0cy5CT09MRUFOX05VTUJFUl9CSU5BUllfT1BFUkFUT1JTID0gQk9PTEVBTl9OVU1CRVJfQklOQVJZX09QRVJBVE9SUztcbmNvbnN0IEVRVUFMSVRZX0JJTkFSWV9PUEVSQVRPUlMgPSBbXCI9PVwiLCBcIj09PVwiLCBcIiE9XCIsIFwiIT09XCJdO1xuZXhwb3J0cy5FUVVBTElUWV9CSU5BUllfT1BFUkFUT1JTID0gRVFVQUxJVFlfQklOQVJZX09QRVJBVE9SUztcbmNvbnN0IENPTVBBUklTT05fQklOQVJZX09QRVJBVE9SUyA9IFsuLi5FUVVBTElUWV9CSU5BUllfT1BFUkFUT1JTLCBcImluXCIsIFwiaW5zdGFuY2VvZlwiXTtcbmV4cG9ydHMuQ09NUEFSSVNPTl9CSU5BUllfT1BFUkFUT1JTID0gQ09NUEFSSVNPTl9CSU5BUllfT1BFUkFUT1JTO1xuY29uc3QgQk9PTEVBTl9CSU5BUllfT1BFUkFUT1JTID0gWy4uLkNPTVBBUklTT05fQklOQVJZX09QRVJBVE9SUywgLi4uQk9PTEVBTl9OVU1CRVJfQklOQVJZX09QRVJBVE9SU107XG5leHBvcnRzLkJPT0xFQU5fQklOQVJZX09QRVJBVE9SUyA9IEJPT0xFQU5fQklOQVJZX09QRVJBVE9SUztcbmNvbnN0IE5VTUJFUl9CSU5BUllfT1BFUkFUT1JTID0gW1wiLVwiLCBcIi9cIiwgXCIlXCIsIFwiKlwiLCBcIioqXCIsIFwiJlwiLCBcInxcIiwgXCI+PlwiLCBcIj4+PlwiLCBcIjw8XCIsIFwiXlwiXTtcbmV4cG9ydHMuTlVNQkVSX0JJTkFSWV9PUEVSQVRPUlMgPSBOVU1CRVJfQklOQVJZX09QRVJBVE9SUztcbmNvbnN0IEJJTkFSWV9PUEVSQVRPUlMgPSBbXCIrXCIsIC4uLk5VTUJFUl9CSU5BUllfT1BFUkFUT1JTLCAuLi5CT09MRUFOX0JJTkFSWV9PUEVSQVRPUlNdO1xuZXhwb3J0cy5CSU5BUllfT1BFUkFUT1JTID0gQklOQVJZX09QRVJBVE9SUztcbmNvbnN0IEFTU0lHTk1FTlRfT1BFUkFUT1JTID0gW1wiPVwiLCBcIis9XCIsIC4uLk5VTUJFUl9CSU5BUllfT1BFUkFUT1JTLm1hcChvcCA9PiBvcCArIFwiPVwiKSwgLi4uTE9HSUNBTF9PUEVSQVRPUlMubWFwKG9wID0+IG9wICsgXCI9XCIpXTtcbmV4cG9ydHMuQVNTSUdOTUVOVF9PUEVSQVRPUlMgPSBBU1NJR05NRU5UX09QRVJBVE9SUztcbmNvbnN0IEJPT0xFQU5fVU5BUllfT1BFUkFUT1JTID0gW1wiZGVsZXRlXCIsIFwiIVwiXTtcbmV4cG9ydHMuQk9PTEVBTl9VTkFSWV9PUEVSQVRPUlMgPSBCT09MRUFOX1VOQVJZX09QRVJBVE9SUztcbmNvbnN0IE5VTUJFUl9VTkFSWV9PUEVSQVRPUlMgPSBbXCIrXCIsIFwiLVwiLCBcIn5cIl07XG5leHBvcnRzLk5VTUJFUl9VTkFSWV9PUEVSQVRPUlMgPSBOVU1CRVJfVU5BUllfT1BFUkFUT1JTO1xuY29uc3QgU1RSSU5HX1VOQVJZX09QRVJBVE9SUyA9IFtcInR5cGVvZlwiXTtcbmV4cG9ydHMuU1RSSU5HX1VOQVJZX09QRVJBVE9SUyA9IFNUUklOR19VTkFSWV9PUEVSQVRPUlM7XG5jb25zdCBVTkFSWV9PUEVSQVRPUlMgPSBbXCJ2b2lkXCIsIFwidGhyb3dcIiwgLi4uQk9PTEVBTl9VTkFSWV9PUEVSQVRPUlMsIC4uLk5VTUJFUl9VTkFSWV9PUEVSQVRPUlMsIC4uLlNUUklOR19VTkFSWV9PUEVSQVRPUlNdO1xuZXhwb3J0cy5VTkFSWV9PUEVSQVRPUlMgPSBVTkFSWV9PUEVSQVRPUlM7XG5jb25zdCBJTkhFUklUX0tFWVMgPSB7XG4gIG9wdGlvbmFsOiBbXCJ0eXBlQW5ub3RhdGlvblwiLCBcInR5cGVQYXJhbWV0ZXJzXCIsIFwicmV0dXJuVHlwZVwiXSxcbiAgZm9yY2U6IFtcInN0YXJ0XCIsIFwibG9jXCIsIFwiZW5kXCJdXG59O1xuZXhwb3J0cy5JTkhFUklUX0tFWVMgPSBJTkhFUklUX0tFWVM7XG5jb25zdCBCTE9DS19TQ09QRURfU1lNQk9MID0gU3ltYm9sLmZvcihcInZhciB1c2VkIHRvIGJlIGJsb2NrIHNjb3BlZFwiKTtcbmV4cG9ydHMuQkxPQ0tfU0NPUEVEX1NZTUJPTCA9IEJMT0NLX1NDT1BFRF9TWU1CT0w7XG5jb25zdCBOT1RfTE9DQUxfQklORElORyA9IFN5bWJvbC5mb3IoXCJzaG91bGQgbm90IGJlIGNvbnNpZGVyZWQgYSBsb2NhbCBiaW5kaW5nXCIpO1xuZXhwb3J0cy5OT1RfTE9DQUxfQklORElORyA9IE5PVF9MT0NBTF9CSU5ESU5HOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZW5zdXJlQmxvY2s7XG5cbnZhciBfdG9CbG9jayA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdG9CbG9ja1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGVuc3VyZUJsb2NrKG5vZGUsIGtleSA9IFwiYm9keVwiKSB7XG4gIHJldHVybiBub2RlW2tleV0gPSAoMCwgX3RvQmxvY2suZGVmYXVsdCkobm9kZVtrZXldLCBub2RlKTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGdhdGhlclNlcXVlbmNlRXhwcmVzc2lvbnM7XG5cbnZhciBfZ2V0QmluZGluZ0lkZW50aWZpZXJzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vcmV0cmlldmVycy9nZXRCaW5kaW5nSWRlbnRpZmllcnNcIikpO1xuXG52YXIgX2dlbmVyYXRlZCA9IHJlcXVpcmUoXCIuLi92YWxpZGF0b3JzL2dlbmVyYXRlZFwiKTtcblxudmFyIF9nZW5lcmF0ZWQyID0gcmVxdWlyZShcIi4uL2J1aWxkZXJzL2dlbmVyYXRlZFwiKTtcblxudmFyIF9jbG9uZU5vZGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9jbG9uZS9jbG9uZU5vZGVcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBnYXRoZXJTZXF1ZW5jZUV4cHJlc3Npb25zKG5vZGVzLCBzY29wZSwgZGVjbGFycykge1xuICBjb25zdCBleHBycyA9IFtdO1xuICBsZXQgZW5zdXJlTGFzdFVuZGVmaW5lZCA9IHRydWU7XG5cbiAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgaWYgKCEoMCwgX2dlbmVyYXRlZC5pc0VtcHR5U3RhdGVtZW50KShub2RlKSkge1xuICAgICAgZW5zdXJlTGFzdFVuZGVmaW5lZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICgoMCwgX2dlbmVyYXRlZC5pc0V4cHJlc3Npb24pKG5vZGUpKSB7XG4gICAgICBleHBycy5wdXNoKG5vZGUpO1xuICAgIH0gZWxzZSBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNFeHByZXNzaW9uU3RhdGVtZW50KShub2RlKSkge1xuICAgICAgZXhwcnMucHVzaChub2RlLmV4cHJlc3Npb24pO1xuICAgIH0gZWxzZSBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNWYXJpYWJsZURlY2xhcmF0aW9uKShub2RlKSkge1xuICAgICAgaWYgKG5vZGUua2luZCAhPT0gXCJ2YXJcIikgcmV0dXJuO1xuXG4gICAgICBmb3IgKGNvbnN0IGRlY2xhciBvZiBub2RlLmRlY2xhcmF0aW9ucykge1xuICAgICAgICBjb25zdCBiaW5kaW5ncyA9ICgwLCBfZ2V0QmluZGluZ0lkZW50aWZpZXJzLmRlZmF1bHQpKGRlY2xhcik7XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoYmluZGluZ3MpKSB7XG4gICAgICAgICAgZGVjbGFycy5wdXNoKHtcbiAgICAgICAgICAgIGtpbmQ6IG5vZGUua2luZCxcbiAgICAgICAgICAgIGlkOiAoMCwgX2Nsb25lTm9kZS5kZWZhdWx0KShiaW5kaW5nc1trZXldKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlY2xhci5pbml0KSB7XG4gICAgICAgICAgZXhwcnMucHVzaCgoMCwgX2dlbmVyYXRlZDIuYXNzaWdubWVudEV4cHJlc3Npb24pKFwiPVwiLCBkZWNsYXIuaWQsIGRlY2xhci5pbml0KSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZW5zdXJlTGFzdFVuZGVmaW5lZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICgoMCwgX2dlbmVyYXRlZC5pc0lmU3RhdGVtZW50KShub2RlKSkge1xuICAgICAgY29uc3QgY29uc2VxdWVudCA9IG5vZGUuY29uc2VxdWVudCA/IGdhdGhlclNlcXVlbmNlRXhwcmVzc2lvbnMoW25vZGUuY29uc2VxdWVudF0sIHNjb3BlLCBkZWNsYXJzKSA6IHNjb3BlLmJ1aWxkVW5kZWZpbmVkTm9kZSgpO1xuICAgICAgY29uc3QgYWx0ZXJuYXRlID0gbm9kZS5hbHRlcm5hdGUgPyBnYXRoZXJTZXF1ZW5jZUV4cHJlc3Npb25zKFtub2RlLmFsdGVybmF0ZV0sIHNjb3BlLCBkZWNsYXJzKSA6IHNjb3BlLmJ1aWxkVW5kZWZpbmVkTm9kZSgpO1xuICAgICAgaWYgKCFjb25zZXF1ZW50IHx8ICFhbHRlcm5hdGUpIHJldHVybjtcbiAgICAgIGV4cHJzLnB1c2goKDAsIF9nZW5lcmF0ZWQyLmNvbmRpdGlvbmFsRXhwcmVzc2lvbikobm9kZS50ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpKTtcbiAgICB9IGVsc2UgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzQmxvY2tTdGF0ZW1lbnQpKG5vZGUpKSB7XG4gICAgICBjb25zdCBib2R5ID0gZ2F0aGVyU2VxdWVuY2VFeHByZXNzaW9ucyhub2RlLmJvZHksIHNjb3BlLCBkZWNsYXJzKTtcbiAgICAgIGlmICghYm9keSkgcmV0dXJuO1xuICAgICAgZXhwcnMucHVzaChib2R5KTtcbiAgICB9IGVsc2UgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzRW1wdHlTdGF0ZW1lbnQpKG5vZGUpKSB7XG4gICAgICBpZiAobm9kZXMuaW5kZXhPZihub2RlKSA9PT0gMCkge1xuICAgICAgICBlbnN1cmVMYXN0VW5kZWZpbmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbnN1cmVMYXN0VW5kZWZpbmVkKSB7XG4gICAgZXhwcnMucHVzaChzY29wZS5idWlsZFVuZGVmaW5lZE5vZGUoKSk7XG4gIH1cblxuICBpZiAoZXhwcnMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGV4cHJzWzBdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoMCwgX2dlbmVyYXRlZDIuc2VxdWVuY2VFeHByZXNzaW9uKShleHBycyk7XG4gIH1cbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHRvQmluZGluZ0lkZW50aWZpZXJOYW1lO1xuXG52YXIgX3RvSWRlbnRpZmllciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdG9JZGVudGlmaWVyXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gdG9CaW5kaW5nSWRlbnRpZmllck5hbWUobmFtZSkge1xuICBuYW1lID0gKDAsIF90b0lkZW50aWZpZXIuZGVmYXVsdCkobmFtZSk7XG4gIGlmIChuYW1lID09PSBcImV2YWxcIiB8fCBuYW1lID09PSBcImFyZ3VtZW50c1wiKSBuYW1lID0gXCJfXCIgKyBuYW1lO1xuICByZXR1cm4gbmFtZTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHRvQmxvY2s7XG5cbnZhciBfZ2VuZXJhdGVkID0gcmVxdWlyZShcIi4uL3ZhbGlkYXRvcnMvZ2VuZXJhdGVkXCIpO1xuXG52YXIgX2dlbmVyYXRlZDIgPSByZXF1aXJlKFwiLi4vYnVpbGRlcnMvZ2VuZXJhdGVkXCIpO1xuXG5mdW5jdGlvbiB0b0Jsb2NrKG5vZGUsIHBhcmVudCkge1xuICBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNCbG9ja1N0YXRlbWVudCkobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGxldCBibG9ja05vZGVzID0gW107XG5cbiAgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzRW1wdHlTdGF0ZW1lbnQpKG5vZGUpKSB7XG4gICAgYmxvY2tOb2RlcyA9IFtdO1xuICB9IGVsc2Uge1xuICAgIGlmICghKDAsIF9nZW5lcmF0ZWQuaXNTdGF0ZW1lbnQpKG5vZGUpKSB7XG4gICAgICBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNGdW5jdGlvbikocGFyZW50KSkge1xuICAgICAgICBub2RlID0gKDAsIF9nZW5lcmF0ZWQyLnJldHVyblN0YXRlbWVudCkobm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlID0gKDAsIF9nZW5lcmF0ZWQyLmV4cHJlc3Npb25TdGF0ZW1lbnQpKG5vZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGJsb2NrTm9kZXMgPSBbbm9kZV07XG4gIH1cblxuICByZXR1cm4gKDAsIF9nZW5lcmF0ZWQyLmJsb2NrU3RhdGVtZW50KShibG9ja05vZGVzKTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHRvQ29tcHV0ZWRLZXk7XG5cbnZhciBfZ2VuZXJhdGVkID0gcmVxdWlyZShcIi4uL3ZhbGlkYXRvcnMvZ2VuZXJhdGVkXCIpO1xuXG52YXIgX2dlbmVyYXRlZDIgPSByZXF1aXJlKFwiLi4vYnVpbGRlcnMvZ2VuZXJhdGVkXCIpO1xuXG5mdW5jdGlvbiB0b0NvbXB1dGVkS2V5KG5vZGUsIGtleSA9IG5vZGUua2V5IHx8IG5vZGUucHJvcGVydHkpIHtcbiAgaWYgKCFub2RlLmNvbXB1dGVkICYmICgwLCBfZ2VuZXJhdGVkLmlzSWRlbnRpZmllcikoa2V5KSkga2V5ID0gKDAsIF9nZW5lcmF0ZWQyLnN0cmluZ0xpdGVyYWwpKGtleS5uYW1lKTtcbiAgcmV0dXJuIGtleTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHRvRXhwcmVzc2lvbjtcblxudmFyIF9nZW5lcmF0ZWQgPSByZXF1aXJlKFwiLi4vdmFsaWRhdG9ycy9nZW5lcmF0ZWRcIik7XG5cbmZ1bmN0aW9uIHRvRXhwcmVzc2lvbihub2RlKSB7XG4gIGlmICgoMCwgX2dlbmVyYXRlZC5pc0V4cHJlc3Npb25TdGF0ZW1lbnQpKG5vZGUpKSB7XG4gICAgbm9kZSA9IG5vZGUuZXhwcmVzc2lvbjtcbiAgfVxuXG4gIGlmICgoMCwgX2dlbmVyYXRlZC5pc0V4cHJlc3Npb24pKG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNDbGFzcykobm9kZSkpIHtcbiAgICBub2RlLnR5cGUgPSBcIkNsYXNzRXhwcmVzc2lvblwiO1xuICB9IGVsc2UgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzRnVuY3Rpb24pKG5vZGUpKSB7XG4gICAgbm9kZS50eXBlID0gXCJGdW5jdGlvbkV4cHJlc3Npb25cIjtcbiAgfVxuXG4gIGlmICghKDAsIF9nZW5lcmF0ZWQuaXNFeHByZXNzaW9uKShub2RlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHR1cm4gJHtub2RlLnR5cGV9IHRvIGFuIGV4cHJlc3Npb25gKTtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdG9JZGVudGlmaWVyO1xuXG52YXIgX2lzVmFsaWRJZGVudGlmaWVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vdmFsaWRhdG9ycy9pc1ZhbGlkSWRlbnRpZmllclwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHRvSWRlbnRpZmllcihuYW1lKSB7XG4gIG5hbWUgPSBuYW1lICsgXCJcIjtcbiAgbmFtZSA9IG5hbWUucmVwbGFjZSgvW15hLXpBLVowLTkkX10vZywgXCItXCIpO1xuICBuYW1lID0gbmFtZS5yZXBsYWNlKC9eWy0wLTldKy8sIFwiXCIpO1xuICBuYW1lID0gbmFtZS5yZXBsYWNlKC9bLVxcc10rKC4pPy9nLCBmdW5jdGlvbiAobWF0Y2gsIGMpIHtcbiAgICByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6IFwiXCI7XG4gIH0pO1xuXG4gIGlmICghKDAsIF9pc1ZhbGlkSWRlbnRpZmllci5kZWZhdWx0KShuYW1lKSkge1xuICAgIG5hbWUgPSBgXyR7bmFtZX1gO1xuICB9XG5cbiAgcmV0dXJuIG5hbWUgfHwgXCJfXCI7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB0b0tleUFsaWFzO1xuXG52YXIgX2dlbmVyYXRlZCA9IHJlcXVpcmUoXCIuLi92YWxpZGF0b3JzL2dlbmVyYXRlZFwiKTtcblxudmFyIF9jbG9uZU5vZGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9jbG9uZS9jbG9uZU5vZGVcIikpO1xuXG52YXIgX3JlbW92ZVByb3BlcnRpZXNEZWVwID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vbW9kaWZpY2F0aW9ucy9yZW1vdmVQcm9wZXJ0aWVzRGVlcFwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHRvS2V5QWxpYXMobm9kZSwga2V5ID0gbm9kZS5rZXkpIHtcbiAgbGV0IGFsaWFzO1xuXG4gIGlmIChub2RlLmtpbmQgPT09IFwibWV0aG9kXCIpIHtcbiAgICByZXR1cm4gdG9LZXlBbGlhcy5pbmNyZW1lbnQoKSArIFwiXCI7XG4gIH0gZWxzZSBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNJZGVudGlmaWVyKShrZXkpKSB7XG4gICAgYWxpYXMgPSBrZXkubmFtZTtcbiAgfSBlbHNlIGlmICgoMCwgX2dlbmVyYXRlZC5pc1N0cmluZ0xpdGVyYWwpKGtleSkpIHtcbiAgICBhbGlhcyA9IEpTT04uc3RyaW5naWZ5KGtleS52YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgYWxpYXMgPSBKU09OLnN0cmluZ2lmeSgoMCwgX3JlbW92ZVByb3BlcnRpZXNEZWVwLmRlZmF1bHQpKCgwLCBfY2xvbmVOb2RlLmRlZmF1bHQpKGtleSkpKTtcbiAgfVxuXG4gIGlmIChub2RlLmNvbXB1dGVkKSB7XG4gICAgYWxpYXMgPSBgWyR7YWxpYXN9XWA7XG4gIH1cblxuICBpZiAobm9kZS5zdGF0aWMpIHtcbiAgICBhbGlhcyA9IGBzdGF0aWM6JHthbGlhc31gO1xuICB9XG5cbiAgcmV0dXJuIGFsaWFzO1xufVxuXG50b0tleUFsaWFzLnVpZCA9IDA7XG5cbnRvS2V5QWxpYXMuaW5jcmVtZW50ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodG9LZXlBbGlhcy51aWQgPj0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICByZXR1cm4gdG9LZXlBbGlhcy51aWQgPSAwO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0b0tleUFsaWFzLnVpZCsrO1xuICB9XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdG9TZXF1ZW5jZUV4cHJlc3Npb247XG5cbnZhciBfZ2F0aGVyU2VxdWVuY2VFeHByZXNzaW9ucyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vZ2F0aGVyU2VxdWVuY2VFeHByZXNzaW9uc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHRvU2VxdWVuY2VFeHByZXNzaW9uKG5vZGVzLCBzY29wZSkge1xuICBpZiAoIShub2RlcyA9PSBudWxsID8gdm9pZCAwIDogbm9kZXMubGVuZ3RoKSkgcmV0dXJuO1xuICBjb25zdCBkZWNsYXJzID0gW107XG4gIGNvbnN0IHJlc3VsdCA9ICgwLCBfZ2F0aGVyU2VxdWVuY2VFeHByZXNzaW9ucy5kZWZhdWx0KShub2Rlcywgc2NvcGUsIGRlY2xhcnMpO1xuICBpZiAoIXJlc3VsdCkgcmV0dXJuO1xuXG4gIGZvciAoY29uc3QgZGVjbGFyIG9mIGRlY2xhcnMpIHtcbiAgICBzY29wZS5wdXNoKGRlY2xhcik7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdG9TdGF0ZW1lbnQ7XG5cbnZhciBfZ2VuZXJhdGVkID0gcmVxdWlyZShcIi4uL3ZhbGlkYXRvcnMvZ2VuZXJhdGVkXCIpO1xuXG52YXIgX2dlbmVyYXRlZDIgPSByZXF1aXJlKFwiLi4vYnVpbGRlcnMvZ2VuZXJhdGVkXCIpO1xuXG5mdW5jdGlvbiB0b1N0YXRlbWVudChub2RlLCBpZ25vcmUpIHtcbiAgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzU3RhdGVtZW50KShub2RlKSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgbGV0IG11c3RIYXZlSWQgPSBmYWxzZTtcbiAgbGV0IG5ld1R5cGU7XG5cbiAgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzQ2xhc3MpKG5vZGUpKSB7XG4gICAgbXVzdEhhdmVJZCA9IHRydWU7XG4gICAgbmV3VHlwZSA9IFwiQ2xhc3NEZWNsYXJhdGlvblwiO1xuICB9IGVsc2UgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzRnVuY3Rpb24pKG5vZGUpKSB7XG4gICAgbXVzdEhhdmVJZCA9IHRydWU7XG4gICAgbmV3VHlwZSA9IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiO1xuICB9IGVsc2UgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzQXNzaWdubWVudEV4cHJlc3Npb24pKG5vZGUpKSB7XG4gICAgcmV0dXJuICgwLCBfZ2VuZXJhdGVkMi5leHByZXNzaW9uU3RhdGVtZW50KShub2RlKTtcbiAgfVxuXG4gIGlmIChtdXN0SGF2ZUlkICYmICFub2RlLmlkKSB7XG4gICAgbmV3VHlwZSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKCFuZXdUeXBlKSB7XG4gICAgaWYgKGlnbm9yZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCB0dXJuICR7bm9kZS50eXBlfSB0byBhIHN0YXRlbWVudGApO1xuICAgIH1cbiAgfVxuXG4gIG5vZGUudHlwZSA9IG5ld1R5cGU7XG4gIHJldHVybiBub2RlO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdmFsdWVUb05vZGU7XG5cbnZhciBfaXNQbGFpbk9iamVjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc1BsYWluT2JqZWN0XCIpKTtcblxudmFyIF9pc1JlZ0V4cCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc1JlZ0V4cFwiKSk7XG5cbnZhciBfaXNWYWxpZElkZW50aWZpZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi92YWxpZGF0b3JzL2lzVmFsaWRJZGVudGlmaWVyXCIpKTtcblxudmFyIF9nZW5lcmF0ZWQgPSByZXF1aXJlKFwiLi4vYnVpbGRlcnMvZ2VuZXJhdGVkXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiB2YWx1ZVRvTm9kZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAoMCwgX2dlbmVyYXRlZC5pZGVudGlmaWVyKShcInVuZGVmaW5lZFwiKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gKDAsIF9nZW5lcmF0ZWQuYm9vbGVhbkxpdGVyYWwpKHZhbHVlKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAoMCwgX2dlbmVyYXRlZC5udWxsTGl0ZXJhbCkoKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gKDAsIF9nZW5lcmF0ZWQuc3RyaW5nTGl0ZXJhbCkodmFsdWUpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgIGxldCByZXN1bHQ7XG5cbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgcmVzdWx0ID0gKDAsIF9nZW5lcmF0ZWQubnVtZXJpY0xpdGVyYWwpKE1hdGguYWJzKHZhbHVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBudW1lcmF0b3I7XG5cbiAgICAgIGlmIChOdW1iZXIuaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIG51bWVyYXRvciA9ICgwLCBfZ2VuZXJhdGVkLm51bWVyaWNMaXRlcmFsKSgwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG51bWVyYXRvciA9ICgwLCBfZ2VuZXJhdGVkLm51bWVyaWNMaXRlcmFsKSgxKTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0ID0gKDAsIF9nZW5lcmF0ZWQuYmluYXJ5RXhwcmVzc2lvbikoXCIvXCIsIG51bWVyYXRvciwgKDAsIF9nZW5lcmF0ZWQubnVtZXJpY0xpdGVyYWwpKDApKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPCAwIHx8IE9iamVjdC5pcyh2YWx1ZSwgLTApKSB7XG4gICAgICByZXN1bHQgPSAoMCwgX2dlbmVyYXRlZC51bmFyeUV4cHJlc3Npb24pKFwiLVwiLCByZXN1bHQpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoKDAsIF9pc1JlZ0V4cC5kZWZhdWx0KSh2YWx1ZSkpIHtcbiAgICBjb25zdCBwYXR0ZXJuID0gdmFsdWUuc291cmNlO1xuICAgIGNvbnN0IGZsYWdzID0gdmFsdWUudG9TdHJpbmcoKS5tYXRjaCgvXFwvKFthLXpdK3wpJC8pWzFdO1xuICAgIHJldHVybiAoMCwgX2dlbmVyYXRlZC5yZWdFeHBMaXRlcmFsKShwYXR0ZXJuLCBmbGFncyk7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gKDAsIF9nZW5lcmF0ZWQuYXJyYXlFeHByZXNzaW9uKSh2YWx1ZS5tYXAodmFsdWVUb05vZGUpKTtcbiAgfVxuXG4gIGlmICgoMCwgX2lzUGxhaW5PYmplY3QuZGVmYXVsdCkodmFsdWUpKSB7XG4gICAgY29uc3QgcHJvcHMgPSBbXTtcblxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHZhbHVlKSkge1xuICAgICAgbGV0IG5vZGVLZXk7XG5cbiAgICAgIGlmICgoMCwgX2lzVmFsaWRJZGVudGlmaWVyLmRlZmF1bHQpKGtleSkpIHtcbiAgICAgICAgbm9kZUtleSA9ICgwLCBfZ2VuZXJhdGVkLmlkZW50aWZpZXIpKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlS2V5ID0gKDAsIF9nZW5lcmF0ZWQuc3RyaW5nTGl0ZXJhbCkoa2V5KTtcbiAgICAgIH1cblxuICAgICAgcHJvcHMucHVzaCgoMCwgX2dlbmVyYXRlZC5vYmplY3RQcm9wZXJ0eSkobm9kZUtleSwgdmFsdWVUb05vZGUodmFsdWVba2V5XSkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKDAsIF9nZW5lcmF0ZWQub2JqZWN0RXhwcmVzc2lvbikocHJvcHMpO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKFwiZG9uJ3Qga25vdyBob3cgdG8gdHVybiB0aGlzIHZhbHVlIGludG8gYSBub2RlXCIpO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jbGFzc01ldGhvZE9yRGVjbGFyZU1ldGhvZENvbW1vbiA9IGV4cG9ydHMuY2xhc3NNZXRob2RPclByb3BlcnR5Q29tbW9uID0gZXhwb3J0cy5wYXR0ZXJuTGlrZUNvbW1vbiA9IGV4cG9ydHMuZnVuY3Rpb25EZWNsYXJhdGlvbkNvbW1vbiA9IGV4cG9ydHMuZnVuY3Rpb25UeXBlQW5ub3RhdGlvbkNvbW1vbiA9IGV4cG9ydHMuZnVuY3Rpb25Db21tb24gPSB2b2lkIDA7XG5cbnZhciBfaXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi92YWxpZGF0b3JzL2lzXCIpKTtcblxudmFyIF9pc1ZhbGlkSWRlbnRpZmllciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3ZhbGlkYXRvcnMvaXNWYWxpZElkZW50aWZpZXJcIikpO1xuXG52YXIgX2hlbHBlclZhbGlkYXRvcklkZW50aWZpZXIgPSByZXF1aXJlKFwiQGJhYmVsL2hlbHBlci12YWxpZGF0b3ItaWRlbnRpZmllclwiKTtcblxudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xuXG52YXIgX3V0aWxzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vdXRpbHNcIikpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgZGVmYXVsdDogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuKDAsIF91dGlscy5kZWZhdWx0KShcIkFycmF5RXhwcmVzc2lvblwiLCB7XG4gIGZpZWxkczoge1xuICAgIGVsZW1lbnRzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlT3JWYWx1ZVR5cGUpKFwibnVsbFwiLCBcIkV4cHJlc3Npb25cIiwgXCJTcHJlYWRFbGVtZW50XCIpKSksXG4gICAgICBkZWZhdWx0OiAhcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORyA/IFtdIDogdW5kZWZpbmVkXG4gICAgfVxuICB9LFxuICB2aXNpdG9yOiBbXCJlbGVtZW50c1wiXSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiQXNzaWdubWVudEV4cHJlc3Npb25cIiwge1xuICBmaWVsZHM6IHtcbiAgICBvcGVyYXRvcjoge1xuICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HKSB7XG4gICAgICAgICAgcmV0dXJuICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSAoMCwgX3V0aWxzLmFzc2VydE9uZU9mKSguLi5fY29uc3RhbnRzLkFTU0lHTk1FTlRfT1BFUkFUT1JTKTtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9ICgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKFwiPVwiKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChub2RlLCBrZXksIHZhbCkge1xuICAgICAgICAgIGNvbnN0IHZhbGlkYXRvciA9ICgwLCBfaXMuZGVmYXVsdCkoXCJQYXR0ZXJuXCIsIG5vZGUubGVmdCkgPyBwYXR0ZXJuIDogaWRlbnRpZmllcjtcbiAgICAgICAgICB2YWxpZGF0b3Iobm9kZSwga2V5LCB2YWwpO1xuICAgICAgICB9O1xuICAgICAgfSgpXG4gICAgfSxcbiAgICBsZWZ0OiB7XG4gICAgICB2YWxpZGF0ZTogIXByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcgPyAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkxWYWxcIikgOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIiwgXCJNZW1iZXJFeHByZXNzaW9uXCIsIFwiQXJyYXlQYXR0ZXJuXCIsIFwiT2JqZWN0UGF0dGVyblwiKVxuICAgIH0sXG4gICAgcmlnaHQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9XG4gIH0sXG4gIGJ1aWxkZXI6IFtcIm9wZXJhdG9yXCIsIFwibGVmdFwiLCBcInJpZ2h0XCJdLFxuICB2aXNpdG9yOiBbXCJsZWZ0XCIsIFwicmlnaHRcIl0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIl1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkJpbmFyeUV4cHJlc3Npb25cIiwge1xuICBidWlsZGVyOiBbXCJvcGVyYXRvclwiLCBcImxlZnRcIiwgXCJyaWdodFwiXSxcbiAgZmllbGRzOiB7XG4gICAgb3BlcmF0b3I6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE9uZU9mKSguLi5fY29uc3RhbnRzLkJJTkFSWV9PUEVSQVRPUlMpXG4gICAgfSxcbiAgICBsZWZ0OiB7XG4gICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBleHByZXNzaW9uID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpO1xuICAgICAgICBjb25zdCBpbk9wID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIsIFwiUHJpdmF0ZU5hbWVcIik7XG5cbiAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gZnVuY3Rpb24gKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gbm9kZS5vcGVyYXRvciA9PT0gXCJpblwiID8gaW5PcCA6IGV4cHJlc3Npb247XG4gICAgICAgICAgdmFsaWRhdG9yKG5vZGUsIGtleSwgdmFsKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YWxpZGF0b3Iub25lT2ZOb2RlVHlwZXMgPSBbXCJFeHByZXNzaW9uXCIsIFwiUHJpdmF0ZU5hbWVcIl07XG4gICAgICAgIHJldHVybiB2YWxpZGF0b3I7XG4gICAgICB9KClcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9LFxuICB2aXNpdG9yOiBbXCJsZWZ0XCIsIFwicmlnaHRcIl0sXG4gIGFsaWFzZXM6IFtcIkJpbmFyeVwiLCBcIkV4cHJlc3Npb25cIl1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkludGVycHJldGVyRGlyZWN0aXZlXCIsIHtcbiAgYnVpbGRlcjogW1widmFsdWVcIl0sXG4gIGZpZWxkczoge1xuICAgIHZhbHVlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwic3RyaW5nXCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJEaXJlY3RpdmVcIiwge1xuICB2aXNpdG9yOiBbXCJ2YWx1ZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkRpcmVjdGl2ZUxpdGVyYWxcIilcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkRpcmVjdGl2ZUxpdGVyYWxcIiwge1xuICBidWlsZGVyOiBbXCJ2YWx1ZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIilcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkJsb2NrU3RhdGVtZW50XCIsIHtcbiAgYnVpbGRlcjogW1wiYm9keVwiLCBcImRpcmVjdGl2ZXNcIl0sXG4gIHZpc2l0b3I6IFtcImRpcmVjdGl2ZXNcIiwgXCJib2R5XCJdLFxuICBmaWVsZHM6IHtcbiAgICBkaXJlY3RpdmVzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJEaXJlY3RpdmVcIikpKSxcbiAgICAgIGRlZmF1bHQ6IFtdXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJTdGF0ZW1lbnRcIikpKVxuICAgIH1cbiAgfSxcbiAgYWxpYXNlczogW1wiU2NvcGFibGVcIiwgXCJCbG9ja1BhcmVudFwiLCBcIkJsb2NrXCIsIFwiU3RhdGVtZW50XCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJCcmVha1N0YXRlbWVudFwiLCB7XG4gIHZpc2l0b3I6IFtcImxhYmVsXCJdLFxuICBmaWVsZHM6IHtcbiAgICBsYWJlbDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9LFxuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJUZXJtaW5hdG9ybGVzc1wiLCBcIkNvbXBsZXRpb25TdGF0ZW1lbnRcIl1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkNhbGxFeHByZXNzaW9uXCIsIHtcbiAgdmlzaXRvcjogW1wiY2FsbGVlXCIsIFwiYXJndW1lbnRzXCIsIFwidHlwZVBhcmFtZXRlcnNcIiwgXCJ0eXBlQXJndW1lbnRzXCJdLFxuICBidWlsZGVyOiBbXCJjYWxsZWVcIiwgXCJhcmd1bWVudHNcIl0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczogT2JqZWN0LmFzc2lnbih7XG4gICAgY2FsbGVlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIsIFwiVjhJbnRyaW5zaWNJZGVudGlmaWVyXCIpXG4gICAgfSxcbiAgICBhcmd1bWVudHM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJhcnJheVwiKSwgKDAsIF91dGlscy5hc3NlcnRFYWNoKSgoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIiwgXCJTcHJlYWRFbGVtZW50XCIsIFwiSlNYTmFtZXNwYWNlZE5hbWVcIiwgXCJBcmd1bWVudFBsYWNlaG9sZGVyXCIpKSlcbiAgICB9XG4gIH0sICFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HID8ge1xuICAgIG9wdGlvbmFsOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRPbmVPZikodHJ1ZSwgZmFsc2UpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XG4gIH0gOiB7fSwge1xuICAgIHR5cGVBcmd1bWVudHM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIHR5cGVQYXJhbWV0ZXJzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XG4gIH0pXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJDYXRjaENsYXVzZVwiLCB7XG4gIHZpc2l0b3I6IFtcInBhcmFtXCIsIFwiYm9keVwiXSxcbiAgZmllbGRzOiB7XG4gICAgcGFyYW06IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIiwgXCJBcnJheVBhdHRlcm5cIiwgXCJPYmplY3RQYXR0ZXJuXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkJsb2NrU3RhdGVtZW50XCIpXG4gICAgfVxuICB9LFxuICBhbGlhc2VzOiBbXCJTY29wYWJsZVwiLCBcIkJsb2NrUGFyZW50XCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIiwge1xuICB2aXNpdG9yOiBbXCJ0ZXN0XCIsIFwiY29uc2VxdWVudFwiLCBcImFsdGVybmF0ZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdGVzdDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgY29uc2VxdWVudDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgYWx0ZXJuYXRlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9LFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCIsIFwiQ29uZGl0aW9uYWxcIl1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkNvbnRpbnVlU3RhdGVtZW50XCIsIHtcbiAgdmlzaXRvcjogW1wibGFiZWxcIl0sXG4gIGZpZWxkczoge1xuICAgIGxhYmVsOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XG4gIH0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIlRlcm1pbmF0b3JsZXNzXCIsIFwiQ29tcGxldGlvblN0YXRlbWVudFwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRGVidWdnZXJTdGF0ZW1lbnRcIiwge1xuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIl1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkRvV2hpbGVTdGF0ZW1lbnRcIiwge1xuICB2aXNpdG9yOiBbXCJ0ZXN0XCIsIFwiYm9keVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdGVzdDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgYm9keToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiU3RhdGVtZW50XCIpXG4gICAgfVxuICB9LFxuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJCbG9ja1BhcmVudFwiLCBcIkxvb3BcIiwgXCJXaGlsZVwiLCBcIlNjb3BhYmxlXCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJFbXB0eVN0YXRlbWVudFwiLCB7XG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRXhwcmVzc2lvblN0YXRlbWVudFwiLCB7XG4gIHZpc2l0b3I6IFtcImV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczoge1xuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9XG4gIH0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIkV4cHJlc3Npb25XcmFwcGVyXCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJGaWxlXCIsIHtcbiAgYnVpbGRlcjogW1wicHJvZ3JhbVwiLCBcImNvbW1lbnRzXCIsIFwidG9rZW5zXCJdLFxuICB2aXNpdG9yOiBbXCJwcm9ncmFtXCJdLFxuICBmaWVsZHM6IHtcbiAgICBwcm9ncmFtOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJQcm9ncmFtXCIpXG4gICAgfSxcbiAgICBjb21tZW50czoge1xuICAgICAgdmFsaWRhdGU6ICFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HID8gT2JqZWN0LmFzc2lnbigoKSA9PiB7fSwge1xuICAgICAgICBlYWNoOiB7XG4gICAgICAgICAgb25lT2ZOb2RlVHlwZXM6IFtcIkNvbW1lbnRCbG9ja1wiLCBcIkNvbW1lbnRMaW5lXCJdXG4gICAgICAgIH1cbiAgICAgIH0pIDogKDAsIF91dGlscy5hc3NlcnRFYWNoKSgoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkNvbW1lbnRCbG9ja1wiLCBcIkNvbW1lbnRMaW5lXCIpKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICB0b2tlbnM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKE9iamVjdC5hc3NpZ24oKCkgPT4ge30sIHtcbiAgICAgICAgdHlwZTogXCJhbnlcIlxuICAgICAgfSkpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkZvckluU3RhdGVtZW50XCIsIHtcbiAgdmlzaXRvcjogW1wibGVmdFwiLCBcInJpZ2h0XCIsIFwiYm9keVwiXSxcbiAgYWxpYXNlczogW1wiU2NvcGFibGVcIiwgXCJTdGF0ZW1lbnRcIiwgXCJGb3JcIiwgXCJCbG9ja1BhcmVudFwiLCBcIkxvb3BcIiwgXCJGb3JYU3RhdGVtZW50XCJdLFxuICBmaWVsZHM6IHtcbiAgICBsZWZ0OiB7XG4gICAgICB2YWxpZGF0ZTogIXByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcgPyAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlZhcmlhYmxlRGVjbGFyYXRpb25cIiwgXCJMVmFsXCIpIDogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsIFwiSWRlbnRpZmllclwiLCBcIk1lbWJlckV4cHJlc3Npb25cIiwgXCJBcnJheVBhdHRlcm5cIiwgXCJPYmplY3RQYXR0ZXJuXCIpXG4gICAgfSxcbiAgICByaWdodDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgYm9keToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiU3RhdGVtZW50XCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJGb3JTdGF0ZW1lbnRcIiwge1xuICB2aXNpdG9yOiBbXCJpbml0XCIsIFwidGVzdFwiLCBcInVwZGF0ZVwiLCBcImJvZHlcIl0sXG4gIGFsaWFzZXM6IFtcIlNjb3BhYmxlXCIsIFwiU3RhdGVtZW50XCIsIFwiRm9yXCIsIFwiQmxvY2tQYXJlbnRcIiwgXCJMb29wXCJdLFxuICBmaWVsZHM6IHtcbiAgICBpbml0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsIFwiRXhwcmVzc2lvblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICB0ZXN0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIHVwZGF0ZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJTdGF0ZW1lbnRcIilcbiAgICB9XG4gIH1cbn0pO1xuY29uc3QgZnVuY3Rpb25Db21tb24gPSB7XG4gIHBhcmFtczoge1xuICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJhcnJheVwiKSwgKDAsIF91dGlscy5hc3NlcnRFYWNoKSgoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIiwgXCJQYXR0ZXJuXCIsIFwiUmVzdEVsZW1lbnRcIiwgXCJUU1BhcmFtZXRlclByb3BlcnR5XCIpKSlcbiAgfSxcbiAgZ2VuZXJhdG9yOiB7XG4gICAgZGVmYXVsdDogZmFsc2VcbiAgfSxcbiAgYXN5bmM6IHtcbiAgICBkZWZhdWx0OiBmYWxzZVxuICB9XG59O1xuZXhwb3J0cy5mdW5jdGlvbkNvbW1vbiA9IGZ1bmN0aW9uQ29tbW9uO1xuY29uc3QgZnVuY3Rpb25UeXBlQW5ub3RhdGlvbkNvbW1vbiA9IHtcbiAgcmV0dXJuVHlwZToge1xuICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlR5cGVBbm5vdGF0aW9uXCIsIFwiVFNUeXBlQW5ub3RhdGlvblwiLCBcIk5vb3BcIiksXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSxcbiAgdHlwZVBhcmFtZXRlcnM6IHtcbiAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiwgXCJUU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiLCBcIk5vb3BcIiksXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfVxufTtcbmV4cG9ydHMuZnVuY3Rpb25UeXBlQW5ub3RhdGlvbkNvbW1vbiA9IGZ1bmN0aW9uVHlwZUFubm90YXRpb25Db21tb247XG5jb25zdCBmdW5jdGlvbkRlY2xhcmF0aW9uQ29tbW9uID0gT2JqZWN0LmFzc2lnbih7fSwgZnVuY3Rpb25Db21tb24sIHtcbiAgZGVjbGFyZToge1xuICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0sXG4gIGlkOiB7XG4gICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9XG59KTtcbmV4cG9ydHMuZnVuY3Rpb25EZWNsYXJhdGlvbkNvbW1vbiA9IGZ1bmN0aW9uRGVjbGFyYXRpb25Db21tb247XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiLCB7XG4gIGJ1aWxkZXI6IFtcImlkXCIsIFwicGFyYW1zXCIsIFwiYm9keVwiLCBcImdlbmVyYXRvclwiLCBcImFzeW5jXCJdLFxuICB2aXNpdG9yOiBbXCJpZFwiLCBcInBhcmFtc1wiLCBcImJvZHlcIiwgXCJyZXR1cm5UeXBlXCIsIFwidHlwZVBhcmFtZXRlcnNcIl0sXG4gIGZpZWxkczogT2JqZWN0LmFzc2lnbih7fSwgZnVuY3Rpb25EZWNsYXJhdGlvbkNvbW1vbiwgZnVuY3Rpb25UeXBlQW5ub3RhdGlvbkNvbW1vbiwge1xuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkJsb2NrU3RhdGVtZW50XCIpXG4gICAgfVxuICB9KSxcbiAgYWxpYXNlczogW1wiU2NvcGFibGVcIiwgXCJGdW5jdGlvblwiLCBcIkJsb2NrUGFyZW50XCIsIFwiRnVuY3Rpb25QYXJlbnRcIiwgXCJTdGF0ZW1lbnRcIiwgXCJQdXJlaXNoXCIsIFwiRGVjbGFyYXRpb25cIl0sXG4gIHZhbGlkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HKSByZXR1cm4gKCkgPT4ge307XG4gICAgY29uc3QgaWRlbnRpZmllciA9ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHBhcmVudCwga2V5LCBub2RlKSB7XG4gICAgICBpZiAoISgwLCBfaXMuZGVmYXVsdCkoXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIiwgcGFyZW50KSkge1xuICAgICAgICBpZGVudGlmaWVyKG5vZGUsIFwiaWRcIiwgbm9kZS5pZCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSgpXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJGdW5jdGlvbkV4cHJlc3Npb25cIiwge1xuICBpbmhlcml0czogXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIsXG4gIGFsaWFzZXM6IFtcIlNjb3BhYmxlXCIsIFwiRnVuY3Rpb25cIiwgXCJCbG9ja1BhcmVudFwiLCBcIkZ1bmN0aW9uUGFyZW50XCIsIFwiRXhwcmVzc2lvblwiLCBcIlB1cmVpc2hcIl0sXG4gIGZpZWxkczogT2JqZWN0LmFzc2lnbih7fSwgZnVuY3Rpb25Db21tb24sIGZ1bmN0aW9uVHlwZUFubm90YXRpb25Db21tb24sIHtcbiAgICBpZDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJCbG9ja1N0YXRlbWVudFwiKVxuICAgIH1cbiAgfSlcbn0pO1xuY29uc3QgcGF0dGVybkxpa2VDb21tb24gPSB7XG4gIHR5cGVBbm5vdGF0aW9uOiB7XG4gICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVHlwZUFubm90YXRpb25cIiwgXCJUU1R5cGVBbm5vdGF0aW9uXCIsIFwiTm9vcFwiKSxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9LFxuICBkZWNvcmF0b3JzOiB7XG4gICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRGVjb3JhdG9yXCIpKSlcbiAgfVxufTtcbmV4cG9ydHMucGF0dGVybkxpa2VDb21tb24gPSBwYXR0ZXJuTGlrZUNvbW1vbjtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJJZGVudGlmaWVyXCIsIHtcbiAgYnVpbGRlcjogW1wibmFtZVwiXSxcbiAgdmlzaXRvcjogW1widHlwZUFubm90YXRpb25cIiwgXCJkZWNvcmF0b3JzXCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCIsIFwiUGF0dGVybkxpa2VcIiwgXCJMVmFsXCIsIFwiVFNFbnRpdHlOYW1lXCJdLFxuICBmaWVsZHM6IE9iamVjdC5hc3NpZ24oe30sIHBhdHRlcm5MaWtlQ29tbW9uLCB7XG4gICAgbmFtZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKSwgT2JqZWN0LmFzc2lnbihmdW5jdGlvbiAobm9kZSwga2V5LCB2YWwpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HKSByZXR1cm47XG5cbiAgICAgICAgaWYgKCEoMCwgX2lzVmFsaWRJZGVudGlmaWVyLmRlZmF1bHQpKHZhbCwgZmFsc2UpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgXCIke3ZhbH1cIiBpcyBub3QgYSB2YWxpZCBpZGVudGlmaWVyIG5hbWVgKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICB9KSlcbiAgICB9LFxuICAgIG9wdGlvbmFsOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9KSxcblxuICB2YWxpZGF0ZShwYXJlbnQsIGtleSwgbm9kZSkge1xuICAgIGlmICghcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORykgcmV0dXJuO1xuICAgIGNvbnN0IG1hdGNoID0gL1xcLihcXHcrKSQvLmV4ZWMoa2V5KTtcbiAgICBpZiAoIW1hdGNoKSByZXR1cm47XG4gICAgY29uc3QgWywgcGFyZW50S2V5XSA9IG1hdGNoO1xuICAgIGNvbnN0IG5vbkNvbXAgPSB7XG4gICAgICBjb21wdXRlZDogZmFsc2VcbiAgICB9O1xuXG4gICAgaWYgKHBhcmVudEtleSA9PT0gXCJwcm9wZXJ0eVwiKSB7XG4gICAgICBpZiAoKDAsIF9pcy5kZWZhdWx0KShcIk1lbWJlckV4cHJlc3Npb25cIiwgcGFyZW50LCBub25Db21wKSkgcmV0dXJuO1xuICAgICAgaWYgKCgwLCBfaXMuZGVmYXVsdCkoXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIiwgcGFyZW50LCBub25Db21wKSkgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAocGFyZW50S2V5ID09PSBcImtleVwiKSB7XG4gICAgICBpZiAoKDAsIF9pcy5kZWZhdWx0KShcIlByb3BlcnR5XCIsIHBhcmVudCwgbm9uQ29tcCkpIHJldHVybjtcbiAgICAgIGlmICgoMCwgX2lzLmRlZmF1bHQpKFwiTWV0aG9kXCIsIHBhcmVudCwgbm9uQ29tcCkpIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHBhcmVudEtleSA9PT0gXCJleHBvcnRlZFwiKSB7XG4gICAgICBpZiAoKDAsIF9pcy5kZWZhdWx0KShcIkV4cG9ydFNwZWNpZmllclwiLCBwYXJlbnQpKSByZXR1cm47XG4gICAgfSBlbHNlIGlmIChwYXJlbnRLZXkgPT09IFwiaW1wb3J0ZWRcIikge1xuICAgICAgaWYgKCgwLCBfaXMuZGVmYXVsdCkoXCJJbXBvcnRTcGVjaWZpZXJcIiwgcGFyZW50LCB7XG4gICAgICAgIGltcG9ydGVkOiBub2RlXG4gICAgICB9KSkgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAocGFyZW50S2V5ID09PSBcIm1ldGFcIikge1xuICAgICAgaWYgKCgwLCBfaXMuZGVmYXVsdCkoXCJNZXRhUHJvcGVydHlcIiwgcGFyZW50LCB7XG4gICAgICAgIG1ldGE6IG5vZGVcbiAgICAgIH0pKSByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCgoMCwgX2hlbHBlclZhbGlkYXRvcklkZW50aWZpZXIuaXNLZXl3b3JkKShub2RlLm5hbWUpIHx8ICgwLCBfaGVscGVyVmFsaWRhdG9ySWRlbnRpZmllci5pc1Jlc2VydmVkV29yZCkobm9kZS5uYW1lKSkgJiYgbm9kZS5uYW1lICE9PSBcInRoaXNcIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgXCIke25vZGUubmFtZX1cIiBpcyBub3QgYSB2YWxpZCBpZGVudGlmaWVyYCk7XG4gICAgfVxuICB9XG5cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIklmU3RhdGVtZW50XCIsIHtcbiAgdmlzaXRvcjogW1widGVzdFwiLCBcImNvbnNlcXVlbnRcIiwgXCJhbHRlcm5hdGVcIl0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIkNvbmRpdGlvbmFsXCJdLFxuICBmaWVsZHM6IHtcbiAgICB0ZXN0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICBjb25zZXF1ZW50OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJTdGF0ZW1lbnRcIilcbiAgICB9LFxuICAgIGFsdGVybmF0ZToge1xuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJTdGF0ZW1lbnRcIilcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkxhYmVsZWRTdGF0ZW1lbnRcIiwge1xuICB2aXNpdG9yOiBbXCJsYWJlbFwiLCBcImJvZHlcIl0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiXSxcbiAgZmllbGRzOiB7XG4gICAgbGFiZWw6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIilcbiAgICB9LFxuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlN0YXRlbWVudFwiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiU3RyaW5nTGl0ZXJhbFwiLCB7XG4gIGJ1aWxkZXI6IFtcInZhbHVlXCJdLFxuICBmaWVsZHM6IHtcbiAgICB2YWx1ZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKVxuICAgIH1cbiAgfSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiLCBcIlB1cmVpc2hcIiwgXCJMaXRlcmFsXCIsIFwiSW1tdXRhYmxlXCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJOdW1lcmljTGl0ZXJhbFwiLCB7XG4gIGJ1aWxkZXI6IFtcInZhbHVlXCJdLFxuICBkZXByZWNhdGVkQWxpYXM6IFwiTnVtYmVyTGl0ZXJhbFwiLFxuICBmaWVsZHM6IHtcbiAgICB2YWx1ZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcIm51bWJlclwiKVxuICAgIH1cbiAgfSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiLCBcIlB1cmVpc2hcIiwgXCJMaXRlcmFsXCIsIFwiSW1tdXRhYmxlXCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJOdWxsTGl0ZXJhbFwiLCB7XG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIiwgXCJQdXJlaXNoXCIsIFwiTGl0ZXJhbFwiLCBcIkltbXV0YWJsZVwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiQm9vbGVhbkxpdGVyYWxcIiwge1xuICBidWlsZGVyOiBbXCJ2YWx1ZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpXG4gICAgfVxuICB9LFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCIsIFwiUHVyZWlzaFwiLCBcIkxpdGVyYWxcIiwgXCJJbW11dGFibGVcIl1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlJlZ0V4cExpdGVyYWxcIiwge1xuICBidWlsZGVyOiBbXCJwYXR0ZXJuXCIsIFwiZmxhZ3NcIl0sXG4gIGRlcHJlY2F0ZWRBbGlhczogXCJSZWdleExpdGVyYWxcIixcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiLCBcIlB1cmVpc2hcIiwgXCJMaXRlcmFsXCJdLFxuICBmaWVsZHM6IHtcbiAgICBwYXR0ZXJuOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwic3RyaW5nXCIpXG4gICAgfSxcbiAgICBmbGFnczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKSwgT2JqZWN0LmFzc2lnbihmdW5jdGlvbiAobm9kZSwga2V5LCB2YWwpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGludmFsaWQgPSAvW15naW1zdXldLy5leGVjKHZhbCk7XG5cbiAgICAgICAgaWYgKGludmFsaWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBcIiR7aW52YWxpZFswXX1cIiBpcyBub3QgYSB2YWxpZCBSZWdFeHAgZmxhZ2ApO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgIH0pKSxcbiAgICAgIGRlZmF1bHQ6IFwiXCJcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkxvZ2ljYWxFeHByZXNzaW9uXCIsIHtcbiAgYnVpbGRlcjogW1wib3BlcmF0b3JcIiwgXCJsZWZ0XCIsIFwicmlnaHRcIl0sXG4gIHZpc2l0b3I6IFtcImxlZnRcIiwgXCJyaWdodFwiXSxcbiAgYWxpYXNlczogW1wiQmluYXJ5XCIsIFwiRXhwcmVzc2lvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgb3BlcmF0b3I6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE9uZU9mKSguLi5fY29uc3RhbnRzLkxPR0lDQUxfT1BFUkFUT1JTKVxuICAgIH0sXG4gICAgbGVmdDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgcmlnaHQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIk1lbWJlckV4cHJlc3Npb25cIiwge1xuICBidWlsZGVyOiBbXCJvYmplY3RcIiwgXCJwcm9wZXJ0eVwiLCBcImNvbXB1dGVkXCIsIFwib3B0aW9uYWxcIl0sXG4gIHZpc2l0b3I6IFtcIm9iamVjdFwiLCBcInByb3BlcnR5XCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCIsIFwiTFZhbFwiXSxcbiAgZmllbGRzOiBPYmplY3QuYXNzaWduKHtcbiAgICBvYmplY3Q6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIHByb3BlcnR5OiB7XG4gICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBub3JtYWwgPSAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIiwgXCJQcml2YXRlTmFtZVwiKTtcbiAgICAgICAgY29uc3QgY29tcHV0ZWQgPSAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIik7XG5cbiAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gZnVuY3Rpb24gKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gbm9kZS5jb21wdXRlZCA/IGNvbXB1dGVkIDogbm9ybWFsO1xuICAgICAgICAgIHZhbGlkYXRvcihub2RlLCBrZXksIHZhbCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFsaWRhdG9yLm9uZU9mTm9kZVR5cGVzID0gW1wiRXhwcmVzc2lvblwiLCBcIklkZW50aWZpZXJcIiwgXCJQcml2YXRlTmFtZVwiXTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRvcjtcbiAgICAgIH0oKVxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfVxuICB9LCAhcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORyA/IHtcbiAgICBvcHRpb25hbDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKHRydWUsIGZhbHNlKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9IDoge30pXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJOZXdFeHByZXNzaW9uXCIsIHtcbiAgaW5oZXJpdHM6IFwiQ2FsbEV4cHJlc3Npb25cIlxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiUHJvZ3JhbVwiLCB7XG4gIHZpc2l0b3I6IFtcImRpcmVjdGl2ZXNcIiwgXCJib2R5XCJdLFxuICBidWlsZGVyOiBbXCJib2R5XCIsIFwiZGlyZWN0aXZlc1wiLCBcInNvdXJjZVR5cGVcIiwgXCJpbnRlcnByZXRlclwiXSxcbiAgZmllbGRzOiB7XG4gICAgc291cmNlRmlsZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKVxuICAgIH0sXG4gICAgc291cmNlVHlwZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKFwic2NyaXB0XCIsIFwibW9kdWxlXCIpLFxuICAgICAgZGVmYXVsdDogXCJzY3JpcHRcIlxuICAgIH0sXG4gICAgaW50ZXJwcmV0ZXI6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkludGVycHJldGVyRGlyZWN0aXZlXCIpLFxuICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBkaXJlY3RpdmVzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJEaXJlY3RpdmVcIikpKSxcbiAgICAgIGRlZmF1bHQ6IFtdXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJTdGF0ZW1lbnRcIikpKVxuICAgIH1cbiAgfSxcbiAgYWxpYXNlczogW1wiU2NvcGFibGVcIiwgXCJCbG9ja1BhcmVudFwiLCBcIkJsb2NrXCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJPYmplY3RFeHByZXNzaW9uXCIsIHtcbiAgdmlzaXRvcjogW1wicHJvcGVydGllc1wiXSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgcHJvcGVydGllczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiT2JqZWN0TWV0aG9kXCIsIFwiT2JqZWN0UHJvcGVydHlcIiwgXCJTcHJlYWRFbGVtZW50XCIpKSlcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIk9iamVjdE1ldGhvZFwiLCB7XG4gIGJ1aWxkZXI6IFtcImtpbmRcIiwgXCJrZXlcIiwgXCJwYXJhbXNcIiwgXCJib2R5XCIsIFwiY29tcHV0ZWRcIiwgXCJnZW5lcmF0b3JcIiwgXCJhc3luY1wiXSxcbiAgZmllbGRzOiBPYmplY3QuYXNzaWduKHt9LCBmdW5jdGlvbkNvbW1vbiwgZnVuY3Rpb25UeXBlQW5ub3RhdGlvbkNvbW1vbiwge1xuICAgIGtpbmQ6IE9iamVjdC5hc3NpZ24oe1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKFwibWV0aG9kXCIsIFwiZ2V0XCIsIFwic2V0XCIpXG4gICAgfSwgIXByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcgPyB7XG4gICAgICBkZWZhdWx0OiBcIm1ldGhvZFwiXG4gICAgfSA6IHt9KSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGtleToge1xuICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3Qgbm9ybWFsID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIsIFwiU3RyaW5nTGl0ZXJhbFwiLCBcIk51bWVyaWNMaXRlcmFsXCIpO1xuICAgICAgICBjb25zdCBjb21wdXRlZCA9ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKTtcblxuICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSBmdW5jdGlvbiAobm9kZSwga2V5LCB2YWwpIHtcbiAgICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSBub2RlLmNvbXB1dGVkID8gY29tcHV0ZWQgOiBub3JtYWw7XG4gICAgICAgICAgdmFsaWRhdG9yKG5vZGUsIGtleSwgdmFsKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YWxpZGF0b3Iub25lT2ZOb2RlVHlwZXMgPSBbXCJFeHByZXNzaW9uXCIsIFwiSWRlbnRpZmllclwiLCBcIlN0cmluZ0xpdGVyYWxcIiwgXCJOdW1lcmljTGl0ZXJhbFwiXTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRvcjtcbiAgICAgIH0oKVxuICAgIH0sXG4gICAgZGVjb3JhdG9yczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRGVjb3JhdG9yXCIpKSksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgYm9keToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiQmxvY2tTdGF0ZW1lbnRcIilcbiAgICB9XG4gIH0pLFxuICB2aXNpdG9yOiBbXCJrZXlcIiwgXCJwYXJhbXNcIiwgXCJib2R5XCIsIFwiZGVjb3JhdG9yc1wiLCBcInJldHVyblR5cGVcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiXSxcbiAgYWxpYXNlczogW1wiVXNlcldoaXRlc3BhY2FibGVcIiwgXCJGdW5jdGlvblwiLCBcIlNjb3BhYmxlXCIsIFwiQmxvY2tQYXJlbnRcIiwgXCJGdW5jdGlvblBhcmVudFwiLCBcIk1ldGhvZFwiLCBcIk9iamVjdE1lbWJlclwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiT2JqZWN0UHJvcGVydHlcIiwge1xuICBidWlsZGVyOiBbXCJrZXlcIiwgXCJ2YWx1ZVwiLCBcImNvbXB1dGVkXCIsIFwic2hvcnRoYW5kXCIsIC4uLighcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORyA/IFtcImRlY29yYXRvcnNcIl0gOiBbXSldLFxuICBmaWVsZHM6IHtcbiAgICBjb21wdXRlZDoge1xuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGtleToge1xuICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3Qgbm9ybWFsID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIsIFwiU3RyaW5nTGl0ZXJhbFwiLCBcIk51bWVyaWNMaXRlcmFsXCIpO1xuICAgICAgICBjb25zdCBjb21wdXRlZCA9ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKTtcblxuICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSBmdW5jdGlvbiAobm9kZSwga2V5LCB2YWwpIHtcbiAgICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSBub2RlLmNvbXB1dGVkID8gY29tcHV0ZWQgOiBub3JtYWw7XG4gICAgICAgICAgdmFsaWRhdG9yKG5vZGUsIGtleSwgdmFsKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YWxpZGF0b3Iub25lT2ZOb2RlVHlwZXMgPSBbXCJFeHByZXNzaW9uXCIsIFwiSWRlbnRpZmllclwiLCBcIlN0cmluZ0xpdGVyYWxcIiwgXCJOdW1lcmljTGl0ZXJhbFwiXTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRvcjtcbiAgICAgIH0oKVxuICAgIH0sXG4gICAgdmFsdWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIiwgXCJQYXR0ZXJuTGlrZVwiKVxuICAgIH0sXG4gICAgc2hvcnRoYW5kOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSwgT2JqZWN0LmFzc2lnbihmdW5jdGlvbiAobm9kZSwga2V5LCB2YWwpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HKSByZXR1cm47XG5cbiAgICAgICAgaWYgKHZhbCAmJiBub2RlLmNvbXB1dGVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByb3BlcnR5IHNob3J0aGFuZCBvZiBPYmplY3RQcm9wZXJ0eSBjYW5ub3QgYmUgdHJ1ZSBpZiBjb21wdXRlZCBpcyB0cnVlXCIpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiYm9vbGVhblwiXG4gICAgICB9KSwgZnVuY3Rpb24gKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgICAgIGlmICghcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORykgcmV0dXJuO1xuXG4gICAgICAgIGlmICh2YWwgJiYgISgwLCBfaXMuZGVmYXVsdCkoXCJJZGVudGlmaWVyXCIsIG5vZGUua2V5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcm9wZXJ0eSBzaG9ydGhhbmQgb2YgT2JqZWN0UHJvcGVydHkgY2Fubm90IGJlIHRydWUgaWYga2V5IGlzIG5vdCBhbiBJZGVudGlmaWVyXCIpO1xuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBkZWNvcmF0b3JzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJEZWNvcmF0b3JcIikpKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9LFxuICB2aXNpdG9yOiBbXCJrZXlcIiwgXCJ2YWx1ZVwiLCBcImRlY29yYXRvcnNcIl0sXG4gIGFsaWFzZXM6IFtcIlVzZXJXaGl0ZXNwYWNhYmxlXCIsIFwiUHJvcGVydHlcIiwgXCJPYmplY3RNZW1iZXJcIl0sXG4gIHZhbGlkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgcGF0dGVybiA9ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiLCBcIlBhdHRlcm5cIik7XG4gICAgY29uc3QgZXhwcmVzc2lvbiA9ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHBhcmVudCwga2V5LCBub2RlKSB7XG4gICAgICBpZiAoIXByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcpIHJldHVybjtcbiAgICAgIGNvbnN0IHZhbGlkYXRvciA9ICgwLCBfaXMuZGVmYXVsdCkoXCJPYmplY3RQYXR0ZXJuXCIsIHBhcmVudCkgPyBwYXR0ZXJuIDogZXhwcmVzc2lvbjtcbiAgICAgIHZhbGlkYXRvcihub2RlLCBcInZhbHVlXCIsIG5vZGUudmFsdWUpO1xuICAgIH07XG4gIH0oKVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiUmVzdEVsZW1lbnRcIiwge1xuICB2aXNpdG9yOiBbXCJhcmd1bWVudFwiLCBcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBidWlsZGVyOiBbXCJhcmd1bWVudFwiXSxcbiAgYWxpYXNlczogW1wiTFZhbFwiLCBcIlBhdHRlcm5MaWtlXCJdLFxuICBkZXByZWNhdGVkQWxpYXM6IFwiUmVzdFByb3BlcnR5XCIsXG4gIGZpZWxkczogT2JqZWN0LmFzc2lnbih7fSwgcGF0dGVybkxpa2VDb21tb24sIHtcbiAgICBhcmd1bWVudDoge1xuICAgICAgdmFsaWRhdGU6ICFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HID8gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJMVmFsXCIpIDogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIsIFwiUGF0dGVyblwiLCBcIk1lbWJlckV4cHJlc3Npb25cIilcbiAgICB9XG4gIH0pLFxuXG4gIHZhbGlkYXRlKHBhcmVudCwga2V5KSB7XG4gICAgaWYgKCFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HKSByZXR1cm47XG4gICAgY29uc3QgbWF0Y2ggPSAvKFxcdyspXFxbKFxcZCspXFxdLy5leGVjKGtleSk7XG4gICAgaWYgKCFtYXRjaCkgdGhyb3cgbmV3IEVycm9yKFwiSW50ZXJuYWwgQmFiZWwgZXJyb3I6IG1hbGZvcm1lZCBrZXkuXCIpO1xuICAgIGNvbnN0IFssIGxpc3RLZXksIGluZGV4XSA9IG1hdGNoO1xuXG4gICAgaWYgKHBhcmVudFtsaXN0S2V5XS5sZW5ndGggPiBpbmRleCArIDEpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFJlc3RFbGVtZW50IG11c3QgYmUgbGFzdCBlbGVtZW50IG9mICR7bGlzdEtleX1gKTtcbiAgICB9XG4gIH1cblxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiUmV0dXJuU3RhdGVtZW50XCIsIHtcbiAgdmlzaXRvcjogW1wiYXJndW1lbnRcIl0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIlRlcm1pbmF0b3JsZXNzXCIsIFwiQ29tcGxldGlvblN0YXRlbWVudFwiXSxcbiAgZmllbGRzOiB7XG4gICAgYXJndW1lbnQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiU2VxdWVuY2VFeHByZXNzaW9uXCIsIHtcbiAgdmlzaXRvcjogW1wiZXhwcmVzc2lvbnNcIl0sXG4gIGZpZWxkczoge1xuICAgIGV4cHJlc3Npb25zOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpKSlcbiAgICB9XG4gIH0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIl1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIsIHtcbiAgdmlzaXRvcjogW1wiZXhwcmVzc2lvblwiXSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiLCBcIkV4cHJlc3Npb25XcmFwcGVyXCJdLFxuICBmaWVsZHM6IHtcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJTd2l0Y2hDYXNlXCIsIHtcbiAgdmlzaXRvcjogW1widGVzdFwiLCBcImNvbnNlcXVlbnRcIl0sXG4gIGZpZWxkczoge1xuICAgIHRlc3Q6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgY29uc2VxdWVudDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiU3RhdGVtZW50XCIpKSlcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlN3aXRjaFN0YXRlbWVudFwiLCB7XG4gIHZpc2l0b3I6IFtcImRpc2NyaW1pbmFudFwiLCBcImNhc2VzXCJdLFxuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJCbG9ja1BhcmVudFwiLCBcIlNjb3BhYmxlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBkaXNjcmltaW5hbnQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIGNhc2VzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJTd2l0Y2hDYXNlXCIpKSlcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRoaXNFeHByZXNzaW9uXCIsIHtcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVGhyb3dTdGF0ZW1lbnRcIiwge1xuICB2aXNpdG9yOiBbXCJhcmd1bWVudFwiXSxcbiAgYWxpYXNlczogW1wiU3RhdGVtZW50XCIsIFwiVGVybWluYXRvcmxlc3NcIiwgXCJDb21wbGV0aW9uU3RhdGVtZW50XCJdLFxuICBmaWVsZHM6IHtcbiAgICBhcmd1bWVudDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVHJ5U3RhdGVtZW50XCIsIHtcbiAgdmlzaXRvcjogW1wiYmxvY2tcIiwgXCJoYW5kbGVyXCIsIFwiZmluYWxpemVyXCJdLFxuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIl0sXG4gIGZpZWxkczoge1xuICAgIGJsb2NrOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJCbG9ja1N0YXRlbWVudFwiKSwgT2JqZWN0LmFzc2lnbihmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAoIXByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcpIHJldHVybjtcblxuICAgICAgICBpZiAoIW5vZGUuaGFuZGxlciAmJiAhbm9kZS5maW5hbGl6ZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVHJ5U3RhdGVtZW50IGV4cGVjdHMgZWl0aGVyIGEgaGFuZGxlciBvciBmaW5hbGl6ZXIsIG9yIGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgb25lT2ZOb2RlVHlwZXM6IFtcIkJsb2NrU3RhdGVtZW50XCJdXG4gICAgICB9KSlcbiAgICB9LFxuICAgIGhhbmRsZXI6IHtcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiQ2F0Y2hDbGF1c2VcIilcbiAgICB9LFxuICAgIGZpbmFsaXplcjoge1xuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJCbG9ja1N0YXRlbWVudFwiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVW5hcnlFeHByZXNzaW9uXCIsIHtcbiAgYnVpbGRlcjogW1wib3BlcmF0b3JcIiwgXCJhcmd1bWVudFwiLCBcInByZWZpeFwiXSxcbiAgZmllbGRzOiB7XG4gICAgcHJlZml4OiB7XG4gICAgICBkZWZhdWx0OiB0cnVlXG4gICAgfSxcbiAgICBhcmd1bWVudDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgb3BlcmF0b3I6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE9uZU9mKSguLi5fY29uc3RhbnRzLlVOQVJZX09QRVJBVE9SUylcbiAgICB9XG4gIH0sXG4gIHZpc2l0b3I6IFtcImFyZ3VtZW50XCJdLFxuICBhbGlhc2VzOiBbXCJVbmFyeUxpa2VcIiwgXCJFeHByZXNzaW9uXCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJVcGRhdGVFeHByZXNzaW9uXCIsIHtcbiAgYnVpbGRlcjogW1wib3BlcmF0b3JcIiwgXCJhcmd1bWVudFwiLCBcInByZWZpeFwiXSxcbiAgZmllbGRzOiB7XG4gICAgcHJlZml4OiB7XG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgYXJndW1lbnQ6IHtcbiAgICAgIHZhbGlkYXRlOiAhcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORyA/ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKSA6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiLCBcIk1lbWJlckV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIG9wZXJhdG9yOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRPbmVPZikoLi4uX2NvbnN0YW50cy5VUERBVEVfT1BFUkFUT1JTKVxuICAgIH1cbiAgfSxcbiAgdmlzaXRvcjogW1wiYXJndW1lbnRcIl0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIl1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlZhcmlhYmxlRGVjbGFyYXRpb25cIiwge1xuICBidWlsZGVyOiBbXCJraW5kXCIsIFwiZGVjbGFyYXRpb25zXCJdLFxuICB2aXNpdG9yOiBbXCJkZWNsYXJhdGlvbnNcIl0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBkZWNsYXJlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBraW5kOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRPbmVPZikoXCJ2YXJcIiwgXCJsZXRcIiwgXCJjb25zdFwiKVxuICAgIH0sXG4gICAgZGVjbGFyYXRpb25zOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJWYXJpYWJsZURlY2xhcmF0b3JcIikpKVxuICAgIH1cbiAgfSxcblxuICB2YWxpZGF0ZShwYXJlbnQsIGtleSwgbm9kZSkge1xuICAgIGlmICghcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORykgcmV0dXJuO1xuICAgIGlmICghKDAsIF9pcy5kZWZhdWx0KShcIkZvclhTdGF0ZW1lbnRcIiwgcGFyZW50LCB7XG4gICAgICBsZWZ0OiBub2RlXG4gICAgfSkpIHJldHVybjtcblxuICAgIGlmIChub2RlLmRlY2xhcmF0aW9ucy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4YWN0bHkgb25lIFZhcmlhYmxlRGVjbGFyYXRvciBpcyByZXF1aXJlZCBpbiB0aGUgVmFyaWFibGVEZWNsYXJhdGlvbiBvZiBhICR7cGFyZW50LnR5cGV9YCk7XG4gICAgfVxuICB9XG5cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlZhcmlhYmxlRGVjbGFyYXRvclwiLCB7XG4gIHZpc2l0b3I6IFtcImlkXCIsIFwiaW5pdFwiXSxcbiAgZmllbGRzOiB7XG4gICAgaWQ6IHtcbiAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORykge1xuICAgICAgICAgIHJldHVybiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkxWYWxcIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBub3JtYWwgPSAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIiwgXCJBcnJheVBhdHRlcm5cIiwgXCJPYmplY3RQYXR0ZXJuXCIpO1xuICAgICAgICBjb25zdCB3aXRob3V0ID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gbm9kZS5pbml0ID8gbm9ybWFsIDogd2l0aG91dDtcbiAgICAgICAgICB2YWxpZGF0b3Iobm9kZSwga2V5LCB2YWwpO1xuICAgICAgICB9O1xuICAgICAgfSgpXG4gICAgfSxcbiAgICBkZWZpbml0ZToge1xuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKVxuICAgIH0sXG4gICAgaW5pdDoge1xuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJXaGlsZVN0YXRlbWVudFwiLCB7XG4gIHZpc2l0b3I6IFtcInRlc3RcIiwgXCJib2R5XCJdLFxuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJCbG9ja1BhcmVudFwiLCBcIkxvb3BcIiwgXCJXaGlsZVwiLCBcIlNjb3BhYmxlXCJdLFxuICBmaWVsZHM6IHtcbiAgICB0ZXN0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJTdGF0ZW1lbnRcIilcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIldpdGhTdGF0ZW1lbnRcIiwge1xuICB2aXNpdG9yOiBbXCJvYmplY3RcIiwgXCJib2R5XCJdLFxuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIl0sXG4gIGZpZWxkczoge1xuICAgIG9iamVjdDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgYm9keToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiU3RhdGVtZW50XCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJBc3NpZ25tZW50UGF0dGVyblwiLCB7XG4gIHZpc2l0b3I6IFtcImxlZnRcIiwgXCJyaWdodFwiLCBcImRlY29yYXRvcnNcIl0sXG4gIGJ1aWxkZXI6IFtcImxlZnRcIiwgXCJyaWdodFwiXSxcbiAgYWxpYXNlczogW1wiUGF0dGVyblwiLCBcIlBhdHRlcm5MaWtlXCIsIFwiTFZhbFwiXSxcbiAgZmllbGRzOiBPYmplY3QuYXNzaWduKHt9LCBwYXR0ZXJuTGlrZUNvbW1vbiwge1xuICAgIGxlZnQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIiwgXCJPYmplY3RQYXR0ZXJuXCIsIFwiQXJyYXlQYXR0ZXJuXCIsIFwiTWVtYmVyRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgcmlnaHQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIGRlY29yYXRvcnM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJhcnJheVwiKSwgKDAsIF91dGlscy5hc3NlcnRFYWNoKSgoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkRlY29yYXRvclwiKSkpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XG4gIH0pXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJBcnJheVBhdHRlcm5cIiwge1xuICB2aXNpdG9yOiBbXCJlbGVtZW50c1wiLCBcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBidWlsZGVyOiBbXCJlbGVtZW50c1wiXSxcbiAgYWxpYXNlczogW1wiUGF0dGVyblwiLCBcIlBhdHRlcm5MaWtlXCIsIFwiTFZhbFwiXSxcbiAgZmllbGRzOiBPYmplY3QuYXNzaWduKHt9LCBwYXR0ZXJuTGlrZUNvbW1vbiwge1xuICAgIGVsZW1lbnRzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlT3JWYWx1ZVR5cGUpKFwibnVsbFwiLCBcIlBhdHRlcm5MaWtlXCIpKSlcbiAgICB9LFxuICAgIGRlY29yYXRvcnM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJhcnJheVwiKSwgKDAsIF91dGlscy5hc3NlcnRFYWNoKSgoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkRlY29yYXRvclwiKSkpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XG4gIH0pXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiLCB7XG4gIGJ1aWxkZXI6IFtcInBhcmFtc1wiLCBcImJvZHlcIiwgXCJhc3luY1wiXSxcbiAgdmlzaXRvcjogW1wicGFyYW1zXCIsIFwiYm9keVwiLCBcInJldHVyblR5cGVcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiXSxcbiAgYWxpYXNlczogW1wiU2NvcGFibGVcIiwgXCJGdW5jdGlvblwiLCBcIkJsb2NrUGFyZW50XCIsIFwiRnVuY3Rpb25QYXJlbnRcIiwgXCJFeHByZXNzaW9uXCIsIFwiUHVyZWlzaFwiXSxcbiAgZmllbGRzOiBPYmplY3QuYXNzaWduKHt9LCBmdW5jdGlvbkNvbW1vbiwgZnVuY3Rpb25UeXBlQW5ub3RhdGlvbkNvbW1vbiwge1xuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJCbG9ja1N0YXRlbWVudFwiLCBcIkV4cHJlc3Npb25cIilcbiAgICB9XG4gIH0pXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJDbGFzc0JvZHlcIiwge1xuICB2aXNpdG9yOiBbXCJib2R5XCJdLFxuICBmaWVsZHM6IHtcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJDbGFzc01ldGhvZFwiLCBcIkNsYXNzUHJpdmF0ZU1ldGhvZFwiLCBcIkNsYXNzUHJvcGVydHlcIiwgXCJDbGFzc1ByaXZhdGVQcm9wZXJ0eVwiLCBcIlRTRGVjbGFyZU1ldGhvZFwiLCBcIlRTSW5kZXhTaWduYXR1cmVcIikpKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiQ2xhc3NFeHByZXNzaW9uXCIsIHtcbiAgYnVpbGRlcjogW1wiaWRcIiwgXCJzdXBlckNsYXNzXCIsIFwiYm9keVwiLCBcImRlY29yYXRvcnNcIl0sXG4gIHZpc2l0b3I6IFtcImlkXCIsIFwiYm9keVwiLCBcInN1cGVyQ2xhc3NcIiwgXCJtaXhpbnNcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiLCBcInN1cGVyVHlwZVBhcmFtZXRlcnNcIiwgXCJpbXBsZW1lbnRzXCIsIFwiZGVjb3JhdG9yc1wiXSxcbiAgYWxpYXNlczogW1wiU2NvcGFibGVcIiwgXCJDbGFzc1wiLCBcIkV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIHR5cGVQYXJhbWV0ZXJzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiwgXCJUU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiLCBcIk5vb3BcIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgYm9keToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiQ2xhc3NCb2R5XCIpXG4gICAgfSxcbiAgICBzdXBlckNsYXNzOiB7XG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIHN1cGVyVHlwZVBhcmFtZXRlcnM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIsIFwiVFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBpbXBsZW1lbnRzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJUU0V4cHJlc3Npb25XaXRoVHlwZUFyZ3VtZW50c1wiLCBcIkNsYXNzSW1wbGVtZW50c1wiKSkpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIGRlY29yYXRvcnM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJhcnJheVwiKSwgKDAsIF91dGlscy5hc3NlcnRFYWNoKSgoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkRlY29yYXRvclwiKSkpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIG1peGluczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSW50ZXJmYWNlRXh0ZW5kc1wiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJDbGFzc0RlY2xhcmF0aW9uXCIsIHtcbiAgaW5oZXJpdHM6IFwiQ2xhc3NFeHByZXNzaW9uXCIsXG4gIGFsaWFzZXM6IFtcIlNjb3BhYmxlXCIsIFwiQ2xhc3NcIiwgXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgaWQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIilcbiAgICB9LFxuICAgIHR5cGVQYXJhbWV0ZXJzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiwgXCJUU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiLCBcIk5vb3BcIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgYm9keToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiQ2xhc3NCb2R5XCIpXG4gICAgfSxcbiAgICBzdXBlckNsYXNzOiB7XG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIHN1cGVyVHlwZVBhcmFtZXRlcnM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIsIFwiVFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBpbXBsZW1lbnRzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJUU0V4cHJlc3Npb25XaXRoVHlwZUFyZ3VtZW50c1wiLCBcIkNsYXNzSW1wbGVtZW50c1wiKSkpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIGRlY29yYXRvcnM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJhcnJheVwiKSwgKDAsIF91dGlscy5hc3NlcnRFYWNoKSgoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkRlY29yYXRvclwiKSkpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIG1peGluczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSW50ZXJmYWNlRXh0ZW5kc1wiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBkZWNsYXJlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBhYnN0cmFjdDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgdmFsaWRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBpZGVudGlmaWVyID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpO1xuICAgIHJldHVybiBmdW5jdGlvbiAocGFyZW50LCBrZXksIG5vZGUpIHtcbiAgICAgIGlmICghcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORykgcmV0dXJuO1xuXG4gICAgICBpZiAoISgwLCBfaXMuZGVmYXVsdCkoXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIiwgcGFyZW50KSkge1xuICAgICAgICBpZGVudGlmaWVyKG5vZGUsIFwiaWRcIiwgbm9kZS5pZCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSgpXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiLCB7XG4gIHZpc2l0b3I6IFtcInNvdXJjZVwiXSxcbiAgYWxpYXNlczogW1wiU3RhdGVtZW50XCIsIFwiRGVjbGFyYXRpb25cIiwgXCJNb2R1bGVEZWNsYXJhdGlvblwiLCBcIkV4cG9ydERlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBzb3VyY2U6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlN0cmluZ0xpdGVyYWxcIilcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiLCB7XG4gIHZpc2l0b3I6IFtcImRlY2xhcmF0aW9uXCJdLFxuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiLCBcIk1vZHVsZURlY2xhcmF0aW9uXCIsIFwiRXhwb3J0RGVjbGFyYXRpb25cIl0sXG4gIGZpZWxkczoge1xuICAgIGRlY2xhcmF0aW9uOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIsIFwiVFNEZWNsYXJlRnVuY3Rpb25cIiwgXCJDbGFzc0RlY2xhcmF0aW9uXCIsIFwiRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiLCB7XG4gIHZpc2l0b3I6IFtcImRlY2xhcmF0aW9uXCIsIFwic3BlY2lmaWVyc1wiLCBcInNvdXJjZVwiXSxcbiAgYWxpYXNlczogW1wiU3RhdGVtZW50XCIsIFwiRGVjbGFyYXRpb25cIiwgXCJNb2R1bGVEZWNsYXJhdGlvblwiLCBcIkV4cG9ydERlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBkZWNsYXJhdGlvbjoge1xuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJEZWNsYXJhdGlvblwiKSwgT2JqZWN0LmFzc2lnbihmdW5jdGlvbiAobm9kZSwga2V5LCB2YWwpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HKSByZXR1cm47XG5cbiAgICAgICAgaWYgKHZhbCAmJiBub2RlLnNwZWNpZmllcnMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9ubHkgZGVjbGFyYXRpb24gb3Igc3BlY2lmaWVycyBpcyBhbGxvd2VkIG9uIEV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgb25lT2ZOb2RlVHlwZXM6IFtcIkRlY2xhcmF0aW9uXCJdXG4gICAgICB9KSwgZnVuY3Rpb24gKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgICAgIGlmICghcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORykgcmV0dXJuO1xuXG4gICAgICAgIGlmICh2YWwgJiYgbm9kZS5zb3VyY2UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGV4cG9ydCBhIGRlY2xhcmF0aW9uIGZyb20gYSBzb3VyY2VcIik7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSxcbiAgICBzcGVjaWZpZXJzOiB7XG4gICAgICBkZWZhdWx0OiBbXSxcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJhcnJheVwiKSwgKDAsIF91dGlscy5hc3NlcnRFYWNoKShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZWQgPSAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cG9ydFNwZWNpZmllclwiLCBcIkV4cG9ydERlZmF1bHRTcGVjaWZpZXJcIiwgXCJFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIik7XG4gICAgICAgIGNvbnN0IHNvdXJjZWxlc3MgPSAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cG9ydFNwZWNpZmllclwiKTtcbiAgICAgICAgaWYgKCFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HKSByZXR1cm4gc291cmNlZDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChub2RlLCBrZXksIHZhbCkge1xuICAgICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IG5vZGUuc291cmNlID8gc291cmNlZCA6IHNvdXJjZWxlc3M7XG4gICAgICAgICAgdmFsaWRhdG9yKG5vZGUsIGtleSwgdmFsKTtcbiAgICAgICAgfTtcbiAgICAgIH0oKSkpXG4gICAgfSxcbiAgICBzb3VyY2U6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlN0cmluZ0xpdGVyYWxcIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgZXhwb3J0S2luZDogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsKSgoMCwgX3V0aWxzLmFzc2VydE9uZU9mKShcInR5cGVcIiwgXCJ2YWx1ZVwiKSlcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRXhwb3J0U3BlY2lmaWVyXCIsIHtcbiAgdmlzaXRvcjogW1wibG9jYWxcIiwgXCJleHBvcnRlZFwiXSxcbiAgYWxpYXNlczogW1wiTW9kdWxlU3BlY2lmaWVyXCJdLFxuICBmaWVsZHM6IHtcbiAgICBsb2NhbDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiKVxuICAgIH0sXG4gICAgZXhwb3J0ZWQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIilcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkZvck9mU3RhdGVtZW50XCIsIHtcbiAgdmlzaXRvcjogW1wibGVmdFwiLCBcInJpZ2h0XCIsIFwiYm9keVwiXSxcbiAgYnVpbGRlcjogW1wibGVmdFwiLCBcInJpZ2h0XCIsIFwiYm9keVwiLCBcImF3YWl0XCJdLFxuICBhbGlhc2VzOiBbXCJTY29wYWJsZVwiLCBcIlN0YXRlbWVudFwiLCBcIkZvclwiLCBcIkJsb2NrUGFyZW50XCIsIFwiTG9vcFwiLCBcIkZvclhTdGF0ZW1lbnRcIl0sXG4gIGZpZWxkczoge1xuICAgIGxlZnQ6IHtcbiAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORykge1xuICAgICAgICAgIHJldHVybiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlZhcmlhYmxlRGVjbGFyYXRpb25cIiwgXCJMVmFsXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGVjbGFyYXRpb24gPSAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlZhcmlhYmxlRGVjbGFyYXRpb25cIik7XG4gICAgICAgIGNvbnN0IGx2YWwgPSAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIiwgXCJNZW1iZXJFeHByZXNzaW9uXCIsIFwiQXJyYXlQYXR0ZXJuXCIsIFwiT2JqZWN0UGF0dGVyblwiKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChub2RlLCBrZXksIHZhbCkge1xuICAgICAgICAgIGlmICgoMCwgX2lzLmRlZmF1bHQpKFwiVmFyaWFibGVEZWNsYXJhdGlvblwiLCB2YWwpKSB7XG4gICAgICAgICAgICBkZWNsYXJhdGlvbihub2RlLCBrZXksIHZhbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGx2YWwobm9kZSwga2V5LCB2YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0oKVxuICAgIH0sXG4gICAgcmlnaHQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlN0YXRlbWVudFwiKVxuICAgIH0sXG4gICAgYXdhaXQ6IHtcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJJbXBvcnREZWNsYXJhdGlvblwiLCB7XG4gIHZpc2l0b3I6IFtcInNwZWNpZmllcnNcIiwgXCJzb3VyY2VcIl0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCIsIFwiTW9kdWxlRGVjbGFyYXRpb25cIl0sXG4gIGZpZWxkczoge1xuICAgIHNwZWNpZmllcnM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJhcnJheVwiKSwgKDAsIF91dGlscy5hc3NlcnRFYWNoKSgoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkltcG9ydFNwZWNpZmllclwiLCBcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIiwgXCJJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIikpKVxuICAgIH0sXG4gICAgc291cmNlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJTdHJpbmdMaXRlcmFsXCIpXG4gICAgfSxcbiAgICBpbXBvcnRLaW5kOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRPbmVPZikoXCJ0eXBlXCIsIFwidHlwZW9mXCIsIFwidmFsdWVcIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiSW1wb3J0RGVmYXVsdFNwZWNpZmllclwiLCB7XG4gIHZpc2l0b3I6IFtcImxvY2FsXCJdLFxuICBhbGlhc2VzOiBbXCJNb2R1bGVTcGVjaWZpZXJcIl0sXG4gIGZpZWxkczoge1xuICAgIGxvY2FsOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIiwge1xuICB2aXNpdG9yOiBbXCJsb2NhbFwiXSxcbiAgYWxpYXNlczogW1wiTW9kdWxlU3BlY2lmaWVyXCJdLFxuICBmaWVsZHM6IHtcbiAgICBsb2NhbDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiSW1wb3J0U3BlY2lmaWVyXCIsIHtcbiAgdmlzaXRvcjogW1wibG9jYWxcIiwgXCJpbXBvcnRlZFwiXSxcbiAgYWxpYXNlczogW1wiTW9kdWxlU3BlY2lmaWVyXCJdLFxuICBmaWVsZHM6IHtcbiAgICBsb2NhbDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiKVxuICAgIH0sXG4gICAgaW1wb3J0ZWQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIilcbiAgICB9LFxuICAgIGltcG9ydEtpbmQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE9uZU9mKShcInR5cGVcIiwgXCJ0eXBlb2ZcIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiTWV0YVByb3BlcnR5XCIsIHtcbiAgdmlzaXRvcjogW1wibWV0YVwiLCBcInByb3BlcnR5XCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBtZXRhOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpLCBPYmplY3QuYXNzaWduKGZ1bmN0aW9uIChub2RlLCBrZXksIHZhbCkge1xuICAgICAgICBpZiAoIXByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcpIHJldHVybjtcbiAgICAgICAgbGV0IHByb3BlcnR5O1xuXG4gICAgICAgIHN3aXRjaCAodmFsLm5hbWUpIHtcbiAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgIHByb3BlcnR5ID0gXCJzZW50XCI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJuZXdcIjpcbiAgICAgICAgICAgIHByb3BlcnR5ID0gXCJ0YXJnZXRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcImltcG9ydFwiOlxuICAgICAgICAgICAgcHJvcGVydHkgPSBcIm1ldGFcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEoMCwgX2lzLmRlZmF1bHQpKFwiSWRlbnRpZmllclwiLCBub2RlLnByb3BlcnR5LCB7XG4gICAgICAgICAgbmFtZTogcHJvcGVydHlcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5yZWNvZ25pc2VkIE1ldGFQcm9wZXJ0eVwiKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBvbmVPZk5vZGVUeXBlczogW1wiSWRlbnRpZmllclwiXVxuICAgICAgfSkpXG4gICAgfSxcbiAgICBwcm9wZXJ0eToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiKVxuICAgIH1cbiAgfVxufSk7XG5jb25zdCBjbGFzc01ldGhvZE9yUHJvcGVydHlDb21tb24gPSB7XG4gIGFic3RyYWN0OiB7XG4gICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSxcbiAgYWNjZXNzaWJpbGl0eToge1xuICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE9uZU9mKShcInB1YmxpY1wiLCBcInByaXZhdGVcIiwgXCJwcm90ZWN0ZWRcIiksXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSxcbiAgc3RhdGljOiB7XG4gICAgZGVmYXVsdDogZmFsc2VcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBkZWZhdWx0OiBmYWxzZVxuICB9LFxuICBvcHRpb25hbDoge1xuICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0sXG4gIGtleToge1xuICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKShmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBub3JtYWwgPSAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIiwgXCJTdHJpbmdMaXRlcmFsXCIsIFwiTnVtZXJpY0xpdGVyYWxcIik7XG4gICAgICBjb25zdCBjb21wdXRlZCA9ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSwga2V5LCB2YWwpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gbm9kZS5jb21wdXRlZCA/IGNvbXB1dGVkIDogbm9ybWFsO1xuICAgICAgICB2YWxpZGF0b3Iobm9kZSwga2V5LCB2YWwpO1xuICAgICAgfTtcbiAgICB9KCksICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiLCBcIlN0cmluZ0xpdGVyYWxcIiwgXCJOdW1lcmljTGl0ZXJhbFwiLCBcIkV4cHJlc3Npb25cIikpXG4gIH1cbn07XG5leHBvcnRzLmNsYXNzTWV0aG9kT3JQcm9wZXJ0eUNvbW1vbiA9IGNsYXNzTWV0aG9kT3JQcm9wZXJ0eUNvbW1vbjtcbmNvbnN0IGNsYXNzTWV0aG9kT3JEZWNsYXJlTWV0aG9kQ29tbW9uID0gT2JqZWN0LmFzc2lnbih7fSwgZnVuY3Rpb25Db21tb24sIGNsYXNzTWV0aG9kT3JQcm9wZXJ0eUNvbW1vbiwge1xuICBraW5kOiB7XG4gICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKFwiZ2V0XCIsIFwic2V0XCIsIFwibWV0aG9kXCIsIFwiY29uc3RydWN0b3JcIiksXG4gICAgZGVmYXVsdDogXCJtZXRob2RcIlxuICB9LFxuICBhY2Nlc3M6IHtcbiAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwic3RyaW5nXCIpLCAoMCwgX3V0aWxzLmFzc2VydE9uZU9mKShcInB1YmxpY1wiLCBcInByaXZhdGVcIiwgXCJwcm90ZWN0ZWRcIikpLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0sXG4gIGRlY29yYXRvcnM6IHtcbiAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJEZWNvcmF0b3JcIikpKSxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9XG59KTtcbmV4cG9ydHMuY2xhc3NNZXRob2RPckRlY2xhcmVNZXRob2RDb21tb24gPSBjbGFzc01ldGhvZE9yRGVjbGFyZU1ldGhvZENvbW1vbjtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJDbGFzc01ldGhvZFwiLCB7XG4gIGFsaWFzZXM6IFtcIkZ1bmN0aW9uXCIsIFwiU2NvcGFibGVcIiwgXCJCbG9ja1BhcmVudFwiLCBcIkZ1bmN0aW9uUGFyZW50XCIsIFwiTWV0aG9kXCJdLFxuICBidWlsZGVyOiBbXCJraW5kXCIsIFwia2V5XCIsIFwicGFyYW1zXCIsIFwiYm9keVwiLCBcImNvbXB1dGVkXCIsIFwic3RhdGljXCIsIFwiZ2VuZXJhdG9yXCIsIFwiYXN5bmNcIl0sXG4gIHZpc2l0b3I6IFtcImtleVwiLCBcInBhcmFtc1wiLCBcImJvZHlcIiwgXCJkZWNvcmF0b3JzXCIsIFwicmV0dXJuVHlwZVwiLCBcInR5cGVQYXJhbWV0ZXJzXCJdLFxuICBmaWVsZHM6IE9iamVjdC5hc3NpZ24oe30sIGNsYXNzTWV0aG9kT3JEZWNsYXJlTWV0aG9kQ29tbW9uLCBmdW5jdGlvblR5cGVBbm5vdGF0aW9uQ29tbW9uLCB7XG4gICAgYm9keToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiQmxvY2tTdGF0ZW1lbnRcIilcbiAgICB9XG4gIH0pXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJPYmplY3RQYXR0ZXJuXCIsIHtcbiAgdmlzaXRvcjogW1wicHJvcGVydGllc1wiLCBcInR5cGVBbm5vdGF0aW9uXCIsIFwiZGVjb3JhdG9yc1wiXSxcbiAgYnVpbGRlcjogW1wicHJvcGVydGllc1wiXSxcbiAgYWxpYXNlczogW1wiUGF0dGVyblwiLCBcIlBhdHRlcm5MaWtlXCIsIFwiTFZhbFwiXSxcbiAgZmllbGRzOiBPYmplY3QuYXNzaWduKHt9LCBwYXR0ZXJuTGlrZUNvbW1vbiwge1xuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJhcnJheVwiKSwgKDAsIF91dGlscy5hc3NlcnRFYWNoKSgoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlJlc3RFbGVtZW50XCIsIFwiT2JqZWN0UHJvcGVydHlcIikpKVxuICAgIH1cbiAgfSlcbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlNwcmVhZEVsZW1lbnRcIiwge1xuICB2aXNpdG9yOiBbXCJhcmd1bWVudFwiXSxcbiAgYWxpYXNlczogW1wiVW5hcnlMaWtlXCJdLFxuICBkZXByZWNhdGVkQWxpYXM6IFwiU3ByZWFkUHJvcGVydHlcIixcbiAgZmllbGRzOiB7XG4gICAgYXJndW1lbnQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlN1cGVyXCIsIHtcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCIsIHtcbiAgdmlzaXRvcjogW1widGFnXCIsIFwicXVhc2lcIl0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczoge1xuICAgIHRhZzoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgcXVhc2k6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlRlbXBsYXRlTGl0ZXJhbFwiKVxuICAgIH0sXG4gICAgdHlwZVBhcmFtZXRlcnM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIsIFwiVFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUZW1wbGF0ZUVsZW1lbnRcIiwge1xuICBidWlsZGVyOiBbXCJ2YWx1ZVwiLCBcInRhaWxcIl0sXG4gIGZpZWxkczoge1xuICAgIHZhbHVlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRTaGFwZSkoe1xuICAgICAgICByYXc6IHtcbiAgICAgICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwic3RyaW5nXCIpXG4gICAgICAgIH0sXG4gICAgICAgIGNvb2tlZDoge1xuICAgICAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIiksXG4gICAgICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9LFxuICAgIHRhaWw6IHtcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUZW1wbGF0ZUxpdGVyYWxcIiwge1xuICB2aXNpdG9yOiBbXCJxdWFzaXNcIiwgXCJleHByZXNzaW9uc1wiXSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiLCBcIkxpdGVyYWxcIl0sXG4gIGZpZWxkczoge1xuICAgIHF1YXNpczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVGVtcGxhdGVFbGVtZW50XCIpKSlcbiAgICB9LFxuICAgIGV4cHJlc3Npb25zOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpKSwgZnVuY3Rpb24gKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgICAgIGlmIChub2RlLnF1YXNpcy5sZW5ndGggIT09IHZhbC5sZW5ndGggKyAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTnVtYmVyIG9mICR7bm9kZS50eXBlfSBxdWFzaXMgc2hvdWxkIGJlIGV4YWN0bHkgb25lIG1vcmUgdGhhbiB0aGUgbnVtYmVyIG9mIGV4cHJlc3Npb25zLlxcbkV4cGVjdGVkICR7dmFsLmxlbmd0aCArIDF9IHF1YXNpcyBidXQgZ290ICR7bm9kZS5xdWFzaXMubGVuZ3RofWApO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiWWllbGRFeHByZXNzaW9uXCIsIHtcbiAgYnVpbGRlcjogW1wiYXJndW1lbnRcIiwgXCJkZWxlZ2F0ZVwiXSxcbiAgdmlzaXRvcjogW1wiYXJndW1lbnRcIl0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIiwgXCJUZXJtaW5hdG9ybGVzc1wiXSxcbiAgZmllbGRzOiB7XG4gICAgZGVsZWdhdGU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpLCBPYmplY3QuYXNzaWduKGZ1bmN0aW9uIChub2RlLCBrZXksIHZhbCkge1xuICAgICAgICBpZiAoIXByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcpIHJldHVybjtcblxuICAgICAgICBpZiAodmFsICYmICFub2RlLmFyZ3VtZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByb3BlcnR5IGRlbGVnYXRlIG9mIFlpZWxkRXhwcmVzc2lvbiBjYW5ub3QgYmUgdHJ1ZSBpZiB0aGVyZSBpcyBubyBhcmd1bWVudFwiKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImJvb2xlYW5cIlxuICAgICAgfSkpLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGFyZ3VtZW50OiB7XG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkF3YWl0RXhwcmVzc2lvblwiLCB7XG4gIGJ1aWxkZXI6IFtcImFyZ3VtZW50XCJdLFxuICB2aXNpdG9yOiBbXCJhcmd1bWVudFwiXSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiLCBcIlRlcm1pbmF0b3JsZXNzXCJdLFxuICBmaWVsZHM6IHtcbiAgICBhcmd1bWVudDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiSW1wb3J0XCIsIHtcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiQmlnSW50TGl0ZXJhbFwiLCB7XG4gIGJ1aWxkZXI6IFtcInZhbHVlXCJdLFxuICBmaWVsZHM6IHtcbiAgICB2YWx1ZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKVxuICAgIH1cbiAgfSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiLCBcIlB1cmVpc2hcIiwgXCJMaXRlcmFsXCIsIFwiSW1tdXRhYmxlXCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIiwge1xuICB2aXNpdG9yOiBbXCJleHBvcnRlZFwiXSxcbiAgYWxpYXNlczogW1wiTW9kdWxlU3BlY2lmaWVyXCJdLFxuICBmaWVsZHM6IHtcbiAgICBleHBvcnRlZDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCIsIHtcbiAgYnVpbGRlcjogW1wib2JqZWN0XCIsIFwicHJvcGVydHlcIiwgXCJjb21wdXRlZFwiLCBcIm9wdGlvbmFsXCJdLFxuICB2aXNpdG9yOiBbXCJvYmplY3RcIiwgXCJwcm9wZXJ0eVwiXSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgb2JqZWN0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICBwcm9wZXJ0eToge1xuICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3Qgbm9ybWFsID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpO1xuICAgICAgICBjb25zdCBjb21wdXRlZCA9ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKTtcblxuICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSBmdW5jdGlvbiAobm9kZSwga2V5LCB2YWwpIHtcbiAgICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSBub2RlLmNvbXB1dGVkID8gY29tcHV0ZWQgOiBub3JtYWw7XG4gICAgICAgICAgdmFsaWRhdG9yKG5vZGUsIGtleSwgdmFsKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YWxpZGF0b3Iub25lT2ZOb2RlVHlwZXMgPSBbXCJFeHByZXNzaW9uXCIsIFwiSWRlbnRpZmllclwiXTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRvcjtcbiAgICAgIH0oKVxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBvcHRpb25hbDoge1xuICAgICAgdmFsaWRhdGU6ICFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HID8gKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSA6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksICgwLCBfdXRpbHMuYXNzZXJ0T3B0aW9uYWxDaGFpblN0YXJ0KSgpKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiLCB7XG4gIHZpc2l0b3I6IFtcImNhbGxlZVwiLCBcImFyZ3VtZW50c1wiLCBcInR5cGVQYXJhbWV0ZXJzXCIsIFwidHlwZUFyZ3VtZW50c1wiXSxcbiAgYnVpbGRlcjogW1wiY2FsbGVlXCIsIFwiYXJndW1lbnRzXCIsIFwib3B0aW9uYWxcIl0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczoge1xuICAgIGNhbGxlZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgYXJndW1lbnRzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIsIFwiU3ByZWFkRWxlbWVudFwiLCBcIkpTWE5hbWVzcGFjZWROYW1lXCIpKSlcbiAgICB9LFxuICAgIG9wdGlvbmFsOiB7XG4gICAgICB2YWxpZGF0ZTogIXByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcgPyAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpIDogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSwgKDAsIF91dGlscy5hc3NlcnRPcHRpb25hbENoYWluU3RhcnQpKCkpXG4gICAgfSxcbiAgICB0eXBlQXJndW1lbnRzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICB0eXBlUGFyYW1ldGVyczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9XG59KTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF91dGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3V0aWxzXCIpKTtcblxudmFyIF9jb3JlID0gcmVxdWlyZShcIi4vY29yZVwiKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IGRlZmF1bHQ6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJBcmd1bWVudFBsYWNlaG9sZGVyXCIsIHt9KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJCaW5kRXhwcmVzc2lvblwiLCB7XG4gIHZpc2l0b3I6IFtcIm9iamVjdFwiLCBcImNhbGxlZVwiXSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiXSxcbiAgZmllbGRzOiAhcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORyA/IHtcbiAgICBvYmplY3Q6IHtcbiAgICAgIHZhbGlkYXRlOiBPYmplY3QuYXNzaWduKCgpID0+IHt9LCB7XG4gICAgICAgIG9uZU9mTm9kZVR5cGVzOiBbXCJFeHByZXNzaW9uXCJdXG4gICAgICB9KVxuICAgIH0sXG4gICAgY2FsbGVlOiB7XG4gICAgICB2YWxpZGF0ZTogT2JqZWN0LmFzc2lnbigoKSA9PiB7fSwge1xuICAgICAgICBvbmVPZk5vZGVUeXBlczogW1wiRXhwcmVzc2lvblwiXVxuICAgICAgfSlcbiAgICB9XG4gIH0gOiB7XG4gICAgb2JqZWN0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICBjYWxsZWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkNsYXNzUHJvcGVydHlcIiwge1xuICB2aXNpdG9yOiBbXCJrZXlcIiwgXCJ2YWx1ZVwiLCBcInR5cGVBbm5vdGF0aW9uXCIsIFwiZGVjb3JhdG9yc1wiXSxcbiAgYnVpbGRlcjogW1wia2V5XCIsIFwidmFsdWVcIiwgXCJ0eXBlQW5ub3RhdGlvblwiLCBcImRlY29yYXRvcnNcIiwgXCJjb21wdXRlZFwiLCBcInN0YXRpY1wiXSxcbiAgYWxpYXNlczogW1wiUHJvcGVydHlcIl0sXG4gIGZpZWxkczogT2JqZWN0LmFzc2lnbih7fSwgX2NvcmUuY2xhc3NNZXRob2RPclByb3BlcnR5Q29tbW9uLCB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgZGVmaW5pdGU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIHR5cGVBbm5vdGF0aW9uOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJUeXBlQW5ub3RhdGlvblwiLCBcIlRTVHlwZUFubm90YXRpb25cIiwgXCJOb29wXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIGRlY29yYXRvcnM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJhcnJheVwiKSwgKDAsIF91dGlscy5hc3NlcnRFYWNoKSgoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkRlY29yYXRvclwiKSkpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIHJlYWRvbmx5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBkZWNsYXJlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9KVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiUGlwZWxpbmVUb3BpY0V4cHJlc3Npb25cIiwge1xuICBidWlsZGVyOiBbXCJleHByZXNzaW9uXCJdLFxuICB2aXNpdG9yOiBbXCJleHByZXNzaW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJQaXBlbGluZUJhcmVGdW5jdGlvblwiLCB7XG4gIGJ1aWxkZXI6IFtcImNhbGxlZVwiXSxcbiAgdmlzaXRvcjogW1wiY2FsbGVlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBjYWxsZWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlBpcGVsaW5lUHJpbWFyeVRvcGljUmVmZXJlbmNlXCIsIHtcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiQ2xhc3NQcml2YXRlUHJvcGVydHlcIiwge1xuICB2aXNpdG9yOiBbXCJrZXlcIiwgXCJ2YWx1ZVwiLCBcImRlY29yYXRvcnNcIl0sXG4gIGJ1aWxkZXI6IFtcImtleVwiLCBcInZhbHVlXCIsIFwiZGVjb3JhdG9yc1wiXSxcbiAgYWxpYXNlczogW1wiUHJvcGVydHlcIiwgXCJQcml2YXRlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBrZXk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlByaXZhdGVOYW1lXCIpXG4gICAgfSxcbiAgICB2YWx1ZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBkZWNvcmF0b3JzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJEZWNvcmF0b3JcIikpKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJDbGFzc1ByaXZhdGVNZXRob2RcIiwge1xuICBidWlsZGVyOiBbXCJraW5kXCIsIFwia2V5XCIsIFwicGFyYW1zXCIsIFwiYm9keVwiLCBcInN0YXRpY1wiXSxcbiAgdmlzaXRvcjogW1wia2V5XCIsIFwicGFyYW1zXCIsIFwiYm9keVwiLCBcImRlY29yYXRvcnNcIiwgXCJyZXR1cm5UeXBlXCIsIFwidHlwZVBhcmFtZXRlcnNcIl0sXG4gIGFsaWFzZXM6IFtcIkZ1bmN0aW9uXCIsIFwiU2NvcGFibGVcIiwgXCJCbG9ja1BhcmVudFwiLCBcIkZ1bmN0aW9uUGFyZW50XCIsIFwiTWV0aG9kXCIsIFwiUHJpdmF0ZVwiXSxcbiAgZmllbGRzOiBPYmplY3QuYXNzaWduKHt9LCBfY29yZS5jbGFzc01ldGhvZE9yRGVjbGFyZU1ldGhvZENvbW1vbiwgX2NvcmUuZnVuY3Rpb25UeXBlQW5ub3RhdGlvbkNvbW1vbiwge1xuICAgIGtleToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiUHJpdmF0ZU5hbWVcIilcbiAgICB9LFxuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkJsb2NrU3RhdGVtZW50XCIpXG4gICAgfVxuICB9KVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiSW1wb3J0QXR0cmlidXRlXCIsIHtcbiAgdmlzaXRvcjogW1wia2V5XCIsIFwidmFsdWVcIl0sXG4gIGZpZWxkczoge1xuICAgIGtleToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiKVxuICAgIH0sXG4gICAgdmFsdWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlN0cmluZ0xpdGVyYWxcIilcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkRlY29yYXRvclwiLCB7XG4gIHZpc2l0b3I6IFtcImV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczoge1xuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkRvRXhwcmVzc2lvblwiLCB7XG4gIHZpc2l0b3I6IFtcImJvZHlcIl0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczoge1xuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkJsb2NrU3RhdGVtZW50XCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJFeHBvcnREZWZhdWx0U3BlY2lmaWVyXCIsIHtcbiAgdmlzaXRvcjogW1wiZXhwb3J0ZWRcIl0sXG4gIGFsaWFzZXM6IFtcIk1vZHVsZVNwZWNpZmllclwiXSxcbiAgZmllbGRzOiB7XG4gICAgZXhwb3J0ZWQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIilcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlByaXZhdGVOYW1lXCIsIHtcbiAgdmlzaXRvcjogW1wiaWRcIl0sXG4gIGFsaWFzZXM6IFtcIlByaXZhdGVcIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJSZWNvcmRFeHByZXNzaW9uXCIsIHtcbiAgdmlzaXRvcjogW1wicHJvcGVydGllc1wiXSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgcHJvcGVydGllczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiT2JqZWN0UHJvcGVydHlcIiwgXCJTcHJlYWRFbGVtZW50XCIpKSlcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlR1cGxlRXhwcmVzc2lvblwiLCB7XG4gIGZpZWxkczoge1xuICAgIGVsZW1lbnRzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIsIFwiU3ByZWFkRWxlbWVudFwiKSkpLFxuICAgICAgZGVmYXVsdDogW11cbiAgICB9XG4gIH0sXG4gIHZpc2l0b3I6IFtcImVsZW1lbnRzXCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJEZWNpbWFsTGl0ZXJhbFwiLCB7XG4gIGJ1aWxkZXI6IFtcInZhbHVlXCJdLFxuICBmaWVsZHM6IHtcbiAgICB2YWx1ZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKVxuICAgIH1cbiAgfSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiLCBcIlB1cmVpc2hcIiwgXCJMaXRlcmFsXCIsIFwiSW1tdXRhYmxlXCJdXG59KTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF91dGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3V0aWxzXCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IGRlZmF1bHQ6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbmNvbnN0IGRlZmluZUludGVyZmFjZWlzaFR5cGUgPSAobmFtZSwgdHlwZVBhcmFtZXRlclR5cGUgPSBcIlR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiKSA9PiB7XG4gICgwLCBfdXRpbHMuZGVmYXVsdCkobmFtZSwge1xuICAgIGJ1aWxkZXI6IFtcImlkXCIsIFwidHlwZVBhcmFtZXRlcnNcIiwgXCJleHRlbmRzXCIsIFwiYm9keVwiXSxcbiAgICB2aXNpdG9yOiBbXCJpZFwiLCBcInR5cGVQYXJhbWV0ZXJzXCIsIFwiZXh0ZW5kc1wiLCBcIm1peGluc1wiLCBcImltcGxlbWVudHNcIiwgXCJib2R5XCJdLFxuICAgIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93RGVjbGFyYXRpb25cIiwgXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiXSxcbiAgICBmaWVsZHM6IHtcbiAgICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgICAgdHlwZVBhcmFtZXRlcnM6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKHR5cGVQYXJhbWV0ZXJUeXBlKSxcbiAgICAgIGV4dGVuZHM6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoKDAsIF91dGlscy5hcnJheU9mVHlwZSkoXCJJbnRlcmZhY2VFeHRlbmRzXCIpKSxcbiAgICAgIG1peGluczogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsKSgoMCwgX3V0aWxzLmFycmF5T2ZUeXBlKShcIkludGVyZmFjZUV4dGVuZHNcIikpLFxuICAgICAgaW1wbGVtZW50czogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsKSgoMCwgX3V0aWxzLmFycmF5T2ZUeXBlKShcIkNsYXNzSW1wbGVtZW50c1wiKSksXG4gICAgICBib2R5OiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJPYmplY3RUeXBlQW5ub3RhdGlvblwiKVxuICAgIH1cbiAgfSk7XG59O1xuXG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiQW55VHlwZUFubm90YXRpb25cIiwge1xuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiRmxvd1R5cGVcIiwgXCJGbG93QmFzZUFubm90YXRpb25cIl1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkFycmF5VHlwZUFubm90YXRpb25cIiwge1xuICB2aXNpdG9yOiBbXCJlbGVtZW50VHlwZVwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dUeXBlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBlbGVtZW50VHlwZTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiRmxvd1R5cGVcIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiQm9vbGVhblR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dUeXBlXCIsIFwiRmxvd0Jhc2VBbm5vdGF0aW9uXCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJCb29sZWFuTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgYnVpbGRlcjogW1widmFsdWVcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93VHlwZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdmFsdWU6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIikpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIk51bGxMaXRlcmFsVHlwZUFubm90YXRpb25cIiwge1xuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiRmxvd1R5cGVcIiwgXCJGbG93QmFzZUFubm90YXRpb25cIl1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkNsYXNzSW1wbGVtZW50c1wiLCB7XG4gIHZpc2l0b3I6IFtcImlkXCIsIFwidHlwZVBhcmFtZXRlcnNcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIHR5cGVQYXJhbWV0ZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpXG4gIH1cbn0pO1xuZGVmaW5lSW50ZXJmYWNlaXNoVHlwZShcIkRlY2xhcmVDbGFzc1wiKTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJEZWNsYXJlRnVuY3Rpb25cIiwge1xuICB2aXNpdG9yOiBbXCJpZFwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dEZWNsYXJhdGlvblwiLCBcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICBwcmVkaWNhdGU6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiRGVjbGFyZWRQcmVkaWNhdGVcIilcbiAgfVxufSk7XG5kZWZpbmVJbnRlcmZhY2Vpc2hUeXBlKFwiRGVjbGFyZUludGVyZmFjZVwiKTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJEZWNsYXJlTW9kdWxlXCIsIHtcbiAgYnVpbGRlcjogW1wiaWRcIiwgXCJib2R5XCIsIFwia2luZFwiXSxcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJib2R5XCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiRmxvd0RlY2xhcmF0aW9uXCIsIFwiU3RhdGVtZW50XCIsIFwiRGVjbGFyYXRpb25cIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoW1wiSWRlbnRpZmllclwiLCBcIlN0cmluZ0xpdGVyYWxcIl0pLFxuICAgIGJvZHk6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkJsb2NrU3RhdGVtZW50XCIpLFxuICAgIGtpbmQ6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoKDAsIF91dGlscy5hc3NlcnRPbmVPZikoXCJDb21tb25KU1wiLCBcIkVTXCIpKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJEZWNsYXJlTW9kdWxlRXhwb3J0c1wiLCB7XG4gIHZpc2l0b3I6IFtcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiRmxvd0RlY2xhcmF0aW9uXCIsIFwiU3RhdGVtZW50XCIsIFwiRGVjbGFyYXRpb25cIl0sXG4gIGZpZWxkczoge1xuICAgIHR5cGVBbm5vdGF0aW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJUeXBlQW5ub3RhdGlvblwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJEZWNsYXJlVHlwZUFsaWFzXCIsIHtcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiLCBcInJpZ2h0XCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiRmxvd0RlY2xhcmF0aW9uXCIsIFwiU3RhdGVtZW50XCIsIFwiRGVjbGFyYXRpb25cIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIHR5cGVQYXJhbWV0ZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiKSxcbiAgICByaWdodDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiRmxvd1R5cGVcIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRGVjbGFyZU9wYXF1ZVR5cGVcIiwge1xuICB2aXNpdG9yOiBbXCJpZFwiLCBcInR5cGVQYXJhbWV0ZXJzXCIsIFwic3VwZXJ0eXBlXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiRmxvd0RlY2xhcmF0aW9uXCIsIFwiU3RhdGVtZW50XCIsIFwiRGVjbGFyYXRpb25cIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIHR5cGVQYXJhbWV0ZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiKSxcbiAgICBzdXBlcnR5cGU6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiRmxvd1R5cGVcIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRGVjbGFyZVZhcmlhYmxlXCIsIHtcbiAgdmlzaXRvcjogW1wiaWRcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93RGVjbGFyYXRpb25cIiwgXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgaWQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIklkZW50aWZpZXJcIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1wiZGVjbGFyYXRpb25cIiwgXCJzcGVjaWZpZXJzXCIsIFwic291cmNlXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiRmxvd0RlY2xhcmF0aW9uXCIsIFwiU3RhdGVtZW50XCIsIFwiRGVjbGFyYXRpb25cIl0sXG4gIGZpZWxkczoge1xuICAgIGRlY2xhcmF0aW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIkZsb3dcIiksXG4gICAgc3BlY2lmaWVyczogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsKSgoMCwgX3V0aWxzLmFycmF5T2ZUeXBlKShbXCJFeHBvcnRTcGVjaWZpZXJcIiwgXCJFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIl0pKSxcbiAgICBzb3VyY2U6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiU3RyaW5nTGl0ZXJhbFwiKSxcbiAgICBkZWZhdWx0OiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIikpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkRlY2xhcmVFeHBvcnRBbGxEZWNsYXJhdGlvblwiLCB7XG4gIHZpc2l0b3I6IFtcInNvdXJjZVwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dEZWNsYXJhdGlvblwiLCBcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBzb3VyY2U6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlN0cmluZ0xpdGVyYWxcIiksXG4gICAgZXhwb3J0S2luZDogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsKSgoMCwgX3V0aWxzLmFzc2VydE9uZU9mKShcInR5cGVcIiwgXCJ2YWx1ZVwiKSlcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRGVjbGFyZWRQcmVkaWNhdGVcIiwge1xuICB2aXNpdG9yOiBbXCJ2YWx1ZVwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dQcmVkaWNhdGVcIl0sXG4gIGZpZWxkczoge1xuICAgIHZhbHVlOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJGbG93XCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkV4aXN0c1R5cGVBbm5vdGF0aW9uXCIsIHtcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dUeXBlXCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1widHlwZVBhcmFtZXRlcnNcIiwgXCJwYXJhbXNcIiwgXCJyZXN0XCIsIFwicmV0dXJuVHlwZVwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dUeXBlXCJdLFxuICBmaWVsZHM6IHtcbiAgICB0eXBlUGFyYW1ldGVyczogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiksXG4gICAgcGFyYW1zOiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFycmF5T2ZUeXBlKShcIkZ1bmN0aW9uVHlwZVBhcmFtXCIpKSxcbiAgICByZXN0OiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIkZ1bmN0aW9uVHlwZVBhcmFtXCIpLFxuICAgIHJldHVyblR5cGU6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkZsb3dUeXBlXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkZ1bmN0aW9uVHlwZVBhcmFtXCIsIHtcbiAgdmlzaXRvcjogW1wibmFtZVwiLCBcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCJdLFxuICBmaWVsZHM6IHtcbiAgICBuYW1lOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIklkZW50aWZpZXJcIiksXG4gICAgdHlwZUFubm90YXRpb246ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkZsb3dUeXBlXCIpLFxuICAgIG9wdGlvbmFsOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIikpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkdlbmVyaWNUeXBlQW5ub3RhdGlvblwiLCB7XG4gIHZpc2l0b3I6IFtcImlkXCIsIFwidHlwZVBhcmFtZXRlcnNcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93VHlwZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgaWQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShbXCJJZGVudGlmaWVyXCIsIFwiUXVhbGlmaWVkVHlwZUlkZW50aWZpZXJcIl0pLFxuICAgIHR5cGVQYXJhbWV0ZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkluZmVycmVkUHJlZGljYXRlXCIsIHtcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dQcmVkaWNhdGVcIl1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkludGVyZmFjZUV4dGVuZHNcIiwge1xuICB2aXNpdG9yOiBbXCJpZFwiLCBcInR5cGVQYXJhbWV0ZXJzXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFtcIklkZW50aWZpZXJcIiwgXCJRdWFsaWZpZWRUeXBlSWRlbnRpZmllclwiXSksXG4gICAgdHlwZVBhcmFtZXRlcnM6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIilcbiAgfVxufSk7XG5kZWZpbmVJbnRlcmZhY2Vpc2hUeXBlKFwiSW50ZXJmYWNlRGVjbGFyYXRpb25cIik7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiSW50ZXJmYWNlVHlwZUFubm90YXRpb25cIiwge1xuICB2aXNpdG9yOiBbXCJleHRlbmRzXCIsIFwiYm9keVwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dUeXBlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBleHRlbmRzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKCgwLCBfdXRpbHMuYXJyYXlPZlR5cGUpKFwiSW50ZXJmYWNlRXh0ZW5kc1wiKSksXG4gICAgYm9keTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiT2JqZWN0VHlwZUFubm90YXRpb25cIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiSW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb25cIiwge1xuICB2aXNpdG9yOiBbXCJ0eXBlc1wiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dUeXBlXCJdLFxuICBmaWVsZHM6IHtcbiAgICB0eXBlczogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hcnJheU9mVHlwZSkoXCJGbG93VHlwZVwiKSlcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiTWl4ZWRUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93VHlwZVwiLCBcIkZsb3dCYXNlQW5ub3RhdGlvblwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRW1wdHlUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93VHlwZVwiLCBcIkZsb3dCYXNlQW5ub3RhdGlvblwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiTnVsbGFibGVUeXBlQW5ub3RhdGlvblwiLCB7XG4gIHZpc2l0b3I6IFtcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiRmxvd1R5cGVcIl0sXG4gIGZpZWxkczoge1xuICAgIHR5cGVBbm5vdGF0aW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJGbG93VHlwZVwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJOdW1iZXJMaXRlcmFsVHlwZUFubm90YXRpb25cIiwge1xuICBidWlsZGVyOiBbXCJ2YWx1ZVwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dUeXBlXCJdLFxuICBmaWVsZHM6IHtcbiAgICB2YWx1ZTogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwibnVtYmVyXCIpKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJOdW1iZXJUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93VHlwZVwiLCBcIkZsb3dCYXNlQW5ub3RhdGlvblwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiT2JqZWN0VHlwZUFubm90YXRpb25cIiwge1xuICB2aXNpdG9yOiBbXCJwcm9wZXJ0aWVzXCIsIFwiaW5kZXhlcnNcIiwgXCJjYWxsUHJvcGVydGllc1wiLCBcImludGVybmFsU2xvdHNcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93VHlwZVwiXSxcbiAgYnVpbGRlcjogW1wicHJvcGVydGllc1wiLCBcImluZGV4ZXJzXCIsIFwiY2FsbFByb3BlcnRpZXNcIiwgXCJpbnRlcm5hbFNsb3RzXCIsIFwiZXhhY3RcIl0sXG4gIGZpZWxkczoge1xuICAgIHByb3BlcnRpZXM6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXJyYXlPZlR5cGUpKFtcIk9iamVjdFR5cGVQcm9wZXJ0eVwiLCBcIk9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eVwiXSkpLFxuICAgIGluZGV4ZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKCgwLCBfdXRpbHMuYXJyYXlPZlR5cGUpKFwiT2JqZWN0VHlwZUluZGV4ZXJcIikpLFxuICAgIGNhbGxQcm9wZXJ0aWVzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKCgwLCBfdXRpbHMuYXJyYXlPZlR5cGUpKFwiT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eVwiKSksXG4gICAgaW50ZXJuYWxTbG90czogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsKSgoMCwgX3V0aWxzLmFycmF5T2ZUeXBlKShcIk9iamVjdFR5cGVJbnRlcm5hbFNsb3RcIikpLFxuICAgIGV4YWN0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSxcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBpbmV4YWN0OiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIikpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIk9iamVjdFR5cGVJbnRlcm5hbFNsb3RcIiwge1xuICB2aXNpdG9yOiBbXCJpZFwiLCBcInZhbHVlXCIsIFwib3B0aW9uYWxcIiwgXCJzdGF0aWNcIiwgXCJtZXRob2RcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJVc2VyV2hpdGVzcGFjYWJsZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgaWQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIklkZW50aWZpZXJcIiksXG4gICAgdmFsdWU6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkZsb3dUeXBlXCIpLFxuICAgIG9wdGlvbmFsOiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpKSxcbiAgICBzdGF0aWM6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIikpLFxuICAgIG1ldGhvZDogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSlcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eVwiLCB7XG4gIHZpc2l0b3I6IFtcInZhbHVlXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiVXNlcldoaXRlc3BhY2FibGVcIl0sXG4gIGZpZWxkczoge1xuICAgIHZhbHVlOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJGbG93VHlwZVwiKSxcbiAgICBzdGF0aWM6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIikpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIk9iamVjdFR5cGVJbmRleGVyXCIsIHtcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJrZXlcIiwgXCJ2YWx1ZVwiLCBcInZhcmlhbmNlXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiVXNlcldoaXRlc3BhY2FibGVcIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIklkZW50aWZpZXJcIiksXG4gICAga2V5OiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJGbG93VHlwZVwiKSxcbiAgICB2YWx1ZTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiRmxvd1R5cGVcIiksXG4gICAgc3RhdGljOiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpKSxcbiAgICB2YXJpYW5jZTogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJWYXJpYW5jZVwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJPYmplY3RUeXBlUHJvcGVydHlcIiwge1xuICB2aXNpdG9yOiBbXCJrZXlcIiwgXCJ2YWx1ZVwiLCBcInZhcmlhbmNlXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiVXNlcldoaXRlc3BhY2FibGVcIl0sXG4gIGZpZWxkczoge1xuICAgIGtleTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFtcIklkZW50aWZpZXJcIiwgXCJTdHJpbmdMaXRlcmFsXCJdKSxcbiAgICB2YWx1ZTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiRmxvd1R5cGVcIiksXG4gICAga2luZDogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hc3NlcnRPbmVPZikoXCJpbml0XCIsIFwiZ2V0XCIsIFwic2V0XCIpKSxcbiAgICBzdGF0aWM6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIikpLFxuICAgIHByb3RvOiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpKSxcbiAgICBvcHRpb25hbDogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSksXG4gICAgdmFyaWFuY2U6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiVmFyaWFuY2VcIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiT2JqZWN0VHlwZVNwcmVhZFByb3BlcnR5XCIsIHtcbiAgdmlzaXRvcjogW1wiYXJndW1lbnRcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJVc2VyV2hpdGVzcGFjYWJsZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgYXJndW1lbnQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkZsb3dUeXBlXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIk9wYXF1ZVR5cGVcIiwge1xuICB2aXNpdG9yOiBbXCJpZFwiLCBcInR5cGVQYXJhbWV0ZXJzXCIsIFwic3VwZXJ0eXBlXCIsIFwiaW1wbHR5cGVcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93RGVjbGFyYXRpb25cIiwgXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgaWQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIklkZW50aWZpZXJcIiksXG4gICAgdHlwZVBhcmFtZXRlcnM6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIpLFxuICAgIHN1cGVydHlwZTogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJGbG93VHlwZVwiKSxcbiAgICBpbXBsdHlwZTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiRmxvd1R5cGVcIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiUXVhbGlmaWVkVHlwZUlkZW50aWZpZXJcIiwge1xuICB2aXNpdG9yOiBbXCJpZFwiLCBcInF1YWxpZmljYXRpb25cIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIHF1YWxpZmljYXRpb246ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShbXCJJZGVudGlmaWVyXCIsIFwiUXVhbGlmaWVkVHlwZUlkZW50aWZpZXJcIl0pXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlN0cmluZ0xpdGVyYWxUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGJ1aWxkZXI6IFtcInZhbHVlXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiRmxvd1R5cGVcIl0sXG4gIGZpZWxkczoge1xuICAgIHZhbHVlOiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIikpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlN0cmluZ1R5cGVBbm5vdGF0aW9uXCIsIHtcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dUeXBlXCIsIFwiRmxvd0Jhc2VBbm5vdGF0aW9uXCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJTeW1ib2xUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93VHlwZVwiLCBcIkZsb3dCYXNlQW5ub3RhdGlvblwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVGhpc1R5cGVBbm5vdGF0aW9uXCIsIHtcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dUeXBlXCIsIFwiRmxvd0Jhc2VBbm5vdGF0aW9uXCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUdXBsZVR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1widHlwZXNcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93VHlwZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdHlwZXM6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXJyYXlPZlR5cGUpKFwiRmxvd1R5cGVcIikpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlR5cGVvZlR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1wiYXJndW1lbnRcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93VHlwZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgYXJndW1lbnQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkZsb3dUeXBlXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlR5cGVBbGlhc1wiLCB7XG4gIHZpc2l0b3I6IFtcImlkXCIsIFwidHlwZVBhcmFtZXRlcnNcIiwgXCJyaWdodFwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dEZWNsYXJhdGlvblwiLCBcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICB0eXBlUGFyYW1ldGVyczogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiksXG4gICAgcmlnaHQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkZsb3dUeXBlXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgYWxpYXNlczogW1wiRmxvd1wiXSxcbiAgdmlzaXRvcjogW1widHlwZUFubm90YXRpb25cIl0sXG4gIGZpZWxkczoge1xuICAgIHR5cGVBbm5vdGF0aW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJGbG93VHlwZVwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUeXBlQ2FzdEV4cHJlc3Npb25cIiwge1xuICB2aXNpdG9yOiBbXCJleHByZXNzaW9uXCIsIFwidHlwZUFubm90YXRpb25cIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJFeHByZXNzaW9uV3JhcHBlclwiLCBcIkV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczoge1xuICAgIGV4cHJlc3Npb246ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkV4cHJlc3Npb25cIiksXG4gICAgdHlwZUFubm90YXRpb246ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlR5cGVBbm5vdGF0aW9uXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlR5cGVQYXJhbWV0ZXJcIiwge1xuICBhbGlhc2VzOiBbXCJGbG93XCJdLFxuICB2aXNpdG9yOiBbXCJib3VuZFwiLCBcImRlZmF1bHRcIiwgXCJ2YXJpYW5jZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgbmFtZTogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwic3RyaW5nXCIpKSxcbiAgICBib3VuZDogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUeXBlQW5ub3RhdGlvblwiKSxcbiAgICBkZWZhdWx0OiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIkZsb3dUeXBlXCIpLFxuICAgIHZhcmlhbmNlOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlZhcmlhbmNlXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIkZsb3dcIl0sXG4gIHZpc2l0b3I6IFtcInBhcmFtc1wiXSxcbiAgZmllbGRzOiB7XG4gICAgcGFyYW1zOiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFycmF5T2ZUeXBlKShcIlR5cGVQYXJhbWV0ZXJcIikpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIsIHtcbiAgYWxpYXNlczogW1wiRmxvd1wiXSxcbiAgdmlzaXRvcjogW1wicGFyYW1zXCJdLFxuICBmaWVsZHM6IHtcbiAgICBwYXJhbXM6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXJyYXlPZlR5cGUpKFwiRmxvd1R5cGVcIikpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlVuaW9uVHlwZUFubm90YXRpb25cIiwge1xuICB2aXNpdG9yOiBbXCJ0eXBlc1wiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dUeXBlXCJdLFxuICBmaWVsZHM6IHtcbiAgICB0eXBlczogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hcnJheU9mVHlwZSkoXCJGbG93VHlwZVwiKSlcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVmFyaWFuY2VcIiwge1xuICBhbGlhc2VzOiBbXCJGbG93XCJdLFxuICBidWlsZGVyOiBbXCJraW5kXCJdLFxuICBmaWVsZHM6IHtcbiAgICBraW5kOiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFzc2VydE9uZU9mKShcIm1pbnVzXCIsIFwicGx1c1wiKSlcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVm9pZFR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dUeXBlXCIsIFwiRmxvd0Jhc2VBbm5vdGF0aW9uXCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJFbnVtRGVjbGFyYXRpb25cIiwge1xuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiXSxcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJib2R5XCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICBib2R5OiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoW1wiRW51bUJvb2xlYW5Cb2R5XCIsIFwiRW51bU51bWJlckJvZHlcIiwgXCJFbnVtU3RyaW5nQm9keVwiLCBcIkVudW1TeW1ib2xCb2R5XCJdKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJFbnVtQm9vbGVhbkJvZHlcIiwge1xuICBhbGlhc2VzOiBbXCJFbnVtQm9keVwiXSxcbiAgdmlzaXRvcjogW1wibWVtYmVyc1wiXSxcbiAgZmllbGRzOiB7XG4gICAgZXhwbGljaXQ6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIikpLFxuICAgIG1lbWJlcnM6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJFbnVtQm9vbGVhbk1lbWJlclwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJFbnVtTnVtYmVyQm9keVwiLCB7XG4gIGFsaWFzZXM6IFtcIkVudW1Cb2R5XCJdLFxuICB2aXNpdG9yOiBbXCJtZW1iZXJzXCJdLFxuICBmaWVsZHM6IHtcbiAgICBleHBsaWNpdDogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSksXG4gICAgbWVtYmVyczogKDAsIF91dGlscy52YWxpZGF0ZUFycmF5T2ZUeXBlKShcIkVudW1OdW1iZXJNZW1iZXJcIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRW51bVN0cmluZ0JvZHlcIiwge1xuICBhbGlhc2VzOiBbXCJFbnVtQm9keVwiXSxcbiAgdmlzaXRvcjogW1wibWVtYmVyc1wiXSxcbiAgZmllbGRzOiB7XG4gICAgZXhwbGljaXQ6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIikpLFxuICAgIG1lbWJlcnM6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoW1wiRW51bVN0cmluZ01lbWJlclwiLCBcIkVudW1EZWZhdWx0ZWRNZW1iZXJcIl0pXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkVudW1TeW1ib2xCb2R5XCIsIHtcbiAgYWxpYXNlczogW1wiRW51bUJvZHlcIl0sXG4gIHZpc2l0b3I6IFtcIm1lbWJlcnNcIl0sXG4gIGZpZWxkczoge1xuICAgIG1lbWJlcnM6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJFbnVtRGVmYXVsdGVkTWVtYmVyXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkVudW1Cb29sZWFuTWVtYmVyXCIsIHtcbiAgYWxpYXNlczogW1wiRW51bU1lbWJlclwiXSxcbiAgdmlzaXRvcjogW1wiaWRcIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIGluaXQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkJvb2xlYW5MaXRlcmFsXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkVudW1OdW1iZXJNZW1iZXJcIiwge1xuICBhbGlhc2VzOiBbXCJFbnVtTWVtYmVyXCJdLFxuICB2aXNpdG9yOiBbXCJpZFwiLCBcImluaXRcIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIGluaXQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIk51bWVyaWNMaXRlcmFsXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkVudW1TdHJpbmdNZW1iZXJcIiwge1xuICBhbGlhc2VzOiBbXCJFbnVtTWVtYmVyXCJdLFxuICB2aXNpdG9yOiBbXCJpZFwiLCBcImluaXRcIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIGluaXQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlN0cmluZ0xpdGVyYWxcIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRW51bURlZmF1bHRlZE1lbWJlclwiLCB7XG4gIGFsaWFzZXM6IFtcIkVudW1NZW1iZXJcIl0sXG4gIHZpc2l0b3I6IFtcImlkXCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKVxuICB9XG59KTsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlZJU0lUT1JfS0VZU1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbHMuVklTSVRPUl9LRVlTO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFMSUFTX0tFWVNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWxzLkFMSUFTX0tFWVM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRkxJUFBFRF9BTElBU19LRVlTXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlscy5GTElQUEVEX0FMSUFTX0tFWVM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTk9ERV9GSUVMRFNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWxzLk5PREVfRklFTERTO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJVSUxERVJfS0VZU1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbHMuQlVJTERFUl9LRVlTO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRFUFJFQ0FURURfS0VZU1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbHMuREVQUkVDQVRFRF9LRVlTO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5PREVfUEFSRU5UX1ZBTElEQVRJT05TXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlscy5OT0RFX1BBUkVOVF9WQUxJREFUSU9OUztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQTEFDRUhPTERFUlNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3BsYWNlaG9sZGVycy5QTEFDRUhPTERFUlM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUExBQ0VIT0xERVJTX0FMSUFTXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9wbGFjZWhvbGRlcnMuUExBQ0VIT0xERVJTX0FMSUFTO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBMQUNFSE9MREVSU19GTElQUEVEX0FMSUFTXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9wbGFjZWhvbGRlcnMuUExBQ0VIT0xERVJTX0ZMSVBQRURfQUxJQVM7XG4gIH1cbn0pO1xuZXhwb3J0cy5UWVBFUyA9IHZvaWQgMDtcblxudmFyIF90b0Zhc3RQcm9wZXJ0aWVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwidG8tZmFzdC1wcm9wZXJ0aWVzXCIpKTtcblxucmVxdWlyZShcIi4vY29yZVwiKTtcblxucmVxdWlyZShcIi4vZmxvd1wiKTtcblxucmVxdWlyZShcIi4vanN4XCIpO1xuXG5yZXF1aXJlKFwiLi9taXNjXCIpO1xuXG5yZXF1aXJlKFwiLi9leHBlcmltZW50YWxcIik7XG5cbnJlcXVpcmUoXCIuL3R5cGVzY3JpcHRcIik7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcblxudmFyIF9wbGFjZWhvbGRlcnMgPSByZXF1aXJlKFwiLi9wbGFjZWhvbGRlcnNcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbigwLCBfdG9GYXN0UHJvcGVydGllcy5kZWZhdWx0KShfdXRpbHMuVklTSVRPUl9LRVlTKTtcbigwLCBfdG9GYXN0UHJvcGVydGllcy5kZWZhdWx0KShfdXRpbHMuQUxJQVNfS0VZUyk7XG4oMCwgX3RvRmFzdFByb3BlcnRpZXMuZGVmYXVsdCkoX3V0aWxzLkZMSVBQRURfQUxJQVNfS0VZUyk7XG4oMCwgX3RvRmFzdFByb3BlcnRpZXMuZGVmYXVsdCkoX3V0aWxzLk5PREVfRklFTERTKTtcbigwLCBfdG9GYXN0UHJvcGVydGllcy5kZWZhdWx0KShfdXRpbHMuQlVJTERFUl9LRVlTKTtcbigwLCBfdG9GYXN0UHJvcGVydGllcy5kZWZhdWx0KShfdXRpbHMuREVQUkVDQVRFRF9LRVlTKTtcbigwLCBfdG9GYXN0UHJvcGVydGllcy5kZWZhdWx0KShfcGxhY2Vob2xkZXJzLlBMQUNFSE9MREVSU19BTElBUyk7XG4oMCwgX3RvRmFzdFByb3BlcnRpZXMuZGVmYXVsdCkoX3BsYWNlaG9sZGVycy5QTEFDRUhPTERFUlNfRkxJUFBFRF9BTElBUyk7XG5jb25zdCBUWVBFUyA9IE9iamVjdC5rZXlzKF91dGlscy5WSVNJVE9SX0tFWVMpLmNvbmNhdChPYmplY3Qua2V5cyhfdXRpbHMuRkxJUFBFRF9BTElBU19LRVlTKSkuY29uY2F0KE9iamVjdC5rZXlzKF91dGlscy5ERVBSRUNBVEVEX0tFWVMpKTtcbmV4cG9ydHMuVFlQRVMgPSBUWVBFUzsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF91dGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3V0aWxzXCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IGRlZmF1bHQ6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJKU1hBdHRyaWJ1dGVcIiwge1xuICB2aXNpdG9yOiBbXCJuYW1lXCIsIFwidmFsdWVcIl0sXG4gIGFsaWFzZXM6IFtcIkpTWFwiLCBcIkltbXV0YWJsZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgbmFtZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSlNYSWRlbnRpZmllclwiLCBcIkpTWE5hbWVzcGFjZWROYW1lXCIpXG4gICAgfSxcbiAgICB2YWx1ZToge1xuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJKU1hFbGVtZW50XCIsIFwiSlNYRnJhZ21lbnRcIiwgXCJTdHJpbmdMaXRlcmFsXCIsIFwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiSlNYQ2xvc2luZ0VsZW1lbnRcIiwge1xuICB2aXNpdG9yOiBbXCJuYW1lXCJdLFxuICBhbGlhc2VzOiBbXCJKU1hcIiwgXCJJbW11dGFibGVcIl0sXG4gIGZpZWxkczoge1xuICAgIG5hbWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkpTWElkZW50aWZpZXJcIiwgXCJKU1hNZW1iZXJFeHByZXNzaW9uXCIsIFwiSlNYTmFtZXNwYWNlZE5hbWVcIilcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkpTWEVsZW1lbnRcIiwge1xuICBidWlsZGVyOiBbXCJvcGVuaW5nRWxlbWVudFwiLCBcImNsb3NpbmdFbGVtZW50XCIsIFwiY2hpbGRyZW5cIiwgXCJzZWxmQ2xvc2luZ1wiXSxcbiAgdmlzaXRvcjogW1wib3BlbmluZ0VsZW1lbnRcIiwgXCJjaGlsZHJlblwiLCBcImNsb3NpbmdFbGVtZW50XCJdLFxuICBhbGlhc2VzOiBbXCJKU1hcIiwgXCJJbW11dGFibGVcIiwgXCJFeHByZXNzaW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBvcGVuaW5nRWxlbWVudDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSlNYT3BlbmluZ0VsZW1lbnRcIilcbiAgICB9LFxuICAgIGNsb3NpbmdFbGVtZW50OiB7XG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkpTWENsb3NpbmdFbGVtZW50XCIpXG4gICAgfSxcbiAgICBjaGlsZHJlbjoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSlNYVGV4dFwiLCBcIkpTWEV4cHJlc3Npb25Db250YWluZXJcIiwgXCJKU1hTcHJlYWRDaGlsZFwiLCBcIkpTWEVsZW1lbnRcIiwgXCJKU1hGcmFnbWVudFwiKSkpXG4gICAgfSxcbiAgICBzZWxmQ2xvc2luZzoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiSlNYRW1wdHlFeHByZXNzaW9uXCIsIHtcbiAgYWxpYXNlczogW1wiSlNYXCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJKU1hFeHByZXNzaW9uQ29udGFpbmVyXCIsIHtcbiAgdmlzaXRvcjogW1wiZXhwcmVzc2lvblwiXSxcbiAgYWxpYXNlczogW1wiSlNYXCIsIFwiSW1tdXRhYmxlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIsIFwiSlNYRW1wdHlFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJKU1hTcHJlYWRDaGlsZFwiLCB7XG4gIHZpc2l0b3I6IFtcImV4cHJlc3Npb25cIl0sXG4gIGFsaWFzZXM6IFtcIkpTWFwiLCBcIkltbXV0YWJsZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiSlNYSWRlbnRpZmllclwiLCB7XG4gIGJ1aWxkZXI6IFtcIm5hbWVcIl0sXG4gIGFsaWFzZXM6IFtcIkpTWFwiXSxcbiAgZmllbGRzOiB7XG4gICAgbmFtZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiSlNYTWVtYmVyRXhwcmVzc2lvblwiLCB7XG4gIHZpc2l0b3I6IFtcIm9iamVjdFwiLCBcInByb3BlcnR5XCJdLFxuICBhbGlhc2VzOiBbXCJKU1hcIl0sXG4gIGZpZWxkczoge1xuICAgIG9iamVjdDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSlNYTWVtYmVyRXhwcmVzc2lvblwiLCBcIkpTWElkZW50aWZpZXJcIilcbiAgICB9LFxuICAgIHByb3BlcnR5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJKU1hJZGVudGlmaWVyXCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJKU1hOYW1lc3BhY2VkTmFtZVwiLCB7XG4gIHZpc2l0b3I6IFtcIm5hbWVzcGFjZVwiLCBcIm5hbWVcIl0sXG4gIGFsaWFzZXM6IFtcIkpTWFwiXSxcbiAgZmllbGRzOiB7XG4gICAgbmFtZXNwYWNlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJKU1hJZGVudGlmaWVyXCIpXG4gICAgfSxcbiAgICBuYW1lOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJKU1hJZGVudGlmaWVyXCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJKU1hPcGVuaW5nRWxlbWVudFwiLCB7XG4gIGJ1aWxkZXI6IFtcIm5hbWVcIiwgXCJhdHRyaWJ1dGVzXCIsIFwic2VsZkNsb3NpbmdcIl0sXG4gIHZpc2l0b3I6IFtcIm5hbWVcIiwgXCJhdHRyaWJ1dGVzXCJdLFxuICBhbGlhc2VzOiBbXCJKU1hcIiwgXCJJbW11dGFibGVcIl0sXG4gIGZpZWxkczoge1xuICAgIG5hbWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkpTWElkZW50aWZpZXJcIiwgXCJKU1hNZW1iZXJFeHByZXNzaW9uXCIsIFwiSlNYTmFtZXNwYWNlZE5hbWVcIilcbiAgICB9LFxuICAgIHNlbGZDbG9zaW5nOiB7XG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgYXR0cmlidXRlczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSlNYQXR0cmlidXRlXCIsIFwiSlNYU3ByZWFkQXR0cmlidXRlXCIpKSlcbiAgICB9LFxuICAgIHR5cGVQYXJhbWV0ZXJzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiLCBcIlRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiSlNYU3ByZWFkQXR0cmlidXRlXCIsIHtcbiAgdmlzaXRvcjogW1wiYXJndW1lbnRcIl0sXG4gIGFsaWFzZXM6IFtcIkpTWFwiXSxcbiAgZmllbGRzOiB7XG4gICAgYXJndW1lbnQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkpTWFRleHRcIiwge1xuICBhbGlhc2VzOiBbXCJKU1hcIiwgXCJJbW11dGFibGVcIl0sXG4gIGJ1aWxkZXI6IFtcInZhbHVlXCJdLFxuICBmaWVsZHM6IHtcbiAgICB2YWx1ZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiSlNYRnJhZ21lbnRcIiwge1xuICBidWlsZGVyOiBbXCJvcGVuaW5nRnJhZ21lbnRcIiwgXCJjbG9zaW5nRnJhZ21lbnRcIiwgXCJjaGlsZHJlblwiXSxcbiAgdmlzaXRvcjogW1wib3BlbmluZ0ZyYWdtZW50XCIsIFwiY2hpbGRyZW5cIiwgXCJjbG9zaW5nRnJhZ21lbnRcIl0sXG4gIGFsaWFzZXM6IFtcIkpTWFwiLCBcIkltbXV0YWJsZVwiLCBcIkV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczoge1xuICAgIG9wZW5pbmdGcmFnbWVudDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSlNYT3BlbmluZ0ZyYWdtZW50XCIpXG4gICAgfSxcbiAgICBjbG9zaW5nRnJhZ21lbnQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkpTWENsb3NpbmdGcmFnbWVudFwiKVxuICAgIH0sXG4gICAgY2hpbGRyZW46IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJhcnJheVwiKSwgKDAsIF91dGlscy5hc3NlcnRFYWNoKSgoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkpTWFRleHRcIiwgXCJKU1hFeHByZXNzaW9uQ29udGFpbmVyXCIsIFwiSlNYU3ByZWFkQ2hpbGRcIiwgXCJKU1hFbGVtZW50XCIsIFwiSlNYRnJhZ21lbnRcIikpKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiSlNYT3BlbmluZ0ZyYWdtZW50XCIsIHtcbiAgYWxpYXNlczogW1wiSlNYXCIsIFwiSW1tdXRhYmxlXCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJKU1hDbG9zaW5nRnJhZ21lbnRcIiwge1xuICBhbGlhc2VzOiBbXCJKU1hcIiwgXCJJbW11dGFibGVcIl1cbn0pOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX3V0aWxzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vdXRpbHNcIikpO1xuXG52YXIgX3BsYWNlaG9sZGVycyA9IHJlcXVpcmUoXCIuL3BsYWNlaG9sZGVyc1wiKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IGRlZmF1bHQ6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJOb29wXCIsIHtcbiAgdmlzaXRvcjogW11cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlBsYWNlaG9sZGVyXCIsIHtcbiAgdmlzaXRvcjogW10sXG4gIGJ1aWxkZXI6IFtcImV4cGVjdGVkTm9kZVwiLCBcIm5hbWVcIl0sXG4gIGZpZWxkczoge1xuICAgIG5hbWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIilcbiAgICB9LFxuICAgIGV4cGVjdGVkTm9kZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKC4uLl9wbGFjZWhvbGRlcnMuUExBQ0VIT0xERVJTKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVjhJbnRyaW5zaWNJZGVudGlmaWVyXCIsIHtcbiAgYnVpbGRlcjogW1wibmFtZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgbmFtZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKVxuICAgIH1cbiAgfVxufSk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlBMQUNFSE9MREVSU19GTElQUEVEX0FMSUFTID0gZXhwb3J0cy5QTEFDRUhPTERFUlNfQUxJQVMgPSBleHBvcnRzLlBMQUNFSE9MREVSUyA9IHZvaWQgMDtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuXG5jb25zdCBQTEFDRUhPTERFUlMgPSBbXCJJZGVudGlmaWVyXCIsIFwiU3RyaW5nTGl0ZXJhbFwiLCBcIkV4cHJlc3Npb25cIiwgXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiLCBcIkJsb2NrU3RhdGVtZW50XCIsIFwiQ2xhc3NCb2R5XCIsIFwiUGF0dGVyblwiXTtcbmV4cG9ydHMuUExBQ0VIT0xERVJTID0gUExBQ0VIT0xERVJTO1xuY29uc3QgUExBQ0VIT0xERVJTX0FMSUFTID0ge1xuICBEZWNsYXJhdGlvbjogW1wiU3RhdGVtZW50XCJdLFxuICBQYXR0ZXJuOiBbXCJQYXR0ZXJuTGlrZVwiLCBcIkxWYWxcIl1cbn07XG5leHBvcnRzLlBMQUNFSE9MREVSU19BTElBUyA9IFBMQUNFSE9MREVSU19BTElBUztcblxuZm9yIChjb25zdCB0eXBlIG9mIFBMQUNFSE9MREVSUykge1xuICBjb25zdCBhbGlhcyA9IF91dGlscy5BTElBU19LRVlTW3R5cGVdO1xuICBpZiAoYWxpYXMgPT0gbnVsbCA/IHZvaWQgMCA6IGFsaWFzLmxlbmd0aCkgUExBQ0VIT0xERVJTX0FMSUFTW3R5cGVdID0gYWxpYXM7XG59XG5cbmNvbnN0IFBMQUNFSE9MREVSU19GTElQUEVEX0FMSUFTID0ge307XG5leHBvcnRzLlBMQUNFSE9MREVSU19GTElQUEVEX0FMSUFTID0gUExBQ0VIT0xERVJTX0ZMSVBQRURfQUxJQVM7XG5PYmplY3Qua2V5cyhQTEFDRUhPTERFUlNfQUxJQVMpLmZvckVhY2godHlwZSA9PiB7XG4gIFBMQUNFSE9MREVSU19BTElBU1t0eXBlXS5mb3JFYWNoKGFsaWFzID0+IHtcbiAgICBpZiAoIU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKFBMQUNFSE9MREVSU19GTElQUEVEX0FMSUFTLCBhbGlhcykpIHtcbiAgICAgIFBMQUNFSE9MREVSU19GTElQUEVEX0FMSUFTW2FsaWFzXSA9IFtdO1xuICAgIH1cblxuICAgIFBMQUNFSE9MREVSU19GTElQUEVEX0FMSUFTW2FsaWFzXS5wdXNoKHR5cGUpO1xuICB9KTtcbn0pOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX3V0aWxzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vdXRpbHNcIikpO1xuXG52YXIgX2NvcmUgPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTsgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FjaGU7IH07IHJldHVybiBjYWNoZTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgZGVmYXVsdDogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuY29uc3QgYm9vbCA9ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIik7XG5jb25zdCB0U0Z1bmN0aW9uVHlwZUFubm90YXRpb25Db21tb24gPSB7XG4gIHJldHVyblR5cGU6IHtcbiAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJUU1R5cGVBbm5vdGF0aW9uXCIsIFwiTm9vcFwiKSxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9LFxuICB0eXBlUGFyYW1ldGVyczoge1xuICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlRTVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIsIFwiTm9vcFwiKSxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9XG59O1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTUGFyYW1ldGVyUHJvcGVydHlcIiwge1xuICBhbGlhc2VzOiBbXCJMVmFsXCJdLFxuICB2aXNpdG9yOiBbXCJwYXJhbWV0ZXJcIl0sXG4gIGZpZWxkczoge1xuICAgIGFjY2Vzc2liaWxpdHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE9uZU9mKShcInB1YmxpY1wiLCBcInByaXZhdGVcIiwgXCJwcm90ZWN0ZWRcIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgcmVhZG9ubHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIHBhcmFtZXRlcjoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiLCBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU0RlY2xhcmVGdW5jdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICB2aXNpdG9yOiBbXCJpZFwiLCBcInR5cGVQYXJhbWV0ZXJzXCIsIFwicGFyYW1zXCIsIFwicmV0dXJuVHlwZVwiXSxcbiAgZmllbGRzOiBPYmplY3QuYXNzaWduKHt9LCBfY29yZS5mdW5jdGlvbkRlY2xhcmF0aW9uQ29tbW9uLCB0U0Z1bmN0aW9uVHlwZUFubm90YXRpb25Db21tb24pXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU0RlY2xhcmVNZXRob2RcIiwge1xuICB2aXNpdG9yOiBbXCJkZWNvcmF0b3JzXCIsIFwia2V5XCIsIFwidHlwZVBhcmFtZXRlcnNcIiwgXCJwYXJhbXNcIiwgXCJyZXR1cm5UeXBlXCJdLFxuICBmaWVsZHM6IE9iamVjdC5hc3NpZ24oe30sIF9jb3JlLmNsYXNzTWV0aG9kT3JEZWNsYXJlTWV0aG9kQ29tbW9uLCB0U0Z1bmN0aW9uVHlwZUFubm90YXRpb25Db21tb24pXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU1F1YWxpZmllZE5hbWVcIiwge1xuICBhbGlhc2VzOiBbXCJUU0VudGl0eU5hbWVcIl0sXG4gIHZpc2l0b3I6IFtcImxlZnRcIiwgXCJyaWdodFwiXSxcbiAgZmllbGRzOiB7XG4gICAgbGVmdDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVFNFbnRpdHlOYW1lXCIpLFxuICAgIHJpZ2h0OiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpXG4gIH1cbn0pO1xuY29uc3Qgc2lnbmF0dXJlRGVjbGFyYXRpb25Db21tb24gPSB7XG4gIHR5cGVQYXJhbWV0ZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlRTVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIpLFxuICBwYXJhbWV0ZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlQXJyYXlPZlR5cGUpKFtcIklkZW50aWZpZXJcIiwgXCJSZXN0RWxlbWVudFwiXSksXG4gIHR5cGVBbm5vdGF0aW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlRTVHlwZUFubm90YXRpb25cIilcbn07XG5jb25zdCBjYWxsQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb24gPSB7XG4gIGFsaWFzZXM6IFtcIlRTVHlwZUVsZW1lbnRcIl0sXG4gIHZpc2l0b3I6IFtcInR5cGVQYXJhbWV0ZXJzXCIsIFwicGFyYW1ldGVyc1wiLCBcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBmaWVsZHM6IHNpZ25hdHVyZURlY2xhcmF0aW9uQ29tbW9uXG59O1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTQ2FsbFNpZ25hdHVyZURlY2xhcmF0aW9uXCIsIGNhbGxDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvbik7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvblwiLCBjYWxsQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb24pO1xuY29uc3QgbmFtZWRUeXBlRWxlbWVudENvbW1vbiA9IHtcbiAga2V5OiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJFeHByZXNzaW9uXCIpLFxuICBjb21wdXRlZDogKDAsIF91dGlscy52YWxpZGF0ZSkoYm9vbCksXG4gIG9wdGlvbmFsOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKGJvb2wpXG59O1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTUHJvcGVydHlTaWduYXR1cmVcIiwge1xuICBhbGlhc2VzOiBbXCJUU1R5cGVFbGVtZW50XCJdLFxuICB2aXNpdG9yOiBbXCJrZXlcIiwgXCJ0eXBlQW5ub3RhdGlvblwiLCBcImluaXRpYWxpemVyXCJdLFxuICBmaWVsZHM6IE9iamVjdC5hc3NpZ24oe30sIG5hbWVkVHlwZUVsZW1lbnRDb21tb24sIHtcbiAgICByZWFkb25seTogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsKShib29sKSxcbiAgICB0eXBlQW5ub3RhdGlvbjogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUU1R5cGVBbm5vdGF0aW9uXCIpLFxuICAgIGluaXRpYWxpemVyOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgfSlcbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTTWV0aG9kU2lnbmF0dXJlXCIsIHtcbiAgYWxpYXNlczogW1wiVFNUeXBlRWxlbWVudFwiXSxcbiAgdmlzaXRvcjogW1wia2V5XCIsIFwidHlwZVBhcmFtZXRlcnNcIiwgXCJwYXJhbWV0ZXJzXCIsIFwidHlwZUFubm90YXRpb25cIl0sXG4gIGZpZWxkczogT2JqZWN0LmFzc2lnbih7fSwgc2lnbmF0dXJlRGVjbGFyYXRpb25Db21tb24sIG5hbWVkVHlwZUVsZW1lbnRDb21tb24pXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU0luZGV4U2lnbmF0dXJlXCIsIHtcbiAgYWxpYXNlczogW1wiVFNUeXBlRWxlbWVudFwiXSxcbiAgdmlzaXRvcjogW1wicGFyYW1ldGVyc1wiLCBcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICByZWFkb25seTogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsKShib29sKSxcbiAgICBwYXJhbWV0ZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlQXJyYXlPZlR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICB0eXBlQW5ub3RhdGlvbjogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUU1R5cGVBbm5vdGF0aW9uXCIpXG4gIH1cbn0pO1xuY29uc3QgdHNLZXl3b3JkVHlwZXMgPSBbXCJUU0FueUtleXdvcmRcIiwgXCJUU0Jvb2xlYW5LZXl3b3JkXCIsIFwiVFNCaWdJbnRLZXl3b3JkXCIsIFwiVFNOZXZlcktleXdvcmRcIiwgXCJUU051bGxLZXl3b3JkXCIsIFwiVFNOdW1iZXJLZXl3b3JkXCIsIFwiVFNPYmplY3RLZXl3b3JkXCIsIFwiVFNTdHJpbmdLZXl3b3JkXCIsIFwiVFNTeW1ib2xLZXl3b3JkXCIsIFwiVFNVbmRlZmluZWRLZXl3b3JkXCIsIFwiVFNVbmtub3duS2V5d29yZFwiLCBcIlRTVm9pZEtleXdvcmRcIl07XG5cbmZvciAoY29uc3QgdHlwZSBvZiB0c0tleXdvcmRUeXBlcykge1xuICAoMCwgX3V0aWxzLmRlZmF1bHQpKHR5cGUsIHtcbiAgICBhbGlhc2VzOiBbXCJUU1R5cGVcIiwgXCJUU0Jhc2VUeXBlXCJdLFxuICAgIHZpc2l0b3I6IFtdLFxuICAgIGZpZWxkczoge31cbiAgfSk7XG59XG5cbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU1RoaXNUeXBlXCIsIHtcbiAgYWxpYXNlczogW1wiVFNUeXBlXCIsIFwiVFNCYXNlVHlwZVwiXSxcbiAgdmlzaXRvcjogW10sXG4gIGZpZWxkczoge31cbn0pO1xuY29uc3QgZm5PckN0ciA9IHtcbiAgYWxpYXNlczogW1wiVFNUeXBlXCJdLFxuICB2aXNpdG9yOiBbXCJ0eXBlUGFyYW1ldGVyc1wiLCBcInBhcmFtZXRlcnNcIiwgXCJ0eXBlQW5ub3RhdGlvblwiXSxcbiAgZmllbGRzOiBzaWduYXR1cmVEZWNsYXJhdGlvbkNvbW1vblxufTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU0Z1bmN0aW9uVHlwZVwiLCBmbk9yQ3RyKTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU0NvbnN0cnVjdG9yVHlwZVwiLCBmbk9yQ3RyKTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU1R5cGVSZWZlcmVuY2VcIiwge1xuICBhbGlhc2VzOiBbXCJUU1R5cGVcIl0sXG4gIHZpc2l0b3I6IFtcInR5cGVOYW1lXCIsIFwidHlwZVBhcmFtZXRlcnNcIl0sXG4gIGZpZWxkczoge1xuICAgIHR5cGVOYW1lOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJUU0VudGl0eU5hbWVcIiksXG4gICAgdHlwZVBhcmFtZXRlcnM6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiVFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU1R5cGVQcmVkaWNhdGVcIiwge1xuICBhbGlhc2VzOiBbXCJUU1R5cGVcIl0sXG4gIHZpc2l0b3I6IFtcInBhcmFtZXRlck5hbWVcIiwgXCJ0eXBlQW5ub3RhdGlvblwiXSxcbiAgYnVpbGRlcjogW1wicGFyYW1ldGVyTmFtZVwiLCBcInR5cGVBbm5vdGF0aW9uXCIsIFwiYXNzZXJ0c1wiXSxcbiAgZmllbGRzOiB7XG4gICAgcGFyYW1ldGVyTmFtZTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFtcIklkZW50aWZpZXJcIiwgXCJUU1RoaXNUeXBlXCJdKSxcbiAgICB0eXBlQW5ub3RhdGlvbjogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUU1R5cGVBbm5vdGF0aW9uXCIpLFxuICAgIGFzc2VydHM6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoYm9vbClcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNUeXBlUXVlcnlcIiwge1xuICBhbGlhc2VzOiBbXCJUU1R5cGVcIl0sXG4gIHZpc2l0b3I6IFtcImV4cHJOYW1lXCJdLFxuICBmaWVsZHM6IHtcbiAgICBleHByTmFtZTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFtcIlRTRW50aXR5TmFtZVwiLCBcIlRTSW1wb3J0VHlwZVwiXSlcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNUeXBlTGl0ZXJhbFwiLCB7XG4gIGFsaWFzZXM6IFtcIlRTVHlwZVwiXSxcbiAgdmlzaXRvcjogW1wibWVtYmVyc1wiXSxcbiAgZmllbGRzOiB7XG4gICAgbWVtYmVyczogKDAsIF91dGlscy52YWxpZGF0ZUFycmF5T2ZUeXBlKShcIlRTVHlwZUVsZW1lbnRcIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNBcnJheVR5cGVcIiwge1xuICBhbGlhc2VzOiBbXCJUU1R5cGVcIl0sXG4gIHZpc2l0b3I6IFtcImVsZW1lbnRUeXBlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBlbGVtZW50VHlwZTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVFNUeXBlXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTVHVwbGVUeXBlXCIsIHtcbiAgYWxpYXNlczogW1wiVFNUeXBlXCJdLFxuICB2aXNpdG9yOiBbXCJlbGVtZW50VHlwZXNcIl0sXG4gIGZpZWxkczoge1xuICAgIGVsZW1lbnRUeXBlczogKDAsIF91dGlscy52YWxpZGF0ZUFycmF5T2ZUeXBlKShbXCJUU1R5cGVcIiwgXCJUU05hbWVkVHVwbGVNZW1iZXJcIl0pXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTT3B0aW9uYWxUeXBlXCIsIHtcbiAgYWxpYXNlczogW1wiVFNUeXBlXCJdLFxuICB2aXNpdG9yOiBbXCJ0eXBlQW5ub3RhdGlvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgdHlwZUFubm90YXRpb246ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlRTVHlwZVwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU1Jlc3RUeXBlXCIsIHtcbiAgYWxpYXNlczogW1wiVFNUeXBlXCJdLFxuICB2aXNpdG9yOiBbXCJ0eXBlQW5ub3RhdGlvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgdHlwZUFubm90YXRpb246ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlRTVHlwZVwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU05hbWVkVHVwbGVNZW1iZXJcIiwge1xuICB2aXNpdG9yOiBbXCJsYWJlbFwiLCBcImVsZW1lbnRUeXBlXCJdLFxuICBidWlsZGVyOiBbXCJsYWJlbFwiLCBcImVsZW1lbnRUeXBlXCIsIFwib3B0aW9uYWxcIl0sXG4gIGZpZWxkczoge1xuICAgIGxhYmVsOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIG9wdGlvbmFsOiB7XG4gICAgICB2YWxpZGF0ZTogYm9vbCxcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBlbGVtZW50VHlwZTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVFNUeXBlXCIpXG4gIH1cbn0pO1xuY29uc3QgdW5pb25PckludGVyc2VjdGlvbiA9IHtcbiAgYWxpYXNlczogW1wiVFNUeXBlXCJdLFxuICB2aXNpdG9yOiBbXCJ0eXBlc1wiXSxcbiAgZmllbGRzOiB7XG4gICAgdHlwZXM6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJUU1R5cGVcIilcbiAgfVxufTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU1VuaW9uVHlwZVwiLCB1bmlvbk9ySW50ZXJzZWN0aW9uKTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU0ludGVyc2VjdGlvblR5cGVcIiwgdW5pb25PckludGVyc2VjdGlvbik7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNDb25kaXRpb25hbFR5cGVcIiwge1xuICBhbGlhc2VzOiBbXCJUU1R5cGVcIl0sXG4gIHZpc2l0b3I6IFtcImNoZWNrVHlwZVwiLCBcImV4dGVuZHNUeXBlXCIsIFwidHJ1ZVR5cGVcIiwgXCJmYWxzZVR5cGVcIl0sXG4gIGZpZWxkczoge1xuICAgIGNoZWNrVHlwZTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVFNUeXBlXCIpLFxuICAgIGV4dGVuZHNUeXBlOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJUU1R5cGVcIiksXG4gICAgdHJ1ZVR5cGU6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlRTVHlwZVwiKSxcbiAgICBmYWxzZVR5cGU6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlRTVHlwZVwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU0luZmVyVHlwZVwiLCB7XG4gIGFsaWFzZXM6IFtcIlRTVHlwZVwiXSxcbiAgdmlzaXRvcjogW1widHlwZVBhcmFtZXRlclwiXSxcbiAgZmllbGRzOiB7XG4gICAgdHlwZVBhcmFtZXRlcjogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVFNUeXBlUGFyYW1ldGVyXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTUGFyZW50aGVzaXplZFR5cGVcIiwge1xuICBhbGlhc2VzOiBbXCJUU1R5cGVcIl0sXG4gIHZpc2l0b3I6IFtcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICB0eXBlQW5ub3RhdGlvbjogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVFNUeXBlXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTVHlwZU9wZXJhdG9yXCIsIHtcbiAgYWxpYXNlczogW1wiVFNUeXBlXCJdLFxuICB2aXNpdG9yOiBbXCJ0eXBlQW5ub3RhdGlvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgb3BlcmF0b3I6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKSksXG4gICAgdHlwZUFubm90YXRpb246ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlRTVHlwZVwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU0luZGV4ZWRBY2Nlc3NUeXBlXCIsIHtcbiAgYWxpYXNlczogW1wiVFNUeXBlXCJdLFxuICB2aXNpdG9yOiBbXCJvYmplY3RUeXBlXCIsIFwiaW5kZXhUeXBlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBvYmplY3RUeXBlOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJUU1R5cGVcIiksXG4gICAgaW5kZXhUeXBlOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJUU1R5cGVcIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNNYXBwZWRUeXBlXCIsIHtcbiAgYWxpYXNlczogW1wiVFNUeXBlXCJdLFxuICB2aXNpdG9yOiBbXCJ0eXBlUGFyYW1ldGVyXCIsIFwidHlwZUFubm90YXRpb25cIl0sXG4gIGZpZWxkczoge1xuICAgIHJlYWRvbmx5OiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKGJvb2wpLFxuICAgIHR5cGVQYXJhbWV0ZXI6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlRTVHlwZVBhcmFtZXRlclwiKSxcbiAgICBvcHRpb25hbDogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsKShib29sKSxcbiAgICB0eXBlQW5ub3RhdGlvbjogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUU1R5cGVcIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNMaXRlcmFsVHlwZVwiLCB7XG4gIGFsaWFzZXM6IFtcIlRTVHlwZVwiLCBcIlRTQmFzZVR5cGVcIl0sXG4gIHZpc2l0b3I6IFtcImxpdGVyYWxcIl0sXG4gIGZpZWxkczoge1xuICAgIGxpdGVyYWw6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShbXCJOdW1lcmljTGl0ZXJhbFwiLCBcIlN0cmluZ0xpdGVyYWxcIiwgXCJCb29sZWFuTGl0ZXJhbFwiLCBcIkJpZ0ludExpdGVyYWxcIl0pXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzXCIsIHtcbiAgYWxpYXNlczogW1wiVFNUeXBlXCJdLFxuICB2aXNpdG9yOiBbXCJleHByZXNzaW9uXCIsIFwidHlwZVBhcmFtZXRlcnNcIl0sXG4gIGZpZWxkczoge1xuICAgIGV4cHJlc3Npb246ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlRTRW50aXR5TmFtZVwiKSxcbiAgICB0eXBlUGFyYW1ldGVyczogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTSW50ZXJmYWNlRGVjbGFyYXRpb25cIiwge1xuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiXSxcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiLCBcImV4dGVuZHNcIiwgXCJib2R5XCJdLFxuICBmaWVsZHM6IHtcbiAgICBkZWNsYXJlOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKGJvb2wpLFxuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIHR5cGVQYXJhbWV0ZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlRTVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIpLFxuICAgIGV4dGVuZHM6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoKDAsIF91dGlscy5hcnJheU9mVHlwZSkoXCJUU0V4cHJlc3Npb25XaXRoVHlwZUFyZ3VtZW50c1wiKSksXG4gICAgYm9keTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVFNJbnRlcmZhY2VCb2R5XCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTSW50ZXJmYWNlQm9keVwiLCB7XG4gIHZpc2l0b3I6IFtcImJvZHlcIl0sXG4gIGZpZWxkczoge1xuICAgIGJvZHk6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJUU1R5cGVFbGVtZW50XCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTVHlwZUFsaWFzRGVjbGFyYXRpb25cIiwge1xuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiXSxcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiLCBcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBkZWNsYXJlOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKGJvb2wpLFxuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIHR5cGVQYXJhbWV0ZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlRTVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIpLFxuICAgIHR5cGVBbm5vdGF0aW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJUU1R5cGVcIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNBc0V4cHJlc3Npb25cIiwge1xuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdLFxuICB2aXNpdG9yOiBbXCJleHByZXNzaW9uXCIsIFwidHlwZUFubm90YXRpb25cIl0sXG4gIGZpZWxkczoge1xuICAgIGV4cHJlc3Npb246ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkV4cHJlc3Npb25cIiksXG4gICAgdHlwZUFubm90YXRpb246ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlRTVHlwZVwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU1R5cGVBc3NlcnRpb25cIiwge1xuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdLFxuICB2aXNpdG9yOiBbXCJ0eXBlQW5ub3RhdGlvblwiLCBcImV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczoge1xuICAgIHR5cGVBbm5vdGF0aW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJUU1R5cGVcIiksXG4gICAgZXhwcmVzc2lvbjogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU0VudW1EZWNsYXJhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICB2aXNpdG9yOiBbXCJpZFwiLCBcIm1lbWJlcnNcIl0sXG4gIGZpZWxkczoge1xuICAgIGRlY2xhcmU6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoYm9vbCksXG4gICAgY29uc3Q6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoYm9vbCksXG4gICAgaWQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIklkZW50aWZpZXJcIiksXG4gICAgbWVtYmVyczogKDAsIF91dGlscy52YWxpZGF0ZUFycmF5T2ZUeXBlKShcIlRTRW51bU1lbWJlclwiKSxcbiAgICBpbml0aWFsaXplcjogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTRW51bU1lbWJlclwiLCB7XG4gIHZpc2l0b3I6IFtcImlkXCIsIFwiaW5pdGlhbGl6ZXJcIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoW1wiSWRlbnRpZmllclwiLCBcIlN0cmluZ0xpdGVyYWxcIl0pLFxuICAgIGluaXRpYWxpemVyOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNNb2R1bGVEZWNsYXJhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICB2aXNpdG9yOiBbXCJpZFwiLCBcImJvZHlcIl0sXG4gIGZpZWxkczoge1xuICAgIGRlY2xhcmU6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoYm9vbCksXG4gICAgZ2xvYmFsOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKGJvb2wpLFxuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoW1wiSWRlbnRpZmllclwiLCBcIlN0cmluZ0xpdGVyYWxcIl0pLFxuICAgIGJvZHk6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShbXCJUU01vZHVsZUJsb2NrXCIsIFwiVFNNb2R1bGVEZWNsYXJhdGlvblwiXSlcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNNb2R1bGVCbG9ja1wiLCB7XG4gIGFsaWFzZXM6IFtcIlNjb3BhYmxlXCIsIFwiQmxvY2tcIiwgXCJCbG9ja1BhcmVudFwiXSxcbiAgdmlzaXRvcjogW1wiYm9keVwiXSxcbiAgZmllbGRzOiB7XG4gICAgYm9keTogKDAsIF91dGlscy52YWxpZGF0ZUFycmF5T2ZUeXBlKShcIlN0YXRlbWVudFwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU0ltcG9ydFR5cGVcIiwge1xuICBhbGlhc2VzOiBbXCJUU1R5cGVcIl0sXG4gIHZpc2l0b3I6IFtcImFyZ3VtZW50XCIsIFwicXVhbGlmaWVyXCIsIFwidHlwZVBhcmFtZXRlcnNcIl0sXG4gIGZpZWxkczoge1xuICAgIGFyZ3VtZW50OiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJTdHJpbmdMaXRlcmFsXCIpLFxuICAgIHF1YWxpZmllcjogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUU0VudGl0eU5hbWVcIiksXG4gICAgdHlwZVBhcmFtZXRlcnM6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiVFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU0ltcG9ydEVxdWFsc0RlY2xhcmF0aW9uXCIsIHtcbiAgYWxpYXNlczogW1wiU3RhdGVtZW50XCJdLFxuICB2aXNpdG9yOiBbXCJpZFwiLCBcIm1vZHVsZVJlZmVyZW5jZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgaXNFeHBvcnQ6ICgwLCBfdXRpbHMudmFsaWRhdGUpKGJvb2wpLFxuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIG1vZHVsZVJlZmVyZW5jZTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFtcIlRTRW50aXR5TmFtZVwiLCBcIlRTRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2VcIl0pXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2VcIiwge1xuICB2aXNpdG9yOiBbXCJleHByZXNzaW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBleHByZXNzaW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJTdHJpbmdMaXRlcmFsXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTTm9uTnVsbEV4cHJlc3Npb25cIiwge1xuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdLFxuICB2aXNpdG9yOiBbXCJleHByZXNzaW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBleHByZXNzaW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTRXhwb3J0QXNzaWdubWVudFwiLCB7XG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiXSxcbiAgdmlzaXRvcjogW1wiZXhwcmVzc2lvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgZXhwcmVzc2lvbjogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU05hbWVzcGFjZUV4cG9ydERlY2xhcmF0aW9uXCIsIHtcbiAgYWxpYXNlczogW1wiU3RhdGVtZW50XCJdLFxuICB2aXNpdG9yOiBbXCJpZFwiXSxcbiAgZmllbGRzOiB7XG4gICAgaWQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIklkZW50aWZpZXJcIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNUeXBlQW5ub3RhdGlvblwiLCB7XG4gIHZpc2l0b3I6IFtcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICB0eXBlQW5ub3RhdGlvbjoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVFNUeXBlXCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1wicGFyYW1zXCJdLFxuICBmaWVsZHM6IHtcbiAgICBwYXJhbXM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJhcnJheVwiKSwgKDAsIF91dGlscy5hc3NlcnRFYWNoKSgoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlRTVHlwZVwiKSkpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiLCB7XG4gIHZpc2l0b3I6IFtcInBhcmFtc1wiXSxcbiAgZmllbGRzOiB7XG4gICAgcGFyYW1zOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJUU1R5cGVQYXJhbWV0ZXJcIikpKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNUeXBlUGFyYW1ldGVyXCIsIHtcbiAgYnVpbGRlcjogW1wiY29uc3RyYWludFwiLCBcImRlZmF1bHRcIiwgXCJuYW1lXCJdLFxuICB2aXNpdG9yOiBbXCJjb25zdHJhaW50XCIsIFwiZGVmYXVsdFwiXSxcbiAgZmllbGRzOiB7XG4gICAgbmFtZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKVxuICAgIH0sXG4gICAgY29uc3RyYWludDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVFNUeXBlXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlRTVHlwZVwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9XG59KTsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMudmFsaWRhdGUgPSB2YWxpZGF0ZTtcbmV4cG9ydHMudHlwZUlzID0gdHlwZUlzO1xuZXhwb3J0cy52YWxpZGF0ZVR5cGUgPSB2YWxpZGF0ZVR5cGU7XG5leHBvcnRzLnZhbGlkYXRlT3B0aW9uYWwgPSB2YWxpZGF0ZU9wdGlvbmFsO1xuZXhwb3J0cy52YWxpZGF0ZU9wdGlvbmFsVHlwZSA9IHZhbGlkYXRlT3B0aW9uYWxUeXBlO1xuZXhwb3J0cy5hcnJheU9mID0gYXJyYXlPZjtcbmV4cG9ydHMuYXJyYXlPZlR5cGUgPSBhcnJheU9mVHlwZTtcbmV4cG9ydHMudmFsaWRhdGVBcnJheU9mVHlwZSA9IHZhbGlkYXRlQXJyYXlPZlR5cGU7XG5leHBvcnRzLmFzc2VydEVhY2ggPSBhc3NlcnRFYWNoO1xuZXhwb3J0cy5hc3NlcnRPbmVPZiA9IGFzc2VydE9uZU9mO1xuZXhwb3J0cy5hc3NlcnROb2RlVHlwZSA9IGFzc2VydE5vZGVUeXBlO1xuZXhwb3J0cy5hc3NlcnROb2RlT3JWYWx1ZVR5cGUgPSBhc3NlcnROb2RlT3JWYWx1ZVR5cGU7XG5leHBvcnRzLmFzc2VydFZhbHVlVHlwZSA9IGFzc2VydFZhbHVlVHlwZTtcbmV4cG9ydHMuYXNzZXJ0U2hhcGUgPSBhc3NlcnRTaGFwZTtcbmV4cG9ydHMuYXNzZXJ0T3B0aW9uYWxDaGFpblN0YXJ0ID0gYXNzZXJ0T3B0aW9uYWxDaGFpblN0YXJ0O1xuZXhwb3J0cy5jaGFpbiA9IGNoYWluO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmaW5lVHlwZTtcbmV4cG9ydHMuTk9ERV9QQVJFTlRfVkFMSURBVElPTlMgPSBleHBvcnRzLkRFUFJFQ0FURURfS0VZUyA9IGV4cG9ydHMuQlVJTERFUl9LRVlTID0gZXhwb3J0cy5OT0RFX0ZJRUxEUyA9IGV4cG9ydHMuRkxJUFBFRF9BTElBU19LRVlTID0gZXhwb3J0cy5BTElBU19LRVlTID0gZXhwb3J0cy5WSVNJVE9SX0tFWVMgPSB2b2lkIDA7XG5cbnZhciBfaXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi92YWxpZGF0b3JzL2lzXCIpKTtcblxudmFyIF92YWxpZGF0ZSA9IHJlcXVpcmUoXCIuLi92YWxpZGF0b3JzL3ZhbGlkYXRlXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5jb25zdCBWSVNJVE9SX0tFWVMgPSB7fTtcbmV4cG9ydHMuVklTSVRPUl9LRVlTID0gVklTSVRPUl9LRVlTO1xuY29uc3QgQUxJQVNfS0VZUyA9IHt9O1xuZXhwb3J0cy5BTElBU19LRVlTID0gQUxJQVNfS0VZUztcbmNvbnN0IEZMSVBQRURfQUxJQVNfS0VZUyA9IHt9O1xuZXhwb3J0cy5GTElQUEVEX0FMSUFTX0tFWVMgPSBGTElQUEVEX0FMSUFTX0tFWVM7XG5jb25zdCBOT0RFX0ZJRUxEUyA9IHt9O1xuZXhwb3J0cy5OT0RFX0ZJRUxEUyA9IE5PREVfRklFTERTO1xuY29uc3QgQlVJTERFUl9LRVlTID0ge307XG5leHBvcnRzLkJVSUxERVJfS0VZUyA9IEJVSUxERVJfS0VZUztcbmNvbnN0IERFUFJFQ0FURURfS0VZUyA9IHt9O1xuZXhwb3J0cy5ERVBSRUNBVEVEX0tFWVMgPSBERVBSRUNBVEVEX0tFWVM7XG5jb25zdCBOT0RFX1BBUkVOVF9WQUxJREFUSU9OUyA9IHt9O1xuZXhwb3J0cy5OT0RFX1BBUkVOVF9WQUxJREFUSU9OUyA9IE5PREVfUEFSRU5UX1ZBTElEQVRJT05TO1xuXG5mdW5jdGlvbiBnZXRUeXBlKHZhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgfSBlbHNlIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICByZXR1cm4gXCJudWxsXCI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWw7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGUodmFsaWRhdGUpIHtcbiAgcmV0dXJuIHtcbiAgICB2YWxpZGF0ZVxuICB9O1xufVxuXG5mdW5jdGlvbiB0eXBlSXModHlwZU5hbWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlTmFtZSA9PT0gXCJzdHJpbmdcIiA/IGFzc2VydE5vZGVUeXBlKHR5cGVOYW1lKSA6IGFzc2VydE5vZGVUeXBlKC4uLnR5cGVOYW1lKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVUeXBlKHR5cGVOYW1lKSB7XG4gIHJldHVybiB2YWxpZGF0ZSh0eXBlSXModHlwZU5hbWUpKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVPcHRpb25hbCh2YWxpZGF0ZSkge1xuICByZXR1cm4ge1xuICAgIHZhbGlkYXRlLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH07XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlT3B0aW9uYWxUeXBlKHR5cGVOYW1lKSB7XG4gIHJldHVybiB7XG4gICAgdmFsaWRhdGU6IHR5cGVJcyh0eXBlTmFtZSksXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXJyYXlPZihlbGVtZW50VHlwZSkge1xuICByZXR1cm4gY2hhaW4oYXNzZXJ0VmFsdWVUeXBlKFwiYXJyYXlcIiksIGFzc2VydEVhY2goZWxlbWVudFR5cGUpKTtcbn1cblxuZnVuY3Rpb24gYXJyYXlPZlR5cGUodHlwZU5hbWUpIHtcbiAgcmV0dXJuIGFycmF5T2YodHlwZUlzKHR5cGVOYW1lKSk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQXJyYXlPZlR5cGUodHlwZU5hbWUpIHtcbiAgcmV0dXJuIHZhbGlkYXRlKGFycmF5T2ZUeXBlKHR5cGVOYW1lKSk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEVhY2goY2FsbGJhY2spIHtcbiAgZnVuY3Rpb24gdmFsaWRhdG9yKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbCkpIHJldHVybjtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdWJrZXkgPSBgJHtrZXl9WyR7aX1dYDtcbiAgICAgIGNvbnN0IHYgPSB2YWxbaV07XG4gICAgICBjYWxsYmFjayhub2RlLCBzdWJrZXksIHYpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcpICgwLCBfdmFsaWRhdGUudmFsaWRhdGVDaGlsZCkobm9kZSwgc3Via2V5LCB2KTtcbiAgICB9XG4gIH1cblxuICB2YWxpZGF0b3IuZWFjaCA9IGNhbGxiYWNrO1xuICByZXR1cm4gdmFsaWRhdG9yO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRPbmVPZiguLi52YWx1ZXMpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUobm9kZSwga2V5LCB2YWwpIHtcbiAgICBpZiAodmFsdWVzLmluZGV4T2YodmFsKSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFByb3BlcnR5ICR7a2V5fSBleHBlY3RlZCB2YWx1ZSB0byBiZSBvbmUgb2YgJHtKU09OLnN0cmluZ2lmeSh2YWx1ZXMpfSBidXQgZ290ICR7SlNPTi5zdHJpbmdpZnkodmFsKX1gKTtcbiAgICB9XG4gIH1cblxuICB2YWxpZGF0ZS5vbmVPZiA9IHZhbHVlcztcbiAgcmV0dXJuIHZhbGlkYXRlO1xufVxuXG5mdW5jdGlvbiBhc3NlcnROb2RlVHlwZSguLi50eXBlcykge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShub2RlLCBrZXksIHZhbCkge1xuICAgIGZvciAoY29uc3QgdHlwZSBvZiB0eXBlcykge1xuICAgICAgaWYgKCgwLCBfaXMuZGVmYXVsdCkodHlwZSwgdmFsKSkge1xuICAgICAgICAoMCwgX3ZhbGlkYXRlLnZhbGlkYXRlQ2hpbGQpKG5vZGUsIGtleSwgdmFsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFByb3BlcnR5ICR7a2V5fSBvZiAke25vZGUudHlwZX0gZXhwZWN0ZWQgbm9kZSB0byBiZSBvZiBhIHR5cGUgJHtKU09OLnN0cmluZ2lmeSh0eXBlcyl9IGJ1dCBpbnN0ZWFkIGdvdCAke0pTT04uc3RyaW5naWZ5KHZhbCA9PSBudWxsID8gdm9pZCAwIDogdmFsLnR5cGUpfWApO1xuICB9XG5cbiAgdmFsaWRhdGUub25lT2ZOb2RlVHlwZXMgPSB0eXBlcztcbiAgcmV0dXJuIHZhbGlkYXRlO1xufVxuXG5mdW5jdGlvbiBhc3NlcnROb2RlT3JWYWx1ZVR5cGUoLi4udHlwZXMpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUobm9kZSwga2V5LCB2YWwpIHtcbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgdHlwZXMpIHtcbiAgICAgIGlmIChnZXRUeXBlKHZhbCkgPT09IHR5cGUgfHwgKDAsIF9pcy5kZWZhdWx0KSh0eXBlLCB2YWwpKSB7XG4gICAgICAgICgwLCBfdmFsaWRhdGUudmFsaWRhdGVDaGlsZCkobm9kZSwga2V5LCB2YWwpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUHJvcGVydHkgJHtrZXl9IG9mICR7bm9kZS50eXBlfSBleHBlY3RlZCBub2RlIHRvIGJlIG9mIGEgdHlwZSAke0pTT04uc3RyaW5naWZ5KHR5cGVzKX0gYnV0IGluc3RlYWQgZ290ICR7SlNPTi5zdHJpbmdpZnkodmFsID09IG51bGwgPyB2b2lkIDAgOiB2YWwudHlwZSl9YCk7XG4gIH1cblxuICB2YWxpZGF0ZS5vbmVPZk5vZGVPclZhbHVlVHlwZXMgPSB0eXBlcztcbiAgcmV0dXJuIHZhbGlkYXRlO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRWYWx1ZVR5cGUodHlwZSkge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShub2RlLCBrZXksIHZhbCkge1xuICAgIGNvbnN0IHZhbGlkID0gZ2V0VHlwZSh2YWwpID09PSB0eXBlO1xuXG4gICAgaWYgKCF2YWxpZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUHJvcGVydHkgJHtrZXl9IGV4cGVjdGVkIHR5cGUgb2YgJHt0eXBlfSBidXQgZ290ICR7Z2V0VHlwZSh2YWwpfWApO1xuICAgIH1cbiAgfVxuXG4gIHZhbGlkYXRlLnR5cGUgPSB0eXBlO1xuICByZXR1cm4gdmFsaWRhdGU7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNoYXBlKHNoYXBlKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgY29uc3QgZXJyb3JzID0gW107XG5cbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIE9iamVjdC5rZXlzKHNoYXBlKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgKDAsIF92YWxpZGF0ZS52YWxpZGF0ZUZpZWxkKShub2RlLCBwcm9wZXJ0eSwgdmFsW3Byb3BlcnR5XSwgc2hhcGVbcHJvcGVydHldKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xuICAgICAgICAgIGVycm9ycy5wdXNoKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFByb3BlcnR5ICR7a2V5fSBvZiAke25vZGUudHlwZX0gZXhwZWN0ZWQgdG8gaGF2ZSB0aGUgZm9sbG93aW5nOlxcbiR7ZXJyb3JzLmpvaW4oXCJcXG5cIil9YCk7XG4gICAgfVxuICB9XG5cbiAgdmFsaWRhdGUuc2hhcGVPZiA9IHNoYXBlO1xuICByZXR1cm4gdmFsaWRhdGU7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE9wdGlvbmFsQ2hhaW5TdGFydCgpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUobm9kZSkge1xuICAgIHZhciBfY3VycmVudDtcblxuICAgIGxldCBjdXJyZW50ID0gbm9kZTtcblxuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHR5cGVcbiAgICAgIH0gPSBjdXJyZW50O1xuXG4gICAgICBpZiAodHlwZSA9PT0gXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgaWYgKGN1cnJlbnQub3B0aW9uYWwpIHJldHVybjtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuY2FsbGVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09IFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgaWYgKGN1cnJlbnQub3B0aW9uYWwpIHJldHVybjtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQub2JqZWN0O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm9uLW9wdGlvbmFsICR7bm9kZS50eXBlfSBtdXN0IGNoYWluIGZyb20gYW4gb3B0aW9uYWwgT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uIG9yIE9wdGlvbmFsQ2FsbEV4cHJlc3Npb24uIEZvdW5kIGNoYWluIGZyb20gJHsoX2N1cnJlbnQgPSBjdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2N1cnJlbnQudHlwZX1gKTtcbiAgfVxuXG4gIHJldHVybiB2YWxpZGF0ZTtcbn1cblxuZnVuY3Rpb24gY2hhaW4oLi4uZm5zKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKC4uLmFyZ3MpIHtcbiAgICBmb3IgKGNvbnN0IGZuIG9mIGZucykge1xuICAgICAgZm4oLi4uYXJncyk7XG4gICAgfVxuICB9XG5cbiAgdmFsaWRhdGUuY2hhaW5PZiA9IGZucztcbiAgcmV0dXJuIHZhbGlkYXRlO1xufVxuXG5jb25zdCB2YWxpZFR5cGVPcHRzID0gW1wiYWxpYXNlc1wiLCBcImJ1aWxkZXJcIiwgXCJkZXByZWNhdGVkQWxpYXNcIiwgXCJmaWVsZHNcIiwgXCJpbmhlcml0c1wiLCBcInZpc2l0b3JcIiwgXCJ2YWxpZGF0ZVwiXTtcbmNvbnN0IHZhbGlkRmllbGRLZXlzID0gW1wiZGVmYXVsdFwiLCBcIm9wdGlvbmFsXCIsIFwidmFsaWRhdGVcIl07XG5cbmZ1bmN0aW9uIGRlZmluZVR5cGUodHlwZSwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IGluaGVyaXRzID0gb3B0cy5pbmhlcml0cyAmJiBzdG9yZVtvcHRzLmluaGVyaXRzXSB8fCB7fTtcbiAgbGV0IGZpZWxkcyA9IG9wdHMuZmllbGRzO1xuXG4gIGlmICghZmllbGRzKSB7XG4gICAgZmllbGRzID0ge307XG5cbiAgICBpZiAoaW5oZXJpdHMuZmllbGRzKSB7XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaW5oZXJpdHMuZmllbGRzKTtcblxuICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICBjb25zdCBmaWVsZCA9IGluaGVyaXRzLmZpZWxkc1trZXldO1xuICAgICAgICBmaWVsZHNba2V5XSA9IHtcbiAgICAgICAgICBkZWZhdWx0OiBmaWVsZC5kZWZhdWx0LFxuICAgICAgICAgIG9wdGlvbmFsOiBmaWVsZC5vcHRpb25hbCxcbiAgICAgICAgICB2YWxpZGF0ZTogZmllbGQudmFsaWRhdGVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCB2aXNpdG9yID0gb3B0cy52aXNpdG9yIHx8IGluaGVyaXRzLnZpc2l0b3IgfHwgW107XG4gIGNvbnN0IGFsaWFzZXMgPSBvcHRzLmFsaWFzZXMgfHwgaW5oZXJpdHMuYWxpYXNlcyB8fCBbXTtcbiAgY29uc3QgYnVpbGRlciA9IG9wdHMuYnVpbGRlciB8fCBpbmhlcml0cy5idWlsZGVyIHx8IG9wdHMudmlzaXRvciB8fCBbXTtcblxuICBmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXMob3B0cykpIHtcbiAgICBpZiAodmFsaWRUeXBlT3B0cy5pbmRleE9mKGspID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHR5cGUgb3B0aW9uIFwiJHtrfVwiIG9uICR7dHlwZX1gKTtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0cy5kZXByZWNhdGVkQWxpYXMpIHtcbiAgICBERVBSRUNBVEVEX0tFWVNbb3B0cy5kZXByZWNhdGVkQWxpYXNdID0gdHlwZTtcbiAgfVxuXG4gIGZvciAoY29uc3Qga2V5IG9mIHZpc2l0b3IuY29uY2F0KGJ1aWxkZXIpKSB7XG4gICAgZmllbGRzW2tleV0gPSBmaWVsZHNba2V5XSB8fCB7fTtcbiAgfVxuXG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGZpZWxkcykpIHtcbiAgICBjb25zdCBmaWVsZCA9IGZpZWxkc1trZXldO1xuXG4gICAgaWYgKGZpZWxkLmRlZmF1bHQgIT09IHVuZGVmaW5lZCAmJiBidWlsZGVyLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgIGZpZWxkLm9wdGlvbmFsID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZmllbGQuZGVmYXVsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmaWVsZC5kZWZhdWx0ID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKCFmaWVsZC52YWxpZGF0ZSAmJiBmaWVsZC5kZWZhdWx0ICE9IG51bGwpIHtcbiAgICAgIGZpZWxkLnZhbGlkYXRlID0gYXNzZXJ0VmFsdWVUeXBlKGdldFR5cGUoZmllbGQuZGVmYXVsdCkpO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyhmaWVsZCkpIHtcbiAgICAgIGlmICh2YWxpZEZpZWxkS2V5cy5pbmRleE9mKGspID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZmllbGQga2V5IFwiJHtrfVwiIG9uICR7dHlwZX0uJHtrZXl9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgVklTSVRPUl9LRVlTW3R5cGVdID0gb3B0cy52aXNpdG9yID0gdmlzaXRvcjtcbiAgQlVJTERFUl9LRVlTW3R5cGVdID0gb3B0cy5idWlsZGVyID0gYnVpbGRlcjtcbiAgTk9ERV9GSUVMRFNbdHlwZV0gPSBvcHRzLmZpZWxkcyA9IGZpZWxkcztcbiAgQUxJQVNfS0VZU1t0eXBlXSA9IG9wdHMuYWxpYXNlcyA9IGFsaWFzZXM7XG4gIGFsaWFzZXMuZm9yRWFjaChhbGlhcyA9PiB7XG4gICAgRkxJUFBFRF9BTElBU19LRVlTW2FsaWFzXSA9IEZMSVBQRURfQUxJQVNfS0VZU1thbGlhc10gfHwgW107XG4gICAgRkxJUFBFRF9BTElBU19LRVlTW2FsaWFzXS5wdXNoKHR5cGUpO1xuICB9KTtcblxuICBpZiAob3B0cy52YWxpZGF0ZSkge1xuICAgIE5PREVfUEFSRU5UX1ZBTElEQVRJT05TW3R5cGVdID0gb3B0cy52YWxpZGF0ZTtcbiAgfVxuXG4gIHN0b3JlW3R5cGVdID0gb3B0cztcbn1cblxuY29uc3Qgc3RvcmUgPSB7fTsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBfZXhwb3J0TmFtZXMgPSB7XG4gIHJlYWN0OiB0cnVlLFxuICBhc3NlcnROb2RlOiB0cnVlLFxuICBjcmVhdGVUeXBlQW5ub3RhdGlvbkJhc2VkT25UeXBlb2Y6IHRydWUsXG4gIGNyZWF0ZVVuaW9uVHlwZUFubm90YXRpb246IHRydWUsXG4gIGNyZWF0ZUZsb3dVbmlvblR5cGU6IHRydWUsXG4gIGNyZWF0ZVRTVW5pb25UeXBlOiB0cnVlLFxuICBjbG9uZU5vZGU6IHRydWUsXG4gIGNsb25lOiB0cnVlLFxuICBjbG9uZURlZXA6IHRydWUsXG4gIGNsb25lRGVlcFdpdGhvdXRMb2M6IHRydWUsXG4gIGNsb25lV2l0aG91dExvYzogdHJ1ZSxcbiAgYWRkQ29tbWVudDogdHJ1ZSxcbiAgYWRkQ29tbWVudHM6IHRydWUsXG4gIGluaGVyaXRJbm5lckNvbW1lbnRzOiB0cnVlLFxuICBpbmhlcml0TGVhZGluZ0NvbW1lbnRzOiB0cnVlLFxuICBpbmhlcml0c0NvbW1lbnRzOiB0cnVlLFxuICBpbmhlcml0VHJhaWxpbmdDb21tZW50czogdHJ1ZSxcbiAgcmVtb3ZlQ29tbWVudHM6IHRydWUsXG4gIGVuc3VyZUJsb2NrOiB0cnVlLFxuICB0b0JpbmRpbmdJZGVudGlmaWVyTmFtZTogdHJ1ZSxcbiAgdG9CbG9jazogdHJ1ZSxcbiAgdG9Db21wdXRlZEtleTogdHJ1ZSxcbiAgdG9FeHByZXNzaW9uOiB0cnVlLFxuICB0b0lkZW50aWZpZXI6IHRydWUsXG4gIHRvS2V5QWxpYXM6IHRydWUsXG4gIHRvU2VxdWVuY2VFeHByZXNzaW9uOiB0cnVlLFxuICB0b1N0YXRlbWVudDogdHJ1ZSxcbiAgdmFsdWVUb05vZGU6IHRydWUsXG4gIGFwcGVuZFRvTWVtYmVyRXhwcmVzc2lvbjogdHJ1ZSxcbiAgaW5oZXJpdHM6IHRydWUsXG4gIHByZXBlbmRUb01lbWJlckV4cHJlc3Npb246IHRydWUsXG4gIHJlbW92ZVByb3BlcnRpZXM6IHRydWUsXG4gIHJlbW92ZVByb3BlcnRpZXNEZWVwOiB0cnVlLFxuICByZW1vdmVUeXBlRHVwbGljYXRlczogdHJ1ZSxcbiAgZ2V0QmluZGluZ0lkZW50aWZpZXJzOiB0cnVlLFxuICBnZXRPdXRlckJpbmRpbmdJZGVudGlmaWVyczogdHJ1ZSxcbiAgdHJhdmVyc2U6IHRydWUsXG4gIHRyYXZlcnNlRmFzdDogdHJ1ZSxcbiAgc2hhbGxvd0VxdWFsOiB0cnVlLFxuICBpczogdHJ1ZSxcbiAgaXNCaW5kaW5nOiB0cnVlLFxuICBpc0Jsb2NrU2NvcGVkOiB0cnVlLFxuICBpc0ltbXV0YWJsZTogdHJ1ZSxcbiAgaXNMZXQ6IHRydWUsXG4gIGlzTm9kZTogdHJ1ZSxcbiAgaXNOb2Rlc0VxdWl2YWxlbnQ6IHRydWUsXG4gIGlzUGxhY2Vob2xkZXJUeXBlOiB0cnVlLFxuICBpc1JlZmVyZW5jZWQ6IHRydWUsXG4gIGlzU2NvcGU6IHRydWUsXG4gIGlzU3BlY2lmaWVyRGVmYXVsdDogdHJ1ZSxcbiAgaXNUeXBlOiB0cnVlLFxuICBpc1ZhbGlkRVMzSWRlbnRpZmllcjogdHJ1ZSxcbiAgaXNWYWxpZElkZW50aWZpZXI6IHRydWUsXG4gIGlzVmFyOiB0cnVlLFxuICBtYXRjaGVzUGF0dGVybjogdHJ1ZSxcbiAgdmFsaWRhdGU6IHRydWUsXG4gIGJ1aWxkTWF0Y2hNZW1iZXJFeHByZXNzaW9uOiB0cnVlXG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXNzZXJ0Tm9kZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfYXNzZXJ0Tm9kZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZVR5cGVBbm5vdGF0aW9uQmFzZWRPblR5cGVvZlwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfY3JlYXRlVHlwZUFubm90YXRpb25CYXNlZE9uVHlwZW9mLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlVW5pb25UeXBlQW5ub3RhdGlvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfY3JlYXRlRmxvd1VuaW9uVHlwZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZUZsb3dVbmlvblR5cGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2NyZWF0ZUZsb3dVbmlvblR5cGUuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVUU1VuaW9uVHlwZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfY3JlYXRlVFNVbmlvblR5cGUuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjbG9uZU5vZGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Nsb25lTm9kZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNsb25lXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9jbG9uZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNsb25lRGVlcFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfY2xvbmVEZWVwLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY2xvbmVEZWVwV2l0aG91dExvY1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfY2xvbmVEZWVwV2l0aG91dExvYy5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNsb25lV2l0aG91dExvY1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfY2xvbmVXaXRob3V0TG9jLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYWRkQ29tbWVudFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfYWRkQ29tbWVudC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFkZENvbW1lbnRzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9hZGRDb21tZW50cy5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImluaGVyaXRJbm5lckNvbW1lbnRzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmhlcml0SW5uZXJDb21tZW50cy5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImluaGVyaXRMZWFkaW5nQ29tbWVudHNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luaGVyaXRMZWFkaW5nQ29tbWVudHMuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpbmhlcml0c0NvbW1lbnRzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmhlcml0c0NvbW1lbnRzLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaW5oZXJpdFRyYWlsaW5nQ29tbWVudHNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luaGVyaXRUcmFpbGluZ0NvbW1lbnRzLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVtb3ZlQ29tbWVudHNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3JlbW92ZUNvbW1lbnRzLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5zdXJlQmxvY2tcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Vuc3VyZUJsb2NrLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9CaW5kaW5nSWRlbnRpZmllck5hbWVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3RvQmluZGluZ0lkZW50aWZpZXJOYW1lLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9CbG9ja1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdG9CbG9jay5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvQ29tcHV0ZWRLZXlcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3RvQ29tcHV0ZWRLZXkuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b0V4cHJlc3Npb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3RvRXhwcmVzc2lvbi5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvSWRlbnRpZmllclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdG9JZGVudGlmaWVyLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9LZXlBbGlhc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdG9LZXlBbGlhcy5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvU2VxdWVuY2VFeHByZXNzaW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF90b1NlcXVlbmNlRXhwcmVzc2lvbi5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvU3RhdGVtZW50XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF90b1N0YXRlbWVudC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInZhbHVlVG9Ob2RlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF92YWx1ZVRvTm9kZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFwcGVuZFRvTWVtYmVyRXhwcmVzc2lvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfYXBwZW5kVG9NZW1iZXJFeHByZXNzaW9uLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaW5oZXJpdHNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luaGVyaXRzLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicHJlcGVuZFRvTWVtYmVyRXhwcmVzc2lvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfcHJlcGVuZFRvTWVtYmVyRXhwcmVzc2lvbi5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlbW92ZVByb3BlcnRpZXNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3JlbW92ZVByb3BlcnRpZXMuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZW1vdmVQcm9wZXJ0aWVzRGVlcFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfcmVtb3ZlUHJvcGVydGllc0RlZXAuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZW1vdmVUeXBlRHVwbGljYXRlc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfcmVtb3ZlVHlwZUR1cGxpY2F0ZXMuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRCaW5kaW5nSWRlbnRpZmllcnNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2dldEJpbmRpbmdJZGVudGlmaWVycy5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldE91dGVyQmluZGluZ0lkZW50aWZpZXJzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9nZXRPdXRlckJpbmRpbmdJZGVudGlmaWVycy5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRyYXZlcnNlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF90cmF2ZXJzZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRyYXZlcnNlRmFzdFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdHJhdmVyc2VGYXN0LmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2hhbGxvd0VxdWFsXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9zaGFsbG93RXF1YWwuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaXMuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0JpbmRpbmdcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2lzQmluZGluZy5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzQmxvY2tTY29wZWRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2lzQmxvY2tTY29wZWQuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0ltbXV0YWJsZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaXNJbW11dGFibGUuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0xldFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaXNMZXQuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc05vZGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2lzTm9kZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzTm9kZXNFcXVpdmFsZW50XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pc05vZGVzRXF1aXZhbGVudC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzUGxhY2Vob2xkZXJUeXBlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pc1BsYWNlaG9sZGVyVHlwZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzUmVmZXJlbmNlZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaXNSZWZlcmVuY2VkLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNTY29wZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaXNTY29wZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzU3BlY2lmaWVyRGVmYXVsdFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaXNTcGVjaWZpZXJEZWZhdWx0LmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNUeXBlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pc1R5cGUuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1ZhbGlkRVMzSWRlbnRpZmllclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaXNWYWxpZEVTM0lkZW50aWZpZXIuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1ZhbGlkSWRlbnRpZmllclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaXNWYWxpZElkZW50aWZpZXIuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1ZhclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaXNWYXIuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtYXRjaGVzUGF0dGVyblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfbWF0Y2hlc1BhdHRlcm4uZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2YWxpZGF0ZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdmFsaWRhdGUuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJidWlsZE1hdGNoTWVtYmVyRXhwcmVzc2lvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfYnVpbGRNYXRjaE1lbWJlckV4cHJlc3Npb24uZGVmYXVsdDtcbiAgfVxufSk7XG5leHBvcnRzLnJlYWN0ID0gdm9pZCAwO1xuXG52YXIgX2lzUmVhY3RDb21wb25lbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvcmVhY3QvaXNSZWFjdENvbXBvbmVudFwiKSk7XG5cbnZhciBfaXNDb21wYXRUYWcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvcmVhY3QvaXNDb21wYXRUYWdcIikpO1xuXG52YXIgX2J1aWxkQ2hpbGRyZW4gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2J1aWxkZXJzL3JlYWN0L2J1aWxkQ2hpbGRyZW5cIikpO1xuXG52YXIgX2Fzc2VydE5vZGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Fzc2VydHMvYXNzZXJ0Tm9kZVwiKSk7XG5cbnZhciBfZ2VuZXJhdGVkID0gcmVxdWlyZShcIi4vYXNzZXJ0cy9nZW5lcmF0ZWRcIik7XG5cbk9iamVjdC5rZXlzKF9nZW5lcmF0ZWQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX2V4cG9ydE5hbWVzLCBrZXkpKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9nZW5lcmF0ZWRba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbnZhciBfY3JlYXRlVHlwZUFubm90YXRpb25CYXNlZE9uVHlwZW9mID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9idWlsZGVycy9mbG93L2NyZWF0ZVR5cGVBbm5vdGF0aW9uQmFzZWRPblR5cGVvZlwiKSk7XG5cbnZhciBfY3JlYXRlRmxvd1VuaW9uVHlwZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vYnVpbGRlcnMvZmxvdy9jcmVhdGVGbG93VW5pb25UeXBlXCIpKTtcblxudmFyIF9jcmVhdGVUU1VuaW9uVHlwZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vYnVpbGRlcnMvdHlwZXNjcmlwdC9jcmVhdGVUU1VuaW9uVHlwZVwiKSk7XG5cbnZhciBfZ2VuZXJhdGVkMiA9IHJlcXVpcmUoXCIuL2J1aWxkZXJzL2dlbmVyYXRlZFwiKTtcblxuT2JqZWN0LmtleXMoX2dlbmVyYXRlZDIpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX2V4cG9ydE5hbWVzLCBrZXkpKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9nZW5lcmF0ZWQyW2tleV07XG4gICAgfVxuICB9KTtcbn0pO1xuXG52YXIgX2Nsb25lTm9kZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY2xvbmUvY2xvbmVOb2RlXCIpKTtcblxudmFyIF9jbG9uZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY2xvbmUvY2xvbmVcIikpO1xuXG52YXIgX2Nsb25lRGVlcCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY2xvbmUvY2xvbmVEZWVwXCIpKTtcblxudmFyIF9jbG9uZURlZXBXaXRob3V0TG9jID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jbG9uZS9jbG9uZURlZXBXaXRob3V0TG9jXCIpKTtcblxudmFyIF9jbG9uZVdpdGhvdXRMb2MgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Nsb25lL2Nsb25lV2l0aG91dExvY1wiKSk7XG5cbnZhciBfYWRkQ29tbWVudCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY29tbWVudHMvYWRkQ29tbWVudFwiKSk7XG5cbnZhciBfYWRkQ29tbWVudHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NvbW1lbnRzL2FkZENvbW1lbnRzXCIpKTtcblxudmFyIF9pbmhlcml0SW5uZXJDb21tZW50cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY29tbWVudHMvaW5oZXJpdElubmVyQ29tbWVudHNcIikpO1xuXG52YXIgX2luaGVyaXRMZWFkaW5nQ29tbWVudHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NvbW1lbnRzL2luaGVyaXRMZWFkaW5nQ29tbWVudHNcIikpO1xuXG52YXIgX2luaGVyaXRzQ29tbWVudHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NvbW1lbnRzL2luaGVyaXRzQ29tbWVudHNcIikpO1xuXG52YXIgX2luaGVyaXRUcmFpbGluZ0NvbW1lbnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jb21tZW50cy9pbmhlcml0VHJhaWxpbmdDb21tZW50c1wiKSk7XG5cbnZhciBfcmVtb3ZlQ29tbWVudHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NvbW1lbnRzL3JlbW92ZUNvbW1lbnRzXCIpKTtcblxudmFyIF9nZW5lcmF0ZWQzID0gcmVxdWlyZShcIi4vY29uc3RhbnRzL2dlbmVyYXRlZFwiKTtcblxuT2JqZWN0LmtleXMoX2dlbmVyYXRlZDMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX2V4cG9ydE5hbWVzLCBrZXkpKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9nZW5lcmF0ZWQzW2tleV07XG4gICAgfVxuICB9KTtcbn0pO1xuXG52YXIgX2NvbnN0YW50cyA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcblxuT2JqZWN0LmtleXMoX2NvbnN0YW50cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfZXhwb3J0TmFtZXMsIGtleSkpIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2NvbnN0YW50c1trZXldO1xuICAgIH1cbiAgfSk7XG59KTtcblxudmFyIF9lbnN1cmVCbG9jayA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY29udmVydGVycy9lbnN1cmVCbG9ja1wiKSk7XG5cbnZhciBfdG9CaW5kaW5nSWRlbnRpZmllck5hbWUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NvbnZlcnRlcnMvdG9CaW5kaW5nSWRlbnRpZmllck5hbWVcIikpO1xuXG52YXIgX3RvQmxvY2sgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NvbnZlcnRlcnMvdG9CbG9ja1wiKSk7XG5cbnZhciBfdG9Db21wdXRlZEtleSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY29udmVydGVycy90b0NvbXB1dGVkS2V5XCIpKTtcblxudmFyIF90b0V4cHJlc3Npb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NvbnZlcnRlcnMvdG9FeHByZXNzaW9uXCIpKTtcblxudmFyIF90b0lkZW50aWZpZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NvbnZlcnRlcnMvdG9JZGVudGlmaWVyXCIpKTtcblxudmFyIF90b0tleUFsaWFzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jb252ZXJ0ZXJzL3RvS2V5QWxpYXNcIikpO1xuXG52YXIgX3RvU2VxdWVuY2VFeHByZXNzaW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jb252ZXJ0ZXJzL3RvU2VxdWVuY2VFeHByZXNzaW9uXCIpKTtcblxudmFyIF90b1N0YXRlbWVudCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY29udmVydGVycy90b1N0YXRlbWVudFwiKSk7XG5cbnZhciBfdmFsdWVUb05vZGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NvbnZlcnRlcnMvdmFsdWVUb05vZGVcIikpO1xuXG52YXIgX2RlZmluaXRpb25zID0gcmVxdWlyZShcIi4vZGVmaW5pdGlvbnNcIik7XG5cbk9iamVjdC5rZXlzKF9kZWZpbml0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfZXhwb3J0TmFtZXMsIGtleSkpIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2RlZmluaXRpb25zW2tleV07XG4gICAgfVxuICB9KTtcbn0pO1xuXG52YXIgX2FwcGVuZFRvTWVtYmVyRXhwcmVzc2lvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbW9kaWZpY2F0aW9ucy9hcHBlbmRUb01lbWJlckV4cHJlc3Npb25cIikpO1xuXG52YXIgX2luaGVyaXRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9tb2RpZmljYXRpb25zL2luaGVyaXRzXCIpKTtcblxudmFyIF9wcmVwZW5kVG9NZW1iZXJFeHByZXNzaW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9tb2RpZmljYXRpb25zL3ByZXBlbmRUb01lbWJlckV4cHJlc3Npb25cIikpO1xuXG52YXIgX3JlbW92ZVByb3BlcnRpZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL21vZGlmaWNhdGlvbnMvcmVtb3ZlUHJvcGVydGllc1wiKSk7XG5cbnZhciBfcmVtb3ZlUHJvcGVydGllc0RlZXAgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL21vZGlmaWNhdGlvbnMvcmVtb3ZlUHJvcGVydGllc0RlZXBcIikpO1xuXG52YXIgX3JlbW92ZVR5cGVEdXBsaWNhdGVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9tb2RpZmljYXRpb25zL2Zsb3cvcmVtb3ZlVHlwZUR1cGxpY2F0ZXNcIikpO1xuXG52YXIgX2dldEJpbmRpbmdJZGVudGlmaWVycyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcmV0cmlldmVycy9nZXRCaW5kaW5nSWRlbnRpZmllcnNcIikpO1xuXG52YXIgX2dldE91dGVyQmluZGluZ0lkZW50aWZpZXJzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9yZXRyaWV2ZXJzL2dldE91dGVyQmluZGluZ0lkZW50aWZpZXJzXCIpKTtcblxudmFyIF90cmF2ZXJzZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdHJhdmVyc2UvdHJhdmVyc2VcIikpO1xuXG52YXIgX3RyYXZlcnNlRmFzdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdHJhdmVyc2UvdHJhdmVyc2VGYXN0XCIpKTtcblxudmFyIF9zaGFsbG93RXF1YWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWxzL3NoYWxsb3dFcXVhbFwiKSk7XG5cbnZhciBfaXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvaXNcIikpO1xuXG52YXIgX2lzQmluZGluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdmFsaWRhdG9ycy9pc0JpbmRpbmdcIikpO1xuXG52YXIgX2lzQmxvY2tTY29wZWQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvaXNCbG9ja1Njb3BlZFwiKSk7XG5cbnZhciBfaXNJbW11dGFibGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvaXNJbW11dGFibGVcIikpO1xuXG52YXIgX2lzTGV0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92YWxpZGF0b3JzL2lzTGV0XCIpKTtcblxudmFyIF9pc05vZGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvaXNOb2RlXCIpKTtcblxudmFyIF9pc05vZGVzRXF1aXZhbGVudCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdmFsaWRhdG9ycy9pc05vZGVzRXF1aXZhbGVudFwiKSk7XG5cbnZhciBfaXNQbGFjZWhvbGRlclR5cGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvaXNQbGFjZWhvbGRlclR5cGVcIikpO1xuXG52YXIgX2lzUmVmZXJlbmNlZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdmFsaWRhdG9ycy9pc1JlZmVyZW5jZWRcIikpO1xuXG52YXIgX2lzU2NvcGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvaXNTY29wZVwiKSk7XG5cbnZhciBfaXNTcGVjaWZpZXJEZWZhdWx0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92YWxpZGF0b3JzL2lzU3BlY2lmaWVyRGVmYXVsdFwiKSk7XG5cbnZhciBfaXNUeXBlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92YWxpZGF0b3JzL2lzVHlwZVwiKSk7XG5cbnZhciBfaXNWYWxpZEVTM0lkZW50aWZpZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvaXNWYWxpZEVTM0lkZW50aWZpZXJcIikpO1xuXG52YXIgX2lzVmFsaWRJZGVudGlmaWVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92YWxpZGF0b3JzL2lzVmFsaWRJZGVudGlmaWVyXCIpKTtcblxudmFyIF9pc1ZhciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdmFsaWRhdG9ycy9pc1ZhclwiKSk7XG5cbnZhciBfbWF0Y2hlc1BhdHRlcm4gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvbWF0Y2hlc1BhdHRlcm5cIikpO1xuXG52YXIgX3ZhbGlkYXRlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92YWxpZGF0b3JzL3ZhbGlkYXRlXCIpKTtcblxudmFyIF9idWlsZE1hdGNoTWVtYmVyRXhwcmVzc2lvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdmFsaWRhdG9ycy9idWlsZE1hdGNoTWVtYmVyRXhwcmVzc2lvblwiKSk7XG5cbnZhciBfZ2VuZXJhdGVkNCA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvZ2VuZXJhdGVkXCIpO1xuXG5PYmplY3Qua2V5cyhfZ2VuZXJhdGVkNCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfZXhwb3J0TmFtZXMsIGtleSkpIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2dlbmVyYXRlZDRba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmNvbnN0IHJlYWN0ID0ge1xuICBpc1JlYWN0Q29tcG9uZW50OiBfaXNSZWFjdENvbXBvbmVudC5kZWZhdWx0LFxuICBpc0NvbXBhdFRhZzogX2lzQ29tcGF0VGFnLmRlZmF1bHQsXG4gIGJ1aWxkQ2hpbGRyZW46IF9idWlsZENoaWxkcmVuLmRlZmF1bHRcbn07XG5leHBvcnRzLnJlYWN0ID0gcmVhY3Q7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBhcHBlbmRUb01lbWJlckV4cHJlc3Npb247XG5cbnZhciBfZ2VuZXJhdGVkID0gcmVxdWlyZShcIi4uL2J1aWxkZXJzL2dlbmVyYXRlZFwiKTtcblxuZnVuY3Rpb24gYXBwZW5kVG9NZW1iZXJFeHByZXNzaW9uKG1lbWJlciwgYXBwZW5kLCBjb21wdXRlZCA9IGZhbHNlKSB7XG4gIG1lbWJlci5vYmplY3QgPSAoMCwgX2dlbmVyYXRlZC5tZW1iZXJFeHByZXNzaW9uKShtZW1iZXIub2JqZWN0LCBtZW1iZXIucHJvcGVydHksIG1lbWJlci5jb21wdXRlZCk7XG4gIG1lbWJlci5wcm9wZXJ0eSA9IGFwcGVuZDtcbiAgbWVtYmVyLmNvbXB1dGVkID0gISFjb21wdXRlZDtcbiAgcmV0dXJuIG1lbWJlcjtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHJlbW92ZVR5cGVEdXBsaWNhdGVzO1xuXG52YXIgX2dlbmVyYXRlZCA9IHJlcXVpcmUoXCIuLi8uLi92YWxpZGF0b3JzL2dlbmVyYXRlZFwiKTtcblxuZnVuY3Rpb24gcmVtb3ZlVHlwZUR1cGxpY2F0ZXMobm9kZXMpIHtcbiAgY29uc3QgZ2VuZXJpY3MgPSB7fTtcbiAgY29uc3QgYmFzZXMgPSB7fTtcbiAgY29uc3QgdHlwZUdyb3VwcyA9IFtdO1xuICBjb25zdCB0eXBlcyA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgaWYgKCFub2RlKSBjb250aW51ZTtcblxuICAgIGlmICh0eXBlcy5pbmRleE9mKG5vZGUpID49IDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICgoMCwgX2dlbmVyYXRlZC5pc0FueVR5cGVBbm5vdGF0aW9uKShub2RlKSkge1xuICAgICAgcmV0dXJuIFtub2RlXTtcbiAgICB9XG5cbiAgICBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNGbG93QmFzZUFubm90YXRpb24pKG5vZGUpKSB7XG4gICAgICBiYXNlc1tub2RlLnR5cGVdID0gbm9kZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICgoMCwgX2dlbmVyYXRlZC5pc1VuaW9uVHlwZUFubm90YXRpb24pKG5vZGUpKSB7XG4gICAgICBpZiAodHlwZUdyb3Vwcy5pbmRleE9mKG5vZGUudHlwZXMpIDwgMCkge1xuICAgICAgICBub2RlcyA9IG5vZGVzLmNvbmNhdChub2RlLnR5cGVzKTtcbiAgICAgICAgdHlwZUdyb3Vwcy5wdXNoKG5vZGUudHlwZXMpO1xuICAgICAgfVxuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNHZW5lcmljVHlwZUFubm90YXRpb24pKG5vZGUpKSB7XG4gICAgICBjb25zdCBuYW1lID0gbm9kZS5pZC5uYW1lO1xuXG4gICAgICBpZiAoZ2VuZXJpY3NbbmFtZV0pIHtcbiAgICAgICAgbGV0IGV4aXN0aW5nID0gZ2VuZXJpY3NbbmFtZV07XG5cbiAgICAgICAgaWYgKGV4aXN0aW5nLnR5cGVQYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgaWYgKG5vZGUudHlwZVBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIGV4aXN0aW5nLnR5cGVQYXJhbWV0ZXJzLnBhcmFtcyA9IHJlbW92ZVR5cGVEdXBsaWNhdGVzKGV4aXN0aW5nLnR5cGVQYXJhbWV0ZXJzLnBhcmFtcy5jb25jYXQobm9kZS50eXBlUGFyYW1ldGVycy5wYXJhbXMpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXhpc3RpbmcgPSBub2RlLnR5cGVQYXJhbWV0ZXJzO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZW5lcmljc1tuYW1lXSA9IG5vZGU7XG4gICAgICB9XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHR5cGVzLnB1c2gobm9kZSk7XG4gIH1cblxuICBmb3IgKGNvbnN0IHR5cGUgb2YgT2JqZWN0LmtleXMoYmFzZXMpKSB7XG4gICAgdHlwZXMucHVzaChiYXNlc1t0eXBlXSk7XG4gIH1cblxuICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMoZ2VuZXJpY3MpKSB7XG4gICAgdHlwZXMucHVzaChnZW5lcmljc1tuYW1lXSk7XG4gIH1cblxuICByZXR1cm4gdHlwZXM7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpbmhlcml0cztcblxudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xuXG52YXIgX2luaGVyaXRzQ29tbWVudHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9jb21tZW50cy9pbmhlcml0c0NvbW1lbnRzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gaW5oZXJpdHMoY2hpbGQsIHBhcmVudCkge1xuICBpZiAoIWNoaWxkIHx8ICFwYXJlbnQpIHJldHVybiBjaGlsZDtcblxuICBmb3IgKGNvbnN0IGtleSBvZiBfY29uc3RhbnRzLklOSEVSSVRfS0VZUy5vcHRpb25hbCkge1xuICAgIGlmIChjaGlsZFtrZXldID09IG51bGwpIHtcbiAgICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhwYXJlbnQpKSB7XG4gICAgaWYgKGtleVswXSA9PT0gXCJfXCIgJiYga2V5ICE9PSBcIl9fY2xvbmVcIikgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xuICB9XG5cbiAgZm9yIChjb25zdCBrZXkgb2YgX2NvbnN0YW50cy5JTkhFUklUX0tFWVMuZm9yY2UpIHtcbiAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG4gIH1cblxuICAoMCwgX2luaGVyaXRzQ29tbWVudHMuZGVmYXVsdCkoY2hpbGQsIHBhcmVudCk7XG4gIHJldHVybiBjaGlsZDtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHByZXBlbmRUb01lbWJlckV4cHJlc3Npb247XG5cbnZhciBfZ2VuZXJhdGVkID0gcmVxdWlyZShcIi4uL2J1aWxkZXJzL2dlbmVyYXRlZFwiKTtcblxuZnVuY3Rpb24gcHJlcGVuZFRvTWVtYmVyRXhwcmVzc2lvbihtZW1iZXIsIHByZXBlbmQpIHtcbiAgbWVtYmVyLm9iamVjdCA9ICgwLCBfZ2VuZXJhdGVkLm1lbWJlckV4cHJlc3Npb24pKHByZXBlbmQsIG1lbWJlci5vYmplY3QpO1xuICByZXR1cm4gbWVtYmVyO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gcmVtb3ZlUHJvcGVydGllcztcblxudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xuXG5jb25zdCBDTEVBUl9LRVlTID0gW1widG9rZW5zXCIsIFwic3RhcnRcIiwgXCJlbmRcIiwgXCJsb2NcIiwgXCJyYXdcIiwgXCJyYXdWYWx1ZVwiXTtcblxuY29uc3QgQ0xFQVJfS0VZU19QTFVTX0NPTU1FTlRTID0gX2NvbnN0YW50cy5DT01NRU5UX0tFWVMuY29uY2F0KFtcImNvbW1lbnRzXCJdKS5jb25jYXQoQ0xFQVJfS0VZUyk7XG5cbmZ1bmN0aW9uIHJlbW92ZVByb3BlcnRpZXMobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IG1hcCA9IG9wdHMucHJlc2VydmVDb21tZW50cyA/IENMRUFSX0tFWVMgOiBDTEVBUl9LRVlTX1BMVVNfQ09NTUVOVFM7XG5cbiAgZm9yIChjb25zdCBrZXkgb2YgbWFwKSB7XG4gICAgaWYgKG5vZGVba2V5XSAhPSBudWxsKSBub2RlW2tleV0gPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhub2RlKSkge1xuICAgIGlmIChrZXlbMF0gPT09IFwiX1wiICYmIG5vZGVba2V5XSAhPSBudWxsKSBub2RlW2tleV0gPSB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhub2RlKTtcblxuICBmb3IgKGNvbnN0IHN5bSBvZiBzeW1ib2xzKSB7XG4gICAgbm9kZVtzeW1dID0gbnVsbDtcbiAgfVxufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gcmVtb3ZlUHJvcGVydGllc0RlZXA7XG5cbnZhciBfdHJhdmVyc2VGYXN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vdHJhdmVyc2UvdHJhdmVyc2VGYXN0XCIpKTtcblxudmFyIF9yZW1vdmVQcm9wZXJ0aWVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9yZW1vdmVQcm9wZXJ0aWVzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gcmVtb3ZlUHJvcGVydGllc0RlZXAodHJlZSwgb3B0cykge1xuICAoMCwgX3RyYXZlcnNlRmFzdC5kZWZhdWx0KSh0cmVlLCBfcmVtb3ZlUHJvcGVydGllcy5kZWZhdWx0LCBvcHRzKTtcbiAgcmV0dXJuIHRyZWU7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSByZW1vdmVUeXBlRHVwbGljYXRlcztcblxudmFyIF9nZW5lcmF0ZWQgPSByZXF1aXJlKFwiLi4vLi4vdmFsaWRhdG9ycy9nZW5lcmF0ZWRcIik7XG5cbmZ1bmN0aW9uIHJlbW92ZVR5cGVEdXBsaWNhdGVzKG5vZGVzKSB7XG4gIGNvbnN0IGdlbmVyaWNzID0ge307XG4gIGNvbnN0IGJhc2VzID0ge307XG4gIGNvbnN0IHR5cGVHcm91cHMgPSBbXTtcbiAgY29uc3QgdHlwZXMgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGlmICghbm9kZSkgY29udGludWU7XG5cbiAgICBpZiAodHlwZXMuaW5kZXhPZihub2RlKSA+PSAwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNUU0FueUtleXdvcmQpKG5vZGUudHlwZSkpIHtcbiAgICAgIHJldHVybiBbbm9kZV07XG4gICAgfVxuXG4gICAgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzVFNCYXNlVHlwZSkobm9kZSkpIHtcbiAgICAgIGJhc2VzW25vZGUudHlwZV0gPSBub2RlO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzVFNVbmlvblR5cGUpKG5vZGUpKSB7XG4gICAgICBpZiAodHlwZUdyb3Vwcy5pbmRleE9mKG5vZGUudHlwZXMpIDwgMCkge1xuICAgICAgICBub2RlcyA9IG5vZGVzLmNvbmNhdChub2RlLnR5cGVzKTtcbiAgICAgICAgdHlwZUdyb3Vwcy5wdXNoKG5vZGUudHlwZXMpO1xuICAgICAgfVxuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB0eXBlcy5wdXNoKG5vZGUpO1xuICB9XG5cbiAgZm9yIChjb25zdCB0eXBlIG9mIE9iamVjdC5rZXlzKGJhc2VzKSkge1xuICAgIHR5cGVzLnB1c2goYmFzZXNbdHlwZV0pO1xuICB9XG5cbiAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKGdlbmVyaWNzKSkge1xuICAgIHR5cGVzLnB1c2goZ2VuZXJpY3NbbmFtZV0pO1xuICB9XG5cbiAgcmV0dXJuIHR5cGVzO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0QmluZGluZ0lkZW50aWZpZXJzO1xuXG52YXIgX2dlbmVyYXRlZCA9IHJlcXVpcmUoXCIuLi92YWxpZGF0b3JzL2dlbmVyYXRlZFwiKTtcblxuZnVuY3Rpb24gZ2V0QmluZGluZ0lkZW50aWZpZXJzKG5vZGUsIGR1cGxpY2F0ZXMsIG91dGVyT25seSkge1xuICBsZXQgc2VhcmNoID0gW10uY29uY2F0KG5vZGUpO1xuICBjb25zdCBpZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIHdoaWxlIChzZWFyY2gubGVuZ3RoKSB7XG4gICAgY29uc3QgaWQgPSBzZWFyY2guc2hpZnQoKTtcbiAgICBpZiAoIWlkKSBjb250aW51ZTtcbiAgICBjb25zdCBrZXlzID0gZ2V0QmluZGluZ0lkZW50aWZpZXJzLmtleXNbaWQudHlwZV07XG5cbiAgICBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNJZGVudGlmaWVyKShpZCkpIHtcbiAgICAgIGlmIChkdXBsaWNhdGVzKSB7XG4gICAgICAgIGNvbnN0IF9pZHMgPSBpZHNbaWQubmFtZV0gPSBpZHNbaWQubmFtZV0gfHwgW107XG5cbiAgICAgICAgX2lkcy5wdXNoKGlkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlkc1tpZC5uYW1lXSA9IGlkO1xuICAgICAgfVxuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNFeHBvcnREZWNsYXJhdGlvbikoaWQpKSB7XG4gICAgICBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNEZWNsYXJhdGlvbikoaWQuZGVjbGFyYXRpb24pKSB7XG4gICAgICAgIHNlYXJjaC5wdXNoKGlkLmRlY2xhcmF0aW9uKTtcbiAgICAgIH1cblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKG91dGVyT25seSkge1xuICAgICAgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzRnVuY3Rpb25EZWNsYXJhdGlvbikoaWQpKSB7XG4gICAgICAgIHNlYXJjaC5wdXNoKGlkLmlkKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICgoMCwgX2dlbmVyYXRlZC5pc0Z1bmN0aW9uRXhwcmVzc2lvbikoaWQpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXlzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoaWRba2V5XSkge1xuICAgICAgICAgIHNlYXJjaCA9IHNlYXJjaC5jb25jYXQoaWRba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gaWRzO1xufVxuXG5nZXRCaW5kaW5nSWRlbnRpZmllcnMua2V5cyA9IHtcbiAgRGVjbGFyZUNsYXNzOiBbXCJpZFwiXSxcbiAgRGVjbGFyZUZ1bmN0aW9uOiBbXCJpZFwiXSxcbiAgRGVjbGFyZU1vZHVsZTogW1wiaWRcIl0sXG4gIERlY2xhcmVWYXJpYWJsZTogW1wiaWRcIl0sXG4gIERlY2xhcmVJbnRlcmZhY2U6IFtcImlkXCJdLFxuICBEZWNsYXJlVHlwZUFsaWFzOiBbXCJpZFwiXSxcbiAgRGVjbGFyZU9wYXF1ZVR5cGU6IFtcImlkXCJdLFxuICBJbnRlcmZhY2VEZWNsYXJhdGlvbjogW1wiaWRcIl0sXG4gIFR5cGVBbGlhczogW1wiaWRcIl0sXG4gIE9wYXF1ZVR5cGU6IFtcImlkXCJdLFxuICBDYXRjaENsYXVzZTogW1wicGFyYW1cIl0sXG4gIExhYmVsZWRTdGF0ZW1lbnQ6IFtcImxhYmVsXCJdLFxuICBVbmFyeUV4cHJlc3Npb246IFtcImFyZ3VtZW50XCJdLFxuICBBc3NpZ25tZW50RXhwcmVzc2lvbjogW1wibGVmdFwiXSxcbiAgSW1wb3J0U3BlY2lmaWVyOiBbXCJsb2NhbFwiXSxcbiAgSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyOiBbXCJsb2NhbFwiXSxcbiAgSW1wb3J0RGVmYXVsdFNwZWNpZmllcjogW1wibG9jYWxcIl0sXG4gIEltcG9ydERlY2xhcmF0aW9uOiBbXCJzcGVjaWZpZXJzXCJdLFxuICBFeHBvcnRTcGVjaWZpZXI6IFtcImV4cG9ydGVkXCJdLFxuICBFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXI6IFtcImV4cG9ydGVkXCJdLFxuICBFeHBvcnREZWZhdWx0U3BlY2lmaWVyOiBbXCJleHBvcnRlZFwiXSxcbiAgRnVuY3Rpb25EZWNsYXJhdGlvbjogW1wiaWRcIiwgXCJwYXJhbXNcIl0sXG4gIEZ1bmN0aW9uRXhwcmVzc2lvbjogW1wiaWRcIiwgXCJwYXJhbXNcIl0sXG4gIEFycm93RnVuY3Rpb25FeHByZXNzaW9uOiBbXCJwYXJhbXNcIl0sXG4gIE9iamVjdE1ldGhvZDogW1wicGFyYW1zXCJdLFxuICBDbGFzc01ldGhvZDogW1wicGFyYW1zXCJdLFxuICBGb3JJblN0YXRlbWVudDogW1wibGVmdFwiXSxcbiAgRm9yT2ZTdGF0ZW1lbnQ6IFtcImxlZnRcIl0sXG4gIENsYXNzRGVjbGFyYXRpb246IFtcImlkXCJdLFxuICBDbGFzc0V4cHJlc3Npb246IFtcImlkXCJdLFxuICBSZXN0RWxlbWVudDogW1wiYXJndW1lbnRcIl0sXG4gIFVwZGF0ZUV4cHJlc3Npb246IFtcImFyZ3VtZW50XCJdLFxuICBPYmplY3RQcm9wZXJ0eTogW1widmFsdWVcIl0sXG4gIEFzc2lnbm1lbnRQYXR0ZXJuOiBbXCJsZWZ0XCJdLFxuICBBcnJheVBhdHRlcm46IFtcImVsZW1lbnRzXCJdLFxuICBPYmplY3RQYXR0ZXJuOiBbXCJwcm9wZXJ0aWVzXCJdLFxuICBWYXJpYWJsZURlY2xhcmF0aW9uOiBbXCJkZWNsYXJhdGlvbnNcIl0sXG4gIFZhcmlhYmxlRGVjbGFyYXRvcjogW1wiaWRcIl1cbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBnZXRPdXRlckJpbmRpbmdJZGVudGlmaWVycztcblxudmFyIF9nZXRCaW5kaW5nSWRlbnRpZmllcnMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2dldEJpbmRpbmdJZGVudGlmaWVyc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGdldE91dGVyQmluZGluZ0lkZW50aWZpZXJzKG5vZGUsIGR1cGxpY2F0ZXMpIHtcbiAgcmV0dXJuICgwLCBfZ2V0QmluZGluZ0lkZW50aWZpZXJzLmRlZmF1bHQpKG5vZGUsIGR1cGxpY2F0ZXMsIHRydWUpO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdHJhdmVyc2U7XG5cbnZhciBfZGVmaW5pdGlvbnMgPSByZXF1aXJlKFwiLi4vZGVmaW5pdGlvbnNcIik7XG5cbmZ1bmN0aW9uIHRyYXZlcnNlKG5vZGUsIGhhbmRsZXJzLCBzdGF0ZSkge1xuICBpZiAodHlwZW9mIGhhbmRsZXJzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBoYW5kbGVycyA9IHtcbiAgICAgIGVudGVyOiBoYW5kbGVyc1xuICAgIH07XG4gIH1cblxuICBjb25zdCB7XG4gICAgZW50ZXIsXG4gICAgZXhpdFxuICB9ID0gaGFuZGxlcnM7XG4gIHRyYXZlcnNlU2ltcGxlSW1wbChub2RlLCBlbnRlciwgZXhpdCwgc3RhdGUsIFtdKTtcbn1cblxuZnVuY3Rpb24gdHJhdmVyc2VTaW1wbGVJbXBsKG5vZGUsIGVudGVyLCBleGl0LCBzdGF0ZSwgYW5jZXN0b3JzKSB7XG4gIGNvbnN0IGtleXMgPSBfZGVmaW5pdGlvbnMuVklTSVRPUl9LRVlTW25vZGUudHlwZV07XG4gIGlmICgha2V5cykgcmV0dXJuO1xuICBpZiAoZW50ZXIpIGVudGVyKG5vZGUsIGFuY2VzdG9ycywgc3RhdGUpO1xuXG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBjb25zdCBzdWJOb2RlID0gbm9kZVtrZXldO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3ViTm9kZSkpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3ViTm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGlsZCA9IHN1Yk5vZGVbaV07XG4gICAgICAgIGlmICghY2hpbGQpIGNvbnRpbnVlO1xuICAgICAgICBhbmNlc3RvcnMucHVzaCh7XG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgfSk7XG4gICAgICAgIHRyYXZlcnNlU2ltcGxlSW1wbChjaGlsZCwgZW50ZXIsIGV4aXQsIHN0YXRlLCBhbmNlc3RvcnMpO1xuICAgICAgICBhbmNlc3RvcnMucG9wKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdWJOb2RlKSB7XG4gICAgICBhbmNlc3RvcnMucHVzaCh7XG4gICAgICAgIG5vZGUsXG4gICAgICAgIGtleVxuICAgICAgfSk7XG4gICAgICB0cmF2ZXJzZVNpbXBsZUltcGwoc3ViTm9kZSwgZW50ZXIsIGV4aXQsIHN0YXRlLCBhbmNlc3RvcnMpO1xuICAgICAgYW5jZXN0b3JzLnBvcCgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChleGl0KSBleGl0KG5vZGUsIGFuY2VzdG9ycywgc3RhdGUpO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdHJhdmVyc2VGYXN0O1xuXG52YXIgX2RlZmluaXRpb25zID0gcmVxdWlyZShcIi4uL2RlZmluaXRpb25zXCIpO1xuXG5mdW5jdGlvbiB0cmF2ZXJzZUZhc3Qobm9kZSwgZW50ZXIsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm47XG4gIGNvbnN0IGtleXMgPSBfZGVmaW5pdGlvbnMuVklTSVRPUl9LRVlTW25vZGUudHlwZV07XG4gIGlmICgha2V5cykgcmV0dXJuO1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgZW50ZXIobm9kZSwgb3B0cyk7XG5cbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGNvbnN0IHN1Yk5vZGUgPSBub2RlW2tleV07XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShzdWJOb2RlKSkge1xuICAgICAgZm9yIChjb25zdCBub2RlIG9mIHN1Yk5vZGUpIHtcbiAgICAgICAgdHJhdmVyc2VGYXN0KG5vZGUsIGVudGVyLCBvcHRzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJhdmVyc2VGYXN0KHN1Yk5vZGUsIGVudGVyLCBvcHRzKTtcbiAgICB9XG4gIH1cbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGluaGVyaXQ7XG5cbmZ1bmN0aW9uIGluaGVyaXQoa2V5LCBjaGlsZCwgcGFyZW50KSB7XG4gIGlmIChjaGlsZCAmJiBwYXJlbnQpIHtcbiAgICBjaGlsZFtrZXldID0gQXJyYXkuZnJvbShuZXcgU2V0KFtdLmNvbmNhdChjaGlsZFtrZXldLCBwYXJlbnRba2V5XSkuZmlsdGVyKEJvb2xlYW4pKSk7XG4gIH1cbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNsZWFuSlNYRWxlbWVudExpdGVyYWxDaGlsZDtcblxudmFyIF9nZW5lcmF0ZWQgPSByZXF1aXJlKFwiLi4vLi4vYnVpbGRlcnMvZ2VuZXJhdGVkXCIpO1xuXG5mdW5jdGlvbiBjbGVhbkpTWEVsZW1lbnRMaXRlcmFsQ2hpbGQoY2hpbGQsIGFyZ3MpIHtcbiAgY29uc3QgbGluZXMgPSBjaGlsZC52YWx1ZS5zcGxpdCgvXFxyXFxufFxcbnxcXHIvKTtcbiAgbGV0IGxhc3ROb25FbXB0eUxpbmUgPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobGluZXNbaV0ubWF0Y2goL1teIFxcdF0vKSkge1xuICAgICAgbGFzdE5vbkVtcHR5TGluZSA9IGk7XG4gICAgfVxuICB9XG5cbiAgbGV0IHN0ciA9IFwiXCI7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXTtcbiAgICBjb25zdCBpc0ZpcnN0TGluZSA9IGkgPT09IDA7XG4gICAgY29uc3QgaXNMYXN0TGluZSA9IGkgPT09IGxpbmVzLmxlbmd0aCAtIDE7XG4gICAgY29uc3QgaXNMYXN0Tm9uRW1wdHlMaW5lID0gaSA9PT0gbGFzdE5vbkVtcHR5TGluZTtcbiAgICBsZXQgdHJpbW1lZExpbmUgPSBsaW5lLnJlcGxhY2UoL1xcdC9nLCBcIiBcIik7XG5cbiAgICBpZiAoIWlzRmlyc3RMaW5lKSB7XG4gICAgICB0cmltbWVkTGluZSA9IHRyaW1tZWRMaW5lLnJlcGxhY2UoL15bIF0rLywgXCJcIik7XG4gICAgfVxuXG4gICAgaWYgKCFpc0xhc3RMaW5lKSB7XG4gICAgICB0cmltbWVkTGluZSA9IHRyaW1tZWRMaW5lLnJlcGxhY2UoL1sgXSskLywgXCJcIik7XG4gICAgfVxuXG4gICAgaWYgKHRyaW1tZWRMaW5lKSB7XG4gICAgICBpZiAoIWlzTGFzdE5vbkVtcHR5TGluZSkge1xuICAgICAgICB0cmltbWVkTGluZSArPSBcIiBcIjtcbiAgICAgIH1cblxuICAgICAgc3RyICs9IHRyaW1tZWRMaW5lO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdHIpIGFyZ3MucHVzaCgoMCwgX2dlbmVyYXRlZC5zdHJpbmdMaXRlcmFsKShzdHIpKTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHNoYWxsb3dFcXVhbDtcblxuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGV4cGVjdGVkKTtcblxuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgaWYgKGFjdHVhbFtrZXldICE9PSBleHBlY3RlZFtrZXldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBidWlsZE1hdGNoTWVtYmVyRXhwcmVzc2lvbjtcblxudmFyIF9tYXRjaGVzUGF0dGVybiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbWF0Y2hlc1BhdHRlcm5cIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBidWlsZE1hdGNoTWVtYmVyRXhwcmVzc2lvbihtYXRjaCwgYWxsb3dQYXJ0aWFsKSB7XG4gIGNvbnN0IHBhcnRzID0gbWF0Y2guc3BsaXQoXCIuXCIpO1xuICByZXR1cm4gbWVtYmVyID0+ICgwLCBfbWF0Y2hlc1BhdHRlcm4uZGVmYXVsdCkobWVtYmVyLCBwYXJ0cywgYWxsb3dQYXJ0aWFsKTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuaXNBcnJheUV4cHJlc3Npb24gPSBpc0FycmF5RXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNBc3NpZ25tZW50RXhwcmVzc2lvbiA9IGlzQXNzaWdubWVudEV4cHJlc3Npb247XG5leHBvcnRzLmlzQmluYXJ5RXhwcmVzc2lvbiA9IGlzQmluYXJ5RXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNJbnRlcnByZXRlckRpcmVjdGl2ZSA9IGlzSW50ZXJwcmV0ZXJEaXJlY3RpdmU7XG5leHBvcnRzLmlzRGlyZWN0aXZlID0gaXNEaXJlY3RpdmU7XG5leHBvcnRzLmlzRGlyZWN0aXZlTGl0ZXJhbCA9IGlzRGlyZWN0aXZlTGl0ZXJhbDtcbmV4cG9ydHMuaXNCbG9ja1N0YXRlbWVudCA9IGlzQmxvY2tTdGF0ZW1lbnQ7XG5leHBvcnRzLmlzQnJlYWtTdGF0ZW1lbnQgPSBpc0JyZWFrU3RhdGVtZW50O1xuZXhwb3J0cy5pc0NhbGxFeHByZXNzaW9uID0gaXNDYWxsRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNDYXRjaENsYXVzZSA9IGlzQ2F0Y2hDbGF1c2U7XG5leHBvcnRzLmlzQ29uZGl0aW9uYWxFeHByZXNzaW9uID0gaXNDb25kaXRpb25hbEV4cHJlc3Npb247XG5leHBvcnRzLmlzQ29udGludWVTdGF0ZW1lbnQgPSBpc0NvbnRpbnVlU3RhdGVtZW50O1xuZXhwb3J0cy5pc0RlYnVnZ2VyU3RhdGVtZW50ID0gaXNEZWJ1Z2dlclN0YXRlbWVudDtcbmV4cG9ydHMuaXNEb1doaWxlU3RhdGVtZW50ID0gaXNEb1doaWxlU3RhdGVtZW50O1xuZXhwb3J0cy5pc0VtcHR5U3RhdGVtZW50ID0gaXNFbXB0eVN0YXRlbWVudDtcbmV4cG9ydHMuaXNFeHByZXNzaW9uU3RhdGVtZW50ID0gaXNFeHByZXNzaW9uU3RhdGVtZW50O1xuZXhwb3J0cy5pc0ZpbGUgPSBpc0ZpbGU7XG5leHBvcnRzLmlzRm9ySW5TdGF0ZW1lbnQgPSBpc0ZvckluU3RhdGVtZW50O1xuZXhwb3J0cy5pc0ZvclN0YXRlbWVudCA9IGlzRm9yU3RhdGVtZW50O1xuZXhwb3J0cy5pc0Z1bmN0aW9uRGVjbGFyYXRpb24gPSBpc0Z1bmN0aW9uRGVjbGFyYXRpb247XG5leHBvcnRzLmlzRnVuY3Rpb25FeHByZXNzaW9uID0gaXNGdW5jdGlvbkV4cHJlc3Npb247XG5leHBvcnRzLmlzSWRlbnRpZmllciA9IGlzSWRlbnRpZmllcjtcbmV4cG9ydHMuaXNJZlN0YXRlbWVudCA9IGlzSWZTdGF0ZW1lbnQ7XG5leHBvcnRzLmlzTGFiZWxlZFN0YXRlbWVudCA9IGlzTGFiZWxlZFN0YXRlbWVudDtcbmV4cG9ydHMuaXNTdHJpbmdMaXRlcmFsID0gaXNTdHJpbmdMaXRlcmFsO1xuZXhwb3J0cy5pc051bWVyaWNMaXRlcmFsID0gaXNOdW1lcmljTGl0ZXJhbDtcbmV4cG9ydHMuaXNOdWxsTGl0ZXJhbCA9IGlzTnVsbExpdGVyYWw7XG5leHBvcnRzLmlzQm9vbGVhbkxpdGVyYWwgPSBpc0Jvb2xlYW5MaXRlcmFsO1xuZXhwb3J0cy5pc1JlZ0V4cExpdGVyYWwgPSBpc1JlZ0V4cExpdGVyYWw7XG5leHBvcnRzLmlzTG9naWNhbEV4cHJlc3Npb24gPSBpc0xvZ2ljYWxFeHByZXNzaW9uO1xuZXhwb3J0cy5pc01lbWJlckV4cHJlc3Npb24gPSBpc01lbWJlckV4cHJlc3Npb247XG5leHBvcnRzLmlzTmV3RXhwcmVzc2lvbiA9IGlzTmV3RXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNQcm9ncmFtID0gaXNQcm9ncmFtO1xuZXhwb3J0cy5pc09iamVjdEV4cHJlc3Npb24gPSBpc09iamVjdEV4cHJlc3Npb247XG5leHBvcnRzLmlzT2JqZWN0TWV0aG9kID0gaXNPYmplY3RNZXRob2Q7XG5leHBvcnRzLmlzT2JqZWN0UHJvcGVydHkgPSBpc09iamVjdFByb3BlcnR5O1xuZXhwb3J0cy5pc1Jlc3RFbGVtZW50ID0gaXNSZXN0RWxlbWVudDtcbmV4cG9ydHMuaXNSZXR1cm5TdGF0ZW1lbnQgPSBpc1JldHVyblN0YXRlbWVudDtcbmV4cG9ydHMuaXNTZXF1ZW5jZUV4cHJlc3Npb24gPSBpc1NlcXVlbmNlRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNQYXJlbnRoZXNpemVkRXhwcmVzc2lvbiA9IGlzUGFyZW50aGVzaXplZEV4cHJlc3Npb247XG5leHBvcnRzLmlzU3dpdGNoQ2FzZSA9IGlzU3dpdGNoQ2FzZTtcbmV4cG9ydHMuaXNTd2l0Y2hTdGF0ZW1lbnQgPSBpc1N3aXRjaFN0YXRlbWVudDtcbmV4cG9ydHMuaXNUaGlzRXhwcmVzc2lvbiA9IGlzVGhpc0V4cHJlc3Npb247XG5leHBvcnRzLmlzVGhyb3dTdGF0ZW1lbnQgPSBpc1Rocm93U3RhdGVtZW50O1xuZXhwb3J0cy5pc1RyeVN0YXRlbWVudCA9IGlzVHJ5U3RhdGVtZW50O1xuZXhwb3J0cy5pc1VuYXJ5RXhwcmVzc2lvbiA9IGlzVW5hcnlFeHByZXNzaW9uO1xuZXhwb3J0cy5pc1VwZGF0ZUV4cHJlc3Npb24gPSBpc1VwZGF0ZUV4cHJlc3Npb247XG5leHBvcnRzLmlzVmFyaWFibGVEZWNsYXJhdGlvbiA9IGlzVmFyaWFibGVEZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNWYXJpYWJsZURlY2xhcmF0b3IgPSBpc1ZhcmlhYmxlRGVjbGFyYXRvcjtcbmV4cG9ydHMuaXNXaGlsZVN0YXRlbWVudCA9IGlzV2hpbGVTdGF0ZW1lbnQ7XG5leHBvcnRzLmlzV2l0aFN0YXRlbWVudCA9IGlzV2l0aFN0YXRlbWVudDtcbmV4cG9ydHMuaXNBc3NpZ25tZW50UGF0dGVybiA9IGlzQXNzaWdubWVudFBhdHRlcm47XG5leHBvcnRzLmlzQXJyYXlQYXR0ZXJuID0gaXNBcnJheVBhdHRlcm47XG5leHBvcnRzLmlzQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24gPSBpc0Fycm93RnVuY3Rpb25FeHByZXNzaW9uO1xuZXhwb3J0cy5pc0NsYXNzQm9keSA9IGlzQ2xhc3NCb2R5O1xuZXhwb3J0cy5pc0NsYXNzRXhwcmVzc2lvbiA9IGlzQ2xhc3NFeHByZXNzaW9uO1xuZXhwb3J0cy5pc0NsYXNzRGVjbGFyYXRpb24gPSBpc0NsYXNzRGVjbGFyYXRpb247XG5leHBvcnRzLmlzRXhwb3J0QWxsRGVjbGFyYXRpb24gPSBpc0V4cG9ydEFsbERlY2xhcmF0aW9uO1xuZXhwb3J0cy5pc0V4cG9ydERlZmF1bHREZWNsYXJhdGlvbiA9IGlzRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uO1xuZXhwb3J0cy5pc0V4cG9ydE5hbWVkRGVjbGFyYXRpb24gPSBpc0V4cG9ydE5hbWVkRGVjbGFyYXRpb247XG5leHBvcnRzLmlzRXhwb3J0U3BlY2lmaWVyID0gaXNFeHBvcnRTcGVjaWZpZXI7XG5leHBvcnRzLmlzRm9yT2ZTdGF0ZW1lbnQgPSBpc0Zvck9mU3RhdGVtZW50O1xuZXhwb3J0cy5pc0ltcG9ydERlY2xhcmF0aW9uID0gaXNJbXBvcnREZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNJbXBvcnREZWZhdWx0U3BlY2lmaWVyID0gaXNJbXBvcnREZWZhdWx0U3BlY2lmaWVyO1xuZXhwb3J0cy5pc0ltcG9ydE5hbWVzcGFjZVNwZWNpZmllciA9IGlzSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyO1xuZXhwb3J0cy5pc0ltcG9ydFNwZWNpZmllciA9IGlzSW1wb3J0U3BlY2lmaWVyO1xuZXhwb3J0cy5pc01ldGFQcm9wZXJ0eSA9IGlzTWV0YVByb3BlcnR5O1xuZXhwb3J0cy5pc0NsYXNzTWV0aG9kID0gaXNDbGFzc01ldGhvZDtcbmV4cG9ydHMuaXNPYmplY3RQYXR0ZXJuID0gaXNPYmplY3RQYXR0ZXJuO1xuZXhwb3J0cy5pc1NwcmVhZEVsZW1lbnQgPSBpc1NwcmVhZEVsZW1lbnQ7XG5leHBvcnRzLmlzU3VwZXIgPSBpc1N1cGVyO1xuZXhwb3J0cy5pc1RhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbiA9IGlzVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uO1xuZXhwb3J0cy5pc1RlbXBsYXRlRWxlbWVudCA9IGlzVGVtcGxhdGVFbGVtZW50O1xuZXhwb3J0cy5pc1RlbXBsYXRlTGl0ZXJhbCA9IGlzVGVtcGxhdGVMaXRlcmFsO1xuZXhwb3J0cy5pc1lpZWxkRXhwcmVzc2lvbiA9IGlzWWllbGRFeHByZXNzaW9uO1xuZXhwb3J0cy5pc0F3YWl0RXhwcmVzc2lvbiA9IGlzQXdhaXRFeHByZXNzaW9uO1xuZXhwb3J0cy5pc0ltcG9ydCA9IGlzSW1wb3J0O1xuZXhwb3J0cy5pc0JpZ0ludExpdGVyYWwgPSBpc0JpZ0ludExpdGVyYWw7XG5leHBvcnRzLmlzRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyID0gaXNFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXI7XG5leHBvcnRzLmlzT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uID0gaXNPcHRpb25hbE1lbWJlckV4cHJlc3Npb247XG5leHBvcnRzLmlzT3B0aW9uYWxDYWxsRXhwcmVzc2lvbiA9IGlzT3B0aW9uYWxDYWxsRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNBbnlUeXBlQW5ub3RhdGlvbiA9IGlzQW55VHlwZUFubm90YXRpb247XG5leHBvcnRzLmlzQXJyYXlUeXBlQW5ub3RhdGlvbiA9IGlzQXJyYXlUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNCb29sZWFuVHlwZUFubm90YXRpb24gPSBpc0Jvb2xlYW5UeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNCb29sZWFuTGl0ZXJhbFR5cGVBbm5vdGF0aW9uID0gaXNCb29sZWFuTGl0ZXJhbFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc051bGxMaXRlcmFsVHlwZUFubm90YXRpb24gPSBpc051bGxMaXRlcmFsVHlwZUFubm90YXRpb247XG5leHBvcnRzLmlzQ2xhc3NJbXBsZW1lbnRzID0gaXNDbGFzc0ltcGxlbWVudHM7XG5leHBvcnRzLmlzRGVjbGFyZUNsYXNzID0gaXNEZWNsYXJlQ2xhc3M7XG5leHBvcnRzLmlzRGVjbGFyZUZ1bmN0aW9uID0gaXNEZWNsYXJlRnVuY3Rpb247XG5leHBvcnRzLmlzRGVjbGFyZUludGVyZmFjZSA9IGlzRGVjbGFyZUludGVyZmFjZTtcbmV4cG9ydHMuaXNEZWNsYXJlTW9kdWxlID0gaXNEZWNsYXJlTW9kdWxlO1xuZXhwb3J0cy5pc0RlY2xhcmVNb2R1bGVFeHBvcnRzID0gaXNEZWNsYXJlTW9kdWxlRXhwb3J0cztcbmV4cG9ydHMuaXNEZWNsYXJlVHlwZUFsaWFzID0gaXNEZWNsYXJlVHlwZUFsaWFzO1xuZXhwb3J0cy5pc0RlY2xhcmVPcGFxdWVUeXBlID0gaXNEZWNsYXJlT3BhcXVlVHlwZTtcbmV4cG9ydHMuaXNEZWNsYXJlVmFyaWFibGUgPSBpc0RlY2xhcmVWYXJpYWJsZTtcbmV4cG9ydHMuaXNEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb24gPSBpc0RlY2xhcmVFeHBvcnREZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNEZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb24gPSBpc0RlY2xhcmVFeHBvcnRBbGxEZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNEZWNsYXJlZFByZWRpY2F0ZSA9IGlzRGVjbGFyZWRQcmVkaWNhdGU7XG5leHBvcnRzLmlzRXhpc3RzVHlwZUFubm90YXRpb24gPSBpc0V4aXN0c1R5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc0Z1bmN0aW9uVHlwZUFubm90YXRpb24gPSBpc0Z1bmN0aW9uVHlwZUFubm90YXRpb247XG5leHBvcnRzLmlzRnVuY3Rpb25UeXBlUGFyYW0gPSBpc0Z1bmN0aW9uVHlwZVBhcmFtO1xuZXhwb3J0cy5pc0dlbmVyaWNUeXBlQW5ub3RhdGlvbiA9IGlzR2VuZXJpY1R5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc0luZmVycmVkUHJlZGljYXRlID0gaXNJbmZlcnJlZFByZWRpY2F0ZTtcbmV4cG9ydHMuaXNJbnRlcmZhY2VFeHRlbmRzID0gaXNJbnRlcmZhY2VFeHRlbmRzO1xuZXhwb3J0cy5pc0ludGVyZmFjZURlY2xhcmF0aW9uID0gaXNJbnRlcmZhY2VEZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNJbnRlcmZhY2VUeXBlQW5ub3RhdGlvbiA9IGlzSW50ZXJmYWNlVHlwZUFubm90YXRpb247XG5leHBvcnRzLmlzSW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb24gPSBpc0ludGVyc2VjdGlvblR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc01peGVkVHlwZUFubm90YXRpb24gPSBpc01peGVkVHlwZUFubm90YXRpb247XG5leHBvcnRzLmlzRW1wdHlUeXBlQW5ub3RhdGlvbiA9IGlzRW1wdHlUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNOdWxsYWJsZVR5cGVBbm5vdGF0aW9uID0gaXNOdWxsYWJsZVR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc051bWJlckxpdGVyYWxUeXBlQW5ub3RhdGlvbiA9IGlzTnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc051bWJlclR5cGVBbm5vdGF0aW9uID0gaXNOdW1iZXJUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNPYmplY3RUeXBlQW5ub3RhdGlvbiA9IGlzT2JqZWN0VHlwZUFubm90YXRpb247XG5leHBvcnRzLmlzT2JqZWN0VHlwZUludGVybmFsU2xvdCA9IGlzT2JqZWN0VHlwZUludGVybmFsU2xvdDtcbmV4cG9ydHMuaXNPYmplY3RUeXBlQ2FsbFByb3BlcnR5ID0gaXNPYmplY3RUeXBlQ2FsbFByb3BlcnR5O1xuZXhwb3J0cy5pc09iamVjdFR5cGVJbmRleGVyID0gaXNPYmplY3RUeXBlSW5kZXhlcjtcbmV4cG9ydHMuaXNPYmplY3RUeXBlUHJvcGVydHkgPSBpc09iamVjdFR5cGVQcm9wZXJ0eTtcbmV4cG9ydHMuaXNPYmplY3RUeXBlU3ByZWFkUHJvcGVydHkgPSBpc09iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eTtcbmV4cG9ydHMuaXNPcGFxdWVUeXBlID0gaXNPcGFxdWVUeXBlO1xuZXhwb3J0cy5pc1F1YWxpZmllZFR5cGVJZGVudGlmaWVyID0gaXNRdWFsaWZpZWRUeXBlSWRlbnRpZmllcjtcbmV4cG9ydHMuaXNTdHJpbmdMaXRlcmFsVHlwZUFubm90YXRpb24gPSBpc1N0cmluZ0xpdGVyYWxUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNTdHJpbmdUeXBlQW5ub3RhdGlvbiA9IGlzU3RyaW5nVHlwZUFubm90YXRpb247XG5leHBvcnRzLmlzU3ltYm9sVHlwZUFubm90YXRpb24gPSBpc1N5bWJvbFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc1RoaXNUeXBlQW5ub3RhdGlvbiA9IGlzVGhpc1R5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc1R1cGxlVHlwZUFubm90YXRpb24gPSBpc1R1cGxlVHlwZUFubm90YXRpb247XG5leHBvcnRzLmlzVHlwZW9mVHlwZUFubm90YXRpb24gPSBpc1R5cGVvZlR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc1R5cGVBbGlhcyA9IGlzVHlwZUFsaWFzO1xuZXhwb3J0cy5pc1R5cGVBbm5vdGF0aW9uID0gaXNUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNUeXBlQ2FzdEV4cHJlc3Npb24gPSBpc1R5cGVDYXN0RXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNUeXBlUGFyYW1ldGVyID0gaXNUeXBlUGFyYW1ldGVyO1xuZXhwb3J0cy5pc1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbiA9IGlzVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uO1xuZXhwb3J0cy5pc1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uID0gaXNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbjtcbmV4cG9ydHMuaXNVbmlvblR5cGVBbm5vdGF0aW9uID0gaXNVbmlvblR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc1ZhcmlhbmNlID0gaXNWYXJpYW5jZTtcbmV4cG9ydHMuaXNWb2lkVHlwZUFubm90YXRpb24gPSBpc1ZvaWRUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNFbnVtRGVjbGFyYXRpb24gPSBpc0VudW1EZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNFbnVtQm9vbGVhbkJvZHkgPSBpc0VudW1Cb29sZWFuQm9keTtcbmV4cG9ydHMuaXNFbnVtTnVtYmVyQm9keSA9IGlzRW51bU51bWJlckJvZHk7XG5leHBvcnRzLmlzRW51bVN0cmluZ0JvZHkgPSBpc0VudW1TdHJpbmdCb2R5O1xuZXhwb3J0cy5pc0VudW1TeW1ib2xCb2R5ID0gaXNFbnVtU3ltYm9sQm9keTtcbmV4cG9ydHMuaXNFbnVtQm9vbGVhbk1lbWJlciA9IGlzRW51bUJvb2xlYW5NZW1iZXI7XG5leHBvcnRzLmlzRW51bU51bWJlck1lbWJlciA9IGlzRW51bU51bWJlck1lbWJlcjtcbmV4cG9ydHMuaXNFbnVtU3RyaW5nTWVtYmVyID0gaXNFbnVtU3RyaW5nTWVtYmVyO1xuZXhwb3J0cy5pc0VudW1EZWZhdWx0ZWRNZW1iZXIgPSBpc0VudW1EZWZhdWx0ZWRNZW1iZXI7XG5leHBvcnRzLmlzSlNYQXR0cmlidXRlID0gaXNKU1hBdHRyaWJ1dGU7XG5leHBvcnRzLmlzSlNYQ2xvc2luZ0VsZW1lbnQgPSBpc0pTWENsb3NpbmdFbGVtZW50O1xuZXhwb3J0cy5pc0pTWEVsZW1lbnQgPSBpc0pTWEVsZW1lbnQ7XG5leHBvcnRzLmlzSlNYRW1wdHlFeHByZXNzaW9uID0gaXNKU1hFbXB0eUV4cHJlc3Npb247XG5leHBvcnRzLmlzSlNYRXhwcmVzc2lvbkNvbnRhaW5lciA9IGlzSlNYRXhwcmVzc2lvbkNvbnRhaW5lcjtcbmV4cG9ydHMuaXNKU1hTcHJlYWRDaGlsZCA9IGlzSlNYU3ByZWFkQ2hpbGQ7XG5leHBvcnRzLmlzSlNYSWRlbnRpZmllciA9IGlzSlNYSWRlbnRpZmllcjtcbmV4cG9ydHMuaXNKU1hNZW1iZXJFeHByZXNzaW9uID0gaXNKU1hNZW1iZXJFeHByZXNzaW9uO1xuZXhwb3J0cy5pc0pTWE5hbWVzcGFjZWROYW1lID0gaXNKU1hOYW1lc3BhY2VkTmFtZTtcbmV4cG9ydHMuaXNKU1hPcGVuaW5nRWxlbWVudCA9IGlzSlNYT3BlbmluZ0VsZW1lbnQ7XG5leHBvcnRzLmlzSlNYU3ByZWFkQXR0cmlidXRlID0gaXNKU1hTcHJlYWRBdHRyaWJ1dGU7XG5leHBvcnRzLmlzSlNYVGV4dCA9IGlzSlNYVGV4dDtcbmV4cG9ydHMuaXNKU1hGcmFnbWVudCA9IGlzSlNYRnJhZ21lbnQ7XG5leHBvcnRzLmlzSlNYT3BlbmluZ0ZyYWdtZW50ID0gaXNKU1hPcGVuaW5nRnJhZ21lbnQ7XG5leHBvcnRzLmlzSlNYQ2xvc2luZ0ZyYWdtZW50ID0gaXNKU1hDbG9zaW5nRnJhZ21lbnQ7XG5leHBvcnRzLmlzTm9vcCA9IGlzTm9vcDtcbmV4cG9ydHMuaXNQbGFjZWhvbGRlciA9IGlzUGxhY2Vob2xkZXI7XG5leHBvcnRzLmlzVjhJbnRyaW5zaWNJZGVudGlmaWVyID0gaXNWOEludHJpbnNpY0lkZW50aWZpZXI7XG5leHBvcnRzLmlzQXJndW1lbnRQbGFjZWhvbGRlciA9IGlzQXJndW1lbnRQbGFjZWhvbGRlcjtcbmV4cG9ydHMuaXNCaW5kRXhwcmVzc2lvbiA9IGlzQmluZEV4cHJlc3Npb247XG5leHBvcnRzLmlzQ2xhc3NQcm9wZXJ0eSA9IGlzQ2xhc3NQcm9wZXJ0eTtcbmV4cG9ydHMuaXNQaXBlbGluZVRvcGljRXhwcmVzc2lvbiA9IGlzUGlwZWxpbmVUb3BpY0V4cHJlc3Npb247XG5leHBvcnRzLmlzUGlwZWxpbmVCYXJlRnVuY3Rpb24gPSBpc1BpcGVsaW5lQmFyZUZ1bmN0aW9uO1xuZXhwb3J0cy5pc1BpcGVsaW5lUHJpbWFyeVRvcGljUmVmZXJlbmNlID0gaXNQaXBlbGluZVByaW1hcnlUb3BpY1JlZmVyZW5jZTtcbmV4cG9ydHMuaXNDbGFzc1ByaXZhdGVQcm9wZXJ0eSA9IGlzQ2xhc3NQcml2YXRlUHJvcGVydHk7XG5leHBvcnRzLmlzQ2xhc3NQcml2YXRlTWV0aG9kID0gaXNDbGFzc1ByaXZhdGVNZXRob2Q7XG5leHBvcnRzLmlzSW1wb3J0QXR0cmlidXRlID0gaXNJbXBvcnRBdHRyaWJ1dGU7XG5leHBvcnRzLmlzRGVjb3JhdG9yID0gaXNEZWNvcmF0b3I7XG5leHBvcnRzLmlzRG9FeHByZXNzaW9uID0gaXNEb0V4cHJlc3Npb247XG5leHBvcnRzLmlzRXhwb3J0RGVmYXVsdFNwZWNpZmllciA9IGlzRXhwb3J0RGVmYXVsdFNwZWNpZmllcjtcbmV4cG9ydHMuaXNQcml2YXRlTmFtZSA9IGlzUHJpdmF0ZU5hbWU7XG5leHBvcnRzLmlzUmVjb3JkRXhwcmVzc2lvbiA9IGlzUmVjb3JkRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNUdXBsZUV4cHJlc3Npb24gPSBpc1R1cGxlRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNEZWNpbWFsTGl0ZXJhbCA9IGlzRGVjaW1hbExpdGVyYWw7XG5leHBvcnRzLmlzVFNQYXJhbWV0ZXJQcm9wZXJ0eSA9IGlzVFNQYXJhbWV0ZXJQcm9wZXJ0eTtcbmV4cG9ydHMuaXNUU0RlY2xhcmVGdW5jdGlvbiA9IGlzVFNEZWNsYXJlRnVuY3Rpb247XG5leHBvcnRzLmlzVFNEZWNsYXJlTWV0aG9kID0gaXNUU0RlY2xhcmVNZXRob2Q7XG5leHBvcnRzLmlzVFNRdWFsaWZpZWROYW1lID0gaXNUU1F1YWxpZmllZE5hbWU7XG5leHBvcnRzLmlzVFNDYWxsU2lnbmF0dXJlRGVjbGFyYXRpb24gPSBpc1RTQ2FsbFNpZ25hdHVyZURlY2xhcmF0aW9uO1xuZXhwb3J0cy5pc1RTQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb24gPSBpc1RTQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb247XG5leHBvcnRzLmlzVFNQcm9wZXJ0eVNpZ25hdHVyZSA9IGlzVFNQcm9wZXJ0eVNpZ25hdHVyZTtcbmV4cG9ydHMuaXNUU01ldGhvZFNpZ25hdHVyZSA9IGlzVFNNZXRob2RTaWduYXR1cmU7XG5leHBvcnRzLmlzVFNJbmRleFNpZ25hdHVyZSA9IGlzVFNJbmRleFNpZ25hdHVyZTtcbmV4cG9ydHMuaXNUU0FueUtleXdvcmQgPSBpc1RTQW55S2V5d29yZDtcbmV4cG9ydHMuaXNUU0Jvb2xlYW5LZXl3b3JkID0gaXNUU0Jvb2xlYW5LZXl3b3JkO1xuZXhwb3J0cy5pc1RTQmlnSW50S2V5d29yZCA9IGlzVFNCaWdJbnRLZXl3b3JkO1xuZXhwb3J0cy5pc1RTTmV2ZXJLZXl3b3JkID0gaXNUU05ldmVyS2V5d29yZDtcbmV4cG9ydHMuaXNUU051bGxLZXl3b3JkID0gaXNUU051bGxLZXl3b3JkO1xuZXhwb3J0cy5pc1RTTnVtYmVyS2V5d29yZCA9IGlzVFNOdW1iZXJLZXl3b3JkO1xuZXhwb3J0cy5pc1RTT2JqZWN0S2V5d29yZCA9IGlzVFNPYmplY3RLZXl3b3JkO1xuZXhwb3J0cy5pc1RTU3RyaW5nS2V5d29yZCA9IGlzVFNTdHJpbmdLZXl3b3JkO1xuZXhwb3J0cy5pc1RTU3ltYm9sS2V5d29yZCA9IGlzVFNTeW1ib2xLZXl3b3JkO1xuZXhwb3J0cy5pc1RTVW5kZWZpbmVkS2V5d29yZCA9IGlzVFNVbmRlZmluZWRLZXl3b3JkO1xuZXhwb3J0cy5pc1RTVW5rbm93bktleXdvcmQgPSBpc1RTVW5rbm93bktleXdvcmQ7XG5leHBvcnRzLmlzVFNWb2lkS2V5d29yZCA9IGlzVFNWb2lkS2V5d29yZDtcbmV4cG9ydHMuaXNUU1RoaXNUeXBlID0gaXNUU1RoaXNUeXBlO1xuZXhwb3J0cy5pc1RTRnVuY3Rpb25UeXBlID0gaXNUU0Z1bmN0aW9uVHlwZTtcbmV4cG9ydHMuaXNUU0NvbnN0cnVjdG9yVHlwZSA9IGlzVFNDb25zdHJ1Y3RvclR5cGU7XG5leHBvcnRzLmlzVFNUeXBlUmVmZXJlbmNlID0gaXNUU1R5cGVSZWZlcmVuY2U7XG5leHBvcnRzLmlzVFNUeXBlUHJlZGljYXRlID0gaXNUU1R5cGVQcmVkaWNhdGU7XG5leHBvcnRzLmlzVFNUeXBlUXVlcnkgPSBpc1RTVHlwZVF1ZXJ5O1xuZXhwb3J0cy5pc1RTVHlwZUxpdGVyYWwgPSBpc1RTVHlwZUxpdGVyYWw7XG5leHBvcnRzLmlzVFNBcnJheVR5cGUgPSBpc1RTQXJyYXlUeXBlO1xuZXhwb3J0cy5pc1RTVHVwbGVUeXBlID0gaXNUU1R1cGxlVHlwZTtcbmV4cG9ydHMuaXNUU09wdGlvbmFsVHlwZSA9IGlzVFNPcHRpb25hbFR5cGU7XG5leHBvcnRzLmlzVFNSZXN0VHlwZSA9IGlzVFNSZXN0VHlwZTtcbmV4cG9ydHMuaXNUU05hbWVkVHVwbGVNZW1iZXIgPSBpc1RTTmFtZWRUdXBsZU1lbWJlcjtcbmV4cG9ydHMuaXNUU1VuaW9uVHlwZSA9IGlzVFNVbmlvblR5cGU7XG5leHBvcnRzLmlzVFNJbnRlcnNlY3Rpb25UeXBlID0gaXNUU0ludGVyc2VjdGlvblR5cGU7XG5leHBvcnRzLmlzVFNDb25kaXRpb25hbFR5cGUgPSBpc1RTQ29uZGl0aW9uYWxUeXBlO1xuZXhwb3J0cy5pc1RTSW5mZXJUeXBlID0gaXNUU0luZmVyVHlwZTtcbmV4cG9ydHMuaXNUU1BhcmVudGhlc2l6ZWRUeXBlID0gaXNUU1BhcmVudGhlc2l6ZWRUeXBlO1xuZXhwb3J0cy5pc1RTVHlwZU9wZXJhdG9yID0gaXNUU1R5cGVPcGVyYXRvcjtcbmV4cG9ydHMuaXNUU0luZGV4ZWRBY2Nlc3NUeXBlID0gaXNUU0luZGV4ZWRBY2Nlc3NUeXBlO1xuZXhwb3J0cy5pc1RTTWFwcGVkVHlwZSA9IGlzVFNNYXBwZWRUeXBlO1xuZXhwb3J0cy5pc1RTTGl0ZXJhbFR5cGUgPSBpc1RTTGl0ZXJhbFR5cGU7XG5leHBvcnRzLmlzVFNFeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHMgPSBpc1RTRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzO1xuZXhwb3J0cy5pc1RTSW50ZXJmYWNlRGVjbGFyYXRpb24gPSBpc1RTSW50ZXJmYWNlRGVjbGFyYXRpb247XG5leHBvcnRzLmlzVFNJbnRlcmZhY2VCb2R5ID0gaXNUU0ludGVyZmFjZUJvZHk7XG5leHBvcnRzLmlzVFNUeXBlQWxpYXNEZWNsYXJhdGlvbiA9IGlzVFNUeXBlQWxpYXNEZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNUU0FzRXhwcmVzc2lvbiA9IGlzVFNBc0V4cHJlc3Npb247XG5leHBvcnRzLmlzVFNUeXBlQXNzZXJ0aW9uID0gaXNUU1R5cGVBc3NlcnRpb247XG5leHBvcnRzLmlzVFNFbnVtRGVjbGFyYXRpb24gPSBpc1RTRW51bURlY2xhcmF0aW9uO1xuZXhwb3J0cy5pc1RTRW51bU1lbWJlciA9IGlzVFNFbnVtTWVtYmVyO1xuZXhwb3J0cy5pc1RTTW9kdWxlRGVjbGFyYXRpb24gPSBpc1RTTW9kdWxlRGVjbGFyYXRpb247XG5leHBvcnRzLmlzVFNNb2R1bGVCbG9jayA9IGlzVFNNb2R1bGVCbG9jaztcbmV4cG9ydHMuaXNUU0ltcG9ydFR5cGUgPSBpc1RTSW1wb3J0VHlwZTtcbmV4cG9ydHMuaXNUU0ltcG9ydEVxdWFsc0RlY2xhcmF0aW9uID0gaXNUU0ltcG9ydEVxdWFsc0RlY2xhcmF0aW9uO1xuZXhwb3J0cy5pc1RTRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2UgPSBpc1RTRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2U7XG5leHBvcnRzLmlzVFNOb25OdWxsRXhwcmVzc2lvbiA9IGlzVFNOb25OdWxsRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNUU0V4cG9ydEFzc2lnbm1lbnQgPSBpc1RTRXhwb3J0QXNzaWdubWVudDtcbmV4cG9ydHMuaXNUU05hbWVzcGFjZUV4cG9ydERlY2xhcmF0aW9uID0gaXNUU05hbWVzcGFjZUV4cG9ydERlY2xhcmF0aW9uO1xuZXhwb3J0cy5pc1RTVHlwZUFubm90YXRpb24gPSBpc1RTVHlwZUFubm90YXRpb247XG5leHBvcnRzLmlzVFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbiA9IGlzVFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbjtcbmV4cG9ydHMuaXNUU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbiA9IGlzVFNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb247XG5leHBvcnRzLmlzVFNUeXBlUGFyYW1ldGVyID0gaXNUU1R5cGVQYXJhbWV0ZXI7XG5leHBvcnRzLmlzRXhwcmVzc2lvbiA9IGlzRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNCaW5hcnkgPSBpc0JpbmFyeTtcbmV4cG9ydHMuaXNTY29wYWJsZSA9IGlzU2NvcGFibGU7XG5leHBvcnRzLmlzQmxvY2tQYXJlbnQgPSBpc0Jsb2NrUGFyZW50O1xuZXhwb3J0cy5pc0Jsb2NrID0gaXNCbG9jaztcbmV4cG9ydHMuaXNTdGF0ZW1lbnQgPSBpc1N0YXRlbWVudDtcbmV4cG9ydHMuaXNUZXJtaW5hdG9ybGVzcyA9IGlzVGVybWluYXRvcmxlc3M7XG5leHBvcnRzLmlzQ29tcGxldGlvblN0YXRlbWVudCA9IGlzQ29tcGxldGlvblN0YXRlbWVudDtcbmV4cG9ydHMuaXNDb25kaXRpb25hbCA9IGlzQ29uZGl0aW9uYWw7XG5leHBvcnRzLmlzTG9vcCA9IGlzTG9vcDtcbmV4cG9ydHMuaXNXaGlsZSA9IGlzV2hpbGU7XG5leHBvcnRzLmlzRXhwcmVzc2lvbldyYXBwZXIgPSBpc0V4cHJlc3Npb25XcmFwcGVyO1xuZXhwb3J0cy5pc0ZvciA9IGlzRm9yO1xuZXhwb3J0cy5pc0ZvclhTdGF0ZW1lbnQgPSBpc0ZvclhTdGF0ZW1lbnQ7XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuZXhwb3J0cy5pc0Z1bmN0aW9uUGFyZW50ID0gaXNGdW5jdGlvblBhcmVudDtcbmV4cG9ydHMuaXNQdXJlaXNoID0gaXNQdXJlaXNoO1xuZXhwb3J0cy5pc0RlY2xhcmF0aW9uID0gaXNEZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNQYXR0ZXJuTGlrZSA9IGlzUGF0dGVybkxpa2U7XG5leHBvcnRzLmlzTFZhbCA9IGlzTFZhbDtcbmV4cG9ydHMuaXNUU0VudGl0eU5hbWUgPSBpc1RTRW50aXR5TmFtZTtcbmV4cG9ydHMuaXNMaXRlcmFsID0gaXNMaXRlcmFsO1xuZXhwb3J0cy5pc0ltbXV0YWJsZSA9IGlzSW1tdXRhYmxlO1xuZXhwb3J0cy5pc1VzZXJXaGl0ZXNwYWNhYmxlID0gaXNVc2VyV2hpdGVzcGFjYWJsZTtcbmV4cG9ydHMuaXNNZXRob2QgPSBpc01ldGhvZDtcbmV4cG9ydHMuaXNPYmplY3RNZW1iZXIgPSBpc09iamVjdE1lbWJlcjtcbmV4cG9ydHMuaXNQcm9wZXJ0eSA9IGlzUHJvcGVydHk7XG5leHBvcnRzLmlzVW5hcnlMaWtlID0gaXNVbmFyeUxpa2U7XG5leHBvcnRzLmlzUGF0dGVybiA9IGlzUGF0dGVybjtcbmV4cG9ydHMuaXNDbGFzcyA9IGlzQ2xhc3M7XG5leHBvcnRzLmlzTW9kdWxlRGVjbGFyYXRpb24gPSBpc01vZHVsZURlY2xhcmF0aW9uO1xuZXhwb3J0cy5pc0V4cG9ydERlY2xhcmF0aW9uID0gaXNFeHBvcnREZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNNb2R1bGVTcGVjaWZpZXIgPSBpc01vZHVsZVNwZWNpZmllcjtcbmV4cG9ydHMuaXNGbG93ID0gaXNGbG93O1xuZXhwb3J0cy5pc0Zsb3dUeXBlID0gaXNGbG93VHlwZTtcbmV4cG9ydHMuaXNGbG93QmFzZUFubm90YXRpb24gPSBpc0Zsb3dCYXNlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNGbG93RGVjbGFyYXRpb24gPSBpc0Zsb3dEZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNGbG93UHJlZGljYXRlID0gaXNGbG93UHJlZGljYXRlO1xuZXhwb3J0cy5pc0VudW1Cb2R5ID0gaXNFbnVtQm9keTtcbmV4cG9ydHMuaXNFbnVtTWVtYmVyID0gaXNFbnVtTWVtYmVyO1xuZXhwb3J0cy5pc0pTWCA9IGlzSlNYO1xuZXhwb3J0cy5pc1ByaXZhdGUgPSBpc1ByaXZhdGU7XG5leHBvcnRzLmlzVFNUeXBlRWxlbWVudCA9IGlzVFNUeXBlRWxlbWVudDtcbmV4cG9ydHMuaXNUU1R5cGUgPSBpc1RTVHlwZTtcbmV4cG9ydHMuaXNUU0Jhc2VUeXBlID0gaXNUU0Jhc2VUeXBlO1xuZXhwb3J0cy5pc051bWJlckxpdGVyYWwgPSBpc051bWJlckxpdGVyYWw7XG5leHBvcnRzLmlzUmVnZXhMaXRlcmFsID0gaXNSZWdleExpdGVyYWw7XG5leHBvcnRzLmlzUmVzdFByb3BlcnR5ID0gaXNSZXN0UHJvcGVydHk7XG5leHBvcnRzLmlzU3ByZWFkUHJvcGVydHkgPSBpc1NwcmVhZFByb3BlcnR5O1xuXG52YXIgX3NoYWxsb3dFcXVhbCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uL3V0aWxzL3NoYWxsb3dFcXVhbFwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGlzQXJyYXlFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJBcnJheUV4cHJlc3Npb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzQXNzaWdubWVudEV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0JpbmFyeUV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkJpbmFyeUV4cHJlc3Npb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzSW50ZXJwcmV0ZXJEaXJlY3RpdmUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkludGVycHJldGVyRGlyZWN0aXZlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0RpcmVjdGl2ZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRGlyZWN0aXZlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0RpcmVjdGl2ZUxpdGVyYWwobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkRpcmVjdGl2ZUxpdGVyYWxcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzQmxvY2tTdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkJsb2NrU3RhdGVtZW50XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0JyZWFrU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJCcmVha1N0YXRlbWVudFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNDYWxsRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiQ2FsbEV4cHJlc3Npb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzQ2F0Y2hDbGF1c2Uobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkNhdGNoQ2xhdXNlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0NvbmRpdGlvbmFsRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0NvbnRpbnVlU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJDb250aW51ZVN0YXRlbWVudFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNEZWJ1Z2dlclN0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRGVidWdnZXJTdGF0ZW1lbnRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRG9XaGlsZVN0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRG9XaGlsZVN0YXRlbWVudFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNFbXB0eVN0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRW1wdHlTdGF0ZW1lbnRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRXhwcmVzc2lvblN0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRXhwcmVzc2lvblN0YXRlbWVudFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNGaWxlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJGaWxlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0ZvckluU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJGb3JJblN0YXRlbWVudFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNGb3JTdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkZvclN0YXRlbWVudFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbkRlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0lkZW50aWZpZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzSWZTdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIklmU3RhdGVtZW50XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0xhYmVsZWRTdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkxhYmVsZWRTdGF0ZW1lbnRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nTGl0ZXJhbChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiU3RyaW5nTGl0ZXJhbFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNOdW1lcmljTGl0ZXJhbChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiTnVtZXJpY0xpdGVyYWxcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzTnVsbExpdGVyYWwobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIk51bGxMaXRlcmFsXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0Jvb2xlYW5MaXRlcmFsKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJCb29sZWFuTGl0ZXJhbFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNSZWdFeHBMaXRlcmFsKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJSZWdFeHBMaXRlcmFsXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0xvZ2ljYWxFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJMb2dpY2FsRXhwcmVzc2lvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNNZW1iZXJFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc05ld0V4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIk5ld0V4cHJlc3Npb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzUHJvZ3JhbShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiUHJvZ3JhbVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3RFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJPYmplY3RFeHByZXNzaW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdE1ldGhvZChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiT2JqZWN0TWV0aG9kXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdFByb3BlcnR5KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJPYmplY3RQcm9wZXJ0eVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNSZXN0RWxlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzUmV0dXJuU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJSZXR1cm5TdGF0ZW1lbnRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzU2VxdWVuY2VFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJTZXF1ZW5jZUV4cHJlc3Npb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzUGFyZW50aGVzaXplZEV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1N3aXRjaENhc2Uobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlN3aXRjaENhc2VcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzU3dpdGNoU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJTd2l0Y2hTdGF0ZW1lbnRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVGhpc0V4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRoaXNFeHByZXNzaW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1Rocm93U3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUaHJvd1N0YXRlbWVudFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUcnlTdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRyeVN0YXRlbWVudFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNVbmFyeUV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlVuYXJ5RXhwcmVzc2lvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNVcGRhdGVFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJVcGRhdGVFeHByZXNzaW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1ZhcmlhYmxlRGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVmFyaWFibGVEZWNsYXJhdG9yKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJWYXJpYWJsZURlY2xhcmF0b3JcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzV2hpbGVTdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIldoaWxlU3RhdGVtZW50XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1dpdGhTdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIldpdGhTdGF0ZW1lbnRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzQXNzaWdubWVudFBhdHRlcm4obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0FycmF5UGF0dGVybihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiQXJyYXlQYXR0ZXJuXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0Fycm93RnVuY3Rpb25FeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNDbGFzc0JvZHkobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkNsYXNzQm9keVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNDbGFzc0V4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkNsYXNzRXhwcmVzc2lvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNDbGFzc0RlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJDbGFzc0RlY2xhcmF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0V4cG9ydEFsbERlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNFeHBvcnROYW1lZERlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0V4cG9ydFNwZWNpZmllcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRXhwb3J0U3BlY2lmaWVyXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0Zvck9mU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJGb3JPZlN0YXRlbWVudFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNJbXBvcnREZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiSW1wb3J0RGVjbGFyYXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzSW1wb3J0RGVmYXVsdFNwZWNpZmllcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiSW1wb3J0RGVmYXVsdFNwZWNpZmllclwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkltcG9ydE5hbWVzcGFjZVNwZWNpZmllclwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNJbXBvcnRTcGVjaWZpZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkltcG9ydFNwZWNpZmllclwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNNZXRhUHJvcGVydHkobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIk1ldGFQcm9wZXJ0eVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNDbGFzc01ldGhvZChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiQ2xhc3NNZXRob2RcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0UGF0dGVybihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiT2JqZWN0UGF0dGVyblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNTcHJlYWRFbGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJTcHJlYWRFbGVtZW50XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1N1cGVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJTdXBlclwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUZW1wbGF0ZUVsZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRlbXBsYXRlRWxlbWVudFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUZW1wbGF0ZUxpdGVyYWwobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRlbXBsYXRlTGl0ZXJhbFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNZaWVsZEV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIllpZWxkRXhwcmVzc2lvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNBd2FpdEV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkF3YWl0RXhwcmVzc2lvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNJbXBvcnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkltcG9ydFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNCaWdJbnRMaXRlcmFsKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJCaWdJbnRMaXRlcmFsXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0V4cG9ydE5hbWVzcGFjZVNwZWNpZmllcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc09wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc09wdGlvbmFsQ2FsbEV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzQW55VHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkFueVR5cGVBbm5vdGF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0FycmF5VHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkFycmF5VHlwZUFubm90YXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzQm9vbGVhblR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJCb29sZWFuVHlwZUFubm90YXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbkxpdGVyYWxUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiQm9vbGVhbkxpdGVyYWxUeXBlQW5ub3RhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNOdWxsTGl0ZXJhbFR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJOdWxsTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0NsYXNzSW1wbGVtZW50cyhub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiQ2xhc3NJbXBsZW1lbnRzXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0RlY2xhcmVDbGFzcyhub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRGVjbGFyZUNsYXNzXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0RlY2xhcmVGdW5jdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRGVjbGFyZUZ1bmN0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0RlY2xhcmVJbnRlcmZhY2Uobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkRlY2xhcmVJbnRlcmZhY2VcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRGVjbGFyZU1vZHVsZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRGVjbGFyZU1vZHVsZVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNEZWNsYXJlTW9kdWxlRXhwb3J0cyhub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRGVjbGFyZU1vZHVsZUV4cG9ydHNcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRGVjbGFyZVR5cGVBbGlhcyhub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRGVjbGFyZVR5cGVBbGlhc1wiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNEZWNsYXJlT3BhcXVlVHlwZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRGVjbGFyZU9wYXF1ZVR5cGVcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRGVjbGFyZVZhcmlhYmxlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJEZWNsYXJlVmFyaWFibGVcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJEZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRGVjbGFyZWRQcmVkaWNhdGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkRlY2xhcmVkUHJlZGljYXRlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0V4aXN0c1R5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJFeGlzdHNUeXBlQW5ub3RhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvblR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uVHlwZVBhcmFtKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJGdW5jdGlvblR5cGVQYXJhbVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNHZW5lcmljVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkdlbmVyaWNUeXBlQW5ub3RhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNJbmZlcnJlZFByZWRpY2F0ZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiSW5mZXJyZWRQcmVkaWNhdGVcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzSW50ZXJmYWNlRXh0ZW5kcyhub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiSW50ZXJmYWNlRXh0ZW5kc1wiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNJbnRlcmZhY2VEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiSW50ZXJmYWNlRGVjbGFyYXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzSW50ZXJmYWNlVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkludGVyZmFjZVR5cGVBbm5vdGF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0ludGVyc2VjdGlvblR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNNaXhlZFR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJNaXhlZFR5cGVBbm5vdGF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0VtcHR5VHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkVtcHR5VHlwZUFubm90YXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzTnVsbGFibGVUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiTnVsbGFibGVUeXBlQW5ub3RhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXJMaXRlcmFsVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIk51bWJlckxpdGVyYWxUeXBlQW5ub3RhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXJUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiTnVtYmVyVHlwZUFubm90YXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0VHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIk9iamVjdFR5cGVBbm5vdGF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdFR5cGVJbnRlcm5hbFNsb3Qobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIk9iamVjdFR5cGVJbnRlcm5hbFNsb3RcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3RUeXBlSW5kZXhlcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiT2JqZWN0VHlwZUluZGV4ZXJcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0VHlwZVByb3BlcnR5KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJPYmplY3RUeXBlUHJvcGVydHlcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0VHlwZVNwcmVhZFByb3BlcnR5KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJPYmplY3RUeXBlU3ByZWFkUHJvcGVydHlcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzT3BhcXVlVHlwZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiT3BhcXVlVHlwZVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNRdWFsaWZpZWRUeXBlSWRlbnRpZmllcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiUXVhbGlmaWVkVHlwZUlkZW50aWZpZXJcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJTdHJpbmdMaXRlcmFsVHlwZUFubm90YXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlN0cmluZ1R5cGVBbm5vdGF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1N5bWJvbFR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJTeW1ib2xUeXBlQW5ub3RhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUaGlzVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRoaXNUeXBlQW5ub3RhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUdXBsZVR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUdXBsZVR5cGVBbm5vdGF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1R5cGVvZlR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUeXBlb2ZUeXBlQW5ub3RhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUeXBlQWxpYXMobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlR5cGVBbGlhc1wiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVHlwZUFubm90YXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVHlwZUNhc3RFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUeXBlQ2FzdEV4cHJlc3Npb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVHlwZVBhcmFtZXRlcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVHlwZVBhcmFtZXRlclwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVW5pb25UeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVW5pb25UeXBlQW5ub3RhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNWYXJpYW5jZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVmFyaWFuY2VcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVm9pZFR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJWb2lkVHlwZUFubm90YXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRW51bURlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJFbnVtRGVjbGFyYXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRW51bUJvb2xlYW5Cb2R5KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJFbnVtQm9vbGVhbkJvZHlcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRW51bU51bWJlckJvZHkobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkVudW1OdW1iZXJCb2R5XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0VudW1TdHJpbmdCb2R5KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJFbnVtU3RyaW5nQm9keVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNFbnVtU3ltYm9sQm9keShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRW51bVN5bWJvbEJvZHlcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRW51bUJvb2xlYW5NZW1iZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkVudW1Cb29sZWFuTWVtYmVyXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0VudW1OdW1iZXJNZW1iZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkVudW1OdW1iZXJNZW1iZXJcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRW51bVN0cmluZ01lbWJlcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRW51bVN0cmluZ01lbWJlclwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNFbnVtRGVmYXVsdGVkTWVtYmVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJFbnVtRGVmYXVsdGVkTWVtYmVyXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0pTWEF0dHJpYnV0ZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiSlNYQXR0cmlidXRlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0pTWENsb3NpbmdFbGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJKU1hDbG9zaW5nRWxlbWVudFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNKU1hFbGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJKU1hFbGVtZW50XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0pTWEVtcHR5RXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiSlNYRW1wdHlFeHByZXNzaW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0pTWEV4cHJlc3Npb25Db250YWluZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkpTWEV4cHJlc3Npb25Db250YWluZXJcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzSlNYU3ByZWFkQ2hpbGQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkpTWFNwcmVhZENoaWxkXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0pTWElkZW50aWZpZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkpTWElkZW50aWZpZXJcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzSlNYTWVtYmVyRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiSlNYTWVtYmVyRXhwcmVzc2lvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNKU1hOYW1lc3BhY2VkTmFtZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiSlNYTmFtZXNwYWNlZE5hbWVcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzSlNYT3BlbmluZ0VsZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkpTWE9wZW5pbmdFbGVtZW50XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0pTWFNwcmVhZEF0dHJpYnV0ZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiSlNYU3ByZWFkQXR0cmlidXRlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0pTWFRleHQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkpTWFRleHRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzSlNYRnJhZ21lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkpTWEZyYWdtZW50XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0pTWE9wZW5pbmdGcmFnbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiSlNYT3BlbmluZ0ZyYWdtZW50XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0pTWENsb3NpbmdGcmFnbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiSlNYQ2xvc2luZ0ZyYWdtZW50XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc05vb3Aobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIk5vb3BcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzUGxhY2Vob2xkZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlBsYWNlaG9sZGVyXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1Y4SW50cmluc2ljSWRlbnRpZmllcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVjhJbnRyaW5zaWNJZGVudGlmaWVyXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0FyZ3VtZW50UGxhY2Vob2xkZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkFyZ3VtZW50UGxhY2Vob2xkZXJcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzQmluZEV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkJpbmRFeHByZXNzaW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0NsYXNzUHJvcGVydHkobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkNsYXNzUHJvcGVydHlcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzUGlwZWxpbmVUb3BpY0V4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlBpcGVsaW5lVG9waWNFeHByZXNzaW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1BpcGVsaW5lQmFyZUZ1bmN0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJQaXBlbGluZUJhcmVGdW5jdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNQaXBlbGluZVByaW1hcnlUb3BpY1JlZmVyZW5jZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiUGlwZWxpbmVQcmltYXJ5VG9waWNSZWZlcmVuY2VcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzQ2xhc3NQcml2YXRlUHJvcGVydHkobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkNsYXNzUHJpdmF0ZVByb3BlcnR5XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0NsYXNzUHJpdmF0ZU1ldGhvZChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiQ2xhc3NQcml2YXRlTWV0aG9kXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0ltcG9ydEF0dHJpYnV0ZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiSW1wb3J0QXR0cmlidXRlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0RlY29yYXRvcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRGVjb3JhdG9yXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0RvRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRG9FeHByZXNzaW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0V4cG9ydERlZmF1bHRTcGVjaWZpZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkV4cG9ydERlZmF1bHRTcGVjaWZpZXJcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzUHJpdmF0ZU5hbWUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlByaXZhdGVOYW1lXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1JlY29yZEV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlJlY29yZEV4cHJlc3Npb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVHVwbGVFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUdXBsZUV4cHJlc3Npb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRGVjaW1hbExpdGVyYWwobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkRlY2ltYWxMaXRlcmFsXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTUGFyYW1ldGVyUHJvcGVydHkobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTUGFyYW1ldGVyUHJvcGVydHlcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNEZWNsYXJlRnVuY3Rpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTRGVjbGFyZUZ1bmN0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTRGVjbGFyZU1ldGhvZChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNEZWNsYXJlTWV0aG9kXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTUXVhbGlmaWVkTmFtZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNRdWFsaWZpZWROYW1lXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTQ2FsbFNpZ25hdHVyZURlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU0NvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU0NvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTUHJvcGVydHlTaWduYXR1cmUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTUHJvcGVydHlTaWduYXR1cmVcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNNZXRob2RTaWduYXR1cmUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTTWV0aG9kU2lnbmF0dXJlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTSW5kZXhTaWduYXR1cmUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTSW5kZXhTaWduYXR1cmVcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNBbnlLZXl3b3JkKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU0FueUtleXdvcmRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNCb29sZWFuS2V5d29yZChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNCb29sZWFuS2V5d29yZFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU0JpZ0ludEtleXdvcmQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTQmlnSW50S2V5d29yZFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU05ldmVyS2V5d29yZChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNOZXZlcktleXdvcmRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNOdWxsS2V5d29yZChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNOdWxsS2V5d29yZFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU051bWJlcktleXdvcmQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTTnVtYmVyS2V5d29yZFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU09iamVjdEtleXdvcmQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTT2JqZWN0S2V5d29yZFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU1N0cmluZ0tleXdvcmQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTU3RyaW5nS2V5d29yZFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU1N5bWJvbEtleXdvcmQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTU3ltYm9sS2V5d29yZFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU1VuZGVmaW5lZEtleXdvcmQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTVW5kZWZpbmVkS2V5d29yZFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU1Vua25vd25LZXl3b3JkKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU1Vua25vd25LZXl3b3JkXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTVm9pZEtleXdvcmQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTVm9pZEtleXdvcmRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNUaGlzVHlwZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNUaGlzVHlwZVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU0Z1bmN0aW9uVHlwZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNGdW5jdGlvblR5cGVcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNDb25zdHJ1Y3RvclR5cGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTQ29uc3RydWN0b3JUeXBlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTVHlwZVJlZmVyZW5jZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNUeXBlUmVmZXJlbmNlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTVHlwZVByZWRpY2F0ZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNUeXBlUHJlZGljYXRlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTVHlwZVF1ZXJ5KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU1R5cGVRdWVyeVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU1R5cGVMaXRlcmFsKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU1R5cGVMaXRlcmFsXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTQXJyYXlUeXBlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU0FycmF5VHlwZVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU1R1cGxlVHlwZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNUdXBsZVR5cGVcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNPcHRpb25hbFR5cGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTT3B0aW9uYWxUeXBlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTUmVzdFR5cGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTUmVzdFR5cGVcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNOYW1lZFR1cGxlTWVtYmVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU05hbWVkVHVwbGVNZW1iZXJcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNVbmlvblR5cGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTVW5pb25UeXBlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTSW50ZXJzZWN0aW9uVHlwZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNJbnRlcnNlY3Rpb25UeXBlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTQ29uZGl0aW9uYWxUeXBlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU0NvbmRpdGlvbmFsVHlwZVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU0luZmVyVHlwZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNJbmZlclR5cGVcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNQYXJlbnRoZXNpemVkVHlwZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNQYXJlbnRoZXNpemVkVHlwZVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU1R5cGVPcGVyYXRvcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNUeXBlT3BlcmF0b3JcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNJbmRleGVkQWNjZXNzVHlwZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNJbmRleGVkQWNjZXNzVHlwZVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU01hcHBlZFR5cGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTTWFwcGVkVHlwZVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU0xpdGVyYWxUeXBlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU0xpdGVyYWxUeXBlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU0V4cHJlc3Npb25XaXRoVHlwZUFyZ3VtZW50c1wiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU0ludGVyZmFjZURlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU0ludGVyZmFjZURlY2xhcmF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTSW50ZXJmYWNlQm9keShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNJbnRlcmZhY2VCb2R5XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTVHlwZUFsaWFzRGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTVHlwZUFsaWFzRGVjbGFyYXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNBc0V4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTQXNFeHByZXNzaW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTVHlwZUFzc2VydGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNUeXBlQXNzZXJ0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTRW51bURlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU0VudW1EZWNsYXJhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU0VudW1NZW1iZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTRW51bU1lbWJlclwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU01vZHVsZURlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU01vZHVsZURlY2xhcmF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTTW9kdWxlQmxvY2sobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTTW9kdWxlQmxvY2tcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNJbXBvcnRUeXBlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU0ltcG9ydFR5cGVcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTTm9uTnVsbEV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTTm9uTnVsbEV4cHJlc3Npb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNFeHBvcnRBc3NpZ25tZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU0V4cG9ydEFzc2lnbm1lbnRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNOYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNOYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU1R5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU1R5cGVBbm5vdGF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTVHlwZVBhcmFtZXRlcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNUeXBlUGFyYW1ldGVyXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0V4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkV4cHJlc3Npb25cIiB8fCBcIkFycmF5RXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiQmluYXJ5RXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIkNhbGxFeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiSWRlbnRpZmllclwiID09PSBub2RlVHlwZSB8fCBcIlN0cmluZ0xpdGVyYWxcIiA9PT0gbm9kZVR5cGUgfHwgXCJOdW1lcmljTGl0ZXJhbFwiID09PSBub2RlVHlwZSB8fCBcIk51bGxMaXRlcmFsXCIgPT09IG5vZGVUeXBlIHx8IFwiQm9vbGVhbkxpdGVyYWxcIiA9PT0gbm9kZVR5cGUgfHwgXCJSZWdFeHBMaXRlcmFsXCIgPT09IG5vZGVUeXBlIHx8IFwiTG9naWNhbEV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJNZW1iZXJFeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiTmV3RXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIk9iamVjdEV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJTZXF1ZW5jZUV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIlRoaXNFeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiVW5hcnlFeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiVXBkYXRlRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiQ2xhc3NFeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiTWV0YVByb3BlcnR5XCIgPT09IG5vZGVUeXBlIHx8IFwiU3VwZXJcIiA9PT0gbm9kZVR5cGUgfHwgXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJUZW1wbGF0ZUxpdGVyYWxcIiA9PT0gbm9kZVR5cGUgfHwgXCJZaWVsZEV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJBd2FpdEV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJJbXBvcnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJCaWdJbnRMaXRlcmFsXCIgPT09IG5vZGVUeXBlIHx8IFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIlR5cGVDYXN0RXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIkpTWEVsZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJKU1hGcmFnbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkJpbmRFeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiUGlwZWxpbmVQcmltYXJ5VG9waWNSZWZlcmVuY2VcIiA9PT0gbm9kZVR5cGUgfHwgXCJEb0V4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJSZWNvcmRFeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiVHVwbGVFeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjaW1hbExpdGVyYWxcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU0FzRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIlRTVHlwZUFzc2VydGlvblwiID09PSBub2RlVHlwZSB8fCBcIlRTTm9uTnVsbEV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgbm9kZVR5cGUgPT09IFwiUGxhY2Vob2xkZXJcIiAmJiAoXCJFeHByZXNzaW9uXCIgPT09IG5vZGUuZXhwZWN0ZWROb2RlIHx8IFwiSWRlbnRpZmllclwiID09PSBub2RlLmV4cGVjdGVkTm9kZSB8fCBcIlN0cmluZ0xpdGVyYWxcIiA9PT0gbm9kZS5leHBlY3RlZE5vZGUpKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNCaW5hcnkobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkJpbmFyeVwiIHx8IFwiQmluYXJ5RXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIkxvZ2ljYWxFeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNTY29wYWJsZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiU2NvcGFibGVcIiB8fCBcIkJsb2NrU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiQ2F0Y2hDbGF1c2VcIiA9PT0gbm9kZVR5cGUgfHwgXCJEb1doaWxlU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiRm9ySW5TdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJGb3JTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiUHJvZ3JhbVwiID09PSBub2RlVHlwZSB8fCBcIk9iamVjdE1ldGhvZFwiID09PSBub2RlVHlwZSB8fCBcIlN3aXRjaFN0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIldoaWxlU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJDbGFzc0V4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJDbGFzc0RlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiRm9yT2ZTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJDbGFzc01ldGhvZFwiID09PSBub2RlVHlwZSB8fCBcIkNsYXNzUHJpdmF0ZU1ldGhvZFwiID09PSBub2RlVHlwZSB8fCBcIlRTTW9kdWxlQmxvY2tcIiA9PT0gbm9kZVR5cGUgfHwgbm9kZVR5cGUgPT09IFwiUGxhY2Vob2xkZXJcIiAmJiBcIkJsb2NrU3RhdGVtZW50XCIgPT09IG5vZGUuZXhwZWN0ZWROb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNCbG9ja1BhcmVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiQmxvY2tQYXJlbnRcIiB8fCBcIkJsb2NrU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiQ2F0Y2hDbGF1c2VcIiA9PT0gbm9kZVR5cGUgfHwgXCJEb1doaWxlU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiRm9ySW5TdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJGb3JTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiUHJvZ3JhbVwiID09PSBub2RlVHlwZSB8fCBcIk9iamVjdE1ldGhvZFwiID09PSBub2RlVHlwZSB8fCBcIlN3aXRjaFN0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIldoaWxlU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJGb3JPZlN0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkNsYXNzTWV0aG9kXCIgPT09IG5vZGVUeXBlIHx8IFwiQ2xhc3NQcml2YXRlTWV0aG9kXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNNb2R1bGVCbG9ja1wiID09PSBub2RlVHlwZSB8fCBub2RlVHlwZSA9PT0gXCJQbGFjZWhvbGRlclwiICYmIFwiQmxvY2tTdGF0ZW1lbnRcIiA9PT0gbm9kZS5leHBlY3RlZE5vZGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0Jsb2NrKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJCbG9ja1wiIHx8IFwiQmxvY2tTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJQcm9ncmFtXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNNb2R1bGVCbG9ja1wiID09PSBub2RlVHlwZSB8fCBub2RlVHlwZSA9PT0gXCJQbGFjZWhvbGRlclwiICYmIFwiQmxvY2tTdGF0ZW1lbnRcIiA9PT0gbm9kZS5leHBlY3RlZE5vZGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1N0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiU3RhdGVtZW50XCIgfHwgXCJCbG9ja1N0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkJyZWFrU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiQ29udGludWVTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJEZWJ1Z2dlclN0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkRvV2hpbGVTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJFbXB0eVN0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJGb3JJblN0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkZvclN0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJJZlN0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkxhYmVsZWRTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJSZXR1cm5TdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJTd2l0Y2hTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJUaHJvd1N0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIlRyeVN0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJXaGlsZVN0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIldpdGhTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJDbGFzc0RlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiRm9yT2ZTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJJbXBvcnREZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkRlY2xhcmVDbGFzc1wiID09PSBub2RlVHlwZSB8fCBcIkRlY2xhcmVGdW5jdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkRlY2xhcmVJbnRlcmZhY2VcIiA9PT0gbm9kZVR5cGUgfHwgXCJEZWNsYXJlTW9kdWxlXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZU1vZHVsZUV4cG9ydHNcIiA9PT0gbm9kZVR5cGUgfHwgXCJEZWNsYXJlVHlwZUFsaWFzXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZU9wYXF1ZVR5cGVcIiA9PT0gbm9kZVR5cGUgfHwgXCJEZWNsYXJlVmFyaWFibGVcIiA9PT0gbm9kZVR5cGUgfHwgXCJEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJEZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJJbnRlcmZhY2VEZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIk9wYXF1ZVR5cGVcIiA9PT0gbm9kZVR5cGUgfHwgXCJUeXBlQWxpYXNcIiA9PT0gbm9kZVR5cGUgfHwgXCJFbnVtRGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJUU0RlY2xhcmVGdW5jdGlvblwiID09PSBub2RlVHlwZSB8fCBcIlRTSW50ZXJmYWNlRGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJUU1R5cGVBbGlhc0RlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNFbnVtRGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJUU01vZHVsZURlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIlRTRXhwb3J0QXNzaWdubWVudFwiID09PSBub2RlVHlwZSB8fCBcIlRTTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgbm9kZVR5cGUgPT09IFwiUGxhY2Vob2xkZXJcIiAmJiAoXCJTdGF0ZW1lbnRcIiA9PT0gbm9kZS5leHBlY3RlZE5vZGUgfHwgXCJEZWNsYXJhdGlvblwiID09PSBub2RlLmV4cGVjdGVkTm9kZSB8fCBcIkJsb2NrU3RhdGVtZW50XCIgPT09IG5vZGUuZXhwZWN0ZWROb2RlKSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVGVybWluYXRvcmxlc3Mobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRlcm1pbmF0b3JsZXNzXCIgfHwgXCJCcmVha1N0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkNvbnRpbnVlU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiUmV0dXJuU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiVGhyb3dTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJZaWVsZEV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJBd2FpdEV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0NvbXBsZXRpb25TdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkNvbXBsZXRpb25TdGF0ZW1lbnRcIiB8fCBcIkJyZWFrU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiQ29udGludWVTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJSZXR1cm5TdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJUaHJvd1N0YXRlbWVudFwiID09PSBub2RlVHlwZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzQ29uZGl0aW9uYWwobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkNvbmRpdGlvbmFsXCIgfHwgXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJJZlN0YXRlbWVudFwiID09PSBub2RlVHlwZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzTG9vcChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiTG9vcFwiIHx8IFwiRG9XaGlsZVN0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkZvckluU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiRm9yU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiV2hpbGVTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJGb3JPZlN0YXRlbWVudFwiID09PSBub2RlVHlwZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzV2hpbGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIldoaWxlXCIgfHwgXCJEb1doaWxlU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiV2hpbGVTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0V4cHJlc3Npb25XcmFwcGVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJFeHByZXNzaW9uV3JhcHBlclwiIHx8IFwiRXhwcmVzc2lvblN0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiVHlwZUNhc3RFeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNGb3Iobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkZvclwiIHx8IFwiRm9ySW5TdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJGb3JTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJGb3JPZlN0YXRlbWVudFwiID09PSBub2RlVHlwZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRm9yWFN0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRm9yWFN0YXRlbWVudFwiIHx8IFwiRm9ySW5TdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJGb3JPZlN0YXRlbWVudFwiID09PSBub2RlVHlwZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkZ1bmN0aW9uXCIgfHwgXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiT2JqZWN0TWV0aG9kXCIgPT09IG5vZGVUeXBlIHx8IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJDbGFzc01ldGhvZFwiID09PSBub2RlVHlwZSB8fCBcIkNsYXNzUHJpdmF0ZU1ldGhvZFwiID09PSBub2RlVHlwZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb25QYXJlbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkZ1bmN0aW9uUGFyZW50XCIgfHwgXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiT2JqZWN0TWV0aG9kXCIgPT09IG5vZGVUeXBlIHx8IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJDbGFzc01ldGhvZFwiID09PSBub2RlVHlwZSB8fCBcIkNsYXNzUHJpdmF0ZU1ldGhvZFwiID09PSBub2RlVHlwZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzUHVyZWlzaChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiUHVyZWlzaFwiIHx8IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIlN0cmluZ0xpdGVyYWxcIiA9PT0gbm9kZVR5cGUgfHwgXCJOdW1lcmljTGl0ZXJhbFwiID09PSBub2RlVHlwZSB8fCBcIk51bGxMaXRlcmFsXCIgPT09IG5vZGVUeXBlIHx8IFwiQm9vbGVhbkxpdGVyYWxcIiA9PT0gbm9kZVR5cGUgfHwgXCJSZWdFeHBMaXRlcmFsXCIgPT09IG5vZGVUeXBlIHx8IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJCaWdJbnRMaXRlcmFsXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjaW1hbExpdGVyYWxcIiA9PT0gbm9kZVR5cGUgfHwgbm9kZVR5cGUgPT09IFwiUGxhY2Vob2xkZXJcIiAmJiBcIlN0cmluZ0xpdGVyYWxcIiA9PT0gbm9kZS5leHBlY3RlZE5vZGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0RlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJEZWNsYXJhdGlvblwiIHx8IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJDbGFzc0RlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiSW1wb3J0RGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJEZWNsYXJlQ2xhc3NcIiA9PT0gbm9kZVR5cGUgfHwgXCJEZWNsYXJlRnVuY3Rpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJEZWNsYXJlSW50ZXJmYWNlXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZU1vZHVsZVwiID09PSBub2RlVHlwZSB8fCBcIkRlY2xhcmVNb2R1bGVFeHBvcnRzXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZVR5cGVBbGlhc1wiID09PSBub2RlVHlwZSB8fCBcIkRlY2xhcmVPcGFxdWVUeXBlXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZVZhcmlhYmxlXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiSW50ZXJmYWNlRGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJPcGFxdWVUeXBlXCIgPT09IG5vZGVUeXBlIHx8IFwiVHlwZUFsaWFzXCIgPT09IG5vZGVUeXBlIHx8IFwiRW51bURlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNEZWNsYXJlRnVuY3Rpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJUU0ludGVyZmFjZURlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNUeXBlQWxpYXNEZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIlRTRW51bURlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNNb2R1bGVEZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBub2RlVHlwZSA9PT0gXCJQbGFjZWhvbGRlclwiICYmIFwiRGVjbGFyYXRpb25cIiA9PT0gbm9kZS5leHBlY3RlZE5vZGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1BhdHRlcm5MaWtlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJQYXR0ZXJuTGlrZVwiIHx8IFwiSWRlbnRpZmllclwiID09PSBub2RlVHlwZSB8fCBcIlJlc3RFbGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiQXNzaWdubWVudFBhdHRlcm5cIiA9PT0gbm9kZVR5cGUgfHwgXCJBcnJheVBhdHRlcm5cIiA9PT0gbm9kZVR5cGUgfHwgXCJPYmplY3RQYXR0ZXJuXCIgPT09IG5vZGVUeXBlIHx8IG5vZGVUeXBlID09PSBcIlBsYWNlaG9sZGVyXCIgJiYgKFwiUGF0dGVyblwiID09PSBub2RlLmV4cGVjdGVkTm9kZSB8fCBcIklkZW50aWZpZXJcIiA9PT0gbm9kZS5leHBlY3RlZE5vZGUpKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNMVmFsKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJMVmFsXCIgfHwgXCJJZGVudGlmaWVyXCIgPT09IG5vZGVUeXBlIHx8IFwiTWVtYmVyRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIlJlc3RFbGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiQXNzaWdubWVudFBhdHRlcm5cIiA9PT0gbm9kZVR5cGUgfHwgXCJBcnJheVBhdHRlcm5cIiA9PT0gbm9kZVR5cGUgfHwgXCJPYmplY3RQYXR0ZXJuXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNQYXJhbWV0ZXJQcm9wZXJ0eVwiID09PSBub2RlVHlwZSB8fCBub2RlVHlwZSA9PT0gXCJQbGFjZWhvbGRlclwiICYmIChcIlBhdHRlcm5cIiA9PT0gbm9kZS5leHBlY3RlZE5vZGUgfHwgXCJJZGVudGlmaWVyXCIgPT09IG5vZGUuZXhwZWN0ZWROb2RlKSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNFbnRpdHlOYW1lKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU0VudGl0eU5hbWVcIiB8fCBcIklkZW50aWZpZXJcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU1F1YWxpZmllZE5hbWVcIiA9PT0gbm9kZVR5cGUgfHwgbm9kZVR5cGUgPT09IFwiUGxhY2Vob2xkZXJcIiAmJiBcIklkZW50aWZpZXJcIiA9PT0gbm9kZS5leHBlY3RlZE5vZGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0xpdGVyYWwobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkxpdGVyYWxcIiB8fCBcIlN0cmluZ0xpdGVyYWxcIiA9PT0gbm9kZVR5cGUgfHwgXCJOdW1lcmljTGl0ZXJhbFwiID09PSBub2RlVHlwZSB8fCBcIk51bGxMaXRlcmFsXCIgPT09IG5vZGVUeXBlIHx8IFwiQm9vbGVhbkxpdGVyYWxcIiA9PT0gbm9kZVR5cGUgfHwgXCJSZWdFeHBMaXRlcmFsXCIgPT09IG5vZGVUeXBlIHx8IFwiVGVtcGxhdGVMaXRlcmFsXCIgPT09IG5vZGVUeXBlIHx8IFwiQmlnSW50TGl0ZXJhbFwiID09PSBub2RlVHlwZSB8fCBcIkRlY2ltYWxMaXRlcmFsXCIgPT09IG5vZGVUeXBlIHx8IG5vZGVUeXBlID09PSBcIlBsYWNlaG9sZGVyXCIgJiYgXCJTdHJpbmdMaXRlcmFsXCIgPT09IG5vZGUuZXhwZWN0ZWROb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNJbW11dGFibGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkltbXV0YWJsZVwiIHx8IFwiU3RyaW5nTGl0ZXJhbFwiID09PSBub2RlVHlwZSB8fCBcIk51bWVyaWNMaXRlcmFsXCIgPT09IG5vZGVUeXBlIHx8IFwiTnVsbExpdGVyYWxcIiA9PT0gbm9kZVR5cGUgfHwgXCJCb29sZWFuTGl0ZXJhbFwiID09PSBub2RlVHlwZSB8fCBcIkJpZ0ludExpdGVyYWxcIiA9PT0gbm9kZVR5cGUgfHwgXCJKU1hBdHRyaWJ1dGVcIiA9PT0gbm9kZVR5cGUgfHwgXCJKU1hDbG9zaW5nRWxlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkpTWEVsZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJKU1hFeHByZXNzaW9uQ29udGFpbmVyXCIgPT09IG5vZGVUeXBlIHx8IFwiSlNYU3ByZWFkQ2hpbGRcIiA9PT0gbm9kZVR5cGUgfHwgXCJKU1hPcGVuaW5nRWxlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkpTWFRleHRcIiA9PT0gbm9kZVR5cGUgfHwgXCJKU1hGcmFnbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkpTWE9wZW5pbmdGcmFnbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkpTWENsb3NpbmdGcmFnbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkRlY2ltYWxMaXRlcmFsXCIgPT09IG5vZGVUeXBlIHx8IG5vZGVUeXBlID09PSBcIlBsYWNlaG9sZGVyXCIgJiYgXCJTdHJpbmdMaXRlcmFsXCIgPT09IG5vZGUuZXhwZWN0ZWROb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNVc2VyV2hpdGVzcGFjYWJsZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVXNlcldoaXRlc3BhY2FibGVcIiB8fCBcIk9iamVjdE1ldGhvZFwiID09PSBub2RlVHlwZSB8fCBcIk9iamVjdFByb3BlcnR5XCIgPT09IG5vZGVUeXBlIHx8IFwiT2JqZWN0VHlwZUludGVybmFsU2xvdFwiID09PSBub2RlVHlwZSB8fCBcIk9iamVjdFR5cGVDYWxsUHJvcGVydHlcIiA9PT0gbm9kZVR5cGUgfHwgXCJPYmplY3RUeXBlSW5kZXhlclwiID09PSBub2RlVHlwZSB8fCBcIk9iamVjdFR5cGVQcm9wZXJ0eVwiID09PSBub2RlVHlwZSB8fCBcIk9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eVwiID09PSBub2RlVHlwZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzTWV0aG9kKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJNZXRob2RcIiB8fCBcIk9iamVjdE1ldGhvZFwiID09PSBub2RlVHlwZSB8fCBcIkNsYXNzTWV0aG9kXCIgPT09IG5vZGVUeXBlIHx8IFwiQ2xhc3NQcml2YXRlTWV0aG9kXCIgPT09IG5vZGVUeXBlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3RNZW1iZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIk9iamVjdE1lbWJlclwiIHx8IFwiT2JqZWN0TWV0aG9kXCIgPT09IG5vZGVUeXBlIHx8IFwiT2JqZWN0UHJvcGVydHlcIiA9PT0gbm9kZVR5cGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1Byb3BlcnR5KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJQcm9wZXJ0eVwiIHx8IFwiT2JqZWN0UHJvcGVydHlcIiA9PT0gbm9kZVR5cGUgfHwgXCJDbGFzc1Byb3BlcnR5XCIgPT09IG5vZGVUeXBlIHx8IFwiQ2xhc3NQcml2YXRlUHJvcGVydHlcIiA9PT0gbm9kZVR5cGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1VuYXJ5TGlrZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVW5hcnlMaWtlXCIgfHwgXCJVbmFyeUV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJTcHJlYWRFbGVtZW50XCIgPT09IG5vZGVUeXBlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNQYXR0ZXJuKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJQYXR0ZXJuXCIgfHwgXCJBc3NpZ25tZW50UGF0dGVyblwiID09PSBub2RlVHlwZSB8fCBcIkFycmF5UGF0dGVyblwiID09PSBub2RlVHlwZSB8fCBcIk9iamVjdFBhdHRlcm5cIiA9PT0gbm9kZVR5cGUgfHwgbm9kZVR5cGUgPT09IFwiUGxhY2Vob2xkZXJcIiAmJiBcIlBhdHRlcm5cIiA9PT0gbm9kZS5leHBlY3RlZE5vZGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0NsYXNzKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJDbGFzc1wiIHx8IFwiQ2xhc3NFeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiQ2xhc3NEZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzTW9kdWxlRGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIk1vZHVsZURlY2xhcmF0aW9uXCIgfHwgXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJJbXBvcnREZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRXhwb3J0RGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkV4cG9ydERlY2xhcmF0aW9uXCIgfHwgXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc01vZHVsZVNwZWNpZmllcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiTW9kdWxlU3BlY2lmaWVyXCIgfHwgXCJFeHBvcnRTcGVjaWZpZXJcIiA9PT0gbm9kZVR5cGUgfHwgXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIgPT09IG5vZGVUeXBlIHx8IFwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIgPT09IG5vZGVUeXBlIHx8IFwiSW1wb3J0U3BlY2lmaWVyXCIgPT09IG5vZGVUeXBlIHx8IFwiRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIgPT09IG5vZGVUeXBlIHx8IFwiRXhwb3J0RGVmYXVsdFNwZWNpZmllclwiID09PSBub2RlVHlwZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRmxvdyhub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRmxvd1wiIHx8IFwiQW55VHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJBcnJheVR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiQm9vbGVhblR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiQm9vbGVhbkxpdGVyYWxUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIk51bGxMaXRlcmFsVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJDbGFzc0ltcGxlbWVudHNcIiA9PT0gbm9kZVR5cGUgfHwgXCJEZWNsYXJlQ2xhc3NcIiA9PT0gbm9kZVR5cGUgfHwgXCJEZWNsYXJlRnVuY3Rpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJEZWNsYXJlSW50ZXJmYWNlXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZU1vZHVsZVwiID09PSBub2RlVHlwZSB8fCBcIkRlY2xhcmVNb2R1bGVFeHBvcnRzXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZVR5cGVBbGlhc1wiID09PSBub2RlVHlwZSB8fCBcIkRlY2xhcmVPcGFxdWVUeXBlXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZVZhcmlhYmxlXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZWRQcmVkaWNhdGVcIiA9PT0gbm9kZVR5cGUgfHwgXCJFeGlzdHNUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkZ1bmN0aW9uVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJGdW5jdGlvblR5cGVQYXJhbVwiID09PSBub2RlVHlwZSB8fCBcIkdlbmVyaWNUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkluZmVycmVkUHJlZGljYXRlXCIgPT09IG5vZGVUeXBlIHx8IFwiSW50ZXJmYWNlRXh0ZW5kc1wiID09PSBub2RlVHlwZSB8fCBcIkludGVyZmFjZURlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiSW50ZXJmYWNlVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIk1peGVkVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJFbXB0eVR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiTnVsbGFibGVUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIk51bWJlckxpdGVyYWxUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIk51bWJlclR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiT2JqZWN0VHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJPYmplY3RUeXBlSW50ZXJuYWxTbG90XCIgPT09IG5vZGVUeXBlIHx8IFwiT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eVwiID09PSBub2RlVHlwZSB8fCBcIk9iamVjdFR5cGVJbmRleGVyXCIgPT09IG5vZGVUeXBlIHx8IFwiT2JqZWN0VHlwZVByb3BlcnR5XCIgPT09IG5vZGVUeXBlIHx8IFwiT2JqZWN0VHlwZVNwcmVhZFByb3BlcnR5XCIgPT09IG5vZGVUeXBlIHx8IFwiT3BhcXVlVHlwZVwiID09PSBub2RlVHlwZSB8fCBcIlF1YWxpZmllZFR5cGVJZGVudGlmaWVyXCIgPT09IG5vZGVUeXBlIHx8IFwiU3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiU3RyaW5nVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJTeW1ib2xUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIlRoaXNUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIlR1cGxlVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJUeXBlb2ZUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIlR5cGVBbGlhc1wiID09PSBub2RlVHlwZSB8fCBcIlR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiVHlwZUNhc3RFeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiVHlwZVBhcmFtZXRlclwiID09PSBub2RlVHlwZSB8fCBcIlR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiVW5pb25UeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIlZhcmlhbmNlXCIgPT09IG5vZGVUeXBlIHx8IFwiVm9pZFR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNGbG93VHlwZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRmxvd1R5cGVcIiB8fCBcIkFueVR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiQXJyYXlUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkJvb2xlYW5UeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkJvb2xlYW5MaXRlcmFsVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJOdWxsTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiRXhpc3RzVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiR2VuZXJpY1R5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiSW50ZXJmYWNlVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIk1peGVkVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJFbXB0eVR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiTnVsbGFibGVUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIk51bWJlckxpdGVyYWxUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIk51bWJlclR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiT2JqZWN0VHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJTdHJpbmdMaXRlcmFsVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJTdHJpbmdUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIlN5bWJvbFR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiVGhpc1R5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiVHVwbGVUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIlR5cGVvZlR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiVW5pb25UeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIlZvaWRUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRmxvd0Jhc2VBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJGbG93QmFzZUFubm90YXRpb25cIiB8fCBcIkFueVR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiQm9vbGVhblR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiTnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIk1peGVkVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJFbXB0eVR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiTnVtYmVyVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJTdHJpbmdUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIlN5bWJvbFR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiVGhpc1R5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiVm9pZFR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNGbG93RGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkZsb3dEZWNsYXJhdGlvblwiIHx8IFwiRGVjbGFyZUNsYXNzXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZUZ1bmN0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZUludGVyZmFjZVwiID09PSBub2RlVHlwZSB8fCBcIkRlY2xhcmVNb2R1bGVcIiA9PT0gbm9kZVR5cGUgfHwgXCJEZWNsYXJlTW9kdWxlRXhwb3J0c1wiID09PSBub2RlVHlwZSB8fCBcIkRlY2xhcmVUeXBlQWxpYXNcIiA9PT0gbm9kZVR5cGUgfHwgXCJEZWNsYXJlT3BhcXVlVHlwZVwiID09PSBub2RlVHlwZSB8fCBcIkRlY2xhcmVWYXJpYWJsZVwiID09PSBub2RlVHlwZSB8fCBcIkRlY2xhcmVFeHBvcnREZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkRlY2xhcmVFeHBvcnRBbGxEZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkludGVyZmFjZURlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiT3BhcXVlVHlwZVwiID09PSBub2RlVHlwZSB8fCBcIlR5cGVBbGlhc1wiID09PSBub2RlVHlwZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRmxvd1ByZWRpY2F0ZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRmxvd1ByZWRpY2F0ZVwiIHx8IFwiRGVjbGFyZWRQcmVkaWNhdGVcIiA9PT0gbm9kZVR5cGUgfHwgXCJJbmZlcnJlZFByZWRpY2F0ZVwiID09PSBub2RlVHlwZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRW51bUJvZHkobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkVudW1Cb2R5XCIgfHwgXCJFbnVtQm9vbGVhbkJvZHlcIiA9PT0gbm9kZVR5cGUgfHwgXCJFbnVtTnVtYmVyQm9keVwiID09PSBub2RlVHlwZSB8fCBcIkVudW1TdHJpbmdCb2R5XCIgPT09IG5vZGVUeXBlIHx8IFwiRW51bVN5bWJvbEJvZHlcIiA9PT0gbm9kZVR5cGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0VudW1NZW1iZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkVudW1NZW1iZXJcIiB8fCBcIkVudW1Cb29sZWFuTWVtYmVyXCIgPT09IG5vZGVUeXBlIHx8IFwiRW51bU51bWJlck1lbWJlclwiID09PSBub2RlVHlwZSB8fCBcIkVudW1TdHJpbmdNZW1iZXJcIiA9PT0gbm9kZVR5cGUgfHwgXCJFbnVtRGVmYXVsdGVkTWVtYmVyXCIgPT09IG5vZGVUeXBlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNKU1gobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkpTWFwiIHx8IFwiSlNYQXR0cmlidXRlXCIgPT09IG5vZGVUeXBlIHx8IFwiSlNYQ2xvc2luZ0VsZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJKU1hFbGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiSlNYRW1wdHlFeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiID09PSBub2RlVHlwZSB8fCBcIkpTWFNwcmVhZENoaWxkXCIgPT09IG5vZGVUeXBlIHx8IFwiSlNYSWRlbnRpZmllclwiID09PSBub2RlVHlwZSB8fCBcIkpTWE1lbWJlckV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJKU1hOYW1lc3BhY2VkTmFtZVwiID09PSBub2RlVHlwZSB8fCBcIkpTWE9wZW5pbmdFbGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiSlNYU3ByZWFkQXR0cmlidXRlXCIgPT09IG5vZGVUeXBlIHx8IFwiSlNYVGV4dFwiID09PSBub2RlVHlwZSB8fCBcIkpTWEZyYWdtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiSlNYT3BlbmluZ0ZyYWdtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiSlNYQ2xvc2luZ0ZyYWdtZW50XCIgPT09IG5vZGVUeXBlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNQcml2YXRlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJQcml2YXRlXCIgfHwgXCJDbGFzc1ByaXZhdGVQcm9wZXJ0eVwiID09PSBub2RlVHlwZSB8fCBcIkNsYXNzUHJpdmF0ZU1ldGhvZFwiID09PSBub2RlVHlwZSB8fCBcIlByaXZhdGVOYW1lXCIgPT09IG5vZGVUeXBlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU1R5cGVFbGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU1R5cGVFbGVtZW50XCIgfHwgXCJUU0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIlRTQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJUU1Byb3BlcnR5U2lnbmF0dXJlXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNNZXRob2RTaWduYXR1cmVcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU0luZGV4U2lnbmF0dXJlXCIgPT09IG5vZGVUeXBlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU1R5cGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTVHlwZVwiIHx8IFwiVFNBbnlLZXl3b3JkXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNCb29sZWFuS2V5d29yZFwiID09PSBub2RlVHlwZSB8fCBcIlRTQmlnSW50S2V5d29yZFwiID09PSBub2RlVHlwZSB8fCBcIlRTTmV2ZXJLZXl3b3JkXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNOdWxsS2V5d29yZFwiID09PSBub2RlVHlwZSB8fCBcIlRTTnVtYmVyS2V5d29yZFwiID09PSBub2RlVHlwZSB8fCBcIlRTT2JqZWN0S2V5d29yZFwiID09PSBub2RlVHlwZSB8fCBcIlRTU3RyaW5nS2V5d29yZFwiID09PSBub2RlVHlwZSB8fCBcIlRTU3ltYm9sS2V5d29yZFwiID09PSBub2RlVHlwZSB8fCBcIlRTVW5kZWZpbmVkS2V5d29yZFwiID09PSBub2RlVHlwZSB8fCBcIlRTVW5rbm93bktleXdvcmRcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU1ZvaWRLZXl3b3JkXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNUaGlzVHlwZVwiID09PSBub2RlVHlwZSB8fCBcIlRTRnVuY3Rpb25UeXBlXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNDb25zdHJ1Y3RvclR5cGVcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU1R5cGVSZWZlcmVuY2VcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU1R5cGVQcmVkaWNhdGVcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU1R5cGVRdWVyeVwiID09PSBub2RlVHlwZSB8fCBcIlRTVHlwZUxpdGVyYWxcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU0FycmF5VHlwZVwiID09PSBub2RlVHlwZSB8fCBcIlRTVHVwbGVUeXBlXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNPcHRpb25hbFR5cGVcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU1Jlc3RUeXBlXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNVbmlvblR5cGVcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU0ludGVyc2VjdGlvblR5cGVcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU0NvbmRpdGlvbmFsVHlwZVwiID09PSBub2RlVHlwZSB8fCBcIlRTSW5mZXJUeXBlXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNQYXJlbnRoZXNpemVkVHlwZVwiID09PSBub2RlVHlwZSB8fCBcIlRTVHlwZU9wZXJhdG9yXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNJbmRleGVkQWNjZXNzVHlwZVwiID09PSBub2RlVHlwZSB8fCBcIlRTTWFwcGVkVHlwZVwiID09PSBub2RlVHlwZSB8fCBcIlRTTGl0ZXJhbFR5cGVcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU0V4cHJlc3Npb25XaXRoVHlwZUFyZ3VtZW50c1wiID09PSBub2RlVHlwZSB8fCBcIlRTSW1wb3J0VHlwZVwiID09PSBub2RlVHlwZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNCYXNlVHlwZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNCYXNlVHlwZVwiIHx8IFwiVFNBbnlLZXl3b3JkXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNCb29sZWFuS2V5d29yZFwiID09PSBub2RlVHlwZSB8fCBcIlRTQmlnSW50S2V5d29yZFwiID09PSBub2RlVHlwZSB8fCBcIlRTTmV2ZXJLZXl3b3JkXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNOdWxsS2V5d29yZFwiID09PSBub2RlVHlwZSB8fCBcIlRTTnVtYmVyS2V5d29yZFwiID09PSBub2RlVHlwZSB8fCBcIlRTT2JqZWN0S2V5d29yZFwiID09PSBub2RlVHlwZSB8fCBcIlRTU3RyaW5nS2V5d29yZFwiID09PSBub2RlVHlwZSB8fCBcIlRTU3ltYm9sS2V5d29yZFwiID09PSBub2RlVHlwZSB8fCBcIlRTVW5kZWZpbmVkS2V5d29yZFwiID09PSBub2RlVHlwZSB8fCBcIlRTVW5rbm93bktleXdvcmRcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU1ZvaWRLZXl3b3JkXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNUaGlzVHlwZVwiID09PSBub2RlVHlwZSB8fCBcIlRTTGl0ZXJhbFR5cGVcIiA9PT0gbm9kZVR5cGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc051bWJlckxpdGVyYWwobm9kZSwgb3B0cykge1xuICBjb25zb2xlLnRyYWNlKFwiVGhlIG5vZGUgdHlwZSBOdW1iZXJMaXRlcmFsIGhhcyBiZWVuIHJlbmFtZWQgdG8gTnVtZXJpY0xpdGVyYWxcIik7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiTnVtYmVyTGl0ZXJhbFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNSZWdleExpdGVyYWwobm9kZSwgb3B0cykge1xuICBjb25zb2xlLnRyYWNlKFwiVGhlIG5vZGUgdHlwZSBSZWdleExpdGVyYWwgaGFzIGJlZW4gcmVuYW1lZCB0byBSZWdFeHBMaXRlcmFsXCIpO1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlJlZ2V4TGl0ZXJhbFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNSZXN0UHJvcGVydHkobm9kZSwgb3B0cykge1xuICBjb25zb2xlLnRyYWNlKFwiVGhlIG5vZGUgdHlwZSBSZXN0UHJvcGVydHkgaGFzIGJlZW4gcmVuYW1lZCB0byBSZXN0RWxlbWVudFwiKTtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJSZXN0UHJvcGVydHlcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzU3ByZWFkUHJvcGVydHkobm9kZSwgb3B0cykge1xuICBjb25zb2xlLnRyYWNlKFwiVGhlIG5vZGUgdHlwZSBTcHJlYWRQcm9wZXJ0eSBoYXMgYmVlbiByZW5hbWVkIHRvIFNwcmVhZEVsZW1lbnRcIik7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiU3ByZWFkUHJvcGVydHlcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpcztcblxudmFyIF9zaGFsbG93RXF1YWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi91dGlscy9zaGFsbG93RXF1YWxcIikpO1xuXG52YXIgX2lzVHlwZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaXNUeXBlXCIpKTtcblxudmFyIF9pc1BsYWNlaG9sZGVyVHlwZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaXNQbGFjZWhvbGRlclR5cGVcIikpO1xuXG52YXIgX2RlZmluaXRpb25zID0gcmVxdWlyZShcIi4uL2RlZmluaXRpb25zXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBpcyh0eXBlLCBub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBtYXRjaGVzID0gKDAsIF9pc1R5cGUuZGVmYXVsdCkobm9kZS50eXBlLCB0eXBlKTtcblxuICBpZiAoIW1hdGNoZXMpIHtcbiAgICBpZiAoIW9wdHMgJiYgbm9kZS50eXBlID09PSBcIlBsYWNlaG9sZGVyXCIgJiYgdHlwZSBpbiBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTKSB7XG4gICAgICByZXR1cm4gKDAsIF9pc1BsYWNlaG9sZGVyVHlwZS5kZWZhdWx0KShub2RlLmV4cGVjdGVkTm9kZSwgdHlwZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICB9XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0JpbmRpbmc7XG5cbnZhciBfZ2V0QmluZGluZ0lkZW50aWZpZXJzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vcmV0cmlldmVycy9nZXRCaW5kaW5nSWRlbnRpZmllcnNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBpc0JpbmRpbmcobm9kZSwgcGFyZW50LCBncmFuZHBhcmVudCkge1xuICBpZiAoZ3JhbmRwYXJlbnQgJiYgbm9kZS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBwYXJlbnQudHlwZSA9PT0gXCJPYmplY3RQcm9wZXJ0eVwiICYmIGdyYW5kcGFyZW50LnR5cGUgPT09IFwiT2JqZWN0RXhwcmVzc2lvblwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3Qga2V5cyA9IF9nZXRCaW5kaW5nSWRlbnRpZmllcnMuZGVmYXVsdC5rZXlzW3BhcmVudC50eXBlXTtcblxuICBpZiAoa2V5cykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgIGNvbnN0IHZhbCA9IHBhcmVudFtrZXldO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIGlmICh2YWwuaW5kZXhPZihub2RlKSA+PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2YWwgPT09IG5vZGUpIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzQmxvY2tTY29wZWQ7XG5cbnZhciBfZ2VuZXJhdGVkID0gcmVxdWlyZShcIi4vZ2VuZXJhdGVkXCIpO1xuXG52YXIgX2lzTGV0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pc0xldFwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGlzQmxvY2tTY29wZWQobm9kZSkge1xuICByZXR1cm4gKDAsIF9nZW5lcmF0ZWQuaXNGdW5jdGlvbkRlY2xhcmF0aW9uKShub2RlKSB8fCAoMCwgX2dlbmVyYXRlZC5pc0NsYXNzRGVjbGFyYXRpb24pKG5vZGUpIHx8ICgwLCBfaXNMZXQuZGVmYXVsdCkobm9kZSk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0ltbXV0YWJsZTtcblxudmFyIF9pc1R5cGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2lzVHlwZVwiKSk7XG5cbnZhciBfZ2VuZXJhdGVkID0gcmVxdWlyZShcIi4vZ2VuZXJhdGVkXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBpc0ltbXV0YWJsZShub2RlKSB7XG4gIGlmICgoMCwgX2lzVHlwZS5kZWZhdWx0KShub2RlLnR5cGUsIFwiSW1tdXRhYmxlXCIpKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNJZGVudGlmaWVyKShub2RlKSkge1xuICAgIGlmIChub2RlLm5hbWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNMZXQ7XG5cbnZhciBfZ2VuZXJhdGVkID0gcmVxdWlyZShcIi4vZ2VuZXJhdGVkXCIpO1xuXG52YXIgX2NvbnN0YW50cyA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHNcIik7XG5cbmZ1bmN0aW9uIGlzTGV0KG5vZGUpIHtcbiAgcmV0dXJuICgwLCBfZ2VuZXJhdGVkLmlzVmFyaWFibGVEZWNsYXJhdGlvbikobm9kZSkgJiYgKG5vZGUua2luZCAhPT0gXCJ2YXJcIiB8fCBub2RlW19jb25zdGFudHMuQkxPQ0tfU0NPUEVEX1NZTUJPTF0pO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNOb2RlO1xuXG52YXIgX2RlZmluaXRpb25zID0gcmVxdWlyZShcIi4uL2RlZmluaXRpb25zXCIpO1xuXG5mdW5jdGlvbiBpc05vZGUobm9kZSkge1xuICByZXR1cm4gISEobm9kZSAmJiBfZGVmaW5pdGlvbnMuVklTSVRPUl9LRVlTW25vZGUudHlwZV0pO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNOb2Rlc0VxdWl2YWxlbnQ7XG5cbnZhciBfZGVmaW5pdGlvbnMgPSByZXF1aXJlKFwiLi4vZGVmaW5pdGlvbnNcIik7XG5cbmZ1bmN0aW9uIGlzTm9kZXNFcXVpdmFsZW50KGEsIGIpIHtcbiAgaWYgKHR5cGVvZiBhICE9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBiICE9PSBcIm9iamVjdFwiIHx8IGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHtcbiAgICByZXR1cm4gYSA9PT0gYjtcbiAgfVxuXG4gIGlmIChhLnR5cGUgIT09IGIudHlwZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGZpZWxkcyA9IE9iamVjdC5rZXlzKF9kZWZpbml0aW9ucy5OT0RFX0ZJRUxEU1thLnR5cGVdIHx8IGEudHlwZSk7XG4gIGNvbnN0IHZpc2l0b3JLZXlzID0gX2RlZmluaXRpb25zLlZJU0lUT1JfS0VZU1thLnR5cGVdO1xuXG4gIGZvciAoY29uc3QgZmllbGQgb2YgZmllbGRzKSB7XG4gICAgaWYgKHR5cGVvZiBhW2ZpZWxkXSAhPT0gdHlwZW9mIGJbZmllbGRdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGFbZmllbGRdID09IG51bGwgJiYgYltmaWVsZF0gPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmIChhW2ZpZWxkXSA9PSBudWxsIHx8IGJbZmllbGRdID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhW2ZpZWxkXSkpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShiW2ZpZWxkXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoYVtmaWVsZF0ubGVuZ3RoICE9PSBiW2ZpZWxkXS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFbZmllbGRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghaXNOb2Rlc0VxdWl2YWxlbnQoYVtmaWVsZF1baV0sIGJbZmllbGRdW2ldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGFbZmllbGRdID09PSBcIm9iamVjdFwiICYmICEodmlzaXRvcktleXMgPT0gbnVsbCA/IHZvaWQgMCA6IHZpc2l0b3JLZXlzLmluY2x1ZGVzKGZpZWxkKSkpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGFbZmllbGRdKSkge1xuICAgICAgICBpZiAoYVtmaWVsZF1ba2V5XSAhPT0gYltmaWVsZF1ba2V5XSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoIWlzTm9kZXNFcXVpdmFsZW50KGFbZmllbGRdLCBiW2ZpZWxkXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzUGxhY2Vob2xkZXJUeXBlO1xuXG52YXIgX2RlZmluaXRpb25zID0gcmVxdWlyZShcIi4uL2RlZmluaXRpb25zXCIpO1xuXG5mdW5jdGlvbiBpc1BsYWNlaG9sZGVyVHlwZShwbGFjZWhvbGRlclR5cGUsIHRhcmdldFR5cGUpIHtcbiAgaWYgKHBsYWNlaG9sZGVyVHlwZSA9PT0gdGFyZ2V0VHlwZSkgcmV0dXJuIHRydWU7XG4gIGNvbnN0IGFsaWFzZXMgPSBfZGVmaW5pdGlvbnMuUExBQ0VIT0xERVJTX0FMSUFTW3BsYWNlaG9sZGVyVHlwZV07XG5cbiAgaWYgKGFsaWFzZXMpIHtcbiAgICBmb3IgKGNvbnN0IGFsaWFzIG9mIGFsaWFzZXMpIHtcbiAgICAgIGlmICh0YXJnZXRUeXBlID09PSBhbGlhcykgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNSZWZlcmVuY2VkO1xuXG5mdW5jdGlvbiBpc1JlZmVyZW5jZWQobm9kZSwgcGFyZW50LCBncmFuZHBhcmVudCkge1xuICBzd2l0Y2ggKHBhcmVudC50eXBlKSB7XG4gICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiSlNYTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgIGlmIChwYXJlbnQucHJvcGVydHkgPT09IG5vZGUpIHtcbiAgICAgICAgcmV0dXJuICEhcGFyZW50LmNvbXB1dGVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyZW50Lm9iamVjdCA9PT0gbm9kZTtcblxuICAgIGNhc2UgXCJWYXJpYWJsZURlY2xhcmF0b3JcIjpcbiAgICAgIHJldHVybiBwYXJlbnQuaW5pdCA9PT0gbm9kZTtcblxuICAgIGNhc2UgXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiOlxuICAgICAgcmV0dXJuIHBhcmVudC5ib2R5ID09PSBub2RlO1xuXG4gICAgY2FzZSBcIkV4cG9ydFNwZWNpZmllclwiOlxuICAgICAgaWYgKHBhcmVudC5zb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyZW50LmxvY2FsID09PSBub2RlO1xuXG4gICAgY2FzZSBcIlByaXZhdGVOYW1lXCI6XG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBjYXNlIFwiQ2xhc3NNZXRob2RcIjpcbiAgICBjYXNlIFwiQ2xhc3NQcml2YXRlTWV0aG9kXCI6XG4gICAgY2FzZSBcIk9iamVjdE1ldGhvZFwiOlxuICAgICAgaWYgKHBhcmVudC5wYXJhbXMuaW5jbHVkZXMobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgY2FzZSBcIk9iamVjdFByb3BlcnR5XCI6XG4gICAgY2FzZSBcIkNsYXNzUHJvcGVydHlcIjpcbiAgICBjYXNlIFwiQ2xhc3NQcml2YXRlUHJvcGVydHlcIjpcbiAgICAgIGlmIChwYXJlbnQua2V5ID09PSBub2RlKSB7XG4gICAgICAgIHJldHVybiAhIXBhcmVudC5jb21wdXRlZDtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmVudC52YWx1ZSA9PT0gbm9kZSkge1xuICAgICAgICByZXR1cm4gIWdyYW5kcGFyZW50IHx8IGdyYW5kcGFyZW50LnR5cGUgIT09IFwiT2JqZWN0UGF0dGVyblwiO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgXCJDbGFzc0RlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIkNsYXNzRXhwcmVzc2lvblwiOlxuICAgICAgcmV0dXJuIHBhcmVudC5zdXBlckNsYXNzID09PSBub2RlO1xuXG4gICAgY2FzZSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCI6XG4gICAgICByZXR1cm4gcGFyZW50LnJpZ2h0ID09PSBub2RlO1xuXG4gICAgY2FzZSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI6XG4gICAgICByZXR1cm4gcGFyZW50LnJpZ2h0ID09PSBub2RlO1xuXG4gICAgY2FzZSBcIkxhYmVsZWRTdGF0ZW1lbnRcIjpcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGNhc2UgXCJDYXRjaENsYXVzZVwiOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgY2FzZSBcIlJlc3RFbGVtZW50XCI6XG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBjYXNlIFwiQnJlYWtTdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiQ29udGludWVTdGF0ZW1lbnRcIjpcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGNhc2UgXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgY2FzZSBcIkV4cG9ydE5hbWVzcGFjZVNwZWNpZmllclwiOlxuICAgIGNhc2UgXCJFeHBvcnREZWZhdWx0U3BlY2lmaWVyXCI6XG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBjYXNlIFwiSW1wb3J0RGVmYXVsdFNwZWNpZmllclwiOlxuICAgIGNhc2UgXCJJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIjpcbiAgICBjYXNlIFwiSW1wb3J0U3BlY2lmaWVyXCI6XG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBjYXNlIFwiSlNYQXR0cmlidXRlXCI6XG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgIGNhc2UgXCJBcnJheVBhdHRlcm5cIjpcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGNhc2UgXCJNZXRhUHJvcGVydHlcIjpcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGNhc2UgXCJPYmplY3RUeXBlUHJvcGVydHlcIjpcbiAgICAgIHJldHVybiBwYXJlbnQua2V5ICE9PSBub2RlO1xuXG4gICAgY2FzZSBcIlRTRW51bU1lbWJlclwiOlxuICAgICAgcmV0dXJuIHBhcmVudC5pZCAhPT0gbm9kZTtcblxuICAgIGNhc2UgXCJUU1Byb3BlcnR5U2lnbmF0dXJlXCI6XG4gICAgICBpZiAocGFyZW50LmtleSA9PT0gbm9kZSkge1xuICAgICAgICByZXR1cm4gISFwYXJlbnQuY29tcHV0ZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc1Njb3BlO1xuXG52YXIgX2dlbmVyYXRlZCA9IHJlcXVpcmUoXCIuL2dlbmVyYXRlZFwiKTtcblxuZnVuY3Rpb24gaXNTY29wZShub2RlLCBwYXJlbnQpIHtcbiAgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzQmxvY2tTdGF0ZW1lbnQpKG5vZGUpICYmICgwLCBfZ2VuZXJhdGVkLmlzRnVuY3Rpb24pKHBhcmVudCwge1xuICAgIGJvZHk6IG5vZGVcbiAgfSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNCbG9ja1N0YXRlbWVudCkobm9kZSkgJiYgKDAsIF9nZW5lcmF0ZWQuaXNDYXRjaENsYXVzZSkocGFyZW50LCB7XG4gICAgYm9keTogbm9kZVxuICB9KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICgoMCwgX2dlbmVyYXRlZC5pc1BhdHRlcm4pKG5vZGUpICYmICgwLCBfZ2VuZXJhdGVkLmlzRnVuY3Rpb24pKHBhcmVudCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiAoMCwgX2dlbmVyYXRlZC5pc1Njb3BhYmxlKShub2RlKTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzU3BlY2lmaWVyRGVmYXVsdDtcblxudmFyIF9nZW5lcmF0ZWQgPSByZXF1aXJlKFwiLi9nZW5lcmF0ZWRcIik7XG5cbmZ1bmN0aW9uIGlzU3BlY2lmaWVyRGVmYXVsdChzcGVjaWZpZXIpIHtcbiAgcmV0dXJuICgwLCBfZ2VuZXJhdGVkLmlzSW1wb3J0RGVmYXVsdFNwZWNpZmllcikoc3BlY2lmaWVyKSB8fCAoMCwgX2dlbmVyYXRlZC5pc0lkZW50aWZpZXIpKHNwZWNpZmllci5pbXBvcnRlZCB8fCBzcGVjaWZpZXIuZXhwb3J0ZWQsIHtcbiAgICBuYW1lOiBcImRlZmF1bHRcIlxuICB9KTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzVHlwZTtcblxudmFyIF9kZWZpbml0aW9ucyA9IHJlcXVpcmUoXCIuLi9kZWZpbml0aW9uc1wiKTtcblxuZnVuY3Rpb24gaXNUeXBlKG5vZGVUeXBlLCB0YXJnZXRUeXBlKSB7XG4gIGlmIChub2RlVHlwZSA9PT0gdGFyZ2V0VHlwZSkgcmV0dXJuIHRydWU7XG4gIGlmIChfZGVmaW5pdGlvbnMuQUxJQVNfS0VZU1t0YXJnZXRUeXBlXSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBhbGlhc2VzID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1t0YXJnZXRUeXBlXTtcblxuICBpZiAoYWxpYXNlcykge1xuICAgIGlmIChhbGlhc2VzWzBdID09PSBub2RlVHlwZSkgcmV0dXJuIHRydWU7XG5cbiAgICBmb3IgKGNvbnN0IGFsaWFzIG9mIGFsaWFzZXMpIHtcbiAgICAgIGlmIChub2RlVHlwZSA9PT0gYWxpYXMpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzVmFsaWRFUzNJZGVudGlmaWVyO1xuXG52YXIgX2lzVmFsaWRJZGVudGlmaWVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pc1ZhbGlkSWRlbnRpZmllclwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmNvbnN0IFJFU0VSVkVEX1dPUkRTX0VTM19PTkxZID0gbmV3IFNldChbXCJhYnN0cmFjdFwiLCBcImJvb2xlYW5cIiwgXCJieXRlXCIsIFwiY2hhclwiLCBcImRvdWJsZVwiLCBcImVudW1cIiwgXCJmaW5hbFwiLCBcImZsb2F0XCIsIFwiZ290b1wiLCBcImltcGxlbWVudHNcIiwgXCJpbnRcIiwgXCJpbnRlcmZhY2VcIiwgXCJsb25nXCIsIFwibmF0aXZlXCIsIFwicGFja2FnZVwiLCBcInByaXZhdGVcIiwgXCJwcm90ZWN0ZWRcIiwgXCJwdWJsaWNcIiwgXCJzaG9ydFwiLCBcInN0YXRpY1wiLCBcInN5bmNocm9uaXplZFwiLCBcInRocm93c1wiLCBcInRyYW5zaWVudFwiLCBcInZvbGF0aWxlXCJdKTtcblxuZnVuY3Rpb24gaXNWYWxpZEVTM0lkZW50aWZpZXIobmFtZSkge1xuICByZXR1cm4gKDAsIF9pc1ZhbGlkSWRlbnRpZmllci5kZWZhdWx0KShuYW1lKSAmJiAhUkVTRVJWRURfV09SRFNfRVMzX09OTFkuaGFzKG5hbWUpO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNWYWxpZElkZW50aWZpZXI7XG5cbnZhciBfaGVscGVyVmFsaWRhdG9ySWRlbnRpZmllciA9IHJlcXVpcmUoXCJAYmFiZWwvaGVscGVyLXZhbGlkYXRvci1pZGVudGlmaWVyXCIpO1xuXG5mdW5jdGlvbiBpc1ZhbGlkSWRlbnRpZmllcihuYW1lLCByZXNlcnZlZCA9IHRydWUpIHtcbiAgaWYgKHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHJlc2VydmVkKSB7XG4gICAgaWYgKCgwLCBfaGVscGVyVmFsaWRhdG9ySWRlbnRpZmllci5pc0tleXdvcmQpKG5hbWUpIHx8ICgwLCBfaGVscGVyVmFsaWRhdG9ySWRlbnRpZmllci5pc1N0cmljdFJlc2VydmVkV29yZCkobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwiYXdhaXRcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAoMCwgX2hlbHBlclZhbGlkYXRvcklkZW50aWZpZXIuaXNJZGVudGlmaWVyTmFtZSkobmFtZSk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc1ZhcjtcblxudmFyIF9nZW5lcmF0ZWQgPSByZXF1aXJlKFwiLi9nZW5lcmF0ZWRcIik7XG5cbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcblxuZnVuY3Rpb24gaXNWYXIobm9kZSkge1xuICByZXR1cm4gKDAsIF9nZW5lcmF0ZWQuaXNWYXJpYWJsZURlY2xhcmF0aW9uKShub2RlLCB7XG4gICAga2luZDogXCJ2YXJcIlxuICB9KSAmJiAhbm9kZVtfY29uc3RhbnRzLkJMT0NLX1NDT1BFRF9TWU1CT0xdO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gbWF0Y2hlc1BhdHRlcm47XG5cbnZhciBfZ2VuZXJhdGVkID0gcmVxdWlyZShcIi4vZ2VuZXJhdGVkXCIpO1xuXG5mdW5jdGlvbiBtYXRjaGVzUGF0dGVybihtZW1iZXIsIG1hdGNoLCBhbGxvd1BhcnRpYWwpIHtcbiAgaWYgKCEoMCwgX2dlbmVyYXRlZC5pc01lbWJlckV4cHJlc3Npb24pKG1lbWJlcikpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgcGFydHMgPSBBcnJheS5pc0FycmF5KG1hdGNoKSA/IG1hdGNoIDogbWF0Y2guc3BsaXQoXCIuXCIpO1xuICBjb25zdCBub2RlcyA9IFtdO1xuICBsZXQgbm9kZTtcblxuICBmb3IgKG5vZGUgPSBtZW1iZXI7ICgwLCBfZ2VuZXJhdGVkLmlzTWVtYmVyRXhwcmVzc2lvbikobm9kZSk7IG5vZGUgPSBub2RlLm9iamVjdCkge1xuICAgIG5vZGVzLnB1c2gobm9kZS5wcm9wZXJ0eSk7XG4gIH1cblxuICBub2Rlcy5wdXNoKG5vZGUpO1xuICBpZiAobm9kZXMubGVuZ3RoIDwgcGFydHMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIGlmICghYWxsb3dQYXJ0aWFsICYmIG5vZGVzLmxlbmd0aCA+IHBhcnRzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAobGV0IGkgPSAwLCBqID0gbm9kZXMubGVuZ3RoIC0gMTsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrLCBqLS0pIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbal07XG4gICAgbGV0IHZhbHVlO1xuXG4gICAgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzSWRlbnRpZmllcikobm9kZSkpIHtcbiAgICAgIHZhbHVlID0gbm9kZS5uYW1lO1xuICAgIH0gZWxzZSBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNTdHJpbmdMaXRlcmFsKShub2RlKSkge1xuICAgICAgdmFsdWUgPSBub2RlLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHBhcnRzW2ldICE9PSB2YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0NvbXBhdFRhZztcblxuZnVuY3Rpb24gaXNDb21wYXRUYWcodGFnTmFtZSkge1xuICByZXR1cm4gISF0YWdOYW1lICYmIC9eW2Etel0vLnRlc3QodGFnTmFtZSk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfYnVpbGRNYXRjaE1lbWJlckV4cHJlc3Npb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9idWlsZE1hdGNoTWVtYmVyRXhwcmVzc2lvblwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmNvbnN0IGlzUmVhY3RDb21wb25lbnQgPSAoMCwgX2J1aWxkTWF0Y2hNZW1iZXJFeHByZXNzaW9uLmRlZmF1bHQpKFwiUmVhY3QuQ29tcG9uZW50XCIpO1xudmFyIF9kZWZhdWx0ID0gaXNSZWFjdENvbXBvbmVudDtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdmFsaWRhdGU7XG5leHBvcnRzLnZhbGlkYXRlRmllbGQgPSB2YWxpZGF0ZUZpZWxkO1xuZXhwb3J0cy52YWxpZGF0ZUNoaWxkID0gdmFsaWRhdGVDaGlsZDtcblxudmFyIF9kZWZpbml0aW9ucyA9IHJlcXVpcmUoXCIuLi9kZWZpbml0aW9uc1wiKTtcblxuZnVuY3Rpb24gdmFsaWRhdGUobm9kZSwga2V5LCB2YWwpIHtcbiAgaWYgKCFub2RlKSByZXR1cm47XG4gIGNvbnN0IGZpZWxkcyA9IF9kZWZpbml0aW9ucy5OT0RFX0ZJRUxEU1tub2RlLnR5cGVdO1xuICBpZiAoIWZpZWxkcykgcmV0dXJuO1xuICBjb25zdCBmaWVsZCA9IGZpZWxkc1trZXldO1xuICB2YWxpZGF0ZUZpZWxkKG5vZGUsIGtleSwgdmFsLCBmaWVsZCk7XG4gIHZhbGlkYXRlQ2hpbGQobm9kZSwga2V5LCB2YWwpO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZpZWxkKG5vZGUsIGtleSwgdmFsLCBmaWVsZCkge1xuICBpZiAoIShmaWVsZCA9PSBudWxsID8gdm9pZCAwIDogZmllbGQudmFsaWRhdGUpKSByZXR1cm47XG4gIGlmIChmaWVsZC5vcHRpb25hbCAmJiB2YWwgPT0gbnVsbCkgcmV0dXJuO1xuICBmaWVsZC52YWxpZGF0ZShub2RlLCBrZXksIHZhbCk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGQobm9kZSwga2V5LCB2YWwpIHtcbiAgaWYgKHZhbCA9PSBudWxsKSByZXR1cm47XG4gIGNvbnN0IHZhbGlkYXRlID0gX2RlZmluaXRpb25zLk5PREVfUEFSRU5UX1ZBTElEQVRJT05TW3ZhbC50eXBlXTtcbiAgaWYgKCF2YWxpZGF0ZSkgcmV0dXJuO1xuICB2YWxpZGF0ZShub2RlLCBrZXksIHZhbCk7XG59IiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKFxuICAgICAgdWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKVxuICAgICkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG52YXIgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZlxuZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxuICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydFxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5pZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICtcbiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nXG4gIClcbn1cblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHsgX19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9IH1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MlxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdwYXJlbnQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAnb2Zmc2V0Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ5dGVPZmZzZXRcbiAgfVxufSlcblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgbGVuZ3RoICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGJ1ZlxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKGFyZylcbiAgfVxuICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbmlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAhPSBudWxsICYmXG4gICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh2YWx1ZSlcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICAgIClcbiAgfVxuXG4gIGlmIChpc0luc3RhbmNlKHZhbHVlLCBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgQXJyYXlCdWZmZXIpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICApXG4gIH1cblxuICB2YXIgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YgJiYgdmFsdWUudmFsdWVPZigpXG4gIGlmICh2YWx1ZU9mICE9IG51bGwgJiYgdmFsdWVPZiAhPT0gdmFsdWUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVPZiwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgdmFyIGIgPSBmcm9tT2JqZWN0KHZhbHVlKVxuICBpZiAoYikgcmV0dXJuIGJcblxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvUHJpbWl0aXZlICE9IG51bGwgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFxuICAgICAgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSgnc3RyaW5nJyksIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aFxuICAgIClcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1Zzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5CdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG5CdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgc2l6ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcIm9mZnNldFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIHZhciBidWZcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAob2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuKVxuXG4gICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBidWZcbiAgICB9XG5cbiAgICBvYmouY29weShidWYsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKVxuICAgIH1cbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmopXG4gIH1cblxuICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IEtfTUFYX0xFTkdUSGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsgS19NQVhfTEVOR1RILnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyID09PSB0cnVlICYmXG4gICAgYiAhPT0gQnVmZmVyLnByb3RvdHlwZSAvLyBzbyBCdWZmZXIuaXNCdWZmZXIoQnVmZmVyLnByb3RvdHlwZSkgd2lsbCBiZSBmYWxzZVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYSwgVWludDhBcnJheSkpIGEgPSBCdWZmZXIuZnJvbShhLCBhLm9mZnNldCwgYS5ieXRlTGVuZ3RoKVxuICBpZiAoaXNJbnN0YW5jZShiLCBVaW50OEFycmF5KSkgYiA9IEJ1ZmZlci5mcm9tKGIsIGIub2Zmc2V0LCBiLmJ5dGVMZW5ndGgpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcImJ1ZjFcIiwgXCJidWYyXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknXG4gICAgKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKGlzSW5zdGFuY2UoYnVmLCBVaW50OEFycmF5KSkge1xuICAgICAgYnVmID0gQnVmZmVyLmZyb20oYnVmKVxuICAgIH1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBpc0luc3RhbmNlKHN0cmluZywgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHN0cmluZ1xuICAgIClcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBtdXN0TWF0Y2ggPSAoYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdID09PSB0cnVlKVxuICBpZiAoIW11c3RNYXRjaCAmJiBsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHtcbiAgICAgICAgICByZXR1cm4gbXVzdE1hdGNoID8gLTEgOiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICB9XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIChhbmQgdGhlIGBpcy1idWZmZXJgIG5wbSBwYWNrYWdlKVxuLy8gdG8gZGV0ZWN0IGEgQnVmZmVyIGluc3RhbmNlLiBJdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgYGluc3RhbmNlb2YgQnVmZmVyYFxuLy8gcmVsaWFibHkgaW4gYSBicm93c2VyaWZ5IGNvbnRleHQgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBkaWZmZXJlbnRcbi8vIGNvcGllcyBvZiB0aGUgJ2J1ZmZlcicgcGFja2FnZSBpbiB1c2UuIFRoaXMgbWV0aG9kIHdvcmtzIGV2ZW4gZm9yIEJ1ZmZlclxuLy8gaW5zdGFuY2VzIHRoYXQgd2VyZSBjcmVhdGVkIGZyb20gYW5vdGhlciBjb3B5IG9mIHRoZSBgYnVmZmVyYCBwYWNrYWdlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTU0XG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZ1xuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLnJlcGxhY2UoLyguezJ9KS9nLCAnJDEgJykudHJpbSgpXG4gIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKGlzSW5zdGFuY2UodGFyZ2V0LCBVaW50OEFycmF5KSkge1xuICAgIHRhcmdldCA9IEJ1ZmZlci5mcm9tKHRhcmdldCwgdGFyZ2V0Lm9mZnNldCwgdGFyZ2V0LmJ5dGVMZW5ndGgpXG4gIH1cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB0YXJnZXQpXG4gICAgKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyJylcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVc2UgYnVpbHQtaW4gd2hlbiBhdmFpbGFibGUsIG1pc3NpbmcgZnJvbSBJRTExXG4gICAgdGhpcy5jb3B5V2l0aGluKHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKVxuICB9IGVsc2UgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoKGVuY29kaW5nID09PSAndXRmOCcgJiYgY29kZSA8IDEyOCkgfHxcbiAgICAgICAgICBlbmNvZGluZyA9PT0gJ2xhdGluMScpIHtcbiAgICAgICAgLy8gRmFzdCBwYXRoOiBJZiBgdmFsYCBmaXRzIGludG8gYSBzaW5nbGUgYnl0ZSwgdXNlIHRoYXQgbnVtZXJpYyB2YWx1ZS5cbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyB2YWwgK1xuICAgICAgICAnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJylcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSB0YWtlcyBlcXVhbCBzaWducyBhcyBlbmQgb2YgdGhlIEJhc2U2NCBlbmNvZGluZ1xuICBzdHIgPSBzdHIuc3BsaXQoJz0nKVswXVxuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbi8vIEFycmF5QnVmZmVyIG9yIFVpbnQ4QXJyYXkgb2JqZWN0cyBmcm9tIG90aGVyIGNvbnRleHRzIChpLmUuIGlmcmFtZXMpIGRvIG5vdCBwYXNzXG4vLyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrIGJ1dCB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIGFzIG9mIHRoYXQgdHlwZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxuZnVuY3Rpb24gaXNJbnN0YW5jZSAob2JqLCB0eXBlKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiB0eXBlIHx8XG4gICAgKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSB0eXBlLm5hbWUpXG59XG5mdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7XG4gIC8vIEZvciBJRTExIHN1cHBvcnRcbiAgcmV0dXJuIG9iaiAhPT0gb2JqIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG4iLCJ2YXIgY2hhcmVuYyA9IHtcbiAgLy8gVVRGLTggZW5jb2RpbmdcbiAgdXRmODoge1xuICAgIC8vIENvbnZlcnQgYSBzdHJpbmcgdG8gYSBieXRlIGFycmF5XG4gICAgc3RyaW5nVG9CeXRlczogZnVuY3Rpb24oc3RyKSB7XG4gICAgICByZXR1cm4gY2hhcmVuYy5iaW4uc3RyaW5nVG9CeXRlcyh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSkpO1xuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgYnl0ZSBhcnJheSB0byBhIHN0cmluZ1xuICAgIGJ5dGVzVG9TdHJpbmc6IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShjaGFyZW5jLmJpbi5ieXRlc1RvU3RyaW5nKGJ5dGVzKSkpO1xuICAgIH1cbiAgfSxcblxuICAvLyBCaW5hcnkgZW5jb2RpbmdcbiAgYmluOiB7XG4gICAgLy8gQ29udmVydCBhIHN0cmluZyB0byBhIGJ5dGUgYXJyYXlcbiAgICBzdHJpbmdUb0J5dGVzOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIGZvciAodmFyIGJ5dGVzID0gW10sIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKVxuICAgICAgICBieXRlcy5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRik7XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYSBieXRlIGFycmF5IHRvIGEgc3RyaW5nXG4gICAgYnl0ZXNUb1N0cmluZzogZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGZvciAodmFyIHN0ciA9IFtdLCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICBzdHIucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldKSk7XG4gICAgICByZXR1cm4gc3RyLmpvaW4oJycpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjaGFyZW5jO1xuIiwiKGZ1bmN0aW9uKCkge1xuICB2YXIgYmFzZTY0bWFwXG4gICAgICA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJyxcblxuICBjcnlwdCA9IHtcbiAgICAvLyBCaXQtd2lzZSByb3RhdGlvbiBsZWZ0XG4gICAgcm90bDogZnVuY3Rpb24obiwgYikge1xuICAgICAgcmV0dXJuIChuIDw8IGIpIHwgKG4gPj4+ICgzMiAtIGIpKTtcbiAgICB9LFxuXG4gICAgLy8gQml0LXdpc2Ugcm90YXRpb24gcmlnaHRcbiAgICByb3RyOiBmdW5jdGlvbihuLCBiKSB7XG4gICAgICByZXR1cm4gKG4gPDwgKDMyIC0gYikpIHwgKG4gPj4+IGIpO1xuICAgIH0sXG5cbiAgICAvLyBTd2FwIGJpZy1lbmRpYW4gdG8gbGl0dGxlLWVuZGlhbiBhbmQgdmljZSB2ZXJzYVxuICAgIGVuZGlhbjogZnVuY3Rpb24obikge1xuICAgICAgLy8gSWYgbnVtYmVyIGdpdmVuLCBzd2FwIGVuZGlhblxuICAgICAgaWYgKG4uY29uc3RydWN0b3IgPT0gTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBjcnlwdC5yb3RsKG4sIDgpICYgMHgwMEZGMDBGRiB8IGNyeXB0LnJvdGwobiwgMjQpICYgMHhGRjAwRkYwMDtcbiAgICAgIH1cblxuICAgICAgLy8gRWxzZSwgYXNzdW1lIGFycmF5IGFuZCBzd2FwIGFsbCBpdGVtc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuLmxlbmd0aDsgaSsrKVxuICAgICAgICBuW2ldID0gY3J5cHQuZW5kaWFuKG5baV0pO1xuICAgICAgcmV0dXJuIG47XG4gICAgfSxcblxuICAgIC8vIEdlbmVyYXRlIGFuIGFycmF5IG9mIGFueSBsZW5ndGggb2YgcmFuZG9tIGJ5dGVzXG4gICAgcmFuZG9tQnl0ZXM6IGZ1bmN0aW9uKG4pIHtcbiAgICAgIGZvciAodmFyIGJ5dGVzID0gW107IG4gPiAwOyBuLS0pXG4gICAgICAgIGJ5dGVzLnB1c2goTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KSk7XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYSBieXRlIGFycmF5IHRvIGJpZy1lbmRpYW4gMzItYml0IHdvcmRzXG4gICAgYnl0ZXNUb1dvcmRzOiBmdW5jdGlvbihieXRlcykge1xuICAgICAgZm9yICh2YXIgd29yZHMgPSBbXSwgaSA9IDAsIGIgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyssIGIgKz0gOClcbiAgICAgICAgd29yZHNbYiA+Pj4gNV0gfD0gYnl0ZXNbaV0gPDwgKDI0IC0gYiAlIDMyKTtcbiAgICAgIHJldHVybiB3b3JkcztcbiAgICB9LFxuXG4gICAgLy8gQ29udmVydCBiaWctZW5kaWFuIDMyLWJpdCB3b3JkcyB0byBhIGJ5dGUgYXJyYXlcbiAgICB3b3Jkc1RvQnl0ZXM6IGZ1bmN0aW9uKHdvcmRzKSB7XG4gICAgICBmb3IgKHZhciBieXRlcyA9IFtdLCBiID0gMDsgYiA8IHdvcmRzLmxlbmd0aCAqIDMyOyBiICs9IDgpXG4gICAgICAgIGJ5dGVzLnB1c2goKHdvcmRzW2IgPj4+IDVdID4+PiAoMjQgLSBiICUgMzIpKSAmIDB4RkYpO1xuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgYnl0ZSBhcnJheSB0byBhIGhleCBzdHJpbmdcbiAgICBieXRlc1RvSGV4OiBmdW5jdGlvbihieXRlcykge1xuICAgICAgZm9yICh2YXIgaGV4ID0gW10sIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4LnB1c2goKGJ5dGVzW2ldID4+PiA0KS50b1N0cmluZygxNikpO1xuICAgICAgICBoZXgucHVzaCgoYnl0ZXNbaV0gJiAweEYpLnRvU3RyaW5nKDE2KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGV4LmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgaGV4IHN0cmluZyB0byBhIGJ5dGUgYXJyYXlcbiAgICBoZXhUb0J5dGVzOiBmdW5jdGlvbihoZXgpIHtcbiAgICAgIGZvciAodmFyIGJ5dGVzID0gW10sIGMgPSAwOyBjIDwgaGV4Lmxlbmd0aDsgYyArPSAyKVxuICAgICAgICBieXRlcy5wdXNoKHBhcnNlSW50KGhleC5zdWJzdHIoYywgMiksIDE2KSk7XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYSBieXRlIGFycmF5IHRvIGEgYmFzZS02NCBzdHJpbmdcbiAgICBieXRlc1RvQmFzZTY0OiBmdW5jdGlvbihieXRlcykge1xuICAgICAgZm9yICh2YXIgYmFzZTY0ID0gW10sIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgdmFyIHRyaXBsZXQgPSAoYnl0ZXNbaV0gPDwgMTYpIHwgKGJ5dGVzW2kgKyAxXSA8PCA4KSB8IGJ5dGVzW2kgKyAyXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA0OyBqKyspXG4gICAgICAgICAgaWYgKGkgKiA4ICsgaiAqIDYgPD0gYnl0ZXMubGVuZ3RoICogOClcbiAgICAgICAgICAgIGJhc2U2NC5wdXNoKGJhc2U2NG1hcC5jaGFyQXQoKHRyaXBsZXQgPj4+IDYgKiAoMyAtIGopKSAmIDB4M0YpKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBiYXNlNjQucHVzaCgnPScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2U2NC5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLy8gQ29udmVydCBhIGJhc2UtNjQgc3RyaW5nIHRvIGEgYnl0ZSBhcnJheVxuICAgIGJhc2U2NFRvQnl0ZXM6IGZ1bmN0aW9uKGJhc2U2NCkge1xuICAgICAgLy8gUmVtb3ZlIG5vbi1iYXNlLTY0IGNoYXJhY3RlcnNcbiAgICAgIGJhc2U2NCA9IGJhc2U2NC5yZXBsYWNlKC9bXkEtWjAtOStcXC9dL2lnLCAnJyk7XG5cbiAgICAgIGZvciAodmFyIGJ5dGVzID0gW10sIGkgPSAwLCBpbW9kNCA9IDA7IGkgPCBiYXNlNjQubGVuZ3RoO1xuICAgICAgICAgIGltb2Q0ID0gKytpICUgNCkge1xuICAgICAgICBpZiAoaW1vZDQgPT0gMCkgY29udGludWU7XG4gICAgICAgIGJ5dGVzLnB1c2goKChiYXNlNjRtYXAuaW5kZXhPZihiYXNlNjQuY2hhckF0KGkgLSAxKSlcbiAgICAgICAgICAgICYgKE1hdGgucG93KDIsIC0yICogaW1vZDQgKyA4KSAtIDEpKSA8PCAoaW1vZDQgKiAyKSlcbiAgICAgICAgICAgIHwgKGJhc2U2NG1hcC5pbmRleE9mKGJhc2U2NC5jaGFyQXQoaSkpID4+PiAoNiAtIGltb2Q0ICogMikpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBieXRlcztcbiAgICB9XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBjcnlwdDtcbn0pKCk7XG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFWaWV3O1xuIiwidmFyIGhhc2hDbGVhciA9IHJlcXVpcmUoJy4vX2hhc2hDbGVhcicpLFxuICAgIGhhc2hEZWxldGUgPSByZXF1aXJlKCcuL19oYXNoRGVsZXRlJyksXG4gICAgaGFzaEdldCA9IHJlcXVpcmUoJy4vX2hhc2hHZXQnKSxcbiAgICBoYXNoSGFzID0gcmVxdWlyZSgnLi9faGFzaEhhcycpLFxuICAgIGhhc2hTZXQgPSByZXF1aXJlKCcuL19oYXNoU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2g7XG4iLCJ2YXIgbGlzdENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVDbGVhcicpLFxuICAgIGxpc3RDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZURlbGV0ZScpLFxuICAgIGxpc3RDYWNoZUdldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUdldCcpLFxuICAgIGxpc3RDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUhhcycpLFxuICAgIGxpc3RDYWNoZVNldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTGlzdENhY2hlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcDtcbiIsInZhciBtYXBDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVDbGVhcicpLFxuICAgIG1hcENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVEZWxldGUnKSxcbiAgICBtYXBDYWNoZUdldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlR2V0JyksXG4gICAgbWFwQ2FjaGVIYXMgPSByZXF1aXJlKCcuL19tYXBDYWNoZUhhcycpLFxuICAgIG1hcENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwQ2FjaGU7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldDtcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBzdGFja0NsZWFyID0gcmVxdWlyZSgnLi9fc3RhY2tDbGVhcicpLFxuICAgIHN0YWNrRGVsZXRlID0gcmVxdWlyZSgnLi9fc3RhY2tEZWxldGUnKSxcbiAgICBzdGFja0dldCA9IHJlcXVpcmUoJy4vX3N0YWNrR2V0JyksXG4gICAgc3RhY2tIYXMgPSByZXF1aXJlKCcuL19zdGFja0hhcycpLFxuICAgIHN0YWNrU2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YWNrO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bWJvbDtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVpbnQ4QXJyYXk7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWFrTWFwO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5RWFjaDtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXNJbmRleCA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUZpbHRlcjtcbiIsInZhciBiYXNlVGltZXMgPSByZXF1aXJlKCcuL19iYXNlVGltZXMnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlMaWtlS2V5cztcbiIsIi8qKlxuICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVB1c2g7XG4iLCJ2YXIgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduVmFsdWU7XG4iLCJ2YXIgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzb2NJbmRleE9mO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnbjtcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25JbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduSW47XG4iLCJ2YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19kZWZpbmVQcm9wZXJ0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gKiB2YWx1ZSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ25WYWx1ZTtcbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYXJyYXlFYWNoID0gcmVxdWlyZSgnLi9fYXJyYXlFYWNoJyksXG4gICAgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VBc3NpZ24gPSByZXF1aXJlKCcuL19iYXNlQXNzaWduJyksXG4gICAgYmFzZUFzc2lnbkluID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnbkluJyksXG4gICAgY2xvbmVCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUJ1ZmZlcicpLFxuICAgIGNvcHlBcnJheSA9IHJlcXVpcmUoJy4vX2NvcHlBcnJheScpLFxuICAgIGNvcHlTeW1ib2xzID0gcmVxdWlyZSgnLi9fY29weVN5bWJvbHMnKSxcbiAgICBjb3B5U3ltYm9sc0luID0gcmVxdWlyZSgnLi9fY29weVN5bWJvbHNJbicpLFxuICAgIGdldEFsbEtleXMgPSByZXF1aXJlKCcuL19nZXRBbGxLZXlzJyksXG4gICAgZ2V0QWxsS2V5c0luID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5c0luJyksXG4gICAgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaW5pdENsb25lQXJyYXkgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVBcnJheScpLFxuICAgIGluaXRDbG9uZUJ5VGFnID0gcmVxdWlyZSgnLi9faW5pdENsb25lQnlUYWcnKSxcbiAgICBpbml0Q2xvbmVPYmplY3QgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVPYmplY3QnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNNYXAgPSByZXF1aXJlKCcuL2lzTWFwJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNTZXQgPSByZXF1aXJlKCcuL2lzU2V0JyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG52YXIgQ0xPTkVfREVFUF9GTEFHID0gMSxcbiAgICBDTE9ORV9GTEFUX0ZMQUcgPSAyLFxuICAgIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgc3VwcG9ydGVkIGJ5IGBfLmNsb25lYC4gKi9cbnZhciBjbG9uZWFibGVUYWdzID0ge307XG5jbG9uZWFibGVUYWdzW2FyZ3NUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheVRhZ10gPVxuY2xvbmVhYmxlVGFnc1thcnJheUJ1ZmZlclRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGFWaWV3VGFnXSA9XG5jbG9uZWFibGVUYWdzW2Jvb2xUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRlVGFnXSA9XG5jbG9uZWFibGVUYWdzW2Zsb2F0MzJUYWddID0gY2xvbmVhYmxlVGFnc1tmbG9hdDY0VGFnXSA9XG5jbG9uZWFibGVUYWdzW2ludDhUYWddID0gY2xvbmVhYmxlVGFnc1tpbnQxNlRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW21hcFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tudW1iZXJUYWddID0gY2xvbmVhYmxlVGFnc1tvYmplY3RUYWddID1cbmNsb25lYWJsZVRhZ3NbcmVnZXhwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc2V0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3N0cmluZ1RhZ10gPSBjbG9uZWFibGVUYWdzW3N5bWJvbFRhZ10gPVxuY2xvbmVhYmxlVGFnc1t1aW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPVxuY2xvbmVhYmxlVGFnc1t1aW50MTZUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbmNsb25lYWJsZVRhZ3NbZXJyb3JUYWddID0gY2xvbmVhYmxlVGFnc1tmdW5jVGFnXSA9XG5jbG9uZWFibGVUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xvbmVgIGFuZCBgXy5jbG9uZURlZXBgIHdoaWNoIHRyYWNrc1xuICogdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogIDEgLSBEZWVwIGNsb25lXG4gKiAgMiAtIEZsYXR0ZW4gaW5oZXJpdGVkIHByb3BlcnRpZXNcbiAqICA0IC0gQ2xvbmUgc3ltYm9sc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBba2V5XSBUaGUga2V5IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIHBhcmVudCBvYmplY3Qgb2YgYHZhbHVlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBhbmQgdGhlaXIgY2xvbmUgY291bnRlcnBhcnRzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIG9iamVjdCwgc3RhY2spIHtcbiAgdmFyIHJlc3VsdCxcbiAgICAgIGlzRGVlcCA9IGJpdG1hc2sgJiBDTE9ORV9ERUVQX0ZMQUcsXG4gICAgICBpc0ZsYXQgPSBiaXRtYXNrICYgQ0xPTkVfRkxBVF9GTEFHLFxuICAgICAgaXNGdWxsID0gYml0bWFzayAmIENMT05FX1NZTUJPTFNfRkxBRztcblxuICBpZiAoY3VzdG9taXplcikge1xuICAgIHJlc3VsdCA9IG9iamVjdCA/IGN1c3RvbWl6ZXIodmFsdWUsIGtleSwgb2JqZWN0LCBzdGFjaykgOiBjdXN0b21pemVyKHZhbHVlKTtcbiAgfVxuICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpO1xuICBpZiAoaXNBcnIpIHtcbiAgICByZXN1bHQgPSBpbml0Q2xvbmVBcnJheSh2YWx1ZSk7XG4gICAgaWYgKCFpc0RlZXApIHtcbiAgICAgIHJldHVybiBjb3B5QXJyYXkodmFsdWUsIHJlc3VsdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpLFxuICAgICAgICBpc0Z1bmMgPSB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xuXG4gICAgaWYgKGlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGNsb25lQnVmZmVyKHZhbHVlLCBpc0RlZXApO1xuICAgIH1cbiAgICBpZiAodGFnID09IG9iamVjdFRhZyB8fCB0YWcgPT0gYXJnc1RhZyB8fCAoaXNGdW5jICYmICFvYmplY3QpKSB7XG4gICAgICByZXN1bHQgPSAoaXNGbGF0IHx8IGlzRnVuYykgPyB7fSA6IGluaXRDbG9uZU9iamVjdCh2YWx1ZSk7XG4gICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICByZXR1cm4gaXNGbGF0XG4gICAgICAgICAgPyBjb3B5U3ltYm9sc0luKHZhbHVlLCBiYXNlQXNzaWduSW4ocmVzdWx0LCB2YWx1ZSkpXG4gICAgICAgICAgOiBjb3B5U3ltYm9scyh2YWx1ZSwgYmFzZUFzc2lnbihyZXN1bHQsIHZhbHVlKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghY2xvbmVhYmxlVGFnc1t0YWddKSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPyB2YWx1ZSA6IHt9O1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gaW5pdENsb25lQnlUYWcodmFsdWUsIHRhZywgaXNEZWVwKTtcbiAgICB9XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBpdHMgY29ycmVzcG9uZGluZyBjbG9uZS5cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQodmFsdWUpO1xuICBpZiAoc3RhY2tlZCkge1xuICAgIHJldHVybiBzdGFja2VkO1xuICB9XG4gIHN0YWNrLnNldCh2YWx1ZSwgcmVzdWx0KTtcblxuICBpZiAoaXNTZXQodmFsdWUpKSB7XG4gICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSkge1xuICAgICAgcmVzdWx0LmFkZChiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN1YlZhbHVlLCB2YWx1ZSwgc3RhY2spKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChpc01hcCh2YWx1ZSkpIHtcbiAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdC5zZXQoa2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIga2V5c0Z1bmMgPSBpc0Z1bGxcbiAgICA/IChpc0ZsYXQgPyBnZXRBbGxLZXlzSW4gOiBnZXRBbGxLZXlzKVxuICAgIDogKGlzRmxhdCA/IGtleXNJbiA6IGtleXMpO1xuXG4gIHZhciBwcm9wcyA9IGlzQXJyID8gdW5kZWZpbmVkIDoga2V5c0Z1bmModmFsdWUpO1xuICBhcnJheUVhY2gocHJvcHMgfHwgdmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIGtleSA9IHN1YlZhbHVlO1xuICAgICAgc3ViVmFsdWUgPSB2YWx1ZVtrZXldO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VDbG9uZTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xudmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgIH1cbiAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ3JlYXRlO1xuIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRBbGxLZXlzO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGdldFJhd1RhZyA9IHJlcXVpcmUoJy4vX2dldFJhd1RhZycpLFxuICAgIG9iamVjdFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fb2JqZWN0VG9TdHJpbmcnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldFRhZztcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzQXJndW1lbnRzO1xuIiwidmFyIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hcGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWFwKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gbWFwVGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc01hcDtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNNYXNrZWQgPSByZXF1aXJlKCcuL19pc01hc2tlZCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNOYXRpdmU7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNSZWdFeHBgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcmVnZXhwLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1JlZ0V4cCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSByZWdleHBUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzUmVnRXhwO1xuIiwidmFyIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzZXRUYWcgPSAnW29iamVjdCBTZXRdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1NldGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzU2V0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gc2V0VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc1NldDtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNUeXBlZEFycmF5O1xuIiwidmFyIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBuYXRpdmVLZXlzID0gcmVxdWlyZSgnLi9fbmF0aXZlS2V5cycpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXM7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXNJbiA9IHJlcXVpcmUoJy4vX25hdGl2ZUtleXNJbicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gIH1cbiAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzSW47XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUaW1lcztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5hcnk7XG4iLCJ2YXIgVWludDhBcnJheSA9IHJlcXVpcmUoJy4vX1VpbnQ4QXJyYXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuICB2YXIgcmVzdWx0ID0gbmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO1xuICBuZXcgVWludDhBcnJheShyZXN1bHQpLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lQXJyYXlCdWZmZXI7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgYWxsb2NVbnNhZmUgPSBCdWZmZXIgPyBCdWZmZXIuYWxsb2NVbnNhZmUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mICBgYnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlciwgaXNEZWVwKSB7XG4gIGlmIChpc0RlZXApIHtcbiAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBhbGxvY1Vuc2FmZSA/IGFsbG9jVW5zYWZlKGxlbmd0aCkgOiBuZXcgYnVmZmVyLmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgYnVmZmVyLmNvcHkocmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUJ1ZmZlcjtcbiIsInZhciBjbG9uZUFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVBcnJheUJ1ZmZlcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgZGF0YVZpZXdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVZpZXcgVGhlIGRhdGEgdmlldyB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgZGF0YSB2aWV3LlxuICovXG5mdW5jdGlvbiBjbG9uZURhdGFWaWV3KGRhdGFWaWV3LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIoZGF0YVZpZXcuYnVmZmVyKSA6IGRhdGFWaWV3LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyBkYXRhVmlldy5jb25zdHJ1Y3RvcihidWZmZXIsIGRhdGFWaWV3LmJ5dGVPZmZzZXQsIGRhdGFWaWV3LmJ5dGVMZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lRGF0YVZpZXc7XG4iLCIvKiogVXNlZCB0byBtYXRjaCBgUmVnRXhwYCBmbGFncyBmcm9tIHRoZWlyIGNvZXJjZWQgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUZsYWdzID0gL1xcdyokLztcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHJlZ2V4cGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWdleHAgVGhlIHJlZ2V4cCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCByZWdleHAuXG4gKi9cbmZ1bmN0aW9uIGNsb25lUmVnRXhwKHJlZ2V4cCkge1xuICB2YXIgcmVzdWx0ID0gbmV3IHJlZ2V4cC5jb25zdHJ1Y3RvcihyZWdleHAuc291cmNlLCByZUZsYWdzLmV4ZWMocmVnZXhwKSk7XG4gIHJlc3VsdC5sYXN0SW5kZXggPSByZWdleHAubGFzdEluZGV4O1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lUmVnRXhwO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGBzeW1ib2xgIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHN5bWJvbCBUaGUgc3ltYm9sIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBzeW1ib2wgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjbG9uZVN5bWJvbChzeW1ib2wpIHtcbiAgcmV0dXJuIHN5bWJvbFZhbHVlT2YgPyBPYmplY3Qoc3ltYm9sVmFsdWVPZi5jYWxsKHN5bWJvbCkpIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVTeW1ib2w7XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVR5cGVkQXJyYXk7XG4iLCIvKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlBcnJheShzb3VyY2UsIGFycmF5KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5QXJyYXk7XG4iLCJ2YXIgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpO1xuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICB2YXIgaXNOZXcgPSAhb2JqZWN0O1xuICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgaWYgKGlzTmV3KSB7XG4gICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5T2JqZWN0O1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKTtcblxuLyoqXG4gKiBDb3BpZXMgb3duIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTeW1ib2xzKHNvdXJjZSwgb2JqZWN0KSB7XG4gIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9scyhzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlTeW1ib2xzO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAgZ2V0U3ltYm9sc0luID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9sc0luJyk7XG5cbi8qKlxuICogQ29waWVzIG93biBhbmQgaW5oZXJpdGVkIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTeW1ib2xzSW4oc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzSW4oc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5U3ltYm9sc0luO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZUpzRGF0YTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBmdW5jID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG4gICAgZnVuYyh7fSwgJycsIHt9KTtcbiAgICByZXR1cm4gZnVuYztcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lUHJvcGVydHk7XG4iLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZyZWVHbG9iYWw7XG4iLCJ2YXIgYmFzZUdldEFsbEtleXMgPSByZXF1aXJlKCcuL19iYXNlR2V0QWxsS2V5cycpLFxuICAgIGdldFN5bWJvbHMgPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXMsIGdldFN5bWJvbHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFsbEtleXM7XG4iLCJ2YXIgYmFzZUdldEFsbEtleXMgPSByZXF1aXJlKCcuL19iYXNlR2V0QWxsS2V5cycpLFxuICAgIGdldFN5bWJvbHNJbiA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHNJbicpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzSW4sIGdldFN5bWJvbHNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWxsS2V5c0luO1xuIiwidmFyIGlzS2V5YWJsZSA9IHJlcXVpcmUoJy4vX2lzS2V5YWJsZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFwRGF0YTtcbiIsInZhciBiYXNlSXNOYXRpdmUgPSByZXF1aXJlKCcuL19iYXNlSXNOYXRpdmUnKSxcbiAgICBnZXRWYWx1ZSA9IHJlcXVpcmUoJy4vX2dldFZhbHVlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TmF0aXZlO1xuIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFByb3RvdHlwZTtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhd1RhZztcbiIsInZhciBhcnJheUZpbHRlciA9IHJlcXVpcmUoJy4vX2FycmF5RmlsdGVyJyksXG4gICAgc3R1YkFycmF5ID0gcmVxdWlyZSgnLi9zdHViQXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFN5bWJvbHM7XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKSxcbiAgICBzdHViQXJyYXkgPSByZXF1aXJlKCcuL3N0dWJBcnJheScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzSW4gPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHdoaWxlIChvYmplY3QpIHtcbiAgICBhcnJheVB1c2gocmVzdWx0LCBnZXRTeW1ib2xzKG9iamVjdCkpO1xuICAgIG9iamVjdCA9IGdldFByb3RvdHlwZShvYmplY3QpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFN5bWJvbHNJbjtcbiIsInZhciBEYXRhVmlldyA9IHJlcXVpcmUoJy4vX0RhdGFWaWV3JyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgUHJvbWlzZSA9IHJlcXVpcmUoJy4vX1Byb21pc2UnKSxcbiAgICBTZXQgPSByZXF1aXJlKCcuL19TZXQnKSxcbiAgICBXZWFrTWFwID0gcmVxdWlyZSgnLi9fV2Vha01hcCcpLFxuICAgIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgdG9Tb3VyY2UgPSByZXF1aXJlKCcuL190b1NvdXJjZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbnZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcyA8IDYuXG5pZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBiYXNlR2V0VGFnKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6ICcnO1xuXG4gICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFRhZztcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFZhbHVlO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hEZWxldGU7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoR2V0O1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEhhcztcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaFNldDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gYXJyYXkgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZUFycmF5KGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAvLyBBZGQgcHJvcGVydGllcyBhc3NpZ25lZCBieSBgUmVnRXhwI2V4ZWNgLlxuICBpZiAobGVuZ3RoICYmIHR5cGVvZiBhcnJheVswXSA9PSAnc3RyaW5nJyAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCAnaW5kZXgnKSkge1xuICAgIHJlc3VsdC5pbmRleCA9IGFycmF5LmluZGV4O1xuICAgIHJlc3VsdC5pbnB1dCA9IGFycmF5LmlucHV0O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lQXJyYXk7XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKSxcbiAgICBjbG9uZURhdGFWaWV3ID0gcmVxdWlyZSgnLi9fY2xvbmVEYXRhVmlldycpLFxuICAgIGNsb25lUmVnRXhwID0gcmVxdWlyZSgnLi9fY2xvbmVSZWdFeHAnKSxcbiAgICBjbG9uZVN5bWJvbCA9IHJlcXVpcmUoJy4vX2Nsb25lU3ltYm9sJyksXG4gICAgY2xvbmVUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fY2xvbmVUeXBlZEFycmF5Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZSBiYXNlZCBvbiBpdHMgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNsb25pbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBNYXBgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIGBTZXRgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgaXNEZWVwKSB7XG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVBcnJheUJ1ZmZlcihvYmplY3QpO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtcblxuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICByZXR1cm4gY2xvbmVEYXRhVmlldyhvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIGZsb2F0MzJUYWc6IGNhc2UgZmxvYXQ2NFRhZzpcbiAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgY2FzZSB1aW50OFRhZzogY2FzZSB1aW50OENsYW1wZWRUYWc6IGNhc2UgdWludDE2VGFnOiBjYXNlIHVpbnQzMlRhZzpcbiAgICAgIHJldHVybiBjbG9uZVR5cGVkQXJyYXkob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcihvYmplY3QpO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICByZXR1cm4gY2xvbmVTeW1ib2wob2JqZWN0KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZUJ5VGFnO1xuIiwidmFyIGJhc2VDcmVhdGUgPSByZXF1aXJlKCcuL19iYXNlQ3JlYXRlJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKVxuICAgIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lT2JqZWN0O1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG5cbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGUgPT0gJ251bWJlcicgfHxcbiAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcbiAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSW5kZXg7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXlhYmxlO1xuIiwidmFyIGNvcmVKc0RhdGEgPSByZXF1aXJlKCcuL19jb3JlSnNEYXRhJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNNYXNrZWQ7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQcm90b3R5cGU7XG4iLCIvKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlQ2xlYXI7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVEZWxldGU7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlR2V0O1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVIYXM7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVTZXQ7XG4iLCJ2YXIgSGFzaCA9IHJlcXVpcmUoJy4vX0hhc2gnKSxcbiAgICBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlQ2xlYXI7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVEZWxldGU7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlR2V0O1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVIYXM7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlU2V0O1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUNyZWF0ZTtcbiIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5cztcbiIsIi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXNJbjtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgaWYgKHR5cGVzKSB7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vZGVVdGlsO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb2JqZWN0VG9TdHJpbmc7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyQXJnO1xuIiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSByb290O1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tEZWxldGU7XG4iLCIvKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tHZXQ7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrSGFzO1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpLFxuICAgIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKTtcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gIH1cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tTZXQ7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9Tb3VyY2U7XG4iLCJ2YXIgYmFzZUNsb25lID0gcmVxdWlyZSgnLi9fYmFzZUNsb25lJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG52YXIgQ0xPTkVfU1lNQk9MU19GTEFHID0gNDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc2hhbGxvdyBjbG9uZSBvZiBgdmFsdWVgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uIHRoZVxuICogW3N0cnVjdHVyZWQgY2xvbmUgYWxnb3JpdGhtXShodHRwczovL21kbi5pby9TdHJ1Y3R1cmVkX2Nsb25lX2FsZ29yaXRobSlcbiAqIGFuZCBzdXBwb3J0cyBjbG9uaW5nIGFycmF5cywgYXJyYXkgYnVmZmVycywgYm9vbGVhbnMsIGRhdGUgb2JqZWN0cywgbWFwcyxcbiAqIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZFxuICogYXJyYXlzLiBUaGUgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgYXJndW1lbnRzYCBvYmplY3RzIGFyZSBjbG9uZWRcbiAqIGFzIHBsYWluIG9iamVjdHMuIEFuIGVtcHR5IG9iamVjdCBpcyByZXR1cm5lZCBmb3IgdW5jbG9uZWFibGUgdmFsdWVzIHN1Y2hcbiAqIGFzIGVycm9yIG9iamVjdHMsIGZ1bmN0aW9ucywgRE9NIG5vZGVzLCBhbmQgV2Vha01hcHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAqIEBzZWUgXy5jbG9uZURlZXBcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbeyAnYSc6IDEgfSwgeyAnYic6IDIgfV07XG4gKlxuICogdmFyIHNoYWxsb3cgPSBfLmNsb25lKG9iamVjdHMpO1xuICogY29uc29sZS5sb2coc2hhbGxvd1swXSA9PT0gb2JqZWN0c1swXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNsb25lKHZhbHVlKSB7XG4gIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX1NZTUJPTFNfRkxBRyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmU7XG4iLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcTtcbiIsInZhciBiYXNlSXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL19iYXNlSXNBcmd1bWVudHMnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXk7XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZTtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpLFxuICAgIHN0dWJGYWxzZSA9IHJlcXVpcmUoJy4vc3R1YkZhbHNlJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0J1ZmZlcjtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb247XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNMZW5ndGg7XG4iLCJ2YXIgYmFzZUlzTWFwID0gcmVxdWlyZSgnLi9fYmFzZUlzTWFwJyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgbm9kZVV0aWwgPSByZXF1aXJlKCcuL19ub2RlVXRpbCcpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc01hcCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzTWFwO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTWFwYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc01hcChuZXcgTWFwKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTWFwKG5ldyBXZWFrTWFwKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc01hcCA9IG5vZGVJc01hcCA/IGJhc2VVbmFyeShub2RlSXNNYXApIDogYmFzZUlzTWFwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTWFwO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG52YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJlxuICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQbGFpbk9iamVjdDtcbiIsInZhciBiYXNlSXNSZWdFeHAgPSByZXF1aXJlKCcuL19iYXNlSXNSZWdFeHAnKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBub2RlVXRpbCA9IHJlcXVpcmUoJy4vX25vZGVVdGlsJyk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzUmVnRXhwID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNSZWdFeHA7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBSZWdFeHBgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHJlZ2V4cCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzUmVnRXhwKC9hYmMvKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUmVnRXhwKCcvYWJjLycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzUmVnRXhwID0gbm9kZUlzUmVnRXhwID8gYmFzZVVuYXJ5KG5vZGVJc1JlZ0V4cCkgOiBiYXNlSXNSZWdFeHA7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNSZWdFeHA7XG4iLCJ2YXIgYmFzZUlzU2V0ID0gcmVxdWlyZSgnLi9fYmFzZUlzU2V0JyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgbm9kZVV0aWwgPSByZXF1aXJlKCcuL19ub2RlVXRpbCcpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1NldCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzU2V0O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU2V0YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1NldChuZXcgU2V0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU2V0KG5ldyBXZWFrU2V0KTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1NldCA9IG5vZGVJc1NldCA/IGJhc2VVbmFyeShub2RlSXNTZXQpIDogYmFzZUlzU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU2V0O1xuIiwidmFyIGJhc2VJc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL19iYXNlSXNUeXBlZEFycmF5JyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgbm9kZVV0aWwgPSByZXF1aXJlKCcuL19ub2RlVXRpbCcpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc1R5cGVkQXJyYXk7XG4iLCJ2YXIgYXJyYXlMaWtlS2V5cyA9IHJlcXVpcmUoJy4vX2FycmF5TGlrZUtleXMnKSxcbiAgICBiYXNlS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXM7XG4iLCJ2YXIgYXJyYXlMaWtlS2V5cyA9IHJlcXVpcmUoJy4vX2FycmF5TGlrZUtleXMnKSxcbiAgICBiYXNlS2V5c0luID0gcmVxdWlyZSgnLi9fYmFzZUtleXNJbicpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzSW4obmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGJhc2VLZXlzSW4ob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzSW47XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWJBcnJheTtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViRmFsc2U7XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLypcbiAqIHFUaXAyIC0gUHJldHR5IHBvd2VyZnVsIHRvb2x0aXBzIC0gdjMuMC4zXG4gKiBodHRwOi8vcXRpcDIuY29tXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE2IFxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlc1xuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IFdlZCBNYXkgMTEgMjAxNiAxMDozMSBHTVQrMDEwMCswMTAwXG4gKiBQbHVnaW5zOiB0aXBzIG1vZGFsIHZpZXdwb3J0IHN2ZyBpbWFnZW1hcCBpZTZcbiAqIFN0eWxlczogY29yZSBiYXNpYyBjc3MzXG4gKi9cbi8qZ2xvYmFsIHdpbmRvdzogZmFsc2UsIGpRdWVyeTogZmFsc2UsIGNvbnNvbGU6IGZhbHNlLCBkZWZpbmU6IGZhbHNlICovXG5cbi8qIENhY2hlIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCAqL1xuKGZ1bmN0aW9uKCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQgKSB7XG5cbi8vIFVzZXMgQU1EIG9yIGJyb3dzZXIgZ2xvYmFscyB0byBjcmVhdGUgYSBqUXVlcnkgcGx1Z2luLlxuKGZ1bmN0aW9uKCBmYWN0b3J5ICkge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0aWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0ZGVmaW5lKFsnanF1ZXJ5J10sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2UgaWYoalF1ZXJ5ICYmICFqUXVlcnkuZm4ucXRpcCkge1xuXHRcdGZhY3RvcnkoalF1ZXJ5KTtcblx0fVxufVxuKGZ1bmN0aW9uKCQpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7IC8vIEVuYWJsZSBFQ01BU2NyaXB0IFwic3RyaWN0XCIgb3BlcmF0aW9uIGZvciB0aGlzIGZ1bmN0aW9uLiBTZWUgbW9yZTogaHR0cDovL2Vqb2huLm9yZy9ibG9nL2VjbWFzY3JpcHQtNS1zdHJpY3QtbW9kZS1qc29uLWFuZC1tb3JlL1xuOy8vIE11bmdlIHRoZSBwcmltaXRpdmVzIC0gUGF1bCBJcmlzaCB0aXBcbnZhciBUUlVFID0gdHJ1ZSxcbkZBTFNFID0gZmFsc2UsXG5OVUxMID0gbnVsbCxcblxuLy8gQ29tbW9uIHZhcmlhYmxlc1xuWCA9ICd4JywgWSA9ICd5JyxcbldJRFRIID0gJ3dpZHRoJyxcbkhFSUdIVCA9ICdoZWlnaHQnLFxuXG4vLyBQb3NpdGlvbmluZyBzaWRlc1xuVE9QID0gJ3RvcCcsXG5MRUZUID0gJ2xlZnQnLFxuQk9UVE9NID0gJ2JvdHRvbScsXG5SSUdIVCA9ICdyaWdodCcsXG5DRU5URVIgPSAnY2VudGVyJyxcblxuLy8gUG9zaXRpb24gYWRqdXN0bWVudCB0eXBlc1xuRkxJUCA9ICdmbGlwJyxcbkZMSVBJTlZFUlQgPSAnZmxpcGludmVydCcsXG5TSElGVCA9ICdzaGlmdCcsXG5cbi8vIFNob3J0Y3V0IHZhcnNcblFUSVAsIFBST1RPVFlQRSwgQ09STkVSLCBDSEVDS1MsXG5QTFVHSU5TID0ge30sXG5OQU1FU1BBQ0UgPSAncXRpcCcsXG5BVFRSX0hBUyA9ICdkYXRhLWhhc3F0aXAnLFxuQVRUUl9JRCA9ICdkYXRhLXF0aXAtaWQnLFxuV0lER0VUID0gWyd1aS13aWRnZXQnLCAndWktdG9vbHRpcCddLFxuU0VMRUNUT1IgPSAnLicrTkFNRVNQQUNFLFxuSU5BQ1RJVkVfRVZFTlRTID0gJ2NsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZWxlYXZlIG1vdXNlZW50ZXInLnNwbGl0KCcgJyksXG5cbkNMQVNTX0ZJWEVEID0gTkFNRVNQQUNFKyctZml4ZWQnLFxuQ0xBU1NfREVGQVVMVCA9IE5BTUVTUEFDRSArICctZGVmYXVsdCcsXG5DTEFTU19GT0NVUyA9IE5BTUVTUEFDRSArICctZm9jdXMnLFxuQ0xBU1NfSE9WRVIgPSBOQU1FU1BBQ0UgKyAnLWhvdmVyJyxcbkNMQVNTX0RJU0FCTEVEID0gTkFNRVNQQUNFKyctZGlzYWJsZWQnLFxuXG5yZXBsYWNlU3VmZml4ID0gJ19yZXBsYWNlZEJ5cVRpcCcsXG5vbGR0aXRsZSA9ICdvbGR0aXRsZScsXG50cmFja2luZ0JvdW5kLFxuXG4vLyBCcm93c2VyIGRldGVjdGlvblxuQlJPV1NFUiA9IHtcblx0Lypcblx0ICogSUUgdmVyc2lvbiBkZXRlY3Rpb25cblx0ICpcblx0ICogQWRhcHRlZCBmcm9tOiBodHRwOi8vYWpheGlhbi5jb20vYXJjaGl2ZXMvYXR0YWNrLW9mLXRoZS1pZS1jb25kaXRpb25hbC1jb21tZW50XG5cdCAqIENyZWRpdCB0byBKYW1lcyBQYWRvbHNleSBmb3IgdGhlIG9yaWdpbmFsIGltcGxlbW50YXRpb24hXG5cdCAqL1xuXHRpZTogKGZ1bmN0aW9uKCkge1xuXHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWVtcHR5ICovXG5cdFx0dmFyIHYsIGk7XG5cdFx0Zm9yIChcblx0XHRcdHYgPSA0LCBpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0XHQoaS5pbm5lckhUTUwgPSAnPCEtLVtpZiBndCBJRSAnICsgdiArICddPjxpPjwvaT48IVtlbmRpZl0tLT4nKSAmJiBpLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpJylbMF07XG5cdFx0XHR2Kz0xXG5cdFx0KSB7fVxuXHRcdHJldHVybiB2ID4gNCA/IHYgOiBOYU47XG5cdFx0LyogZXNsaW50LWVuYWJsZSBuby1lbXB0eSAqL1xuXHR9KSgpLFxuXG5cdC8qXG5cdCAqIGlPUyB2ZXJzaW9uIGRldGVjdGlvblxuXHQgKi9cblx0aU9TOiBwYXJzZUZsb2F0KFxuXHRcdCgnJyArICgvQ1BVLipPUyAoWzAtOV9dezEsNX0pfChDUFUgbGlrZSkuKkFwcGxlV2ViS2l0LipNb2JpbGUvaS5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpIHx8IFswLCcnXSlbMV0pXG5cdFx0LnJlcGxhY2UoJ3VuZGVmaW5lZCcsICczXzInKS5yZXBsYWNlKCdfJywgJy4nKS5yZXBsYWNlKCdfJywgJycpXG5cdCkgfHwgRkFMU0Vcbn07XG47ZnVuY3Rpb24gUVRpcCh0YXJnZXQsIG9wdGlvbnMsIGlkLCBhdHRyKSB7XG5cdC8vIEVsZW1lbnRzIGFuZCBJRFxuXHR0aGlzLmlkID0gaWQ7XG5cdHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuXHR0aGlzLnRvb2x0aXAgPSBOVUxMO1xuXHR0aGlzLmVsZW1lbnRzID0geyB0YXJnZXQ6IHRhcmdldCB9O1xuXG5cdC8vIEludGVybmFsIGNvbnN0cnVjdHNcblx0dGhpcy5faWQgPSBOQU1FU1BBQ0UgKyAnLScgKyBpZDtcblx0dGhpcy50aW1lcnMgPSB7IGltZzoge30gfTtcblx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0dGhpcy5wbHVnaW5zID0ge307XG5cblx0Ly8gQ2FjaGUgb2JqZWN0XG5cdHRoaXMuY2FjaGUgPSB7XG5cdFx0ZXZlbnQ6IHt9LFxuXHRcdHRhcmdldDogJCgpLFxuXHRcdGRpc2FibGVkOiBGQUxTRSxcblx0XHRhdHRyOiBhdHRyLFxuXHRcdG9uVG9vbHRpcDogRkFMU0UsXG5cdFx0bGFzdENsYXNzOiAnJ1xuXHR9O1xuXG5cdC8vIFNldCB0aGUgaW5pdGlhbCBmbGFnc1xuXHR0aGlzLnJlbmRlcmVkID0gdGhpcy5kZXN0cm95ZWQgPSB0aGlzLmRpc2FibGVkID0gdGhpcy53YWl0aW5nID1cblx0XHR0aGlzLmhpZGRlbkR1cmluZ1dhaXQgPSB0aGlzLnBvc2l0aW9uaW5nID0gdGhpcy50cmlnZ2VyaW5nID0gRkFMU0U7XG59XG5QUk9UT1RZUEUgPSBRVGlwLnByb3RvdHlwZTtcblxuUFJPVE9UWVBFLl93aGVuID0gZnVuY3Rpb24oZGVmZXJyZWRzKSB7XG5cdHJldHVybiAkLndoZW4uYXBwbHkoJCwgZGVmZXJyZWRzKTtcbn07XG5cblBST1RPVFlQRS5yZW5kZXIgPSBmdW5jdGlvbihzaG93KSB7XG5cdGlmKHRoaXMucmVuZGVyZWQgfHwgdGhpcy5kZXN0cm95ZWQpIHsgcmV0dXJuIHRoaXM7IH0gLy8gSWYgdG9vbHRpcCBoYXMgYWxyZWFkeSBiZWVuIHJlbmRlcmVkLCBleGl0XG5cblx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0Y2FjaGUgPSB0aGlzLmNhY2hlLFxuXHRcdGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cyxcblx0XHR0ZXh0ID0gb3B0aW9ucy5jb250ZW50LnRleHQsXG5cdFx0dGl0bGUgPSBvcHRpb25zLmNvbnRlbnQudGl0bGUsXG5cdFx0YnV0dG9uID0gb3B0aW9ucy5jb250ZW50LmJ1dHRvbixcblx0XHRwb3NPcHRpb25zID0gb3B0aW9ucy5wb3NpdGlvbixcblx0XHRkZWZlcnJlZHMgPSBbXTtcblxuXHQvLyBBZGQgQVJJQSBhdHRyaWJ1dGVzIHRvIHRhcmdldFxuXHQkLmF0dHIodGhpcy50YXJnZXRbMF0sICdhcmlhLWRlc2NyaWJlZGJ5JywgdGhpcy5faWQpO1xuXG5cdC8vIENyZWF0ZSBwdWJsaWMgcG9zaXRpb24gb2JqZWN0IHRoYXQgdHJhY2tzIGN1cnJlbnQgcG9zaXRpb24gY29ybmVyc1xuXHRjYWNoZS5wb3NDbGFzcyA9IHRoaXMuX2NyZWF0ZVBvc0NsYXNzKFxuXHRcdCh0aGlzLnBvc2l0aW9uID0geyBteTogcG9zT3B0aW9ucy5teSwgYXQ6IHBvc09wdGlvbnMuYXQgfSkubXlcblx0KTtcblxuXHQvLyBDcmVhdGUgdG9vbHRpcCBlbGVtZW50XG5cdHRoaXMudG9vbHRpcCA9IGVsZW1lbnRzLnRvb2x0aXAgPSAkKCc8ZGl2Lz4nLCB7XG5cdFx0J2lkJzogdGhpcy5faWQsXG5cdFx0J2NsYXNzJzogWyBOQU1FU1BBQ0UsIENMQVNTX0RFRkFVTFQsIG9wdGlvbnMuc3R5bGUuY2xhc3NlcywgY2FjaGUucG9zQ2xhc3MgXS5qb2luKCcgJyksXG5cdFx0J3dpZHRoJzogb3B0aW9ucy5zdHlsZS53aWR0aCB8fCAnJyxcblx0XHQnaGVpZ2h0Jzogb3B0aW9ucy5zdHlsZS5oZWlnaHQgfHwgJycsXG5cdFx0J3RyYWNraW5nJzogcG9zT3B0aW9ucy50YXJnZXQgPT09ICdtb3VzZScgJiYgcG9zT3B0aW9ucy5hZGp1c3QubW91c2UsXG5cblx0XHQvKiBBUklBIHNwZWNpZmljIGF0dHJpYnV0ZXMgKi9cblx0XHQncm9sZSc6ICdhbGVydCcsXG5cdFx0J2FyaWEtbGl2ZSc6ICdwb2xpdGUnLFxuXHRcdCdhcmlhLWF0b21pYyc6IEZBTFNFLFxuXHRcdCdhcmlhLWRlc2NyaWJlZGJ5JzogdGhpcy5faWQgKyAnLWNvbnRlbnQnLFxuXHRcdCdhcmlhLWhpZGRlbic6IFRSVUVcblx0fSlcblx0LnRvZ2dsZUNsYXNzKENMQVNTX0RJU0FCTEVELCB0aGlzLmRpc2FibGVkKVxuXHQuYXR0cihBVFRSX0lELCB0aGlzLmlkKVxuXHQuZGF0YShOQU1FU1BBQ0UsIHRoaXMpXG5cdC5hcHBlbmRUbyhwb3NPcHRpb25zLmNvbnRhaW5lcilcblx0LmFwcGVuZChcblx0XHQvLyBDcmVhdGUgY29udGVudCBlbGVtZW50XG5cdFx0ZWxlbWVudHMuY29udGVudCA9ICQoJzxkaXYgLz4nLCB7XG5cdFx0XHQnY2xhc3MnOiBOQU1FU1BBQ0UgKyAnLWNvbnRlbnQnLFxuXHRcdFx0J2lkJzogdGhpcy5faWQgKyAnLWNvbnRlbnQnLFxuXHRcdFx0J2FyaWEtYXRvbWljJzogVFJVRVxuXHRcdH0pXG5cdCk7XG5cblx0Ly8gU2V0IHJlbmRlcmVkIGZsYWcgYW5kIHByZXZlbnQgcmVkdW5kYW50IHJlcG9zaXRpb24gY2FsbHMgZm9yIG5vd1xuXHR0aGlzLnJlbmRlcmVkID0gLTE7XG5cdHRoaXMucG9zaXRpb25pbmcgPSBUUlVFO1xuXG5cdC8vIENyZWF0ZSB0aXRsZS4uLlxuXHRpZih0aXRsZSkge1xuXHRcdHRoaXMuX2NyZWF0ZVRpdGxlKCk7XG5cblx0XHQvLyBVcGRhdGUgdGl0bGUgb25seSBpZiBpdHMgbm90IGEgY2FsbGJhY2sgKGNhbGxlZCBpbiB0b2dnbGUgaWYgc28pXG5cdFx0aWYoISQuaXNGdW5jdGlvbih0aXRsZSkpIHtcblx0XHRcdGRlZmVycmVkcy5wdXNoKCB0aGlzLl91cGRhdGVUaXRsZSh0aXRsZSwgRkFMU0UpICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ3JlYXRlIGJ1dHRvblxuXHRpZihidXR0b24pIHsgdGhpcy5fY3JlYXRlQnV0dG9uKCk7IH1cblxuXHQvLyBTZXQgcHJvcGVyIHJlbmRlcmVkIGZsYWcgYW5kIHVwZGF0ZSBjb250ZW50IGlmIG5vdCBhIGNhbGxiYWNrIGZ1bmN0aW9uIChjYWxsZWQgaW4gdG9nZ2xlKVxuXHRpZighJC5pc0Z1bmN0aW9uKHRleHQpKSB7XG5cdFx0ZGVmZXJyZWRzLnB1c2goIHRoaXMuX3VwZGF0ZUNvbnRlbnQodGV4dCwgRkFMU0UpICk7XG5cdH1cblx0dGhpcy5yZW5kZXJlZCA9IFRSVUU7XG5cblx0Ly8gU2V0dXAgd2lkZ2V0IGNsYXNzZXNcblx0dGhpcy5fc2V0V2lkZ2V0KCk7XG5cblx0Ly8gSW5pdGlhbGl6ZSAncmVuZGVyJyBwbHVnaW5zXG5cdCQuZWFjaChQTFVHSU5TLCBmdW5jdGlvbihuYW1lKSB7XG5cdFx0dmFyIGluc3RhbmNlO1xuXHRcdGlmKHRoaXMuaW5pdGlhbGl6ZSA9PT0gJ3JlbmRlcicgJiYgKGluc3RhbmNlID0gdGhpcyhzZWxmKSkpIHtcblx0XHRcdHNlbGYucGx1Z2luc1tuYW1lXSA9IGluc3RhbmNlO1xuXHRcdH1cblx0fSk7XG5cblx0Ly8gVW5hc3NpZ24gaW5pdGlhbCBldmVudHMgYW5kIGFzc2lnbiBwcm9wZXIgZXZlbnRzXG5cdHRoaXMuX3VuYXNzaWduRXZlbnRzKCk7XG5cdHRoaXMuX2Fzc2lnbkV2ZW50cygpO1xuXG5cdC8vIFdoZW4gZGVmZXJyZWRzIGhhdmUgY29tcGxldGVkXG5cdHRoaXMuX3doZW4oZGVmZXJyZWRzKS50aGVuKGZ1bmN0aW9uKCkge1xuXHRcdC8vIHRvb2x0aXByZW5kZXIgZXZlbnRcblx0XHRzZWxmLl90cmlnZ2VyKCdyZW5kZXInKTtcblxuXHRcdC8vIFJlc2V0IGZsYWdzXG5cdFx0c2VsZi5wb3NpdGlvbmluZyA9IEZBTFNFO1xuXG5cdFx0Ly8gU2hvdyB0b29sdGlwIGlmIG5vdCBoaWRkZW4gZHVyaW5nIHdhaXQgcGVyaW9kXG5cdFx0aWYoIXNlbGYuaGlkZGVuRHVyaW5nV2FpdCAmJiAob3B0aW9ucy5zaG93LnJlYWR5IHx8IHNob3cpKSB7XG5cdFx0XHRzZWxmLnRvZ2dsZShUUlVFLCBjYWNoZS5ldmVudCwgRkFMU0UpO1xuXHRcdH1cblx0XHRzZWxmLmhpZGRlbkR1cmluZ1dhaXQgPSBGQUxTRTtcblx0fSk7XG5cblx0Ly8gRXhwb3NlIEFQSVxuXHRRVElQLmFwaVt0aGlzLmlkXSA9IHRoaXM7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5QUk9UT1RZUEUuZGVzdHJveSA9IGZ1bmN0aW9uKGltbWVkaWF0ZSkge1xuXHQvLyBTZXQgZmxhZyB0aGUgc2lnbmlmeSBkZXN0cm95IGlzIHRha2luZyBwbGFjZSB0byBwbHVnaW5zXG5cdC8vIGFuZCBlbnN1cmUgaXQgb25seSBnZXRzIGRlc3Ryb3llZCBvbmNlIVxuXHRpZih0aGlzLmRlc3Ryb3llZCkgeyByZXR1cm4gdGhpcy50YXJnZXQ7IH1cblxuXHRmdW5jdGlvbiBwcm9jZXNzKCkge1xuXHRcdGlmKHRoaXMuZGVzdHJveWVkKSB7IHJldHVybjsgfVxuXHRcdHRoaXMuZGVzdHJveWVkID0gVFJVRTtcblxuXHRcdHZhciB0YXJnZXQgPSB0aGlzLnRhcmdldCxcblx0XHRcdHRpdGxlID0gdGFyZ2V0LmF0dHIob2xkdGl0bGUpLFxuXHRcdFx0dGltZXI7XG5cblx0XHQvLyBEZXN0cm95IHRvb2x0aXAgaWYgcmVuZGVyZWRcblx0XHRpZih0aGlzLnJlbmRlcmVkKSB7XG5cdFx0XHR0aGlzLnRvb2x0aXAuc3RvcCgxLDApLmZpbmQoJyonKS5yZW1vdmUoKS5lbmQoKS5yZW1vdmUoKTtcblx0XHR9XG5cblx0XHQvLyBEZXN0cm95IGFsbCBwbHVnaW5zXG5cdFx0JC5lYWNoKHRoaXMucGx1Z2lucywgZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmRlc3Ryb3kgJiYgdGhpcy5kZXN0cm95KCk7XG5cdFx0fSk7XG5cblx0XHQvLyBDbGVhciB0aW1lcnNcblx0XHRmb3IgKHRpbWVyIGluIHRoaXMudGltZXJzKSB7XG5cdFx0XHRpZiAodGhpcy50aW1lcnMuaGFzT3duUHJvcGVydHkodGltZXIpKSB7XG5cdFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLnRpbWVyc1t0aW1lcl0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSBhcGkgb2JqZWN0IGFuZCBBUklBIGF0dHJpYnV0ZXNcblx0XHR0YXJnZXQucmVtb3ZlRGF0YShOQU1FU1BBQ0UpXG5cdFx0XHQucmVtb3ZlQXR0cihBVFRSX0lEKVxuXHRcdFx0LnJlbW92ZUF0dHIoQVRUUl9IQVMpXG5cdFx0XHQucmVtb3ZlQXR0cignYXJpYS1kZXNjcmliZWRieScpO1xuXG5cdFx0Ly8gUmVzZXQgb2xkIHRpdGxlIGF0dHJpYnV0ZSBpZiByZW1vdmVkXG5cdFx0aWYodGhpcy5vcHRpb25zLnN1cHByZXNzICYmIHRpdGxlKSB7XG5cdFx0XHR0YXJnZXQuYXR0cigndGl0bGUnLCB0aXRsZSkucmVtb3ZlQXR0cihvbGR0aXRsZSk7XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHFUaXAgZXZlbnRzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIEFQSVxuXHRcdHRoaXMuX3VuYXNzaWduRXZlbnRzKCk7XG5cblx0XHQvLyBSZW1vdmUgSUQgZnJvbSB1c2VkIGlkIG9iamVjdHMsIGFuZCBkZWxldGUgb2JqZWN0IHJlZmVyZW5jZXNcblx0XHQvLyBmb3IgYmV0dGVyIGdhcmJhZ2UgY29sbGVjdGlvbiBhbmQgbGVhayBwcm90ZWN0aW9uXG5cdFx0dGhpcy5vcHRpb25zID0gdGhpcy5lbGVtZW50cyA9IHRoaXMuY2FjaGUgPSB0aGlzLnRpbWVycyA9XG5cdFx0XHR0aGlzLnBsdWdpbnMgPSB0aGlzLm1vdXNlID0gTlVMTDtcblxuXHRcdC8vIERlbGV0ZSBlcG94c2VkIEFQSSBvYmplY3Rcblx0XHRkZWxldGUgUVRJUC5hcGlbdGhpcy5pZF07XG5cdH1cblxuXHQvLyBJZiBhbiBpbW1lZGlhdGUgZGVzdHJveSBpcyBuZWVkZWRcblx0aWYoKGltbWVkaWF0ZSAhPT0gVFJVRSB8fCB0aGlzLnRyaWdnZXJpbmcgPT09ICdoaWRlJykgJiYgdGhpcy5yZW5kZXJlZCkge1xuXHRcdHRoaXMudG9vbHRpcC5vbmUoJ3Rvb2x0aXBoaWRkZW4nLCAkLnByb3h5KHByb2Nlc3MsIHRoaXMpKTtcblx0XHQhdGhpcy50cmlnZ2VyaW5nICYmIHRoaXMuaGlkZSgpO1xuXHR9XG5cblx0Ly8gSWYgd2UncmUgbm90IGluIHRoZSBwcm9jZXNzIG9mIGhpZGluZy4uLiBwcm9jZXNzXG5cdGVsc2UgeyBwcm9jZXNzLmNhbGwodGhpcyk7IH1cblxuXHRyZXR1cm4gdGhpcy50YXJnZXQ7XG59O1xuO2Z1bmN0aW9uIGludmFsaWRPcHQoYSkge1xuXHRyZXR1cm4gYSA9PT0gTlVMTCB8fCAkLnR5cGUoYSkgIT09ICdvYmplY3QnO1xufVxuXG5mdW5jdGlvbiBpbnZhbGlkQ29udGVudChjKSB7XG5cdHJldHVybiAhKCQuaXNGdW5jdGlvbihjKSB8fCBcbiAgICAgICAgICAgIGMgJiYgYy5hdHRyIHx8IFxuICAgICAgICAgICAgYy5sZW5ndGggfHwgXG4gICAgICAgICAgICAkLnR5cGUoYykgPT09ICdvYmplY3QnICYmIChjLmpxdWVyeSB8fCBjLnRoZW4pKTtcbn1cblxuLy8gT3B0aW9uIG9iamVjdCBzYW5pdGl6ZXJcbmZ1bmN0aW9uIHNhbml0aXplT3B0aW9ucyhvcHRzKSB7XG5cdHZhciBjb250ZW50LCB0ZXh0LCBhamF4LCBvbmNlO1xuXG5cdGlmKGludmFsaWRPcHQob3B0cykpIHsgcmV0dXJuIEZBTFNFOyB9XG5cblx0aWYoaW52YWxpZE9wdChvcHRzLm1ldGFkYXRhKSkge1xuXHRcdG9wdHMubWV0YWRhdGEgPSB7IHR5cGU6IG9wdHMubWV0YWRhdGEgfTtcblx0fVxuXG5cdGlmKCdjb250ZW50JyBpbiBvcHRzKSB7XG5cdFx0Y29udGVudCA9IG9wdHMuY29udGVudDtcblxuXHRcdGlmKGludmFsaWRPcHQoY29udGVudCkgfHwgY29udGVudC5qcXVlcnkgfHwgY29udGVudC5kb25lKSB7XG5cdFx0XHR0ZXh0ID0gaW52YWxpZENvbnRlbnQoY29udGVudCkgPyBGQUxTRSA6IGNvbnRlbnQ7XG5cdFx0XHRjb250ZW50ID0gb3B0cy5jb250ZW50ID0ge1xuXHRcdFx0XHR0ZXh0OiB0ZXh0XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRlbHNlIHsgdGV4dCA9IGNvbnRlbnQudGV4dDsgfVxuXG5cdFx0Ly8gREVQUkVDQVRFRCAtIE9sZCBjb250ZW50LmFqYXggcGx1Z2luIGZ1bmN0aW9uYWxpdHlcblx0XHQvLyBDb252ZXJ0cyBpdCBpbnRvIHRoZSBwcm9wZXIgRGVmZXJyZWQgc3ludGF4XG5cdFx0aWYoJ2FqYXgnIGluIGNvbnRlbnQpIHtcblx0XHRcdGFqYXggPSBjb250ZW50LmFqYXg7XG5cdFx0XHRvbmNlID0gYWpheCAmJiBhamF4Lm9uY2UgIT09IEZBTFNFO1xuXHRcdFx0ZGVsZXRlIGNvbnRlbnQuYWpheDtcblxuXHRcdFx0Y29udGVudC50ZXh0ID0gZnVuY3Rpb24oZXZlbnQsIGFwaSkge1xuXHRcdFx0XHR2YXIgbG9hZGluZyA9IHRleHQgfHwgJCh0aGlzKS5hdHRyKGFwaS5vcHRpb25zLmNvbnRlbnQuYXR0cikgfHwgJ0xvYWRpbmcuLi4nLFxuXG5cdFx0XHRcdGRlZmVycmVkID0gJC5hamF4KFxuXHRcdFx0XHRcdCQuZXh0ZW5kKHt9LCBhamF4LCB7IGNvbnRleHQ6IGFwaSB9KVxuXHRcdFx0XHQpXG5cdFx0XHRcdC50aGVuKGFqYXguc3VjY2VzcywgTlVMTCwgYWpheC5lcnJvcilcblx0XHRcdFx0LnRoZW4oZnVuY3Rpb24obmV3Q29udGVudCkge1xuXHRcdFx0XHRcdGlmKG5ld0NvbnRlbnQgJiYgb25jZSkgeyBhcGkuc2V0KCdjb250ZW50LnRleHQnLCBuZXdDb250ZW50KTsgfVxuXHRcdFx0XHRcdHJldHVybiBuZXdDb250ZW50O1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRmdW5jdGlvbih4aHIsIHN0YXR1cywgZXJyb3IpIHtcblx0XHRcdFx0XHRpZihhcGkuZGVzdHJveWVkIHx8IHhoci5zdGF0dXMgPT09IDApIHsgcmV0dXJuOyB9XG5cdFx0XHRcdFx0YXBpLnNldCgnY29udGVudC50ZXh0Jywgc3RhdHVzICsgJzogJyArIGVycm9yKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0cmV0dXJuICFvbmNlID8gKGFwaS5zZXQoJ2NvbnRlbnQudGV4dCcsIGxvYWRpbmcpLCBkZWZlcnJlZCkgOiBsb2FkaW5nO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRpZigndGl0bGUnIGluIGNvbnRlbnQpIHtcblx0XHRcdGlmKCQuaXNQbGFpbk9iamVjdChjb250ZW50LnRpdGxlKSkge1xuXHRcdFx0XHRjb250ZW50LmJ1dHRvbiA9IGNvbnRlbnQudGl0bGUuYnV0dG9uO1xuXHRcdFx0XHRjb250ZW50LnRpdGxlID0gY29udGVudC50aXRsZS50ZXh0O1xuXHRcdFx0fVxuXG5cdFx0XHRpZihpbnZhbGlkQ29udGVudChjb250ZW50LnRpdGxlIHx8IEZBTFNFKSkge1xuXHRcdFx0XHRjb250ZW50LnRpdGxlID0gRkFMU0U7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYoJ3Bvc2l0aW9uJyBpbiBvcHRzICYmIGludmFsaWRPcHQob3B0cy5wb3NpdGlvbikpIHtcblx0XHRvcHRzLnBvc2l0aW9uID0geyBteTogb3B0cy5wb3NpdGlvbiwgYXQ6IG9wdHMucG9zaXRpb24gfTtcblx0fVxuXG5cdGlmKCdzaG93JyBpbiBvcHRzICYmIGludmFsaWRPcHQob3B0cy5zaG93KSkge1xuXHRcdG9wdHMuc2hvdyA9IG9wdHMuc2hvdy5qcXVlcnkgPyB7IHRhcmdldDogb3B0cy5zaG93IH0gOlxuXHRcdFx0b3B0cy5zaG93ID09PSBUUlVFID8geyByZWFkeTogVFJVRSB9IDogeyBldmVudDogb3B0cy5zaG93IH07XG5cdH1cblxuXHRpZignaGlkZScgaW4gb3B0cyAmJiBpbnZhbGlkT3B0KG9wdHMuaGlkZSkpIHtcblx0XHRvcHRzLmhpZGUgPSBvcHRzLmhpZGUuanF1ZXJ5ID8geyB0YXJnZXQ6IG9wdHMuaGlkZSB9IDogeyBldmVudDogb3B0cy5oaWRlIH07XG5cdH1cblxuXHRpZignc3R5bGUnIGluIG9wdHMgJiYgaW52YWxpZE9wdChvcHRzLnN0eWxlKSkge1xuXHRcdG9wdHMuc3R5bGUgPSB7IGNsYXNzZXM6IG9wdHMuc3R5bGUgfTtcblx0fVxuXG5cdC8vIFNhbml0aXplIHBsdWdpbiBvcHRpb25zXG5cdCQuZWFjaChQTFVHSU5TLCBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnNhbml0aXplICYmIHRoaXMuc2FuaXRpemUob3B0cyk7XG5cdH0pO1xuXG5cdHJldHVybiBvcHRzO1xufVxuXG4vLyBTZXR1cCBidWlsdGluIC5zZXQoKSBvcHRpb24gY2hlY2tzXG5DSEVDS1MgPSBQUk9UT1RZUEUuY2hlY2tzID0ge1xuXHRidWlsdGluOiB7XG5cdFx0Ly8gQ29yZSBjaGVja3Ncblx0XHQnXmlkJCc6IGZ1bmN0aW9uKG9iaiwgbywgdiwgcHJldikge1xuXHRcdFx0dmFyIGlkID0gdiA9PT0gVFJVRSA/IFFUSVAubmV4dGlkIDogdixcblx0XHRcdFx0bmV3SWQgPSBOQU1FU1BBQ0UgKyAnLScgKyBpZDtcblxuXHRcdFx0aWYoaWQgIT09IEZBTFNFICYmIGlkLmxlbmd0aCA+IDAgJiYgISQoJyMnK25ld0lkKS5sZW5ndGgpIHtcblx0XHRcdFx0dGhpcy5faWQgPSBuZXdJZDtcblxuXHRcdFx0XHRpZih0aGlzLnJlbmRlcmVkKSB7XG5cdFx0XHRcdFx0dGhpcy50b29sdGlwWzBdLmlkID0gdGhpcy5faWQ7XG5cdFx0XHRcdFx0dGhpcy5lbGVtZW50cy5jb250ZW50WzBdLmlkID0gdGhpcy5faWQgKyAnLWNvbnRlbnQnO1xuXHRcdFx0XHRcdHRoaXMuZWxlbWVudHMudGl0bGVbMF0uaWQgPSB0aGlzLl9pZCArICctdGl0bGUnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHsgb2JqW29dID0gcHJldjsgfVxuXHRcdH0sXG5cdFx0J15wcmVyZW5kZXInOiBmdW5jdGlvbihvYmosIG8sIHYpIHtcblx0XHRcdHYgJiYgIXRoaXMucmVuZGVyZWQgJiYgdGhpcy5yZW5kZXIodGhpcy5vcHRpb25zLnNob3cucmVhZHkpO1xuXHRcdH0sXG5cblx0XHQvLyBDb250ZW50IGNoZWNrc1xuXHRcdCdeY29udGVudC50ZXh0JCc6IGZ1bmN0aW9uKG9iaiwgbywgdikge1xuXHRcdFx0dGhpcy5fdXBkYXRlQ29udGVudCh2KTtcblx0XHR9LFxuXHRcdCdeY29udGVudC5hdHRyJCc6IGZ1bmN0aW9uKG9iaiwgbywgdiwgcHJldikge1xuXHRcdFx0aWYodGhpcy5vcHRpb25zLmNvbnRlbnQudGV4dCA9PT0gdGhpcy50YXJnZXQuYXR0cihwcmV2KSkge1xuXHRcdFx0XHR0aGlzLl91cGRhdGVDb250ZW50KCB0aGlzLnRhcmdldC5hdHRyKHYpICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQnXmNvbnRlbnQudGl0bGUkJzogZnVuY3Rpb24ob2JqLCBvLCB2KSB7XG5cdFx0XHQvLyBSZW1vdmUgdGl0bGUgaWYgY29udGVudCBpcyBudWxsXG5cdFx0XHRpZighdikgeyByZXR1cm4gdGhpcy5fcmVtb3ZlVGl0bGUoKTsgfVxuXG5cdFx0XHQvLyBJZiB0aXRsZSBpc24ndCBhbHJlYWR5IGNyZWF0ZWQsIGNyZWF0ZSBpdCBub3cgYW5kIHVwZGF0ZVxuXHRcdFx0diAmJiAhdGhpcy5lbGVtZW50cy50aXRsZSAmJiB0aGlzLl9jcmVhdGVUaXRsZSgpO1xuXHRcdFx0dGhpcy5fdXBkYXRlVGl0bGUodik7XG5cdFx0fSxcblx0XHQnXmNvbnRlbnQuYnV0dG9uJCc6IGZ1bmN0aW9uKG9iaiwgbywgdikge1xuXHRcdFx0dGhpcy5fdXBkYXRlQnV0dG9uKHYpO1xuXHRcdH0sXG5cdFx0J15jb250ZW50LnRpdGxlLih0ZXh0fGJ1dHRvbikkJzogZnVuY3Rpb24ob2JqLCBvLCB2KSB7XG5cdFx0XHR0aGlzLnNldCgnY29udGVudC4nK28sIHYpOyAvLyBCYWNrd2FyZHMgdGl0bGUudGV4dC9idXR0b24gY29tcGF0XG5cdFx0fSxcblxuXHRcdC8vIFBvc2l0aW9uIGNoZWNrc1xuXHRcdCdecG9zaXRpb24uKG15fGF0KSQnOiBmdW5jdGlvbihvYmosIG8sIHYpe1xuXHRcdFx0aWYoJ3N0cmluZycgPT09IHR5cGVvZiB2KSB7XG5cdFx0XHRcdHRoaXMucG9zaXRpb25bb10gPSBvYmpbb10gPSBuZXcgQ09STkVSKHYsIG8gPT09ICdhdCcpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0J15wb3NpdGlvbi5jb250YWluZXIkJzogZnVuY3Rpb24ob2JqLCBvLCB2KXtcblx0XHRcdHRoaXMucmVuZGVyZWQgJiYgdGhpcy50b29sdGlwLmFwcGVuZFRvKHYpO1xuXHRcdH0sXG5cblx0XHQvLyBTaG93IGNoZWNrc1xuXHRcdCdec2hvdy5yZWFkeSQnOiBmdW5jdGlvbihvYmosIG8sIHYpIHtcblx0XHRcdHYgJiYgKCF0aGlzLnJlbmRlcmVkICYmIHRoaXMucmVuZGVyKFRSVUUpIHx8IHRoaXMudG9nZ2xlKFRSVUUpKTtcblx0XHR9LFxuXG5cdFx0Ly8gU3R5bGUgY2hlY2tzXG5cdFx0J15zdHlsZS5jbGFzc2VzJCc6IGZ1bmN0aW9uKG9iaiwgbywgdiwgcCkge1xuXHRcdFx0dGhpcy5yZW5kZXJlZCAmJiB0aGlzLnRvb2x0aXAucmVtb3ZlQ2xhc3MocCkuYWRkQ2xhc3Modik7XG5cdFx0fSxcblx0XHQnXnN0eWxlLih3aWR0aHxoZWlnaHQpJzogZnVuY3Rpb24ob2JqLCBvLCB2KSB7XG5cdFx0XHR0aGlzLnJlbmRlcmVkICYmIHRoaXMudG9vbHRpcC5jc3Mobywgdik7XG5cdFx0fSxcblx0XHQnXnN0eWxlLndpZGdldHxjb250ZW50LnRpdGxlJzogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnJlbmRlcmVkICYmIHRoaXMuX3NldFdpZGdldCgpO1xuXHRcdH0sXG5cdFx0J15zdHlsZS5kZWYnOiBmdW5jdGlvbihvYmosIG8sIHYpIHtcblx0XHRcdHRoaXMucmVuZGVyZWQgJiYgdGhpcy50b29sdGlwLnRvZ2dsZUNsYXNzKENMQVNTX0RFRkFVTFQsICEhdik7XG5cdFx0fSxcblxuXHRcdC8vIEV2ZW50cyBjaGVja1xuXHRcdCdeZXZlbnRzLihyZW5kZXJ8c2hvd3xtb3ZlfGhpZGV8Zm9jdXN8Ymx1cikkJzogZnVuY3Rpb24ob2JqLCBvLCB2KSB7XG5cdFx0XHR0aGlzLnJlbmRlcmVkICYmIHRoaXMudG9vbHRpcFsoJC5pc0Z1bmN0aW9uKHYpID8gJycgOiAndW4nKSArICdiaW5kJ10oJ3Rvb2x0aXAnK28sIHYpO1xuXHRcdH0sXG5cblx0XHQvLyBQcm9wZXJ0aWVzIHdoaWNoIHJlcXVpcmUgZXZlbnQgcmVhc3NpZ25tZW50XG5cdFx0J14oc2hvd3xoaWRlfHBvc2l0aW9uKS4oZXZlbnR8dGFyZ2V0fGZpeGVkfGluYWN0aXZlfGxlYXZlfGRpc3RhbmNlfHZpZXdwb3J0fGFkanVzdCknOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmKCF0aGlzLnJlbmRlcmVkKSB7IHJldHVybjsgfVxuXG5cdFx0XHQvLyBTZXQgdHJhY2tpbmcgZmxhZ1xuXHRcdFx0dmFyIHBvc09wdGlvbnMgPSB0aGlzLm9wdGlvbnMucG9zaXRpb247XG5cdFx0XHR0aGlzLnRvb2x0aXAuYXR0cigndHJhY2tpbmcnLCBwb3NPcHRpb25zLnRhcmdldCA9PT0gJ21vdXNlJyAmJiBwb3NPcHRpb25zLmFkanVzdC5tb3VzZSk7XG5cblx0XHRcdC8vIFJlYXNzaWduIGV2ZW50c1xuXHRcdFx0dGhpcy5fdW5hc3NpZ25FdmVudHMoKTtcblx0XHRcdHRoaXMuX2Fzc2lnbkV2ZW50cygpO1xuXHRcdH1cblx0fVxufTtcblxuLy8gRG90IG5vdGF0aW9uIGNvbnZlcnRlclxuZnVuY3Rpb24gY29udmVydE5vdGF0aW9uKG9wdGlvbnMsIG5vdGF0aW9uKSB7XG5cdHZhciBpID0gMCwgb2JqLCBvcHRpb24gPSBvcHRpb25zLFxuXG5cdC8vIFNwbGl0IG5vdGF0aW9uIGludG8gYXJyYXlcblx0bGV2ZWxzID0gbm90YXRpb24uc3BsaXQoJy4nKTtcblxuXHQvLyBMb29wIHRocm91Z2hcblx0d2hpbGUob3B0aW9uID0gb3B0aW9uWyBsZXZlbHNbaSsrXSBdKSB7XG5cdFx0aWYoaSA8IGxldmVscy5sZW5ndGgpIHsgb2JqID0gb3B0aW9uOyB9XG5cdH1cblxuXHRyZXR1cm4gW29iaiB8fCBvcHRpb25zLCBsZXZlbHMucG9wKCldO1xufVxuXG5QUk9UT1RZUEUuZ2V0ID0gZnVuY3Rpb24obm90YXRpb24pIHtcblx0aWYodGhpcy5kZXN0cm95ZWQpIHsgcmV0dXJuIHRoaXM7IH1cblxuXHR2YXIgbyA9IGNvbnZlcnROb3RhdGlvbih0aGlzLm9wdGlvbnMsIG5vdGF0aW9uLnRvTG93ZXJDYXNlKCkpLFxuXHRcdHJlc3VsdCA9IG9bMF1bIG9bMV0gXTtcblxuXHRyZXR1cm4gcmVzdWx0LnByZWNlZGFuY2UgPyByZXN1bHQuc3RyaW5nKCkgOiByZXN1bHQ7XG59O1xuXG5mdW5jdGlvbiBzZXRDYWxsYmFjayhub3RhdGlvbiwgYXJncykge1xuXHR2YXIgY2F0ZWdvcnksIHJ1bGUsIG1hdGNoO1xuXG5cdGZvcihjYXRlZ29yeSBpbiB0aGlzLmNoZWNrcykge1xuXHRcdGlmICghdGhpcy5jaGVja3MuaGFzT3duUHJvcGVydHkoY2F0ZWdvcnkpKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRmb3IocnVsZSBpbiB0aGlzLmNoZWNrc1tjYXRlZ29yeV0pIHtcblx0XHRcdGlmICghdGhpcy5jaGVja3NbY2F0ZWdvcnldLmhhc093blByb3BlcnR5KHJ1bGUpKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdGlmKG1hdGNoID0gKG5ldyBSZWdFeHAocnVsZSwgJ2knKSkuZXhlYyhub3RhdGlvbikpIHtcblx0XHRcdFx0YXJncy5wdXNoKG1hdGNoKTtcblxuXHRcdFx0XHRpZihjYXRlZ29yeSA9PT0gJ2J1aWx0aW4nIHx8IHRoaXMucGx1Z2luc1tjYXRlZ29yeV0pIHtcblx0XHRcdFx0XHR0aGlzLmNoZWNrc1tjYXRlZ29yeV1bcnVsZV0uYXBwbHkoXG5cdFx0XHRcdFx0XHR0aGlzLnBsdWdpbnNbY2F0ZWdvcnldIHx8IHRoaXMsIGFyZ3Ncblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbnZhciBybW92ZSA9IC9ecG9zaXRpb25cXC4obXl8YXR8YWRqdXN0fHRhcmdldHxjb250YWluZXJ8dmlld3BvcnQpfHN0eWxlfGNvbnRlbnR8c2hvd1xcLnJlYWR5L2ksXG5cdHJyZW5kZXIgPSAvXnByZXJlbmRlcnxzaG93XFwucmVhZHkvaTtcblxuUFJPVE9UWVBFLnNldCA9IGZ1bmN0aW9uKG9wdGlvbiwgdmFsdWUpIHtcblx0aWYodGhpcy5kZXN0cm95ZWQpIHsgcmV0dXJuIHRoaXM7IH1cblxuXHR2YXIgcmVuZGVyZWQgPSB0aGlzLnJlbmRlcmVkLFxuXHRcdHJlcG9zaXRpb24gPSBGQUxTRSxcblx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdG5hbWU7XG5cblx0Ly8gQ29udmVydCBzaW5ndWxhciBvcHRpb24vdmFsdWUgcGFpciBpbnRvIG9iamVjdCBmb3JtXG5cdGlmKCdzdHJpbmcnID09PSB0eXBlb2Ygb3B0aW9uKSB7XG5cdFx0bmFtZSA9IG9wdGlvbjsgb3B0aW9uID0ge307IG9wdGlvbltuYW1lXSA9IHZhbHVlO1xuXHR9XG5cdGVsc2UgeyBvcHRpb24gPSAkLmV4dGVuZCh7fSwgb3B0aW9uKTsgfVxuXG5cdC8vIFNldCBhbGwgb2YgdGhlIGRlZmluZWQgb3B0aW9ucyB0byB0aGVpciBuZXcgdmFsdWVzXG5cdCQuZWFjaChvcHRpb24sIGZ1bmN0aW9uKG5vdGF0aW9uLCB2YWwpIHtcblx0XHRpZihyZW5kZXJlZCAmJiBycmVuZGVyLnRlc3Qobm90YXRpb24pKSB7XG5cdFx0XHRkZWxldGUgb3B0aW9uW25vdGF0aW9uXTsgcmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFNldCBuZXcgb2JqIHZhbHVlXG5cdFx0dmFyIG9iaiA9IGNvbnZlcnROb3RhdGlvbihvcHRpb25zLCBub3RhdGlvbi50b0xvd2VyQ2FzZSgpKSwgcHJldmlvdXM7XG5cdFx0cHJldmlvdXMgPSBvYmpbMF1bIG9ialsxXSBdO1xuXHRcdG9ialswXVsgb2JqWzFdIF0gPSB2YWwgJiYgdmFsLm5vZGVUeXBlID8gJCh2YWwpIDogdmFsO1xuXG5cdFx0Ly8gQWxzbyBjaGVjayBpZiB3ZSBuZWVkIHRvIHJlcG9zaXRpb25cblx0XHRyZXBvc2l0aW9uID0gcm1vdmUudGVzdChub3RhdGlvbikgfHwgcmVwb3NpdGlvbjtcblxuXHRcdC8vIFNldCB0aGUgbmV3IHBhcmFtcyBmb3IgdGhlIGNhbGxiYWNrXG5cdFx0b3B0aW9uW25vdGF0aW9uXSA9IFtvYmpbMF0sIG9ialsxXSwgdmFsLCBwcmV2aW91c107XG5cdH0pO1xuXG5cdC8vIFJlLXNhbml0aXplIG9wdGlvbnNcblx0c2FuaXRpemVPcHRpb25zKG9wdGlvbnMpO1xuXG5cdC8qXG5cdCAqIEV4ZWN1dGUgYW55IHZhbGlkIGNhbGxiYWNrcyBmb3IgdGhlIHNldCBvcHRpb25zXG5cdCAqIEFsc28gc2V0IHBvc2l0aW9uaW5nIGZsYWcgc28gd2UgZG9uJ3QgZ2V0IGxvYWRzIG9mIHJlZHVuZGFudCByZXBvc2l0aW9uaW5nIGNhbGxzLlxuXHQgKi9cblx0dGhpcy5wb3NpdGlvbmluZyA9IFRSVUU7XG5cdCQuZWFjaChvcHRpb24sICQucHJveHkoc2V0Q2FsbGJhY2ssIHRoaXMpKTtcblx0dGhpcy5wb3NpdGlvbmluZyA9IEZBTFNFO1xuXG5cdC8vIFVwZGF0ZSBwb3NpdGlvbiBpZiBuZWVkZWRcblx0aWYodGhpcy5yZW5kZXJlZCAmJiB0aGlzLnRvb2x0aXBbMF0ub2Zmc2V0V2lkdGggPiAwICYmIHJlcG9zaXRpb24pIHtcblx0XHR0aGlzLnJlcG9zaXRpb24oIG9wdGlvbnMucG9zaXRpb24udGFyZ2V0ID09PSAnbW91c2UnID8gTlVMTCA6IHRoaXMuY2FjaGUuZXZlbnQgKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcbjtQUk9UT1RZUEUuX3VwZGF0ZSA9IGZ1bmN0aW9uKGNvbnRlbnQsIGVsZW1lbnQpIHtcblx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdGNhY2hlID0gdGhpcy5jYWNoZTtcblxuXHQvLyBNYWtlIHN1cmUgdG9vbHRpcCBpcyByZW5kZXJlZCBhbmQgY29udGVudCBpcyBkZWZpbmVkLiBJZiBub3QgcmV0dXJuXG5cdGlmKCF0aGlzLnJlbmRlcmVkIHx8ICFjb250ZW50KSB7IHJldHVybiBGQUxTRTsgfVxuXG5cdC8vIFVzZSBmdW5jdGlvbiB0byBwYXJzZSBjb250ZW50XG5cdGlmKCQuaXNGdW5jdGlvbihjb250ZW50KSkge1xuXHRcdGNvbnRlbnQgPSBjb250ZW50LmNhbGwodGhpcy5lbGVtZW50cy50YXJnZXQsIGNhY2hlLmV2ZW50LCB0aGlzKSB8fCAnJztcblx0fVxuXG5cdC8vIEhhbmRsZSBkZWZlcnJlZCBjb250ZW50XG5cdGlmKCQuaXNGdW5jdGlvbihjb250ZW50LnRoZW4pKSB7XG5cdFx0Y2FjaGUud2FpdGluZyA9IFRSVUU7XG5cdFx0cmV0dXJuIGNvbnRlbnQudGhlbihmdW5jdGlvbihjKSB7XG5cdFx0XHRjYWNoZS53YWl0aW5nID0gRkFMU0U7XG5cdFx0XHRyZXR1cm4gc2VsZi5fdXBkYXRlKGMsIGVsZW1lbnQpO1xuXHRcdH0sIE5VTEwsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdHJldHVybiBzZWxmLl91cGRhdGUoZSwgZWxlbWVudCk7XG5cdFx0fSk7XG5cdH1cblxuXHQvLyBJZiBjb250ZW50IGlzIG51bGwuLi4gcmV0dXJuIGZhbHNlXG5cdGlmKGNvbnRlbnQgPT09IEZBTFNFIHx8ICFjb250ZW50ICYmIGNvbnRlbnQgIT09ICcnKSB7IHJldHVybiBGQUxTRTsgfVxuXG5cdC8vIEFwcGVuZCBuZXcgY29udGVudCBpZiBpdHMgYSBET00gYXJyYXkgYW5kIHNob3cgaXQgaWYgaGlkZGVuXG5cdGlmKGNvbnRlbnQuanF1ZXJ5ICYmIGNvbnRlbnQubGVuZ3RoID4gMCkge1xuXHRcdGVsZW1lbnQuZW1wdHkoKS5hcHBlbmQoXG5cdFx0XHRjb250ZW50LmNzcyh7IGRpc3BsYXk6ICdibG9jaycsIHZpc2liaWxpdHk6ICd2aXNpYmxlJyB9KVxuXHRcdCk7XG5cdH1cblxuXHQvLyBDb250ZW50IGlzIGEgcmVndWxhciBzdHJpbmcsIGluc2VydCB0aGUgbmV3IGNvbnRlbnRcblx0ZWxzZSB7IGVsZW1lbnQuaHRtbChjb250ZW50KTsgfVxuXG5cdC8vIFdhaXQgZm9yIGNvbnRlbnQgdG8gYmUgbG9hZGVkLCBhbmQgcmVwb3NpdGlvblxuXHRyZXR1cm4gdGhpcy5fd2FpdEZvckNvbnRlbnQoZWxlbWVudCkudGhlbihmdW5jdGlvbihpbWFnZXMpIHtcblx0XHRpZihzZWxmLnJlbmRlcmVkICYmIHNlbGYudG9vbHRpcFswXS5vZmZzZXRXaWR0aCA+IDApIHtcblx0XHRcdHNlbGYucmVwb3NpdGlvbihjYWNoZS5ldmVudCwgIWltYWdlcy5sZW5ndGgpO1xuXHRcdH1cblx0fSk7XG59O1xuXG5QUk9UT1RZUEUuX3dhaXRGb3JDb250ZW50ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuXHR2YXIgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXG5cdC8vIFNldCBmbGFnXG5cdGNhY2hlLndhaXRpbmcgPSBUUlVFO1xuXG5cdC8vIElmIGltYWdlc0xvYWRlZCBpcyBpbmNsdWRlZCwgZW5zdXJlIGltYWdlcyBoYXZlIGxvYWRlZCBhbmQgcmV0dXJuIHByb21pc2Vcblx0cmV0dXJuICggJC5mbi5pbWFnZXNMb2FkZWQgPyBlbGVtZW50LmltYWdlc0xvYWRlZCgpIDogbmV3ICQuRGVmZXJyZWQoKS5yZXNvbHZlKFtdKSApXG5cdFx0LmRvbmUoZnVuY3Rpb24oKSB7IGNhY2hlLndhaXRpbmcgPSBGQUxTRTsgfSlcblx0XHQucHJvbWlzZSgpO1xufTtcblxuUFJPVE9UWVBFLl91cGRhdGVDb250ZW50ID0gZnVuY3Rpb24oY29udGVudCwgcmVwb3NpdGlvbikge1xuXHR0aGlzLl91cGRhdGUoY29udGVudCwgdGhpcy5lbGVtZW50cy5jb250ZW50LCByZXBvc2l0aW9uKTtcbn07XG5cblBST1RPVFlQRS5fdXBkYXRlVGl0bGUgPSBmdW5jdGlvbihjb250ZW50LCByZXBvc2l0aW9uKSB7XG5cdGlmKHRoaXMuX3VwZGF0ZShjb250ZW50LCB0aGlzLmVsZW1lbnRzLnRpdGxlLCByZXBvc2l0aW9uKSA9PT0gRkFMU0UpIHtcblx0XHR0aGlzLl9yZW1vdmVUaXRsZShGQUxTRSk7XG5cdH1cbn07XG5cblBST1RPVFlQRS5fY3JlYXRlVGl0bGUgPSBmdW5jdGlvbigpXG57XG5cdHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHMsXG5cdFx0aWQgPSB0aGlzLl9pZCsnLXRpdGxlJztcblxuXHQvLyBEZXN0cm95IHByZXZpb3VzIHRpdGxlIGVsZW1lbnQsIGlmIHByZXNlbnRcblx0aWYoZWxlbWVudHMudGl0bGViYXIpIHsgdGhpcy5fcmVtb3ZlVGl0bGUoKTsgfVxuXG5cdC8vIENyZWF0ZSB0aXRsZSBiYXIgYW5kIHRpdGxlIGVsZW1lbnRzXG5cdGVsZW1lbnRzLnRpdGxlYmFyID0gJCgnPGRpdiAvPicsIHtcblx0XHQnY2xhc3MnOiBOQU1FU1BBQ0UgKyAnLXRpdGxlYmFyICcgKyAodGhpcy5vcHRpb25zLnN0eWxlLndpZGdldCA/IGNyZWF0ZVdpZGdldENsYXNzKCdoZWFkZXInKSA6ICcnKVxuXHR9KVxuXHQuYXBwZW5kKFxuXHRcdGVsZW1lbnRzLnRpdGxlID0gJCgnPGRpdiAvPicsIHtcblx0XHRcdCdpZCc6IGlkLFxuXHRcdFx0J2NsYXNzJzogTkFNRVNQQUNFICsgJy10aXRsZScsXG5cdFx0XHQnYXJpYS1hdG9taWMnOiBUUlVFXG5cdFx0fSlcblx0KVxuXHQuaW5zZXJ0QmVmb3JlKGVsZW1lbnRzLmNvbnRlbnQpXG5cblx0Ly8gQnV0dG9uLXNwZWNpZmljIGV2ZW50c1xuXHQuZGVsZWdhdGUoJy5xdGlwLWNsb3NlJywgJ21vdXNlZG93biBrZXlkb3duIG1vdXNldXAga2V5dXAgbW91c2VvdXQnLCBmdW5jdGlvbihldmVudCkge1xuXHRcdCQodGhpcykudG9nZ2xlQ2xhc3MoJ3VpLXN0YXRlLWFjdGl2ZSB1aS1zdGF0ZS1mb2N1cycsIGV2ZW50LnR5cGUuc3Vic3RyKC00KSA9PT0gJ2Rvd24nKTtcblx0fSlcblx0LmRlbGVnYXRlKCcucXRpcC1jbG9zZScsICdtb3VzZW92ZXIgbW91c2VvdXQnLCBmdW5jdGlvbihldmVudCl7XG5cdFx0JCh0aGlzKS50b2dnbGVDbGFzcygndWktc3RhdGUtaG92ZXInLCBldmVudC50eXBlID09PSAnbW91c2VvdmVyJyk7XG5cdH0pO1xuXG5cdC8vIENyZWF0ZSBidXR0b24gaWYgZW5hYmxlZFxuXHRpZih0aGlzLm9wdGlvbnMuY29udGVudC5idXR0b24pIHsgdGhpcy5fY3JlYXRlQnV0dG9uKCk7IH1cbn07XG5cblBST1RPVFlQRS5fcmVtb3ZlVGl0bGUgPSBmdW5jdGlvbihyZXBvc2l0aW9uKVxue1xuXHR2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdGlmKGVsZW1lbnRzLnRpdGxlKSB7XG5cdFx0ZWxlbWVudHMudGl0bGViYXIucmVtb3ZlKCk7XG5cdFx0ZWxlbWVudHMudGl0bGViYXIgPSBlbGVtZW50cy50aXRsZSA9IGVsZW1lbnRzLmJ1dHRvbiA9IE5VTEw7XG5cblx0XHQvLyBSZXBvc2l0aW9uIGlmIGVuYWJsZWRcblx0XHRpZihyZXBvc2l0aW9uICE9PSBGQUxTRSkgeyB0aGlzLnJlcG9zaXRpb24oKTsgfVxuXHR9XG59O1xuO1BST1RPVFlQRS5fY3JlYXRlUG9zQ2xhc3MgPSBmdW5jdGlvbihteSkge1xuXHRyZXR1cm4gTkFNRVNQQUNFICsgJy1wb3MtJyArIChteSB8fCB0aGlzLm9wdGlvbnMucG9zaXRpb24ubXkpLmFiYnJldigpO1xufTtcblxuUFJPVE9UWVBFLnJlcG9zaXRpb24gPSBmdW5jdGlvbihldmVudCwgZWZmZWN0KSB7XG5cdGlmKCF0aGlzLnJlbmRlcmVkIHx8IHRoaXMucG9zaXRpb25pbmcgfHwgdGhpcy5kZXN0cm95ZWQpIHsgcmV0dXJuIHRoaXM7IH1cblxuXHQvLyBTZXQgcG9zaXRpb25pbmcgZmxhZ1xuXHR0aGlzLnBvc2l0aW9uaW5nID0gVFJVRTtcblxuXHR2YXIgY2FjaGUgPSB0aGlzLmNhY2hlLFxuXHRcdHRvb2x0aXAgPSB0aGlzLnRvb2x0aXAsXG5cdFx0cG9zT3B0aW9ucyA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbixcblx0XHR0YXJnZXQgPSBwb3NPcHRpb25zLnRhcmdldCxcblx0XHRteSA9IHBvc09wdGlvbnMubXksXG5cdFx0YXQgPSBwb3NPcHRpb25zLmF0LFxuXHRcdHZpZXdwb3J0ID0gcG9zT3B0aW9ucy52aWV3cG9ydCxcblx0XHRjb250YWluZXIgPSBwb3NPcHRpb25zLmNvbnRhaW5lcixcblx0XHRhZGp1c3QgPSBwb3NPcHRpb25zLmFkanVzdCxcblx0XHRtZXRob2QgPSBhZGp1c3QubWV0aG9kLnNwbGl0KCcgJyksXG5cdFx0dG9vbHRpcFdpZHRoID0gdG9vbHRpcC5vdXRlcldpZHRoKEZBTFNFKSxcblx0XHR0b29sdGlwSGVpZ2h0ID0gdG9vbHRpcC5vdXRlckhlaWdodChGQUxTRSksXG5cdFx0dGFyZ2V0V2lkdGggPSAwLFxuXHRcdHRhcmdldEhlaWdodCA9IDAsXG5cdFx0dHlwZSA9IHRvb2x0aXAuY3NzKCdwb3NpdGlvbicpLFxuXHRcdHBvc2l0aW9uID0geyBsZWZ0OiAwLCB0b3A6IDAgfSxcblx0XHR2aXNpYmxlID0gdG9vbHRpcFswXS5vZmZzZXRXaWR0aCA+IDAsXG5cdFx0aXNTY3JvbGwgPSBldmVudCAmJiBldmVudC50eXBlID09PSAnc2Nyb2xsJyxcblx0XHR3aW4gPSAkKHdpbmRvdyksXG5cdFx0ZG9jID0gY29udGFpbmVyWzBdLm93bmVyRG9jdW1lbnQsXG5cdFx0bW91c2UgPSB0aGlzLm1vdXNlLFxuXHRcdHBsdWdpbkNhbGN1bGF0aW9ucywgb2Zmc2V0LCBhZGp1c3RlZCwgbmV3Q2xhc3M7XG5cblx0Ly8gQ2hlY2sgaWYgYWJzb2x1dGUgcG9zaXRpb24gd2FzIHBhc3NlZFxuXHRpZigkLmlzQXJyYXkodGFyZ2V0KSAmJiB0YXJnZXQubGVuZ3RoID09PSAyKSB7XG5cdFx0Ly8gRm9yY2UgbGVmdCB0b3AgYW5kIHNldCBwb3NpdGlvblxuXHRcdGF0ID0geyB4OiBMRUZULCB5OiBUT1AgfTtcblx0XHRwb3NpdGlvbiA9IHsgbGVmdDogdGFyZ2V0WzBdLCB0b3A6IHRhcmdldFsxXSB9O1xuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgbW91c2Ugd2FzIHRoZSB0YXJnZXRcblx0ZWxzZSBpZih0YXJnZXQgPT09ICdtb3VzZScpIHtcblx0XHQvLyBGb3JjZSBsZWZ0IHRvcCB0byBhbGxvdyBmbGlwcGluZ1xuXHRcdGF0ID0geyB4OiBMRUZULCB5OiBUT1AgfTtcblxuXHRcdC8vIFVzZSB0aGUgbW91c2Ugb3JpZ2luIHRoYXQgY2F1c2VkIHRoZSBzaG93IGV2ZW50LCBpZiBkaXN0YW5jZSBoaWRpbmcgaXMgZW5hYmxlZFxuXHRcdGlmKCghYWRqdXN0Lm1vdXNlIHx8IHRoaXMub3B0aW9ucy5oaWRlLmRpc3RhbmNlKSAmJiBjYWNoZS5vcmlnaW4gJiYgY2FjaGUub3JpZ2luLnBhZ2VYKSB7XG5cdFx0XHRldmVudCA9ICBjYWNoZS5vcmlnaW47XG5cdFx0fVxuXG5cdFx0Ly8gVXNlIGNhY2hlZCBldmVudCBmb3IgcmVzaXplL3Njcm9sbCBldmVudHNcblx0XHRlbHNlIGlmKCFldmVudCB8fCBldmVudCAmJiAoZXZlbnQudHlwZSA9PT0gJ3Jlc2l6ZScgfHwgZXZlbnQudHlwZSA9PT0gJ3Njcm9sbCcpKSB7XG5cdFx0XHRldmVudCA9IGNhY2hlLmV2ZW50O1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSwgdXNlIHRoZSBjYWNoZWQgbW91c2UgY29vcmRpbmF0ZXMgaWYgYXZhaWxhYmxlXG5cdFx0ZWxzZSBpZihtb3VzZSAmJiBtb3VzZS5wYWdlWCkge1xuXHRcdFx0ZXZlbnQgPSBtb3VzZTtcblx0XHR9XG5cblx0XHQvLyBDYWxjdWxhdGUgYm9keSBhbmQgY29udGFpbmVyIG9mZnNldCBhbmQgdGFrZSB0aGVtIGludG8gYWNjb3VudCBiZWxvd1xuXHRcdGlmKHR5cGUgIT09ICdzdGF0aWMnKSB7IHBvc2l0aW9uID0gY29udGFpbmVyLm9mZnNldCgpOyB9XG5cdFx0aWYoZG9jLmJvZHkub2Zmc2V0V2lkdGggIT09ICh3aW5kb3cuaW5uZXJXaWR0aCB8fCBkb2MuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoKSkge1xuXHRcdFx0b2Zmc2V0ID0gJChkb2N1bWVudC5ib2R5KS5vZmZzZXQoKTtcblx0XHR9XG5cblx0XHQvLyBVc2UgZXZlbnQgY29vcmRpbmF0ZXMgZm9yIHBvc2l0aW9uXG5cdFx0cG9zaXRpb24gPSB7XG5cdFx0XHRsZWZ0OiBldmVudC5wYWdlWCAtIHBvc2l0aW9uLmxlZnQgKyAob2Zmc2V0ICYmIG9mZnNldC5sZWZ0IHx8IDApLFxuXHRcdFx0dG9wOiBldmVudC5wYWdlWSAtIHBvc2l0aW9uLnRvcCArIChvZmZzZXQgJiYgb2Zmc2V0LnRvcCB8fCAwKVxuXHRcdH07XG5cblx0XHQvLyBTY3JvbGwgZXZlbnRzIGFyZSBhIHBhaW4sIHNvbWUgYnJvd3NlcnNcblx0XHRpZihhZGp1c3QubW91c2UgJiYgaXNTY3JvbGwgJiYgbW91c2UpIHtcblx0XHRcdHBvc2l0aW9uLmxlZnQgLT0gKG1vdXNlLnNjcm9sbFggfHwgMCkgLSB3aW4uc2Nyb2xsTGVmdCgpO1xuXHRcdFx0cG9zaXRpb24udG9wIC09IChtb3VzZS5zY3JvbGxZIHx8IDApIC0gd2luLnNjcm9sbFRvcCgpO1xuXHRcdH1cblx0fVxuXG5cdC8vIFRhcmdldCB3YXNuJ3QgbW91c2Ugb3IgYWJzb2x1dGUuLi5cblx0ZWxzZSB7XG5cdFx0Ly8gQ2hlY2sgaWYgZXZlbnQgdGFyZ2V0dGluZyBpcyBiZWluZyB1c2VkXG5cdFx0aWYodGFyZ2V0ID09PSAnZXZlbnQnKSB7XG5cdFx0XHRpZihldmVudCAmJiBldmVudC50YXJnZXQgJiYgZXZlbnQudHlwZSAhPT0gJ3Njcm9sbCcgJiYgZXZlbnQudHlwZSAhPT0gJ3Jlc2l6ZScpIHtcblx0XHRcdFx0Y2FjaGUudGFyZ2V0ID0gJChldmVudC50YXJnZXQpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZighZXZlbnQudGFyZ2V0KSB7XG5cdFx0XHRcdGNhY2hlLnRhcmdldCA9IHRoaXMuZWxlbWVudHMudGFyZ2V0O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmKHRhcmdldCAhPT0gJ2V2ZW50Jyl7XG5cdFx0XHRjYWNoZS50YXJnZXQgPSAkKHRhcmdldC5qcXVlcnkgPyB0YXJnZXQgOiB0aGlzLmVsZW1lbnRzLnRhcmdldCk7XG5cdFx0fVxuXHRcdHRhcmdldCA9IGNhY2hlLnRhcmdldDtcblxuXHRcdC8vIFBhcnNlIHRoZSB0YXJnZXQgaW50byBhIGpRdWVyeSBvYmplY3QgYW5kIG1ha2Ugc3VyZSB0aGVyZSdzIGFuIGVsZW1lbnQgcHJlc2VudFxuXHRcdHRhcmdldCA9ICQodGFyZ2V0KS5lcSgwKTtcblx0XHRpZih0YXJnZXQubGVuZ3RoID09PSAwKSB7IHJldHVybiB0aGlzOyB9XG5cblx0XHQvLyBDaGVjayBpZiB3aW5kb3cgb3IgZG9jdW1lbnQgaXMgdGhlIHRhcmdldFxuXHRcdGVsc2UgaWYodGFyZ2V0WzBdID09PSBkb2N1bWVudCB8fCB0YXJnZXRbMF0gPT09IHdpbmRvdykge1xuXHRcdFx0dGFyZ2V0V2lkdGggPSBCUk9XU0VSLmlPUyA/IHdpbmRvdy5pbm5lcldpZHRoIDogdGFyZ2V0LndpZHRoKCk7XG5cdFx0XHR0YXJnZXRIZWlnaHQgPSBCUk9XU0VSLmlPUyA/IHdpbmRvdy5pbm5lckhlaWdodCA6IHRhcmdldC5oZWlnaHQoKTtcblxuXHRcdFx0aWYodGFyZ2V0WzBdID09PSB3aW5kb3cpIHtcblx0XHRcdFx0cG9zaXRpb24gPSB7XG5cdFx0XHRcdFx0dG9wOiAodmlld3BvcnQgfHwgdGFyZ2V0KS5zY3JvbGxUb3AoKSxcblx0XHRcdFx0XHRsZWZ0OiAodmlld3BvcnQgfHwgdGFyZ2V0KS5zY3JvbGxMZWZ0KClcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDaGVjayBpZiB0aGUgdGFyZ2V0IGlzIGFuIDxBUkVBPiBlbGVtZW50XG5cdFx0ZWxzZSBpZihQTFVHSU5TLmltYWdlbWFwICYmIHRhcmdldC5pcygnYXJlYScpKSB7XG5cdFx0XHRwbHVnaW5DYWxjdWxhdGlvbnMgPSBQTFVHSU5TLmltYWdlbWFwKHRoaXMsIHRhcmdldCwgYXQsIFBMVUdJTlMudmlld3BvcnQgPyBtZXRob2QgOiBGQUxTRSk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgaWYgdGhlIHRhcmdldCBpcyBhbiBTVkcgZWxlbWVudFxuXHRcdGVsc2UgaWYoUExVR0lOUy5zdmcgJiYgdGFyZ2V0ICYmIHRhcmdldFswXS5vd25lclNWR0VsZW1lbnQpIHtcblx0XHRcdHBsdWdpbkNhbGN1bGF0aW9ucyA9IFBMVUdJTlMuc3ZnKHRoaXMsIHRhcmdldCwgYXQsIFBMVUdJTlMudmlld3BvcnQgPyBtZXRob2QgOiBGQUxTRSk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlIHVzZSByZWd1bGFyIGpRdWVyeSBtZXRob2RzXG5cdFx0ZWxzZSB7XG5cdFx0XHR0YXJnZXRXaWR0aCA9IHRhcmdldC5vdXRlcldpZHRoKEZBTFNFKTtcblx0XHRcdHRhcmdldEhlaWdodCA9IHRhcmdldC5vdXRlckhlaWdodChGQUxTRSk7XG5cdFx0XHRwb3NpdGlvbiA9IHRhcmdldC5vZmZzZXQoKTtcblx0XHR9XG5cblx0XHQvLyBQYXJzZSByZXR1cm5lZCBwbHVnaW4gdmFsdWVzIGludG8gcHJvcGVyIHZhcmlhYmxlc1xuXHRcdGlmKHBsdWdpbkNhbGN1bGF0aW9ucykge1xuXHRcdFx0dGFyZ2V0V2lkdGggPSBwbHVnaW5DYWxjdWxhdGlvbnMud2lkdGg7XG5cdFx0XHR0YXJnZXRIZWlnaHQgPSBwbHVnaW5DYWxjdWxhdGlvbnMuaGVpZ2h0O1xuXHRcdFx0b2Zmc2V0ID0gcGx1Z2luQ2FsY3VsYXRpb25zLm9mZnNldDtcblx0XHRcdHBvc2l0aW9uID0gcGx1Z2luQ2FsY3VsYXRpb25zLnBvc2l0aW9uO1xuXHRcdH1cblxuXHRcdC8vIEFkanVzdCBwb3NpdGlvbiB0byB0YWtlIGludG8gYWNjb3VudCBvZmZzZXQgcGFyZW50c1xuXHRcdHBvc2l0aW9uID0gdGhpcy5yZXBvc2l0aW9uLm9mZnNldCh0YXJnZXQsIHBvc2l0aW9uLCBjb250YWluZXIpO1xuXG5cdFx0Ly8gQWRqdXN0IGZvciBwb3NpdGlvbi5maXhlZCB0b29sdGlwcyAoYW5kIGFsc28gaU9TIHNjcm9sbCBidWcgaW4gdjMuMi00LjAgJiB2NC4zLTQuMy4yKVxuXHRcdGlmKEJST1dTRVIuaU9TID4gMy4xICYmIEJST1dTRVIuaU9TIDwgNC4xIHx8XG5cdFx0XHRCUk9XU0VSLmlPUyA+PSA0LjMgJiYgQlJPV1NFUi5pT1MgPCA0LjMzIHx8XG5cdFx0XHQhQlJPV1NFUi5pT1MgJiYgdHlwZSA9PT0gJ2ZpeGVkJ1xuXHRcdCl7XG5cdFx0XHRwb3NpdGlvbi5sZWZ0IC09IHdpbi5zY3JvbGxMZWZ0KCk7XG5cdFx0XHRwb3NpdGlvbi50b3AgLT0gd2luLnNjcm9sbFRvcCgpO1xuXHRcdH1cblxuXHRcdC8vIEFkanVzdCBwb3NpdGlvbiByZWxhdGl2ZSB0byB0YXJnZXRcblx0XHRpZighcGx1Z2luQ2FsY3VsYXRpb25zIHx8IHBsdWdpbkNhbGN1bGF0aW9ucyAmJiBwbHVnaW5DYWxjdWxhdGlvbnMuYWRqdXN0YWJsZSAhPT0gRkFMU0UpIHtcblx0XHRcdHBvc2l0aW9uLmxlZnQgKz0gYXQueCA9PT0gUklHSFQgPyB0YXJnZXRXaWR0aCA6IGF0LnggPT09IENFTlRFUiA/IHRhcmdldFdpZHRoIC8gMiA6IDA7XG5cdFx0XHRwb3NpdGlvbi50b3AgKz0gYXQueSA9PT0gQk9UVE9NID8gdGFyZ2V0SGVpZ2h0IDogYXQueSA9PT0gQ0VOVEVSID8gdGFyZ2V0SGVpZ2h0IC8gMiA6IDA7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWRqdXN0IHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRvb2x0aXBcblx0cG9zaXRpb24ubGVmdCArPSBhZGp1c3QueCArIChteS54ID09PSBSSUdIVCA/IC10b29sdGlwV2lkdGggOiBteS54ID09PSBDRU5URVIgPyAtdG9vbHRpcFdpZHRoIC8gMiA6IDApO1xuXHRwb3NpdGlvbi50b3AgKz0gYWRqdXN0LnkgKyAobXkueSA9PT0gQk9UVE9NID8gLXRvb2x0aXBIZWlnaHQgOiBteS55ID09PSBDRU5URVIgPyAtdG9vbHRpcEhlaWdodCAvIDIgOiAwKTtcblxuXHQvLyBVc2Ugdmlld3BvcnQgYWRqdXN0bWVudCBwbHVnaW4gaWYgZW5hYmxlZFxuXHRpZihQTFVHSU5TLnZpZXdwb3J0KSB7XG5cdFx0YWRqdXN0ZWQgPSBwb3NpdGlvbi5hZGp1c3RlZCA9IFBMVUdJTlMudmlld3BvcnQoXG5cdFx0XHR0aGlzLCBwb3NpdGlvbiwgcG9zT3B0aW9ucywgdGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCwgdG9vbHRpcFdpZHRoLCB0b29sdGlwSGVpZ2h0XG5cdFx0KTtcblxuXHRcdC8vIEFwcGx5IG9mZnNldHMgc3VwcGxpZWQgYnkgcG9zaXRpb25pbmcgcGx1Z2luIChpZiB1c2VkKVxuXHRcdGlmKG9mZnNldCAmJiBhZGp1c3RlZC5sZWZ0KSB7IHBvc2l0aW9uLmxlZnQgKz0gb2Zmc2V0LmxlZnQ7IH1cblx0XHRpZihvZmZzZXQgJiYgYWRqdXN0ZWQudG9wKSB7ICBwb3NpdGlvbi50b3AgKz0gb2Zmc2V0LnRvcDsgfVxuXG5cdFx0Ly8gQXBwbHkgYW55IG5ldyAnbXknIHBvc2l0aW9uXG5cdFx0aWYoYWRqdXN0ZWQubXkpIHsgdGhpcy5wb3NpdGlvbi5teSA9IGFkanVzdGVkLm15OyB9XG5cdH1cblxuXHQvLyBWaWV3cG9ydCBhZGp1c3RtZW50IGlzIGRpc2FibGVkLCBzZXQgdmFsdWVzIHRvIHplcm9cblx0ZWxzZSB7IHBvc2l0aW9uLmFkanVzdGVkID0geyBsZWZ0OiAwLCB0b3A6IDAgfTsgfVxuXG5cdC8vIFNldCB0b29sdGlwIHBvc2l0aW9uIGNsYXNzIGlmIGl0J3MgY2hhbmdlZFxuXHRpZihjYWNoZS5wb3NDbGFzcyAhPT0gKG5ld0NsYXNzID0gdGhpcy5fY3JlYXRlUG9zQ2xhc3ModGhpcy5wb3NpdGlvbi5teSkpKSB7XG5cdFx0Y2FjaGUucG9zQ2xhc3MgPSBuZXdDbGFzcztcblx0XHR0b29sdGlwLnJlbW92ZUNsYXNzKGNhY2hlLnBvc0NsYXNzKS5hZGRDbGFzcyhuZXdDbGFzcyk7XG5cdH1cblxuXHQvLyB0b29sdGlwbW92ZSBldmVudFxuXHRpZighdGhpcy5fdHJpZ2dlcignbW92ZScsIFtwb3NpdGlvbiwgdmlld3BvcnQuZWxlbSB8fCB2aWV3cG9ydF0sIGV2ZW50KSkgeyByZXR1cm4gdGhpczsgfVxuXHRkZWxldGUgcG9zaXRpb24uYWRqdXN0ZWQ7XG5cblx0Ly8gSWYgZWZmZWN0IGlzIGRpc2FibGVkLCB0YXJnZXQgaXQgbW91c2UsIG5vIGFuaW1hdGlvbiBpcyBkZWZpbmVkIG9yIHBvc2l0aW9uaW5nIGdpdmVzIE5hTiBvdXQsIHNldCBDU1MgZGlyZWN0bHlcblx0aWYoZWZmZWN0ID09PSBGQUxTRSB8fCAhdmlzaWJsZSB8fCBpc05hTihwb3NpdGlvbi5sZWZ0KSB8fCBpc05hTihwb3NpdGlvbi50b3ApIHx8IHRhcmdldCA9PT0gJ21vdXNlJyB8fCAhJC5pc0Z1bmN0aW9uKHBvc09wdGlvbnMuZWZmZWN0KSkge1xuXHRcdHRvb2x0aXAuY3NzKHBvc2l0aW9uKTtcblx0fVxuXG5cdC8vIFVzZSBjdXN0b20gZnVuY3Rpb24gaWYgcHJvdmlkZWRcblx0ZWxzZSBpZigkLmlzRnVuY3Rpb24ocG9zT3B0aW9ucy5lZmZlY3QpKSB7XG5cdFx0cG9zT3B0aW9ucy5lZmZlY3QuY2FsbCh0b29sdGlwLCB0aGlzLCAkLmV4dGVuZCh7fSwgcG9zaXRpb24pKTtcblx0XHR0b29sdGlwLnF1ZXVlKGZ1bmN0aW9uKG5leHQpIHtcblx0XHRcdC8vIFJlc2V0IGF0dHJpYnV0ZXMgdG8gYXZvaWQgY3Jvc3MtYnJvd3NlciByZW5kZXJpbmcgYnVnc1xuXHRcdFx0JCh0aGlzKS5jc3MoeyBvcGFjaXR5OiAnJywgaGVpZ2h0OiAnJyB9KTtcblx0XHRcdGlmKEJST1dTRVIuaWUpIHsgdGhpcy5zdHlsZS5yZW1vdmVBdHRyaWJ1dGUoJ2ZpbHRlcicpOyB9XG5cblx0XHRcdG5leHQoKTtcblx0XHR9KTtcblx0fVxuXG5cdC8vIFNldCBwb3NpdGlvbmluZyBmbGFnXG5cdHRoaXMucG9zaXRpb25pbmcgPSBGQUxTRTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8vIEN1c3RvbSAobW9yZSBjb3JyZWN0IGZvciBxVGlwISkgb2Zmc2V0IGNhbGN1bGF0b3JcblBST1RPVFlQRS5yZXBvc2l0aW9uLm9mZnNldCA9IGZ1bmN0aW9uKGVsZW0sIHBvcywgY29udGFpbmVyKSB7XG5cdGlmKCFjb250YWluZXJbMF0pIHsgcmV0dXJuIHBvczsgfVxuXG5cdHZhciBvd25lckRvY3VtZW50ID0gJChlbGVtWzBdLm93bmVyRG9jdW1lbnQpLFxuXHRcdHF1aXJrcyA9ICEhQlJPV1NFUi5pZSAmJiBkb2N1bWVudC5jb21wYXRNb2RlICE9PSAnQ1NTMUNvbXBhdCcsXG5cdFx0cGFyZW50ID0gY29udGFpbmVyWzBdLFxuXHRcdHNjcm9sbGVkLCBwb3NpdGlvbiwgcGFyZW50T2Zmc2V0LCBvdmVyZmxvdztcblxuXHRmdW5jdGlvbiBzY3JvbGwoZSwgaSkge1xuXHRcdHBvcy5sZWZ0ICs9IGkgKiBlLnNjcm9sbExlZnQoKTtcblx0XHRwb3MudG9wICs9IGkgKiBlLnNjcm9sbFRvcCgpO1xuXHR9XG5cblx0Ly8gQ29tcGVuc2F0ZSBmb3Igbm9uLXN0YXRpYyBjb250YWluZXJzIG9mZnNldFxuXHRkbyB7XG5cdFx0aWYoKHBvc2l0aW9uID0gJC5jc3MocGFyZW50LCAncG9zaXRpb24nKSkgIT09ICdzdGF0aWMnKSB7XG5cdFx0XHRpZihwb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQgPSBwYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0XHRcdHNjcm9sbChvd25lckRvY3VtZW50LCAtMSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0cGFyZW50T2Zmc2V0ID0gJChwYXJlbnQpLnBvc2l0aW9uKCk7XG5cdFx0XHRcdHBhcmVudE9mZnNldC5sZWZ0ICs9IHBhcnNlRmxvYXQoJC5jc3MocGFyZW50LCAnYm9yZGVyTGVmdFdpZHRoJykpIHx8IDA7XG5cdFx0XHRcdHBhcmVudE9mZnNldC50b3AgKz0gcGFyc2VGbG9hdCgkLmNzcyhwYXJlbnQsICdib3JkZXJUb3BXaWR0aCcpKSB8fCAwO1xuXHRcdFx0fVxuXG5cdFx0XHRwb3MubGVmdCAtPSBwYXJlbnRPZmZzZXQubGVmdCArIChwYXJzZUZsb2F0KCQuY3NzKHBhcmVudCwgJ21hcmdpbkxlZnQnKSkgfHwgMCk7XG5cdFx0XHRwb3MudG9wIC09IHBhcmVudE9mZnNldC50b3AgKyAocGFyc2VGbG9hdCgkLmNzcyhwYXJlbnQsICdtYXJnaW5Ub3AnKSkgfHwgMCk7XG5cblx0XHRcdC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IHBhcmVudCBlbGVtZW50IHdpdGggYW4gb3ZlcmZsb3cgb2YgXCJzY3JvbGxcIiBvciBcImF1dG9cIiwgc3RvcmUgaXRcblx0XHRcdGlmKCFzY3JvbGxlZCAmJiAob3ZlcmZsb3cgPSAkLmNzcyhwYXJlbnQsICdvdmVyZmxvdycpKSAhPT0gJ2hpZGRlbicgJiYgb3ZlcmZsb3cgIT09ICd2aXNpYmxlJykgeyBzY3JvbGxlZCA9ICQocGFyZW50KTsgfVxuXHRcdH1cblx0fVxuXHR3aGlsZShwYXJlbnQgPSBwYXJlbnQub2Zmc2V0UGFyZW50KTtcblxuXHQvLyBDb21wZW5zYXRlIGZvciBjb250YWluZXJzIHNjcm9sbCBpZiBpdCBhbHNvIGhhcyBhbiBvZmZzZXRQYXJlbnQgKG9yIGluIElFIHF1aXJrcyBtb2RlKVxuXHRpZihzY3JvbGxlZCAmJiAoc2Nyb2xsZWRbMF0gIT09IG93bmVyRG9jdW1lbnRbMF0gfHwgcXVpcmtzKSkge1xuXHRcdHNjcm9sbChzY3JvbGxlZCwgMSk7XG5cdH1cblxuXHRyZXR1cm4gcG9zO1xufTtcblxuLy8gQ29ybmVyIGNsYXNzXG52YXIgQyA9IChDT1JORVIgPSBQUk9UT1RZUEUucmVwb3NpdGlvbi5Db3JuZXIgPSBmdW5jdGlvbihjb3JuZXIsIGZvcmNlWSkge1xuXHRjb3JuZXIgPSAoJycgKyBjb3JuZXIpLnJlcGxhY2UoLyhbQS1aXSkvLCAnICQxJykucmVwbGFjZSgvbWlkZGxlL2dpLCBDRU5URVIpLnRvTG93ZXJDYXNlKCk7XG5cdHRoaXMueCA9IChjb3JuZXIubWF0Y2goL2xlZnR8cmlnaHQvaSkgfHwgY29ybmVyLm1hdGNoKC9jZW50ZXIvKSB8fCBbJ2luaGVyaXQnXSlbMF0udG9Mb3dlckNhc2UoKTtcblx0dGhpcy55ID0gKGNvcm5lci5tYXRjaCgvdG9wfGJvdHRvbXxjZW50ZXIvaSkgfHwgWydpbmhlcml0J10pWzBdLnRvTG93ZXJDYXNlKCk7XG5cdHRoaXMuZm9yY2VZID0gISFmb3JjZVk7XG5cblx0dmFyIGYgPSBjb3JuZXIuY2hhckF0KDApO1xuXHR0aGlzLnByZWNlZGFuY2UgPSBmID09PSAndCcgfHwgZiA9PT0gJ2InID8gWSA6IFg7XG59KS5wcm90b3R5cGU7XG5cbkMuaW52ZXJ0ID0gZnVuY3Rpb24oeiwgY2VudGVyKSB7XG5cdHRoaXNbel0gPSB0aGlzW3pdID09PSBMRUZUID8gUklHSFQgOiB0aGlzW3pdID09PSBSSUdIVCA/IExFRlQgOiBjZW50ZXIgfHwgdGhpc1t6XTtcbn07XG5cbkMuc3RyaW5nID0gZnVuY3Rpb24oam9pbikge1xuXHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueTtcblxuXHR2YXIgcmVzdWx0ID0geCAhPT0geSA/XG5cdFx0eCA9PT0gJ2NlbnRlcicgfHwgeSAhPT0gJ2NlbnRlcicgJiYgKHRoaXMucHJlY2VkYW5jZSA9PT0gWSB8fCB0aGlzLmZvcmNlWSkgPyBcblx0XHRcdFt5LHhdIDogXG5cdFx0XHRbeCx5XSA6XG5cdFx0W3hdO1xuXG5cdHJldHVybiBqb2luICE9PSBmYWxzZSA/IHJlc3VsdC5qb2luKCcgJykgOiByZXN1bHQ7XG59O1xuXG5DLmFiYnJldiA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgcmVzdWx0ID0gdGhpcy5zdHJpbmcoZmFsc2UpO1xuXHRyZXR1cm4gcmVzdWx0WzBdLmNoYXJBdCgwKSArIChyZXN1bHRbMV0gJiYgcmVzdWx0WzFdLmNoYXJBdCgwKSB8fCAnJyk7XG59O1xuXG5DLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiBuZXcgQ09STkVSKCB0aGlzLnN0cmluZygpLCB0aGlzLmZvcmNlWSApO1xufTtcblxuO1xuUFJPVE9UWVBFLnRvZ2dsZSA9IGZ1bmN0aW9uKHN0YXRlLCBldmVudCkge1xuXHR2YXIgY2FjaGUgPSB0aGlzLmNhY2hlLFxuXHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0dG9vbHRpcCA9IHRoaXMudG9vbHRpcDtcblxuXHQvLyBUcnkgdG8gcHJldmVudCBmbGlja2VyaW5nIHdoZW4gdG9vbHRpcCBvdmVybGFwcyBzaG93IGVsZW1lbnRcblx0aWYoZXZlbnQpIHtcblx0XHRpZigoL292ZXJ8ZW50ZXIvKS50ZXN0KGV2ZW50LnR5cGUpICYmIGNhY2hlLmV2ZW50ICYmICgvb3V0fGxlYXZlLykudGVzdChjYWNoZS5ldmVudC50eXBlKSAmJlxuXHRcdFx0b3B0aW9ucy5zaG93LnRhcmdldC5hZGQoZXZlbnQudGFyZ2V0KS5sZW5ndGggPT09IG9wdGlvbnMuc2hvdy50YXJnZXQubGVuZ3RoICYmXG5cdFx0XHR0b29sdGlwLmhhcyhldmVudC5yZWxhdGVkVGFyZ2V0KS5sZW5ndGgpIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8vIENhY2hlIGV2ZW50XG5cdFx0Y2FjaGUuZXZlbnQgPSAkLmV2ZW50LmZpeChldmVudCk7XG5cdH1cblxuXHQvLyBJZiB3ZSdyZSBjdXJyZW50bHkgd2FpdGluZyBhbmQgd2UndmUganVzdCBoaWRkZW4uLi4gc3RvcCBpdFxuXHR0aGlzLndhaXRpbmcgJiYgIXN0YXRlICYmICh0aGlzLmhpZGRlbkR1cmluZ1dhaXQgPSBUUlVFKTtcblxuXHQvLyBSZW5kZXIgdGhlIHRvb2x0aXAgaWYgc2hvd2luZyBhbmQgaXQgaXNuJ3QgYWxyZWFkeVxuXHRpZighdGhpcy5yZW5kZXJlZCkgeyByZXR1cm4gc3RhdGUgPyB0aGlzLnJlbmRlcigxKSA6IHRoaXM7IH1cblx0ZWxzZSBpZih0aGlzLmRlc3Ryb3llZCB8fCB0aGlzLmRpc2FibGVkKSB7IHJldHVybiB0aGlzOyB9XG5cblx0dmFyIHR5cGUgPSBzdGF0ZSA/ICdzaG93JyA6ICdoaWRlJyxcblx0XHRvcHRzID0gdGhpcy5vcHRpb25zW3R5cGVdLFxuXHRcdHBvc09wdGlvbnMgPSB0aGlzLm9wdGlvbnMucG9zaXRpb24sXG5cdFx0Y29udGVudE9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuY29udGVudCxcblx0XHR3aWR0aCA9IHRoaXMudG9vbHRpcC5jc3MoJ3dpZHRoJyksXG5cdFx0dmlzaWJsZSA9IHRoaXMudG9vbHRpcC5pcygnOnZpc2libGUnKSxcblx0XHRhbmltYXRlID0gc3RhdGUgfHwgb3B0cy50YXJnZXQubGVuZ3RoID09PSAxLFxuXHRcdHNhbWVUYXJnZXQgPSAhZXZlbnQgfHwgb3B0cy50YXJnZXQubGVuZ3RoIDwgMiB8fCBjYWNoZS50YXJnZXRbMF0gPT09IGV2ZW50LnRhcmdldCxcblx0XHRpZGVudGljYWxTdGF0ZSwgYWxsb3csIGFmdGVyO1xuXG5cdC8vIERldGVjdCBzdGF0ZSBpZiB2YWxpZCBvbmUgaXNuJ3QgcHJvdmlkZWRcblx0aWYoKHR5cGVvZiBzdGF0ZSkuc2VhcmNoKCdib29sZWFufG51bWJlcicpKSB7IHN0YXRlID0gIXZpc2libGU7IH1cblxuXHQvLyBDaGVjayBpZiB0aGUgdG9vbHRpcCBpcyBpbiBhbiBpZGVudGljYWwgc3RhdGUgdG8gdGhlIG5ldyB3b3VsZC1iZSBzdGF0ZVxuXHRpZGVudGljYWxTdGF0ZSA9ICF0b29sdGlwLmlzKCc6YW5pbWF0ZWQnKSAmJiB2aXNpYmxlID09PSBzdGF0ZSAmJiBzYW1lVGFyZ2V0O1xuXG5cdC8vIEZpcmUgdG9vbHRpcChzaG93L2hpZGUpIGV2ZW50IGFuZCBjaGVjayBpZiBkZXN0cm95ZWRcblx0YWxsb3cgPSAhaWRlbnRpY2FsU3RhdGUgPyAhIXRoaXMuX3RyaWdnZXIodHlwZSwgWzkwXSkgOiBOVUxMO1xuXG5cdC8vIENoZWNrIHRvIG1ha2Ugc3VyZSB0aGUgdG9vbHRpcCB3YXNuJ3QgZGVzdHJveWVkIGluIHRoZSBjYWxsYmFja1xuXHRpZih0aGlzLmRlc3Ryb3llZCkgeyByZXR1cm4gdGhpczsgfVxuXG5cdC8vIElmIHRoZSB1c2VyIGRpZG4ndCBzdG9wIHRoZSBtZXRob2QgcHJlbWF0dXJlbHkgYW5kIHdlJ3JlIHNob3dpbmcgdGhlIHRvb2x0aXAsIGZvY3VzIGl0XG5cdGlmKGFsbG93ICE9PSBGQUxTRSAmJiBzdGF0ZSkgeyB0aGlzLmZvY3VzKGV2ZW50KTsgfVxuXG5cdC8vIElmIHRoZSBzdGF0ZSBoYXNuJ3QgY2hhbmdlZCBvciB0aGUgdXNlciBzdG9wcGVkIGl0LCByZXR1cm4gZWFybHlcblx0aWYoIWFsbG93IHx8IGlkZW50aWNhbFN0YXRlKSB7IHJldHVybiB0aGlzOyB9XG5cblx0Ly8gU2V0IEFSSUEgaGlkZGVuIGF0dHJpYnV0ZVxuXHQkLmF0dHIodG9vbHRpcFswXSwgJ2FyaWEtaGlkZGVuJywgISEhc3RhdGUpO1xuXG5cdC8vIEV4ZWN1dGUgc3RhdGUgc3BlY2lmaWMgcHJvcGVydGllc1xuXHRpZihzdGF0ZSkge1xuXHRcdC8vIFN0b3JlIHNob3cgb3JpZ2luIGNvb3JkaW5hdGVzXG5cdFx0dGhpcy5tb3VzZSAmJiAoY2FjaGUub3JpZ2luID0gJC5ldmVudC5maXgodGhpcy5tb3VzZSkpO1xuXG5cdFx0Ly8gVXBkYXRlIHRvb2x0aXAgY29udGVudCAmIHRpdGxlIGlmIGl0J3MgYSBkeW5hbWljIGZ1bmN0aW9uXG5cdFx0aWYoJC5pc0Z1bmN0aW9uKGNvbnRlbnRPcHRpb25zLnRleHQpKSB7IHRoaXMuX3VwZGF0ZUNvbnRlbnQoY29udGVudE9wdGlvbnMudGV4dCwgRkFMU0UpOyB9XG5cdFx0aWYoJC5pc0Z1bmN0aW9uKGNvbnRlbnRPcHRpb25zLnRpdGxlKSkgeyB0aGlzLl91cGRhdGVUaXRsZShjb250ZW50T3B0aW9ucy50aXRsZSwgRkFMU0UpOyB9XG5cblx0XHQvLyBDYWNoZSBtb3VzZW1vdmUgZXZlbnRzIGZvciBwb3NpdGlvbmluZyBwdXJwb3NlcyAoaWYgbm90IGFscmVhZHkgdHJhY2tpbmcpXG5cdFx0aWYoIXRyYWNraW5nQm91bmQgJiYgcG9zT3B0aW9ucy50YXJnZXQgPT09ICdtb3VzZScgJiYgcG9zT3B0aW9ucy5hZGp1c3QubW91c2UpIHtcblx0XHRcdCQoZG9jdW1lbnQpLmJpbmQoJ21vdXNlbW92ZS4nK05BTUVTUEFDRSwgdGhpcy5fc3RvcmVNb3VzZSk7XG5cdFx0XHR0cmFja2luZ0JvdW5kID0gVFJVRTtcblx0XHR9XG5cblx0XHQvLyBVcGRhdGUgdGhlIHRvb2x0aXAgcG9zaXRpb24gKHNldCB3aWR0aCBmaXJzdCB0byBwcmV2ZW50IHZpZXdwb3J0L21heC13aWR0aCBpc3N1ZXMpXG5cdFx0aWYoIXdpZHRoKSB7IHRvb2x0aXAuY3NzKCd3aWR0aCcsIHRvb2x0aXAub3V0ZXJXaWR0aChGQUxTRSkpOyB9XG5cdFx0dGhpcy5yZXBvc2l0aW9uKGV2ZW50LCBhcmd1bWVudHNbMl0pO1xuXHRcdGlmKCF3aWR0aCkgeyB0b29sdGlwLmNzcygnd2lkdGgnLCAnJyk7IH1cblxuXHRcdC8vIEhpZGUgb3RoZXIgdG9vbHRpcHMgaWYgdG9vbHRpcCBpcyBzb2xvXG5cdFx0aWYoISFvcHRzLnNvbG8pIHtcblx0XHRcdCh0eXBlb2Ygb3B0cy5zb2xvID09PSAnc3RyaW5nJyA/ICQob3B0cy5zb2xvKSA6ICQoU0VMRUNUT1IsIG9wdHMuc29sbykpXG5cdFx0XHRcdC5ub3QodG9vbHRpcCkubm90KG9wdHMudGFyZ2V0KS5xdGlwKCdoaWRlJywgbmV3ICQuRXZlbnQoJ3Rvb2x0aXBzb2xvJykpO1xuXHRcdH1cblx0fVxuXHRlbHNlIHtcblx0XHQvLyBDbGVhciBzaG93IHRpbWVyIGlmIHdlJ3JlIGhpZGluZ1xuXHRcdGNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5zaG93KTtcblxuXHRcdC8vIFJlbW92ZSBjYWNoZWQgb3JpZ2luIG9uIGhpZGVcblx0XHRkZWxldGUgY2FjaGUub3JpZ2luO1xuXG5cdFx0Ly8gUmVtb3ZlIG1vdXNlIHRyYWNraW5nIGV2ZW50IGlmIG5vdCBuZWVkZWQgKGFsbCB0cmFja2luZyBxVGlwcyBhcmUgaGlkZGVuKVxuXHRcdGlmKHRyYWNraW5nQm91bmQgJiYgISQoU0VMRUNUT1IrJ1t0cmFja2luZz1cInRydWVcIl06dmlzaWJsZScsIG9wdHMuc29sbykubm90KHRvb2x0aXApLmxlbmd0aCkge1xuXHRcdFx0JChkb2N1bWVudCkudW5iaW5kKCdtb3VzZW1vdmUuJytOQU1FU1BBQ0UpO1xuXHRcdFx0dHJhY2tpbmdCb3VuZCA9IEZBTFNFO1xuXHRcdH1cblxuXHRcdC8vIEJsdXIgdGhlIHRvb2x0aXBcblx0XHR0aGlzLmJsdXIoZXZlbnQpO1xuXHR9XG5cblx0Ly8gRGVmaW5lIHBvc3QtYW5pbWF0aW9uLCBzdGF0ZSBzcGVjaWZpYyBwcm9wZXJ0aWVzXG5cdGFmdGVyID0gJC5wcm94eShmdW5jdGlvbigpIHtcblx0XHRpZihzdGF0ZSkge1xuXHRcdFx0Ly8gUHJldmVudCBhbnRpYWxpYXMgZnJvbSBkaXNhcHBlYXJpbmcgaW4gSUUgYnkgcmVtb3ZpbmcgZmlsdGVyXG5cdFx0XHRpZihCUk9XU0VSLmllKSB7IHRvb2x0aXBbMF0uc3R5bGUucmVtb3ZlQXR0cmlidXRlKCdmaWx0ZXInKTsgfVxuXG5cdFx0XHQvLyBSZW1vdmUgb3ZlcmZsb3cgc2V0dGluZyB0byBwcmV2ZW50IHRpcCBidWdzXG5cdFx0XHR0b29sdGlwLmNzcygnb3ZlcmZsb3cnLCAnJyk7XG5cblx0XHRcdC8vIEF1dG9mb2N1cyBlbGVtZW50cyBpZiBlbmFibGVkXG5cdFx0XHRpZignc3RyaW5nJyA9PT0gdHlwZW9mIG9wdHMuYXV0b2ZvY3VzKSB7XG5cdFx0XHRcdCQodGhpcy5vcHRpb25zLnNob3cuYXV0b2ZvY3VzLCB0b29sdGlwKS5mb2N1cygpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBzZXQsIGhpZGUgdG9vbHRpcCB3aGVuIGluYWN0aXZlIGZvciBkZWxheSBwZXJpb2Rcblx0XHRcdHRoaXMub3B0aW9ucy5zaG93LnRhcmdldC50cmlnZ2VyKCdxdGlwLScrdGhpcy5pZCsnLWluYWN0aXZlJyk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gUmVzZXQgQ1NTIHN0YXRlc1xuXHRcdFx0dG9vbHRpcC5jc3Moe1xuXHRcdFx0XHRkaXNwbGF5OiAnJyxcblx0XHRcdFx0dmlzaWJpbGl0eTogJycsXG5cdFx0XHRcdG9wYWNpdHk6ICcnLFxuXHRcdFx0XHRsZWZ0OiAnJyxcblx0XHRcdFx0dG9wOiAnJ1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Ly8gdG9vbHRpcHZpc2libGUvdG9vbHRpcGhpZGRlbiBldmVudHNcblx0XHR0aGlzLl90cmlnZ2VyKHN0YXRlID8gJ3Zpc2libGUnIDogJ2hpZGRlbicpO1xuXHR9LCB0aGlzKTtcblxuXHQvLyBJZiBubyBlZmZlY3QgdHlwZSBpcyBzdXBwbGllZCwgdXNlIGEgc2ltcGxlIHRvZ2dsZVxuXHRpZihvcHRzLmVmZmVjdCA9PT0gRkFMU0UgfHwgYW5pbWF0ZSA9PT0gRkFMU0UpIHtcblx0XHR0b29sdGlwWyB0eXBlIF0oKTtcblx0XHRhZnRlcigpO1xuXHR9XG5cblx0Ly8gVXNlIGN1c3RvbSBmdW5jdGlvbiBpZiBwcm92aWRlZFxuXHRlbHNlIGlmKCQuaXNGdW5jdGlvbihvcHRzLmVmZmVjdCkpIHtcblx0XHR0b29sdGlwLnN0b3AoMSwgMSk7XG5cdFx0b3B0cy5lZmZlY3QuY2FsbCh0b29sdGlwLCB0aGlzKTtcblx0XHR0b29sdGlwLnF1ZXVlKCdmeCcsIGZ1bmN0aW9uKG4pIHtcblx0XHRcdGFmdGVyKCk7IG4oKTtcblx0XHR9KTtcblx0fVxuXG5cdC8vIFVzZSBiYXNpYyBmYWRlIGZ1bmN0aW9uIGJ5IGRlZmF1bHRcblx0ZWxzZSB7IHRvb2x0aXAuZmFkZVRvKDkwLCBzdGF0ZSA/IDEgOiAwLCBhZnRlcik7IH1cblxuXHQvLyBJZiBpbmFjdGl2ZSBoaWRlIG1ldGhvZCBpcyBzZXQsIGFjdGl2ZSBpdFxuXHRpZihzdGF0ZSkgeyBvcHRzLnRhcmdldC50cmlnZ2VyKCdxdGlwLScrdGhpcy5pZCsnLWluYWN0aXZlJyk7IH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblBST1RPVFlQRS5zaG93ID0gZnVuY3Rpb24oZXZlbnQpIHsgcmV0dXJuIHRoaXMudG9nZ2xlKFRSVUUsIGV2ZW50KTsgfTtcblxuUFJPVE9UWVBFLmhpZGUgPSBmdW5jdGlvbihldmVudCkgeyByZXR1cm4gdGhpcy50b2dnbGUoRkFMU0UsIGV2ZW50KTsgfTtcbjtQUk9UT1RZUEUuZm9jdXMgPSBmdW5jdGlvbihldmVudCkge1xuXHRpZighdGhpcy5yZW5kZXJlZCB8fCB0aGlzLmRlc3Ryb3llZCkgeyByZXR1cm4gdGhpczsgfVxuXG5cdHZhciBxdGlwcyA9ICQoU0VMRUNUT1IpLFxuXHRcdHRvb2x0aXAgPSB0aGlzLnRvb2x0aXAsXG5cdFx0Y3VySW5kZXggPSBwYXJzZUludCh0b29sdGlwWzBdLnN0eWxlLnpJbmRleCwgMTApLFxuXHRcdG5ld0luZGV4ID0gUVRJUC56aW5kZXggKyBxdGlwcy5sZW5ndGg7XG5cblx0Ly8gT25seSB1cGRhdGUgdGhlIHotaW5kZXggaWYgaXQgaGFzIGNoYW5nZWQgYW5kIHRvb2x0aXAgaXMgbm90IGFscmVhZHkgZm9jdXNlZFxuXHRpZighdG9vbHRpcC5oYXNDbGFzcyhDTEFTU19GT0NVUykpIHtcblx0XHQvLyB0b29sdGlwZm9jdXMgZXZlbnRcblx0XHRpZih0aGlzLl90cmlnZ2VyKCdmb2N1cycsIFtuZXdJbmRleF0sIGV2ZW50KSkge1xuXHRcdFx0Ly8gT25seSB1cGRhdGUgei1pbmRleCdzIGlmIHRoZXkndmUgY2hhbmdlZFxuXHRcdFx0aWYoY3VySW5kZXggIT09IG5ld0luZGV4KSB7XG5cdFx0XHRcdC8vIFJlZHVjZSBvdXIgei1pbmRleCdzIGFuZCBrZWVwIHRoZW0gcHJvcGVybHkgb3JkZXJlZFxuXHRcdFx0XHRxdGlwcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmKHRoaXMuc3R5bGUuekluZGV4ID4gY3VySW5kZXgpIHtcblx0XHRcdFx0XHRcdHRoaXMuc3R5bGUuekluZGV4ID0gdGhpcy5zdHlsZS56SW5kZXggLSAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gRmlyZSBibHVyIGV2ZW50IGZvciBmb2N1c2VkIHRvb2x0aXBcblx0XHRcdFx0cXRpcHMuZmlsdGVyKCcuJyArIENMQVNTX0ZPQ1VTKS5xdGlwKCdibHVyJywgZXZlbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgdGhlIG5ldyB6LWluZGV4XG5cdFx0XHR0b29sdGlwLmFkZENsYXNzKENMQVNTX0ZPQ1VTKVswXS5zdHlsZS56SW5kZXggPSBuZXdJbmRleDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblBST1RPVFlQRS5ibHVyID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0aWYoIXRoaXMucmVuZGVyZWQgfHwgdGhpcy5kZXN0cm95ZWQpIHsgcmV0dXJuIHRoaXM7IH1cblxuXHQvLyBTZXQgZm9jdXNlZCBzdGF0dXMgdG8gRkFMU0Vcblx0dGhpcy50b29sdGlwLnJlbW92ZUNsYXNzKENMQVNTX0ZPQ1VTKTtcblxuXHQvLyB0b29sdGlwYmx1ciBldmVudFxuXHR0aGlzLl90cmlnZ2VyKCdibHVyJywgWyB0aGlzLnRvb2x0aXAuY3NzKCd6SW5kZXgnKSBdLCBldmVudCk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuO1BST1RPVFlQRS5kaXNhYmxlID0gZnVuY3Rpb24oc3RhdGUpIHtcblx0aWYodGhpcy5kZXN0cm95ZWQpIHsgcmV0dXJuIHRoaXM7IH1cblxuXHQvLyBJZiAndG9nZ2xlJyBpcyBwYXNzZWQsIHRvZ2dsZSB0aGUgY3VycmVudCBzdGF0ZVxuXHRpZihzdGF0ZSA9PT0gJ3RvZ2dsZScpIHtcblx0XHRzdGF0ZSA9ICEodGhpcy5yZW5kZXJlZCA/IHRoaXMudG9vbHRpcC5oYXNDbGFzcyhDTEFTU19ESVNBQkxFRCkgOiB0aGlzLmRpc2FibGVkKTtcblx0fVxuXG5cdC8vIERpc2FibGUgaWYgbm8gc3RhdGUgcGFzc2VkXG5cdGVsc2UgaWYoJ2Jvb2xlYW4nICE9PSB0eXBlb2Ygc3RhdGUpIHtcblx0XHRzdGF0ZSA9IFRSVUU7XG5cdH1cblxuXHRpZih0aGlzLnJlbmRlcmVkKSB7XG5cdFx0dGhpcy50b29sdGlwLnRvZ2dsZUNsYXNzKENMQVNTX0RJU0FCTEVELCBzdGF0ZSlcblx0XHRcdC5hdHRyKCdhcmlhLWRpc2FibGVkJywgc3RhdGUpO1xuXHR9XG5cblx0dGhpcy5kaXNhYmxlZCA9ICEhc3RhdGU7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5QUk9UT1RZUEUuZW5hYmxlID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmRpc2FibGUoRkFMU0UpOyB9O1xuO1BST1RPVFlQRS5fY3JlYXRlQnV0dG9uID0gZnVuY3Rpb24oKVxue1xuXHR2YXIgc2VsZiA9IHRoaXMsXG5cdFx0ZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzLFxuXHRcdHRvb2x0aXAgPSBlbGVtZW50cy50b29sdGlwLFxuXHRcdGJ1dHRvbiA9IHRoaXMub3B0aW9ucy5jb250ZW50LmJ1dHRvbixcblx0XHRpc1N0cmluZyA9IHR5cGVvZiBidXR0b24gPT09ICdzdHJpbmcnLFxuXHRcdGNsb3NlID0gaXNTdHJpbmcgPyBidXR0b24gOiAnQ2xvc2UgdG9vbHRpcCc7XG5cblx0aWYoZWxlbWVudHMuYnV0dG9uKSB7IGVsZW1lbnRzLmJ1dHRvbi5yZW1vdmUoKTsgfVxuXG5cdC8vIFVzZSBjdXN0b20gYnV0dG9uIGlmIG9uZSB3YXMgc3VwcGxpZWQgYnkgdXNlciwgZWxzZSB1c2UgZGVmYXVsdFxuXHRpZihidXR0b24uanF1ZXJ5KSB7XG5cdFx0ZWxlbWVudHMuYnV0dG9uID0gYnV0dG9uO1xuXHR9XG5cdGVsc2Uge1xuXHRcdGVsZW1lbnRzLmJ1dHRvbiA9ICQoJzxhIC8+Jywge1xuXHRcdFx0J2NsYXNzJzogJ3F0aXAtY2xvc2UgJyArICh0aGlzLm9wdGlvbnMuc3R5bGUud2lkZ2V0ID8gJycgOiBOQU1FU1BBQ0UrJy1pY29uJyksXG5cdFx0XHQndGl0bGUnOiBjbG9zZSxcblx0XHRcdCdhcmlhLWxhYmVsJzogY2xvc2Vcblx0XHR9KVxuXHRcdC5wcmVwZW5kKFxuXHRcdFx0JCgnPHNwYW4gLz4nLCB7XG5cdFx0XHRcdCdjbGFzcyc6ICd1aS1pY29uIHVpLWljb24tY2xvc2UnLFxuXHRcdFx0XHQnaHRtbCc6ICcmdGltZXM7J1xuXHRcdFx0fSlcblx0XHQpO1xuXHR9XG5cblx0Ly8gQ3JlYXRlIGJ1dHRvbiBhbmQgc2V0dXAgYXR0cmlidXRlc1xuXHRlbGVtZW50cy5idXR0b24uYXBwZW5kVG8oZWxlbWVudHMudGl0bGViYXIgfHwgdG9vbHRpcClcblx0XHQuYXR0cigncm9sZScsICdidXR0b24nKVxuXHRcdC5jbGljayhmdW5jdGlvbihldmVudCkge1xuXHRcdFx0aWYoIXRvb2x0aXAuaGFzQ2xhc3MoQ0xBU1NfRElTQUJMRUQpKSB7IHNlbGYuaGlkZShldmVudCk7IH1cblx0XHRcdHJldHVybiBGQUxTRTtcblx0XHR9KTtcbn07XG5cblBST1RPVFlQRS5fdXBkYXRlQnV0dG9uID0gZnVuY3Rpb24oYnV0dG9uKVxue1xuXHQvLyBNYWtlIHN1cmUgdG9vbHRpcCBpcyByZW5kZXJlZCBhbmQgaWYgbm90LCByZXR1cm5cblx0aWYoIXRoaXMucmVuZGVyZWQpIHsgcmV0dXJuIEZBTFNFOyB9XG5cblx0dmFyIGVsZW0gPSB0aGlzLmVsZW1lbnRzLmJ1dHRvbjtcblx0aWYoYnV0dG9uKSB7IHRoaXMuX2NyZWF0ZUJ1dHRvbigpOyB9XG5cdGVsc2UgeyBlbGVtLnJlbW92ZSgpOyB9XG59O1xuOy8vIFdpZGdldCBjbGFzcyBjcmVhdG9yXG5mdW5jdGlvbiBjcmVhdGVXaWRnZXRDbGFzcyhjbHMpIHtcblx0cmV0dXJuIFdJREdFVC5jb25jYXQoJycpLmpvaW4oY2xzID8gJy0nK2NscysnICcgOiAnICcpO1xufVxuXG4vLyBXaWRnZXQgY2xhc3Mgc2V0dGVyIG1ldGhvZFxuUFJPVE9UWVBFLl9zZXRXaWRnZXQgPSBmdW5jdGlvbigpXG57XG5cdHZhciBvbiA9IHRoaXMub3B0aW9ucy5zdHlsZS53aWRnZXQsXG5cdFx0ZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzLFxuXHRcdHRvb2x0aXAgPSBlbGVtZW50cy50b29sdGlwLFxuXHRcdGRpc2FibGVkID0gdG9vbHRpcC5oYXNDbGFzcyhDTEFTU19ESVNBQkxFRCk7XG5cblx0dG9vbHRpcC5yZW1vdmVDbGFzcyhDTEFTU19ESVNBQkxFRCk7XG5cdENMQVNTX0RJU0FCTEVEID0gb24gPyAndWktc3RhdGUtZGlzYWJsZWQnIDogJ3F0aXAtZGlzYWJsZWQnO1xuXHR0b29sdGlwLnRvZ2dsZUNsYXNzKENMQVNTX0RJU0FCTEVELCBkaXNhYmxlZCk7XG5cblx0dG9vbHRpcC50b2dnbGVDbGFzcygndWktaGVscGVyLXJlc2V0ICcrY3JlYXRlV2lkZ2V0Q2xhc3MoKSwgb24pLnRvZ2dsZUNsYXNzKENMQVNTX0RFRkFVTFQsIHRoaXMub3B0aW9ucy5zdHlsZS5kZWYgJiYgIW9uKTtcblxuXHRpZihlbGVtZW50cy5jb250ZW50KSB7XG5cdFx0ZWxlbWVudHMuY29udGVudC50b2dnbGVDbGFzcyggY3JlYXRlV2lkZ2V0Q2xhc3MoJ2NvbnRlbnQnKSwgb24pO1xuXHR9XG5cdGlmKGVsZW1lbnRzLnRpdGxlYmFyKSB7XG5cdFx0ZWxlbWVudHMudGl0bGViYXIudG9nZ2xlQ2xhc3MoIGNyZWF0ZVdpZGdldENsYXNzKCdoZWFkZXInKSwgb24pO1xuXHR9XG5cdGlmKGVsZW1lbnRzLmJ1dHRvbikge1xuXHRcdGVsZW1lbnRzLmJ1dHRvbi50b2dnbGVDbGFzcyhOQU1FU1BBQ0UrJy1pY29uJywgIW9uKTtcblx0fVxufTtcbjtmdW5jdGlvbiBkZWxheShjYWxsYmFjaywgZHVyYXRpb24pIHtcblx0Ly8gSWYgdG9vbHRpcCBoYXMgZGlzcGxheWVkLCBzdGFydCBoaWRlIHRpbWVyXG5cdGlmKGR1cmF0aW9uID4gMCkge1xuXHRcdHJldHVybiBzZXRUaW1lb3V0KFxuXHRcdFx0JC5wcm94eShjYWxsYmFjaywgdGhpcyksIGR1cmF0aW9uXG5cdFx0KTtcblx0fVxuXHRlbHNleyBjYWxsYmFjay5jYWxsKHRoaXMpOyB9XG59XG5cbmZ1bmN0aW9uIHNob3dNZXRob2QoZXZlbnQpIHtcblx0aWYodGhpcy50b29sdGlwLmhhc0NsYXNzKENMQVNTX0RJU0FCTEVEKSkgeyByZXR1cm47IH1cblxuXHQvLyBDbGVhciBoaWRlIHRpbWVyc1xuXHRjbGVhclRpbWVvdXQodGhpcy50aW1lcnMuc2hvdyk7XG5cdGNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5oaWRlKTtcblxuXHQvLyBTdGFydCBzaG93IHRpbWVyXG5cdHRoaXMudGltZXJzLnNob3cgPSBkZWxheS5jYWxsKHRoaXMsXG5cdFx0ZnVuY3Rpb24oKSB7IHRoaXMudG9nZ2xlKFRSVUUsIGV2ZW50KTsgfSxcblx0XHR0aGlzLm9wdGlvbnMuc2hvdy5kZWxheVxuXHQpO1xufVxuXG5mdW5jdGlvbiBoaWRlTWV0aG9kKGV2ZW50KSB7XG5cdGlmKHRoaXMudG9vbHRpcC5oYXNDbGFzcyhDTEFTU19ESVNBQkxFRCkgfHwgdGhpcy5kZXN0cm95ZWQpIHsgcmV0dXJuOyB9XG5cblx0Ly8gQ2hlY2sgaWYgbmV3IHRhcmdldCB3YXMgYWN0dWFsbHkgdGhlIHRvb2x0aXAgZWxlbWVudFxuXHR2YXIgcmVsYXRlZFRhcmdldCA9ICQoZXZlbnQucmVsYXRlZFRhcmdldCksXG5cdFx0b250b1Rvb2x0aXAgPSByZWxhdGVkVGFyZ2V0LmNsb3Nlc3QoU0VMRUNUT1IpWzBdID09PSB0aGlzLnRvb2x0aXBbMF0sXG5cdFx0b250b1RhcmdldCA9IHJlbGF0ZWRUYXJnZXRbMF0gPT09IHRoaXMub3B0aW9ucy5zaG93LnRhcmdldFswXTtcblxuXHQvLyBDbGVhciB0aW1lcnMgYW5kIHN0b3AgYW5pbWF0aW9uIHF1ZXVlXG5cdGNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5zaG93KTtcblx0Y2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLmhpZGUpO1xuXG5cdC8vIFByZXZlbnQgaGlkaW5nIGlmIHRvb2x0aXAgaXMgZml4ZWQgYW5kIGV2ZW50IHRhcmdldCBpcyB0aGUgdG9vbHRpcC5cblx0Ly8gT3IgaWYgbW91c2UgcG9zaXRpb25pbmcgaXMgZW5hYmxlZCBhbmQgY3Vyc29yIG1vbWVudGFyaWx5IG92ZXJsYXBzXG5cdGlmKHRoaXMgIT09IHJlbGF0ZWRUYXJnZXRbMF0gJiZcblx0XHQodGhpcy5vcHRpb25zLnBvc2l0aW9uLnRhcmdldCA9PT0gJ21vdXNlJyAmJiBvbnRvVG9vbHRpcCkgfHxcblx0XHR0aGlzLm9wdGlvbnMuaGlkZS5maXhlZCAmJiAoXG5cdFx0XHQoL21vdXNlKG91dHxsZWF2ZXxtb3ZlKS8pLnRlc3QoZXZlbnQudHlwZSkgJiYgKG9udG9Ub29sdGlwIHx8IG9udG9UYXJnZXQpKVxuXHRcdClcblx0e1xuXHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWVtcHR5ICovXG5cdFx0dHJ5IHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHR9IGNhdGNoKGUpIHt9XG5cdFx0LyogZXNsaW50LWVuYWJsZSBuby1lbXB0eSAqL1xuXG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gSWYgdG9vbHRpcCBoYXMgZGlzcGxheWVkLCBzdGFydCBoaWRlIHRpbWVyXG5cdHRoaXMudGltZXJzLmhpZGUgPSBkZWxheS5jYWxsKHRoaXMsXG5cdFx0ZnVuY3Rpb24oKSB7IHRoaXMudG9nZ2xlKEZBTFNFLCBldmVudCk7IH0sXG5cdFx0dGhpcy5vcHRpb25zLmhpZGUuZGVsYXksXG5cdFx0dGhpc1xuXHQpO1xufVxuXG5mdW5jdGlvbiBpbmFjdGl2ZU1ldGhvZChldmVudCkge1xuXHRpZih0aGlzLnRvb2x0aXAuaGFzQ2xhc3MoQ0xBU1NfRElTQUJMRUQpIHx8ICF0aGlzLm9wdGlvbnMuaGlkZS5pbmFjdGl2ZSkgeyByZXR1cm47IH1cblxuXHQvLyBDbGVhciB0aW1lclxuXHRjbGVhclRpbWVvdXQodGhpcy50aW1lcnMuaW5hY3RpdmUpO1xuXG5cdHRoaXMudGltZXJzLmluYWN0aXZlID0gZGVsYXkuY2FsbCh0aGlzLFxuXHRcdGZ1bmN0aW9uKCl7IHRoaXMuaGlkZShldmVudCk7IH0sXG5cdFx0dGhpcy5vcHRpb25zLmhpZGUuaW5hY3RpdmVcblx0KTtcbn1cblxuZnVuY3Rpb24gcmVwb3NpdGlvbk1ldGhvZChldmVudCkge1xuXHRpZih0aGlzLnJlbmRlcmVkICYmIHRoaXMudG9vbHRpcFswXS5vZmZzZXRXaWR0aCA+IDApIHsgdGhpcy5yZXBvc2l0aW9uKGV2ZW50KTsgfVxufVxuXG4vLyBTdG9yZSBtb3VzZSBjb29yZGluYXRlc1xuUFJPVE9UWVBFLl9zdG9yZU1vdXNlID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0KHRoaXMubW91c2UgPSAkLmV2ZW50LmZpeChldmVudCkpLnR5cGUgPSAnbW91c2Vtb3ZlJztcblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vLyBCaW5kIGV2ZW50c1xuUFJPVE9UWVBFLl9iaW5kID0gZnVuY3Rpb24odGFyZ2V0cywgZXZlbnRzLCBtZXRob2QsIHN1ZmZpeCwgY29udGV4dCkge1xuXHRpZighdGFyZ2V0cyB8fCAhbWV0aG9kIHx8ICFldmVudHMubGVuZ3RoKSB7IHJldHVybjsgfVxuXHR2YXIgbnMgPSAnLicgKyB0aGlzLl9pZCArIChzdWZmaXggPyAnLScrc3VmZml4IDogJycpO1xuXHQkKHRhcmdldHMpLmJpbmQoXG5cdFx0KGV2ZW50cy5zcGxpdCA/IGV2ZW50cyA6IGV2ZW50cy5qb2luKG5zICsgJyAnKSkgKyBucyxcblx0XHQkLnByb3h5KG1ldGhvZCwgY29udGV4dCB8fCB0aGlzKVxuXHQpO1xuXHRyZXR1cm4gdGhpcztcbn07XG5QUk9UT1RZUEUuX3VuYmluZCA9IGZ1bmN0aW9uKHRhcmdldHMsIHN1ZmZpeCkge1xuXHR0YXJnZXRzICYmICQodGFyZ2V0cykudW5iaW5kKCcuJyArIHRoaXMuX2lkICsgKHN1ZmZpeCA/ICctJytzdWZmaXggOiAnJykpO1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8vIEdsb2JhbCBkZWxlZ2F0aW9uIGhlbHBlclxuZnVuY3Rpb24gZGVsZWdhdGUoc2VsZWN0b3IsIGV2ZW50cywgbWV0aG9kKSB7XG5cdCQoZG9jdW1lbnQuYm9keSkuZGVsZWdhdGUoc2VsZWN0b3IsXG5cdFx0KGV2ZW50cy5zcGxpdCA/IGV2ZW50cyA6IGV2ZW50cy5qb2luKCcuJytOQU1FU1BBQ0UgKyAnICcpKSArICcuJytOQU1FU1BBQ0UsXG5cdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgYXBpID0gUVRJUC5hcGlbICQuYXR0cih0aGlzLCBBVFRSX0lEKSBdO1xuXHRcdFx0YXBpICYmICFhcGkuZGlzYWJsZWQgJiYgbWV0aG9kLmFwcGx5KGFwaSwgYXJndW1lbnRzKTtcblx0XHR9XG5cdCk7XG59XG4vLyBFdmVudCB0cmlnZ2VyXG5QUk9UT1RZUEUuX3RyaWdnZXIgPSBmdW5jdGlvbih0eXBlLCBhcmdzLCBldmVudCkge1xuXHR2YXIgY2FsbGJhY2sgPSBuZXcgJC5FdmVudCgndG9vbHRpcCcrdHlwZSk7XG5cdGNhbGxiYWNrLm9yaWdpbmFsRXZlbnQgPSBldmVudCAmJiAkLmV4dGVuZCh7fSwgZXZlbnQpIHx8IHRoaXMuY2FjaGUuZXZlbnQgfHwgTlVMTDtcblxuXHR0aGlzLnRyaWdnZXJpbmcgPSB0eXBlO1xuXHR0aGlzLnRvb2x0aXAudHJpZ2dlcihjYWxsYmFjaywgW3RoaXNdLmNvbmNhdChhcmdzIHx8IFtdKSk7XG5cdHRoaXMudHJpZ2dlcmluZyA9IEZBTFNFO1xuXG5cdHJldHVybiAhY2FsbGJhY2suaXNEZWZhdWx0UHJldmVudGVkKCk7XG59O1xuXG5QUk9UT1RZUEUuX2JpbmRFdmVudHMgPSBmdW5jdGlvbihzaG93RXZlbnRzLCBoaWRlRXZlbnRzLCBzaG93VGFyZ2V0cywgaGlkZVRhcmdldHMsIHNob3dDYWxsYmFjaywgaGlkZUNhbGxiYWNrKSB7XG5cdC8vIEdldCB0YXNyZ2V0cyB0aGF0IGx5ZSB3aXRoaW4gYm90aFxuXHR2YXIgc2ltaWxhclRhcmdldHMgPSBzaG93VGFyZ2V0cy5maWx0ZXIoIGhpZGVUYXJnZXRzICkuYWRkKCBoaWRlVGFyZ2V0cy5maWx0ZXIoc2hvd1RhcmdldHMpICksXG5cdFx0dG9nZ2xlRXZlbnRzID0gW107XG5cblx0Ly8gSWYgaGlkZSBhbmQgc2hvdyB0YXJnZXRzIGFyZSB0aGUgc2FtZS4uLlxuXHRpZihzaW1pbGFyVGFyZ2V0cy5sZW5ndGgpIHtcblxuXHRcdC8vIEZpbHRlciBpZGVudGljYWwgc2hvdy9oaWRlIGV2ZW50c1xuXHRcdCQuZWFjaChoaWRlRXZlbnRzLCBmdW5jdGlvbihpLCB0eXBlKSB7XG5cdFx0XHR2YXIgc2hvd0luZGV4ID0gJC5pbkFycmF5KHR5cGUsIHNob3dFdmVudHMpO1xuXG5cdFx0XHQvLyBCb3RoIGV2ZW50cyBhcmUgaWRlbnRpY2FsLCByZW1vdmUgZnJvbSBib3RoIGhpZGUgYW5kIHNob3cgZXZlbnRzXG5cdFx0XHQvLyBhbmQgYXBwZW5kIHRvIHRvZ2dsZUV2ZW50c1xuXHRcdFx0c2hvd0luZGV4ID4gLTEgJiYgdG9nZ2xlRXZlbnRzLnB1c2goIHNob3dFdmVudHMuc3BsaWNlKCBzaG93SW5kZXgsIDEgKVswXSApO1xuXHRcdH0pO1xuXG5cdFx0Ly8gVG9nZ2xlIGV2ZW50cyBhcmUgc3BlY2lhbCBjYXNlIG9mIGlkZW50aWNhbCBzaG93L2hpZGUgZXZlbnRzLCB3aGljaCBoYXBwZW4gaW4gc2VxdWVuY2Vcblx0XHRpZih0b2dnbGVFdmVudHMubGVuZ3RoKSB7XG5cdFx0XHQvLyBCaW5kIHRvZ2dsZSBldmVudHMgdG8gdGhlIHNpbWlsYXIgdGFyZ2V0c1xuXHRcdFx0dGhpcy5fYmluZChzaW1pbGFyVGFyZ2V0cywgdG9nZ2xlRXZlbnRzLCBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHR2YXIgc3RhdGUgPSB0aGlzLnJlbmRlcmVkID8gdGhpcy50b29sdGlwWzBdLm9mZnNldFdpZHRoID4gMCA6IGZhbHNlO1xuXHRcdFx0XHQoc3RhdGUgPyBoaWRlQ2FsbGJhY2sgOiBzaG93Q2FsbGJhY2spLmNhbGwodGhpcywgZXZlbnQpO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIFJlbW92ZSB0aGUgc2ltaWxhciB0YXJnZXRzIGZyb20gdGhlIHJlZ3VsYXIgc2hvdy9oaWRlIGJpbmRpbmdzXG5cdFx0XHRzaG93VGFyZ2V0cyA9IHNob3dUYXJnZXRzLm5vdChzaW1pbGFyVGFyZ2V0cyk7XG5cdFx0XHRoaWRlVGFyZ2V0cyA9IGhpZGVUYXJnZXRzLm5vdChzaW1pbGFyVGFyZ2V0cyk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQXBwbHkgc2hvdy9oaWRlL3RvZ2dsZSBldmVudHNcblx0dGhpcy5fYmluZChzaG93VGFyZ2V0cywgc2hvd0V2ZW50cywgc2hvd0NhbGxiYWNrKTtcblx0dGhpcy5fYmluZChoaWRlVGFyZ2V0cywgaGlkZUV2ZW50cywgaGlkZUNhbGxiYWNrKTtcbn07XG5cblBST1RPVFlQRS5fYXNzaWduSW5pdGlhbEV2ZW50cyA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdHNob3dUYXJnZXQgPSBvcHRpb25zLnNob3cudGFyZ2V0LFxuXHRcdGhpZGVUYXJnZXQgPSBvcHRpb25zLmhpZGUudGFyZ2V0LFxuXHRcdHNob3dFdmVudHMgPSBvcHRpb25zLnNob3cuZXZlbnQgPyAkLnRyaW0oJycgKyBvcHRpb25zLnNob3cuZXZlbnQpLnNwbGl0KCcgJykgOiBbXSxcblx0XHRoaWRlRXZlbnRzID0gb3B0aW9ucy5oaWRlLmV2ZW50ID8gJC50cmltKCcnICsgb3B0aW9ucy5oaWRlLmV2ZW50KS5zcGxpdCgnICcpIDogW107XG5cblx0Ly8gQ2F0Y2ggcmVtb3ZlL3JlbW92ZXF0aXAgZXZlbnRzIG9uIHRhcmdldCBlbGVtZW50IHRvIGRlc3Ryb3kgcmVkdW5kYW50IHRvb2x0aXBzXG5cdHRoaXMuX2JpbmQodGhpcy5lbGVtZW50cy50YXJnZXQsIFsncmVtb3ZlJywgJ3JlbW92ZXF0aXAnXSwgZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5kZXN0cm95KHRydWUpO1xuXHR9LCAnZGVzdHJveScpO1xuXG5cdC8qXG5cdCAqIE1ha2Ugc3VyZSBob3ZlckludGVudCBmdW5jdGlvbnMgcHJvcGVybHkgYnkgdXNpbmcgbW91c2VsZWF2ZSBhcyBhIGhpZGUgZXZlbnQgaWZcblx0ICogbW91c2VlbnRlci9tb3VzZW91dCBpcyB1c2VkIGZvciBzaG93LmV2ZW50LCBldmVuIGlmIGl0IGlzbid0IGluIHRoZSB1c2VycyBvcHRpb25zLlxuXHQgKi9cblx0aWYoL21vdXNlKG92ZXJ8ZW50ZXIpL2kudGVzdChvcHRpb25zLnNob3cuZXZlbnQpICYmICEvbW91c2Uob3V0fGxlYXZlKS9pLnRlc3Qob3B0aW9ucy5oaWRlLmV2ZW50KSkge1xuXHRcdGhpZGVFdmVudHMucHVzaCgnbW91c2VsZWF2ZScpO1xuXHR9XG5cblx0Lypcblx0ICogQWxzbyBtYWtlIHN1cmUgaW5pdGlhbCBtb3VzZSB0YXJnZXR0aW5nIHdvcmtzIGNvcnJlY3RseSBieSBjYWNoaW5nIG1vdXNlbW92ZSBjb29yZHNcblx0ICogb24gc2hvdyB0YXJnZXRzIGJlZm9yZSB0aGUgdG9vbHRpcCBoYXMgcmVuZGVyZWQuIEFsc28gc2V0IG9uVGFyZ2V0IHdoZW4gdHJpZ2dlcmVkIHRvXG5cdCAqIGtlZXAgbW91c2UgdHJhY2tpbmcgd29ya2luZy5cblx0ICovXG5cdHRoaXMuX2JpbmQoc2hvd1RhcmdldCwgJ21vdXNlbW92ZScsIGZ1bmN0aW9uKG1vdmVFdmVudCkge1xuXHRcdHRoaXMuX3N0b3JlTW91c2UobW92ZUV2ZW50KTtcblx0XHR0aGlzLmNhY2hlLm9uVGFyZ2V0ID0gVFJVRTtcblx0fSk7XG5cblx0Ly8gRGVmaW5lIGhvdmVySW50ZW50IGZ1bmN0aW9uXG5cdGZ1bmN0aW9uIGhvdmVySW50ZW50KGhvdmVyRXZlbnQpIHtcblx0XHQvLyBPbmx5IGNvbnRpbnVlIGlmIHRvb2x0aXAgaXNuJ3QgZGlzYWJsZWRcblx0XHRpZih0aGlzLmRpc2FibGVkIHx8IHRoaXMuZGVzdHJveWVkKSB7IHJldHVybiBGQUxTRTsgfVxuXG5cdFx0Ly8gQ2FjaGUgdGhlIGV2ZW50IGRhdGFcblx0XHR0aGlzLmNhY2hlLmV2ZW50ID0gaG92ZXJFdmVudCAmJiAkLmV2ZW50LmZpeChob3ZlckV2ZW50KTtcblx0XHR0aGlzLmNhY2hlLnRhcmdldCA9IGhvdmVyRXZlbnQgJiYgJChob3ZlckV2ZW50LnRhcmdldCk7XG5cblx0XHQvLyBTdGFydCB0aGUgZXZlbnQgc2VxdWVuY2Vcblx0XHRjbGVhclRpbWVvdXQodGhpcy50aW1lcnMuc2hvdyk7XG5cdFx0dGhpcy50aW1lcnMuc2hvdyA9IGRlbGF5LmNhbGwodGhpcyxcblx0XHRcdGZ1bmN0aW9uKCkgeyB0aGlzLnJlbmRlcih0eXBlb2YgaG92ZXJFdmVudCA9PT0gJ29iamVjdCcgfHwgb3B0aW9ucy5zaG93LnJlYWR5KTsgfSxcblx0XHRcdG9wdGlvbnMucHJlcmVuZGVyID8gMCA6IG9wdGlvbnMuc2hvdy5kZWxheVxuXHRcdCk7XG5cdH1cblxuXHQvLyBGaWx0ZXIgYW5kIGJpbmQgZXZlbnRzXG5cdHRoaXMuX2JpbmRFdmVudHMoc2hvd0V2ZW50cywgaGlkZUV2ZW50cywgc2hvd1RhcmdldCwgaGlkZVRhcmdldCwgaG92ZXJJbnRlbnQsIGZ1bmN0aW9uKCkge1xuXHRcdGlmKCF0aGlzLnRpbWVycykgeyByZXR1cm4gRkFMU0U7IH1cblx0XHRjbGVhclRpbWVvdXQodGhpcy50aW1lcnMuc2hvdyk7XG5cdH0pO1xuXG5cdC8vIFByZXJlbmRlcmluZyBpcyBlbmFibGVkLCBjcmVhdGUgdG9vbHRpcCBub3dcblx0aWYob3B0aW9ucy5zaG93LnJlYWR5IHx8IG9wdGlvbnMucHJlcmVuZGVyKSB7IGhvdmVySW50ZW50LmNhbGwodGhpcywgZXZlbnQpOyB9XG59O1xuXG4vLyBFdmVudCBhc3NpZ25tZW50IG1ldGhvZFxuUFJPVE9UWVBFLl9hc3NpZ25FdmVudHMgPSBmdW5jdGlvbigpIHtcblx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0cG9zT3B0aW9ucyA9IG9wdGlvbnMucG9zaXRpb24sXG5cblx0XHR0b29sdGlwID0gdGhpcy50b29sdGlwLFxuXHRcdHNob3dUYXJnZXQgPSBvcHRpb25zLnNob3cudGFyZ2V0LFxuXHRcdGhpZGVUYXJnZXQgPSBvcHRpb25zLmhpZGUudGFyZ2V0LFxuXHRcdGNvbnRhaW5lclRhcmdldCA9IHBvc09wdGlvbnMuY29udGFpbmVyLFxuXHRcdHZpZXdwb3J0VGFyZ2V0ID0gcG9zT3B0aW9ucy52aWV3cG9ydCxcblx0XHRkb2N1bWVudFRhcmdldCA9ICQoZG9jdW1lbnQpLFxuXHRcdHdpbmRvd1RhcmdldCA9ICQod2luZG93KSxcblxuXHRcdHNob3dFdmVudHMgPSBvcHRpb25zLnNob3cuZXZlbnQgPyAkLnRyaW0oJycgKyBvcHRpb25zLnNob3cuZXZlbnQpLnNwbGl0KCcgJykgOiBbXSxcblx0XHRoaWRlRXZlbnRzID0gb3B0aW9ucy5oaWRlLmV2ZW50ID8gJC50cmltKCcnICsgb3B0aW9ucy5oaWRlLmV2ZW50KS5zcGxpdCgnICcpIDogW107XG5cblxuXHQvLyBBc3NpZ24gcGFzc2VkIGV2ZW50IGNhbGxiYWNrc1xuXHQkLmVhY2gob3B0aW9ucy5ldmVudHMsIGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrKSB7XG5cdFx0c2VsZi5fYmluZCh0b29sdGlwLCBuYW1lID09PSAndG9nZ2xlJyA/IFsndG9vbHRpcHNob3cnLCd0b29sdGlwaGlkZSddIDogWyd0b29sdGlwJytuYW1lXSwgY2FsbGJhY2ssIG51bGwsIHRvb2x0aXApO1xuXHR9KTtcblxuXHQvLyBIaWRlIHRvb2x0aXBzIHdoZW4gbGVhdmluZyBjdXJyZW50IHdpbmRvdy9mcmFtZSAoYnV0IG5vdCBzZWxlY3Qvb3B0aW9uIGVsZW1lbnRzKVxuXHRpZigvbW91c2Uob3V0fGxlYXZlKS9pLnRlc3Qob3B0aW9ucy5oaWRlLmV2ZW50KSAmJiBvcHRpb25zLmhpZGUubGVhdmUgPT09ICd3aW5kb3cnKSB7XG5cdFx0dGhpcy5fYmluZChkb2N1bWVudFRhcmdldCwgWydtb3VzZW91dCcsICdibHVyJ10sIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRpZighL3NlbGVjdHxvcHRpb24vLnRlc3QoZXZlbnQudGFyZ2V0Lm5vZGVOYW1lKSAmJiAhZXZlbnQucmVsYXRlZFRhcmdldCkge1xuXHRcdFx0XHR0aGlzLmhpZGUoZXZlbnQpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0Ly8gRW5hYmxlIGhpZGUuZml4ZWQgYnkgYWRkaW5nIGFwcHJvcHJpYXRlIGNsYXNzXG5cdGlmKG9wdGlvbnMuaGlkZS5maXhlZCkge1xuXHRcdGhpZGVUYXJnZXQgPSBoaWRlVGFyZ2V0LmFkZCggdG9vbHRpcC5hZGRDbGFzcyhDTEFTU19GSVhFRCkgKTtcblx0fVxuXG5cdC8qXG5cdCAqIE1ha2Ugc3VyZSBob3ZlckludGVudCBmdW5jdGlvbnMgcHJvcGVybHkgYnkgdXNpbmcgbW91c2VsZWF2ZSB0byBjbGVhciBzaG93IHRpbWVyIGlmXG5cdCAqIG1vdXNlZW50ZXIvbW91c2VvdXQgaXMgdXNlZCBmb3Igc2hvdy5ldmVudCwgZXZlbiBpZiBpdCBpc24ndCBpbiB0aGUgdXNlcnMgb3B0aW9ucy5cblx0ICovXG5cdGVsc2UgaWYoL21vdXNlKG92ZXJ8ZW50ZXIpL2kudGVzdChvcHRpb25zLnNob3cuZXZlbnQpKSB7XG5cdFx0dGhpcy5fYmluZChoaWRlVGFyZ2V0LCAnbW91c2VsZWF2ZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLnNob3cpO1xuXHRcdH0pO1xuXHR9XG5cblx0Ly8gSGlkZSB0b29sdGlwIG9uIGRvY3VtZW50IG1vdXNlZG93biBpZiB1bmZvY3VzIGV2ZW50cyBhcmUgZW5hYmxlZFxuXHRpZigoJycgKyBvcHRpb25zLmhpZGUuZXZlbnQpLmluZGV4T2YoJ3VuZm9jdXMnKSA+IC0xKSB7XG5cdFx0dGhpcy5fYmluZChjb250YWluZXJUYXJnZXQuY2xvc2VzdCgnaHRtbCcpLCBbJ21vdXNlZG93bicsICd0b3VjaHN0YXJ0J10sIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHR2YXIgZWxlbSA9ICQoZXZlbnQudGFyZ2V0KSxcblx0XHRcdFx0ZW5hYmxlZCA9IHRoaXMucmVuZGVyZWQgJiYgIXRoaXMudG9vbHRpcC5oYXNDbGFzcyhDTEFTU19ESVNBQkxFRCkgJiYgdGhpcy50b29sdGlwWzBdLm9mZnNldFdpZHRoID4gMCxcblx0XHRcdFx0aXNBbmNlc3RvciA9IGVsZW0ucGFyZW50cyhTRUxFQ1RPUikuZmlsdGVyKHRoaXMudG9vbHRpcFswXSkubGVuZ3RoID4gMDtcblxuXHRcdFx0aWYoZWxlbVswXSAhPT0gdGhpcy50YXJnZXRbMF0gJiYgZWxlbVswXSAhPT0gdGhpcy50b29sdGlwWzBdICYmICFpc0FuY2VzdG9yICYmXG5cdFx0XHRcdCF0aGlzLnRhcmdldC5oYXMoZWxlbVswXSkubGVuZ3RoICYmIGVuYWJsZWRcblx0XHRcdCkge1xuXHRcdFx0XHR0aGlzLmhpZGUoZXZlbnQpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgdGhlIHRvb2x0aXAgaGlkZXMgd2hlbiBpbmFjdGl2ZVxuXHRpZignbnVtYmVyJyA9PT0gdHlwZW9mIG9wdGlvbnMuaGlkZS5pbmFjdGl2ZSkge1xuXHRcdC8vIEJpbmQgaW5hY3RpdmUgbWV0aG9kIHRvIHNob3cgdGFyZ2V0KHMpIGFzIGEgY3VzdG9tIGV2ZW50XG5cdFx0dGhpcy5fYmluZChzaG93VGFyZ2V0LCAncXRpcC0nK3RoaXMuaWQrJy1pbmFjdGl2ZScsIGluYWN0aXZlTWV0aG9kLCAnaW5hY3RpdmUnKTtcblxuXHRcdC8vIERlZmluZSBldmVudHMgd2hpY2ggcmVzZXQgdGhlICdpbmFjdGl2ZScgZXZlbnQgaGFuZGxlclxuXHRcdHRoaXMuX2JpbmQoaGlkZVRhcmdldC5hZGQodG9vbHRpcCksIFFUSVAuaW5hY3RpdmVFdmVudHMsIGluYWN0aXZlTWV0aG9kKTtcblx0fVxuXG5cdC8vIEZpbHRlciBhbmQgYmluZCBldmVudHNcblx0dGhpcy5fYmluZEV2ZW50cyhzaG93RXZlbnRzLCBoaWRlRXZlbnRzLCBzaG93VGFyZ2V0LCBoaWRlVGFyZ2V0LCBzaG93TWV0aG9kLCBoaWRlTWV0aG9kKTtcblxuXHQvLyBNb3VzZSBtb3ZlbWVudCBiaW5kaW5nc1xuXHR0aGlzLl9iaW5kKHNob3dUYXJnZXQuYWRkKHRvb2x0aXApLCAnbW91c2Vtb3ZlJywgZnVuY3Rpb24oZXZlbnQpIHtcblx0XHQvLyBDaGVjayBpZiB0aGUgdG9vbHRpcCBoaWRlcyB3aGVuIG1vdXNlIGlzIG1vdmVkIGEgY2VydGFpbiBkaXN0YW5jZVxuXHRcdGlmKCdudW1iZXInID09PSB0eXBlb2Ygb3B0aW9ucy5oaWRlLmRpc3RhbmNlKSB7XG5cdFx0XHR2YXIgb3JpZ2luID0gdGhpcy5jYWNoZS5vcmlnaW4gfHwge30sXG5cdFx0XHRcdGxpbWl0ID0gdGhpcy5vcHRpb25zLmhpZGUuZGlzdGFuY2UsXG5cdFx0XHRcdGFicyA9IE1hdGguYWJzO1xuXG5cdFx0XHQvLyBDaGVjayBpZiB0aGUgbW92ZW1lbnQgaGFzIGdvbmUgYmV5b25kIHRoZSBsaW1pdCwgYW5kIGhpZGUgaXQgaWYgc29cblx0XHRcdGlmKGFicyhldmVudC5wYWdlWCAtIG9yaWdpbi5wYWdlWCkgPj0gbGltaXQgfHwgYWJzKGV2ZW50LnBhZ2VZIC0gb3JpZ2luLnBhZ2VZKSA+PSBsaW1pdCkge1xuXHRcdFx0XHR0aGlzLmhpZGUoZXZlbnQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhY2hlIG1vdXNlbW92ZSBjb29yZHMgb24gc2hvdyB0YXJnZXRzXG5cdFx0dGhpcy5fc3RvcmVNb3VzZShldmVudCk7XG5cdH0pO1xuXG5cdC8vIE1vdXNlIHBvc2l0aW9uaW5nIGV2ZW50c1xuXHRpZihwb3NPcHRpb25zLnRhcmdldCA9PT0gJ21vdXNlJykge1xuXHRcdC8vIElmIG1vdXNlIGFkanVzdG1lbnQgaXMgb24uLi5cblx0XHRpZihwb3NPcHRpb25zLmFkanVzdC5tb3VzZSkge1xuXHRcdFx0Ly8gQXBwbHkgYSBtb3VzZWxlYXZlIGV2ZW50IHNvIHdlIGRvbid0IGdldCBwcm9ibGVtcyB3aXRoIG92ZXJsYXBwaW5nXG5cdFx0XHRpZihvcHRpb25zLmhpZGUuZXZlbnQpIHtcblx0XHRcdFx0Ly8gVHJhY2sgaWYgd2UncmUgb24gdGhlIHRhcmdldCBvciBub3Rcblx0XHRcdFx0dGhpcy5fYmluZChzaG93VGFyZ2V0LCBbJ21vdXNlZW50ZXInLCAnbW91c2VsZWF2ZSddLCBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRcdGlmKCF0aGlzLmNhY2hlKSB7cmV0dXJuIEZBTFNFOyB9XG5cdFx0XHRcdFx0dGhpcy5jYWNoZS5vblRhcmdldCA9IGV2ZW50LnR5cGUgPT09ICdtb3VzZWVudGVyJztcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFVwZGF0ZSB0b29sdGlwIHBvc2l0aW9uIG9uIG1vdXNlbW92ZVxuXHRcdFx0dGhpcy5fYmluZChkb2N1bWVudFRhcmdldCwgJ21vdXNlbW92ZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdC8vIFVwZGF0ZSB0aGUgdG9vbHRpcCBwb3NpdGlvbiBvbmx5IGlmIHRoZSB0b29sdGlwIGlzIHZpc2libGUgYW5kIGFkanVzdG1lbnQgaXMgZW5hYmxlZFxuXHRcdFx0XHRpZih0aGlzLnJlbmRlcmVkICYmIHRoaXMuY2FjaGUub25UYXJnZXQgJiYgIXRoaXMudG9vbHRpcC5oYXNDbGFzcyhDTEFTU19ESVNBQkxFRCkgJiYgdGhpcy50b29sdGlwWzBdLm9mZnNldFdpZHRoID4gMCkge1xuXHRcdFx0XHRcdHRoaXMucmVwb3NpdGlvbihldmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdC8vIEFkanVzdCBwb3NpdGlvbnMgb2YgdGhlIHRvb2x0aXAgb24gd2luZG93IHJlc2l6ZSBpZiBlbmFibGVkXG5cdGlmKHBvc09wdGlvbnMuYWRqdXN0LnJlc2l6ZSB8fCB2aWV3cG9ydFRhcmdldC5sZW5ndGgpIHtcblx0XHR0aGlzLl9iaW5kKCAkLmV2ZW50LnNwZWNpYWwucmVzaXplID8gdmlld3BvcnRUYXJnZXQgOiB3aW5kb3dUYXJnZXQsICdyZXNpemUnLCByZXBvc2l0aW9uTWV0aG9kICk7XG5cdH1cblxuXHQvLyBBZGp1c3QgdG9vbHRpcCBwb3NpdGlvbiBvbiBzY3JvbGwgb2YgdGhlIHdpbmRvdyBvciB2aWV3cG9ydCBlbGVtZW50IGlmIHByZXNlbnRcblx0aWYocG9zT3B0aW9ucy5hZGp1c3Quc2Nyb2xsKSB7XG5cdFx0dGhpcy5fYmluZCggd2luZG93VGFyZ2V0LmFkZChwb3NPcHRpb25zLmNvbnRhaW5lciksICdzY3JvbGwnLCByZXBvc2l0aW9uTWV0aG9kICk7XG5cdH1cbn07XG5cbi8vIFVuLWFzc2lnbm1lbnQgbWV0aG9kXG5QUk9UT1RZUEUuX3VuYXNzaWduRXZlbnRzID0gZnVuY3Rpb24oKSB7XG5cdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdHNob3dUYXJnZXRzID0gb3B0aW9ucy5zaG93LnRhcmdldCxcblx0XHRoaWRlVGFyZ2V0cyA9IG9wdGlvbnMuaGlkZS50YXJnZXQsXG5cdFx0dGFyZ2V0cyA9ICQuZ3JlcChbXG5cdFx0XHR0aGlzLmVsZW1lbnRzLnRhcmdldFswXSxcblx0XHRcdHRoaXMucmVuZGVyZWQgJiYgdGhpcy50b29sdGlwWzBdLFxuXHRcdFx0b3B0aW9ucy5wb3NpdGlvbi5jb250YWluZXJbMF0sXG5cdFx0XHRvcHRpb25zLnBvc2l0aW9uLnZpZXdwb3J0WzBdLFxuXHRcdFx0b3B0aW9ucy5wb3NpdGlvbi5jb250YWluZXIuY2xvc2VzdCgnaHRtbCcpWzBdLCAvLyB1bmZvY3VzXG5cdFx0XHR3aW5kb3csXG5cdFx0XHRkb2N1bWVudFxuXHRcdF0sIGZ1bmN0aW9uKGkpIHtcblx0XHRcdHJldHVybiB0eXBlb2YgaSA9PT0gJ29iamVjdCc7XG5cdFx0fSk7XG5cblx0Ly8gQWRkIHNob3cgYW5kIGhpZGUgdGFyZ2V0cyBpZiB0aGV5J3JlIHZhbGlkXG5cdGlmKHNob3dUYXJnZXRzICYmIHNob3dUYXJnZXRzLnRvQXJyYXkpIHtcblx0XHR0YXJnZXRzID0gdGFyZ2V0cy5jb25jYXQoc2hvd1RhcmdldHMudG9BcnJheSgpKTtcblx0fVxuXHRpZihoaWRlVGFyZ2V0cyAmJiBoaWRlVGFyZ2V0cy50b0FycmF5KSB7XG5cdFx0dGFyZ2V0cyA9IHRhcmdldHMuY29uY2F0KGhpZGVUYXJnZXRzLnRvQXJyYXkoKSk7XG5cdH1cblxuXHQvLyBVbmJpbmQgdGhlIGV2ZW50c1xuXHR0aGlzLl91bmJpbmQodGFyZ2V0cylcblx0XHQuX3VuYmluZCh0YXJnZXRzLCAnZGVzdHJveScpXG5cdFx0Ll91bmJpbmQodGFyZ2V0cywgJ2luYWN0aXZlJyk7XG59O1xuXG4vLyBBcHBseSBjb21tb24gZXZlbnQgaGFuZGxlcnMgdXNpbmcgZGVsZWdhdGUgKGF2b2lkcyBleGNlc3NpdmUgLmJpbmQgY2FsbHMhKVxuJChmdW5jdGlvbigpIHtcblx0ZGVsZWdhdGUoU0VMRUNUT1IsIFsnbW91c2VlbnRlcicsICdtb3VzZWxlYXZlJ10sIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHN0YXRlID0gZXZlbnQudHlwZSA9PT0gJ21vdXNlZW50ZXInLFxuXHRcdFx0dG9vbHRpcCA9ICQoZXZlbnQuY3VycmVudFRhcmdldCksXG5cdFx0XHR0YXJnZXQgPSAkKGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgZXZlbnQudGFyZ2V0KSxcblx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cblx0XHQvLyBPbiBtb3VzZWVudGVyLi4uXG5cdFx0aWYoc3RhdGUpIHtcblx0XHRcdC8vIEZvY3VzIHRoZSB0b29sdGlwIG9uIG1vdXNlZW50ZXIgKHotaW5kZXggc3RhY2tpbmcpXG5cdFx0XHR0aGlzLmZvY3VzKGV2ZW50KTtcblxuXHRcdFx0Ly8gQ2xlYXIgaGlkZSB0aW1lciBvbiB0b29sdGlwIGhvdmVyIHRvIHByZXZlbnQgaXQgZnJvbSBjbG9zaW5nXG5cdFx0XHR0b29sdGlwLmhhc0NsYXNzKENMQVNTX0ZJWEVEKSAmJiAhdG9vbHRpcC5oYXNDbGFzcyhDTEFTU19ESVNBQkxFRCkgJiYgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLmhpZGUpO1xuXHRcdH1cblxuXHRcdC8vIE9uIG1vdXNlbGVhdmUuLi5cblx0XHRlbHNlIHtcblx0XHRcdC8vIFdoZW4gbW91c2UgdHJhY2tpbmcgaXMgZW5hYmxlZCwgaGlkZSB3aGVuIHdlIGxlYXZlIHRoZSB0b29sdGlwIGFuZCBub3Qgb250byB0aGUgc2hvdyB0YXJnZXQgKGlmIGEgaGlkZSBldmVudCBpcyBzZXQpXG5cdFx0XHRpZihvcHRpb25zLnBvc2l0aW9uLnRhcmdldCA9PT0gJ21vdXNlJyAmJiBvcHRpb25zLnBvc2l0aW9uLmFkanVzdC5tb3VzZSAmJlxuXHRcdFx0XHRvcHRpb25zLmhpZGUuZXZlbnQgJiYgb3B0aW9ucy5zaG93LnRhcmdldCAmJiAhdGFyZ2V0LmNsb3Nlc3Qob3B0aW9ucy5zaG93LnRhcmdldFswXSkubGVuZ3RoKSB7XG5cdFx0XHRcdHRoaXMuaGlkZShldmVudCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIGhvdmVyIGNsYXNzXG5cdFx0dG9vbHRpcC50b2dnbGVDbGFzcyhDTEFTU19IT1ZFUiwgc3RhdGUpO1xuXHR9KTtcblxuXHQvLyBEZWZpbmUgZXZlbnRzIHdoaWNoIHJlc2V0IHRoZSAnaW5hY3RpdmUnIGV2ZW50IGhhbmRsZXJcblx0ZGVsZWdhdGUoJ1snK0FUVFJfSUQrJ10nLCBJTkFDVElWRV9FVkVOVFMsIGluYWN0aXZlTWV0aG9kKTtcbn0pO1xuOy8vIEluaXRpYWxpemF0aW9uIG1ldGhvZFxuZnVuY3Rpb24gaW5pdChlbGVtLCBpZCwgb3B0cykge1xuXHR2YXIgb2JqLCBwb3NPcHRpb25zLCBhdHRyLCBjb25maWcsIHRpdGxlLFxuXG5cdC8vIFNldHVwIGVsZW1lbnQgcmVmZXJlbmNlc1xuXHRkb2NCb2R5ID0gJChkb2N1bWVudC5ib2R5KSxcblxuXHQvLyBVc2UgZG9jdW1lbnQgYm9keSBpbnN0ZWFkIG9mIGRvY3VtZW50IGVsZW1lbnQgaWYgbmVlZGVkXG5cdG5ld1RhcmdldCA9IGVsZW1bMF0gPT09IGRvY3VtZW50ID8gZG9jQm9keSA6IGVsZW0sXG5cblx0Ly8gR3JhYiBtZXRhZGF0YSBmcm9tIGVsZW1lbnQgaWYgcGx1Z2luIGlzIHByZXNlbnRcblx0bWV0YWRhdGEgPSBlbGVtLm1ldGFkYXRhID8gZWxlbS5tZXRhZGF0YShvcHRzLm1ldGFkYXRhKSA6IE5VTEwsXG5cblx0Ly8gSWYgbWV0YWRhdGEgdHlwZSBpZiBIVE1MNSwgZ3JhYiAnbmFtZScgZnJvbSB0aGUgb2JqZWN0IGluc3RlYWQsIG9yIHVzZSB0aGUgcmVndWxhciBkYXRhIG9iamVjdCBvdGhlcndpc2Vcblx0bWV0YWRhdGE1ID0gb3B0cy5tZXRhZGF0YS50eXBlID09PSAnaHRtbDUnICYmIG1ldGFkYXRhID8gbWV0YWRhdGFbb3B0cy5tZXRhZGF0YS5uYW1lXSA6IE5VTEwsXG5cblx0Ly8gR3JhYiBkYXRhIGZyb20gbWV0YWRhdGEubmFtZSAob3IgZGF0YS1xdGlwb3B0cyBhcyBmYWxsYmFjaykgdXNpbmcgLmRhdGEoKSBtZXRob2QsXG5cdGh0bWw1ID0gZWxlbS5kYXRhKG9wdHMubWV0YWRhdGEubmFtZSB8fCAncXRpcG9wdHMnKTtcblxuXHQvLyBJZiB3ZSBkb24ndCBnZXQgYW4gb2JqZWN0IHJldHVybmVkIGF0dGVtcHQgdG8gcGFyc2UgaXQgbWFudWFseWwgd2l0aG91dCBwYXJzZUpTT05cblx0LyogZXNsaW50LWRpc2FibGUgbm8tZW1wdHkgKi9cblx0dHJ5IHsgaHRtbDUgPSB0eXBlb2YgaHRtbDUgPT09ICdzdHJpbmcnID8gJC5wYXJzZUpTT04oaHRtbDUpIDogaHRtbDU7IH1cblx0Y2F0Y2goZSkge31cblx0LyogZXNsaW50LWVuYWJsZSBuby1lbXB0eSAqL1xuXG5cdC8vIE1lcmdlIGluIGFuZCBzYW5pdGl6ZSBtZXRhZGF0YVxuXHRjb25maWcgPSAkLmV4dGVuZChUUlVFLCB7fSwgUVRJUC5kZWZhdWx0cywgb3B0cyxcblx0XHR0eXBlb2YgaHRtbDUgPT09ICdvYmplY3QnID8gc2FuaXRpemVPcHRpb25zKGh0bWw1KSA6IE5VTEwsXG5cdFx0c2FuaXRpemVPcHRpb25zKG1ldGFkYXRhNSB8fCBtZXRhZGF0YSkpO1xuXG5cdC8vIFJlLWdyYWIgb3VyIHBvc2l0aW9uaW5nIG9wdGlvbnMgbm93IHdlJ3ZlIG1lcmdlZCBvdXIgbWV0YWRhdGEgYW5kIHNldCBpZCB0byBwYXNzZWQgdmFsdWVcblx0cG9zT3B0aW9ucyA9IGNvbmZpZy5wb3NpdGlvbjtcblx0Y29uZmlnLmlkID0gaWQ7XG5cblx0Ly8gU2V0dXAgbWlzc2luZyBjb250ZW50IGlmIG5vbmUgaXMgZGV0ZWN0ZWRcblx0aWYoJ2Jvb2xlYW4nID09PSB0eXBlb2YgY29uZmlnLmNvbnRlbnQudGV4dCkge1xuXHRcdGF0dHIgPSBlbGVtLmF0dHIoY29uZmlnLmNvbnRlbnQuYXR0cik7XG5cblx0XHQvLyBHcmFiIGZyb20gc3VwcGxpZWQgYXR0cmlidXRlIGlmIGF2YWlsYWJsZVxuXHRcdGlmKGNvbmZpZy5jb250ZW50LmF0dHIgIT09IEZBTFNFICYmIGF0dHIpIHsgY29uZmlnLmNvbnRlbnQudGV4dCA9IGF0dHI7IH1cblxuXHRcdC8vIE5vIHZhbGlkIGNvbnRlbnQgd2FzIGZvdW5kLCBhYm9ydCByZW5kZXJcblx0XHRlbHNlIHsgcmV0dXJuIEZBTFNFOyB9XG5cdH1cblxuXHQvLyBTZXR1cCB0YXJnZXQgb3B0aW9uc1xuXHRpZighcG9zT3B0aW9ucy5jb250YWluZXIubGVuZ3RoKSB7IHBvc09wdGlvbnMuY29udGFpbmVyID0gZG9jQm9keTsgfVxuXHRpZihwb3NPcHRpb25zLnRhcmdldCA9PT0gRkFMU0UpIHsgcG9zT3B0aW9ucy50YXJnZXQgPSBuZXdUYXJnZXQ7IH1cblx0aWYoY29uZmlnLnNob3cudGFyZ2V0ID09PSBGQUxTRSkgeyBjb25maWcuc2hvdy50YXJnZXQgPSBuZXdUYXJnZXQ7IH1cblx0aWYoY29uZmlnLnNob3cuc29sbyA9PT0gVFJVRSkgeyBjb25maWcuc2hvdy5zb2xvID0gcG9zT3B0aW9ucy5jb250YWluZXIuY2xvc2VzdCgnYm9keScpOyB9XG5cdGlmKGNvbmZpZy5oaWRlLnRhcmdldCA9PT0gRkFMU0UpIHsgY29uZmlnLmhpZGUudGFyZ2V0ID0gbmV3VGFyZ2V0OyB9XG5cdGlmKGNvbmZpZy5wb3NpdGlvbi52aWV3cG9ydCA9PT0gVFJVRSkgeyBjb25maWcucG9zaXRpb24udmlld3BvcnQgPSBwb3NPcHRpb25zLmNvbnRhaW5lcjsgfVxuXG5cdC8vIEVuc3VyZSB3ZSBvbmx5IHVzZSBhIHNpbmdsZSBjb250YWluZXJcblx0cG9zT3B0aW9ucy5jb250YWluZXIgPSBwb3NPcHRpb25zLmNvbnRhaW5lci5lcSgwKTtcblxuXHQvLyBDb252ZXJ0IHBvc2l0aW9uIGNvcm5lciB2YWx1ZXMgaW50byB4IGFuZCB5IHN0cmluZ3Ncblx0cG9zT3B0aW9ucy5hdCA9IG5ldyBDT1JORVIocG9zT3B0aW9ucy5hdCwgVFJVRSk7XG5cdHBvc09wdGlvbnMubXkgPSBuZXcgQ09STkVSKHBvc09wdGlvbnMubXkpO1xuXG5cdC8vIERlc3Ryb3kgcHJldmlvdXMgdG9vbHRpcCBpZiBvdmVyd3JpdGUgaXMgZW5hYmxlZCwgb3Igc2tpcCBlbGVtZW50IGlmIG5vdFxuXHRpZihlbGVtLmRhdGEoTkFNRVNQQUNFKSkge1xuXHRcdGlmKGNvbmZpZy5vdmVyd3JpdGUpIHtcblx0XHRcdGVsZW0ucXRpcCgnZGVzdHJveScsIHRydWUpO1xuXHRcdH1cblx0XHRlbHNlIGlmKGNvbmZpZy5vdmVyd3JpdGUgPT09IEZBTFNFKSB7XG5cdFx0XHRyZXR1cm4gRkFMU0U7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWRkIGhhcy1xdGlwIGF0dHJpYnV0ZVxuXHRlbGVtLmF0dHIoQVRUUl9IQVMsIGlkKTtcblxuXHQvLyBSZW1vdmUgdGl0bGUgYXR0cmlidXRlIGFuZCBzdG9yZSBpdCBpZiBwcmVzZW50XG5cdGlmKGNvbmZpZy5zdXBwcmVzcyAmJiAodGl0bGUgPSBlbGVtLmF0dHIoJ3RpdGxlJykpKSB7XG5cdFx0Ly8gRmluYWwgYXR0ciBjYWxsIGZpeGVzIGV2ZW50IGRlbGVnYXRpb20gYW5kIElFIGRlZmF1bHQgdG9vbHRpcCBzaG93aW5nIHByb2JsZW1cblx0XHRlbGVtLnJlbW92ZUF0dHIoJ3RpdGxlJykuYXR0cihvbGR0aXRsZSwgdGl0bGUpLmF0dHIoJ3RpdGxlJywgJycpO1xuXHR9XG5cblx0Ly8gSW5pdGlhbGl6ZSB0aGUgdG9vbHRpcCBhbmQgYWRkIEFQSSByZWZlcmVuY2Vcblx0b2JqID0gbmV3IFFUaXAoZWxlbSwgY29uZmlnLCBpZCwgISFhdHRyKTtcblx0ZWxlbS5kYXRhKE5BTUVTUEFDRSwgb2JqKTtcblxuXHRyZXR1cm4gb2JqO1xufVxuXG4vLyBqUXVlcnkgJC5mbiBleHRlbnNpb24gbWV0aG9kXG5RVElQID0gJC5mbi5xdGlwID0gZnVuY3Rpb24ob3B0aW9ucywgbm90YXRpb24sIG5ld1ZhbHVlKVxue1xuXHR2YXIgY29tbWFuZCA9ICgnJyArIG9wdGlvbnMpLnRvTG93ZXJDYXNlKCksIC8vIFBhcnNlIGNvbW1hbmRcblx0XHRyZXR1cm5lZCA9IE5VTEwsXG5cdFx0YXJncyA9ICQubWFrZUFycmF5KGFyZ3VtZW50cykuc2xpY2UoMSksXG5cdFx0ZXZlbnQgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0sXG5cdFx0b3B0cyA9IHRoaXNbMF0gPyAkLmRhdGEodGhpc1swXSwgTkFNRVNQQUNFKSA6IE5VTEw7XG5cblx0Ly8gQ2hlY2sgZm9yIEFQSSByZXF1ZXN0XG5cdGlmKCFhcmd1bWVudHMubGVuZ3RoICYmIG9wdHMgfHwgY29tbWFuZCA9PT0gJ2FwaScpIHtcblx0XHRyZXR1cm4gb3B0cztcblx0fVxuXG5cdC8vIEV4ZWN1dGUgQVBJIGNvbW1hbmQgaWYgcHJlc2VudFxuXHRlbHNlIGlmKCdzdHJpbmcnID09PSB0eXBlb2Ygb3B0aW9ucykge1xuXHRcdHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBhcGkgPSAkLmRhdGEodGhpcywgTkFNRVNQQUNFKTtcblx0XHRcdGlmKCFhcGkpIHsgcmV0dXJuIFRSVUU7IH1cblxuXHRcdFx0Ly8gQ2FjaGUgdGhlIGV2ZW50IGlmIHBvc3NpYmxlXG5cdFx0XHRpZihldmVudCAmJiBldmVudC50aW1lU3RhbXApIHsgYXBpLmNhY2hlLmV2ZW50ID0gZXZlbnQ7IH1cblxuXHRcdFx0Ly8gQ2hlY2sgZm9yIHNwZWNpZmljIEFQSSBjb21tYW5kc1xuXHRcdFx0aWYobm90YXRpb24gJiYgKGNvbW1hbmQgPT09ICdvcHRpb24nIHx8IGNvbW1hbmQgPT09ICdvcHRpb25zJykpIHtcblx0XHRcdFx0aWYobmV3VmFsdWUgIT09IHVuZGVmaW5lZCB8fCAkLmlzUGxhaW5PYmplY3Qobm90YXRpb24pKSB7XG5cdFx0XHRcdFx0YXBpLnNldChub3RhdGlvbiwgbmV3VmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybmVkID0gYXBpLmdldChub3RhdGlvbik7XG5cdFx0XHRcdFx0cmV0dXJuIEZBTFNFO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEV4ZWN1dGUgQVBJIGNvbW1hbmRcblx0XHRcdGVsc2UgaWYoYXBpW2NvbW1hbmRdKSB7XG5cdFx0XHRcdGFwaVtjb21tYW5kXS5hcHBseShhcGksIGFyZ3MpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHJldHVybmVkICE9PSBOVUxMID8gcmV0dXJuZWQgOiB0aGlzO1xuXHR9XG5cblx0Ly8gTm8gQVBJIGNvbW1hbmRzLiB2YWxpZGF0ZSBwcm92aWRlZCBvcHRpb25zIGFuZCBzZXR1cCBxVGlwc1xuXHRlbHNlIGlmKCdvYmplY3QnID09PSB0eXBlb2Ygb3B0aW9ucyB8fCAhYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdC8vIFNhbml0aXplIG9wdGlvbnMgZmlyc3Rcblx0XHRvcHRzID0gc2FuaXRpemVPcHRpb25zKCQuZXh0ZW5kKFRSVUUsIHt9LCBvcHRpb25zKSk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGkpIHtcblx0XHRcdHZhciBhcGksIGlkO1xuXG5cdFx0XHQvLyBGaW5kIG5leHQgYXZhaWxhYmxlIElELCBvciB1c2UgY3VzdG9tIElEIGlmIHByb3ZpZGVkXG5cdFx0XHRpZCA9ICQuaXNBcnJheShvcHRzLmlkKSA/IG9wdHMuaWRbaV0gOiBvcHRzLmlkO1xuXHRcdFx0aWQgPSAhaWQgfHwgaWQgPT09IEZBTFNFIHx8IGlkLmxlbmd0aCA8IDEgfHwgUVRJUC5hcGlbaWRdID8gUVRJUC5uZXh0aWQrKyA6IGlkO1xuXG5cdFx0XHQvLyBJbml0aWFsaXplIHRoZSBxVGlwIGFuZCByZS1ncmFiIG5ld2x5IHNhbml0aXplZCBvcHRpb25zXG5cdFx0XHRhcGkgPSBpbml0KCQodGhpcyksIGlkLCBvcHRzKTtcblx0XHRcdGlmKGFwaSA9PT0gRkFMU0UpIHsgcmV0dXJuIFRSVUU7IH1cblx0XHRcdGVsc2UgeyBRVElQLmFwaVtpZF0gPSBhcGk7IH1cblxuXHRcdFx0Ly8gSW5pdGlhbGl6ZSBwbHVnaW5zXG5cdFx0XHQkLmVhY2goUExVR0lOUywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmKHRoaXMuaW5pdGlhbGl6ZSA9PT0gJ2luaXRpYWxpemUnKSB7IHRoaXMoYXBpKTsgfVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEFzc2lnbiBpbml0aWFsIHByZS1yZW5kZXIgZXZlbnRzXG5cdFx0XHRhcGkuX2Fzc2lnbkluaXRpYWxFdmVudHMoZXZlbnQpO1xuXHRcdH0pO1xuXHR9XG59O1xuXG4vLyBFeHBvc2UgY2xhc3NcbiQucXRpcCA9IFFUaXA7XG5cbi8vIFBvcHVsYXRlZCBpbiByZW5kZXIgbWV0aG9kXG5RVElQLmFwaSA9IHt9O1xuOyQuZWFjaCh7XG5cdC8qIEFsbG93IG90aGVyIHBsdWdpbnMgdG8gc3VjY2Vzc2Z1bGx5IHJldHJpZXZlIHRoZSB0aXRsZSBvZiBhbiBlbGVtZW50IHdpdGggYSBxVGlwIGFwcGxpZWQgKi9cblx0YXR0cjogZnVuY3Rpb24oYXR0ciwgdmFsKSB7XG5cdFx0aWYodGhpcy5sZW5ndGgpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpc1swXSxcblx0XHRcdFx0dGl0bGUgPSAndGl0bGUnLFxuXHRcdFx0XHRhcGkgPSAkLmRhdGEoc2VsZiwgJ3F0aXAnKTtcblxuXHRcdFx0aWYoYXR0ciA9PT0gdGl0bGUgJiYgYXBpICYmIGFwaS5vcHRpb25zICYmICdvYmplY3QnID09PSB0eXBlb2YgYXBpICYmICdvYmplY3QnID09PSB0eXBlb2YgYXBpLm9wdGlvbnMgJiYgYXBpLm9wdGlvbnMuc3VwcHJlc3MpIHtcblx0XHRcdFx0aWYoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcblx0XHRcdFx0XHRyZXR1cm4gJC5hdHRyKHNlbGYsIG9sZHRpdGxlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHFUaXAgaXMgcmVuZGVyZWQgYW5kIHRpdGxlIHdhcyBvcmlnaW5hbGx5IHVzZWQgYXMgY29udGVudCwgdXBkYXRlIGl0XG5cdFx0XHRcdGlmKGFwaSAmJiBhcGkub3B0aW9ucy5jb250ZW50LmF0dHIgPT09IHRpdGxlICYmIGFwaS5jYWNoZS5hdHRyKSB7XG5cdFx0XHRcdFx0YXBpLnNldCgnY29udGVudC50ZXh0JywgdmFsKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFVzZSB0aGUgcmVndWxhciBhdHRyIG1ldGhvZCB0byBzZXQsIHRoZW4gY2FjaGUgdGhlIHJlc3VsdFxuXHRcdFx0XHRyZXR1cm4gdGhpcy5hdHRyKG9sZHRpdGxlLCB2YWwpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiAkLmZuWydhdHRyJytyZXBsYWNlU3VmZml4XS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9LFxuXG5cdC8qIEFsbG93IGNsb25lIHRvIGNvcnJlY3RseSByZXRyaWV2ZSBjYWNoZWQgdGl0bGUgYXR0cmlidXRlcyAqL1xuXHRjbG9uZTogZnVuY3Rpb24oa2VlcERhdGEpIHtcblx0XHQvLyBDbG9uZSBvdXIgZWxlbWVudCB1c2luZyB0aGUgcmVhbCBjbG9uZSBtZXRob2Rcblx0XHR2YXIgZWxlbXMgPSAkLmZuWydjbG9uZScrcmVwbGFjZVN1ZmZpeF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuXHRcdC8vIEdyYWIgYWxsIGVsZW1lbnRzIHdpdGggYW4gb2xkdGl0bGUgc2V0LCBhbmQgY2hhbmdlIGl0IHRvIHJlZ3VsYXIgdGl0bGUgYXR0cmlidXRlLCBpZiBrZWVwRGF0YSBpcyBmYWxzZVxuXHRcdGlmKCFrZWVwRGF0YSkge1xuXHRcdFx0ZWxlbXMuZmlsdGVyKCdbJytvbGR0aXRsZSsnXScpLmF0dHIoJ3RpdGxlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAkLmF0dHIodGhpcywgb2xkdGl0bGUpO1xuXHRcdFx0fSlcblx0XHRcdC5yZW1vdmVBdHRyKG9sZHRpdGxlKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZWxlbXM7XG5cdH1cbn0sIGZ1bmN0aW9uKG5hbWUsIGZ1bmMpIHtcblx0aWYoIWZ1bmMgfHwgJC5mbltuYW1lK3JlcGxhY2VTdWZmaXhdKSB7IHJldHVybiBUUlVFOyB9XG5cblx0dmFyIG9sZCA9ICQuZm5bbmFtZStyZXBsYWNlU3VmZml4XSA9ICQuZm5bbmFtZV07XG5cdCQuZm5bbmFtZV0gPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IG9sZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9O1xufSk7XG5cbi8qIEZpcmUgb2ZmICdyZW1vdmVxdGlwJyBoYW5kbGVyIGluICQuY2xlYW5EYXRhIGlmIGpRdWVyeSBVSSBub3QgcHJlc2VudCAoaXQgYWxyZWFkeSBkb2VzIHNpbWlsYXIpLlxuICogVGhpcyBzbmlwcGV0IGlzIHRha2VuIGRpcmVjdGx5IGZyb20galF1ZXJ5IFVJIHNvdXJjZSBjb2RlIGZvdW5kIGhlcmU6XG4gKiAgICAgaHR0cDovL2NvZGUuanF1ZXJ5LmNvbS91aS9qcXVlcnktdWktZ2l0LmpzXG4gKi9cbmlmKCEkLnVpKSB7XG5cdCRbJ2NsZWFuRGF0YScrcmVwbGFjZVN1ZmZpeF0gPSAkLmNsZWFuRGF0YTtcblx0JC5jbGVhbkRhdGEgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG5cdFx0Zm9yKHZhciBpID0gMCwgZWxlbTsgKGVsZW0gPSAkKCBlbGVtc1tpXSApKS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYoZWxlbS5hdHRyKEFUVFJfSEFTKSkge1xuXHRcdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1lbXB0eSAqL1xuXHRcdFx0XHR0cnkgeyBlbGVtLnRyaWdnZXJIYW5kbGVyKCdyZW1vdmVxdGlwJyk7IH1cblx0XHRcdFx0Y2F0Y2goIGUgKSB7fVxuXHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWVtcHR5ICovXG5cdFx0XHR9XG5cdFx0fVxuXHRcdCRbJ2NsZWFuRGF0YScrcmVwbGFjZVN1ZmZpeF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fTtcbn1cbjsvLyBxVGlwIHZlcnNpb25cblFUSVAudmVyc2lvbiA9ICczLjAuMyc7XG5cbi8vIEJhc2UgSUQgZm9yIGFsbCBxVGlwc1xuUVRJUC5uZXh0aWQgPSAwO1xuXG4vLyBJbmFjdGl2ZSBldmVudHMgYXJyYXlcblFUSVAuaW5hY3RpdmVFdmVudHMgPSBJTkFDVElWRV9FVkVOVFM7XG5cbi8vIEJhc2Ugei1pbmRleCBmb3IgYWxsIHFUaXBzXG5RVElQLnppbmRleCA9IDE1MDAwO1xuXG4vLyBEZWZpbmUgY29uZmlndXJhdGlvbiBkZWZhdWx0c1xuUVRJUC5kZWZhdWx0cyA9IHtcblx0cHJlcmVuZGVyOiBGQUxTRSxcblx0aWQ6IEZBTFNFLFxuXHRvdmVyd3JpdGU6IFRSVUUsXG5cdHN1cHByZXNzOiBUUlVFLFxuXHRjb250ZW50OiB7XG5cdFx0dGV4dDogVFJVRSxcblx0XHRhdHRyOiAndGl0bGUnLFxuXHRcdHRpdGxlOiBGQUxTRSxcblx0XHRidXR0b246IEZBTFNFXG5cdH0sXG5cdHBvc2l0aW9uOiB7XG5cdFx0bXk6ICd0b3AgbGVmdCcsXG5cdFx0YXQ6ICdib3R0b20gcmlnaHQnLFxuXHRcdHRhcmdldDogRkFMU0UsXG5cdFx0Y29udGFpbmVyOiBGQUxTRSxcblx0XHR2aWV3cG9ydDogRkFMU0UsXG5cdFx0YWRqdXN0OiB7XG5cdFx0XHR4OiAwLCB5OiAwLFxuXHRcdFx0bW91c2U6IFRSVUUsXG5cdFx0XHRzY3JvbGw6IFRSVUUsXG5cdFx0XHRyZXNpemU6IFRSVUUsXG5cdFx0XHRtZXRob2Q6ICdmbGlwaW52ZXJ0IGZsaXBpbnZlcnQnXG5cdFx0fSxcblx0XHRlZmZlY3Q6IGZ1bmN0aW9uKGFwaSwgcG9zKSB7XG5cdFx0XHQkKHRoaXMpLmFuaW1hdGUocG9zLCB7XG5cdFx0XHRcdGR1cmF0aW9uOiAyMDAsXG5cdFx0XHRcdHF1ZXVlOiBGQUxTRVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXHRzaG93OiB7XG5cdFx0dGFyZ2V0OiBGQUxTRSxcblx0XHRldmVudDogJ21vdXNlZW50ZXInLFxuXHRcdGVmZmVjdDogVFJVRSxcblx0XHRkZWxheTogOTAsXG5cdFx0c29sbzogRkFMU0UsXG5cdFx0cmVhZHk6IEZBTFNFLFxuXHRcdGF1dG9mb2N1czogRkFMU0Vcblx0fSxcblx0aGlkZToge1xuXHRcdHRhcmdldDogRkFMU0UsXG5cdFx0ZXZlbnQ6ICdtb3VzZWxlYXZlJyxcblx0XHRlZmZlY3Q6IFRSVUUsXG5cdFx0ZGVsYXk6IDAsXG5cdFx0Zml4ZWQ6IEZBTFNFLFxuXHRcdGluYWN0aXZlOiBGQUxTRSxcblx0XHRsZWF2ZTogJ3dpbmRvdycsXG5cdFx0ZGlzdGFuY2U6IEZBTFNFXG5cdH0sXG5cdHN0eWxlOiB7XG5cdFx0Y2xhc3NlczogJycsXG5cdFx0d2lkZ2V0OiBGQUxTRSxcblx0XHR3aWR0aDogRkFMU0UsXG5cdFx0aGVpZ2h0OiBGQUxTRSxcblx0XHRkZWY6IFRSVUVcblx0fSxcblx0ZXZlbnRzOiB7XG5cdFx0cmVuZGVyOiBOVUxMLFxuXHRcdG1vdmU6IE5VTEwsXG5cdFx0c2hvdzogTlVMTCxcblx0XHRoaWRlOiBOVUxMLFxuXHRcdHRvZ2dsZTogTlVMTCxcblx0XHR2aXNpYmxlOiBOVUxMLFxuXHRcdGhpZGRlbjogTlVMTCxcblx0XHRmb2N1czogTlVMTCxcblx0XHRibHVyOiBOVUxMXG5cdH1cbn07XG47dmFyIFRJUCxcbmNyZWF0ZVZNTCxcblNDQUxFLFxuUElYRUxfUkFUSU8sXG5CQUNLSU5HX1NUT1JFX1JBVElPLFxuXG4vLyBDb21tb24gQ1NTIHN0cmluZ3Ncbk1BUkdJTiA9ICdtYXJnaW4nLFxuQk9SREVSID0gJ2JvcmRlcicsXG5DT0xPUiA9ICdjb2xvcicsXG5CR19DT0xPUiA9ICdiYWNrZ3JvdW5kLWNvbG9yJyxcblRSQU5TUEFSRU5UID0gJ3RyYW5zcGFyZW50JyxcbklNUE9SVEFOVCA9ICcgIWltcG9ydGFudCcsXG5cbi8vIENoZWNrIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIDxjYW52YXMvPiBlbGVtZW50c1xuSEFTQ0FOVkFTID0gISFkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0LFxuXG4vLyBJbnZhbGlkIGNvbG91ciB2YWx1ZXMgdXNlZCBpbiBwYXJzZUNvbG91cnMoKVxuSU5WQUxJRCA9IC9yZ2JhP1xcKDAsIDAsIDAoLCAwKT9cXCl8dHJhbnNwYXJlbnR8IzEyMzQ1Ni9pO1xuXG4vLyBDYW1lbC1jYXNlIG1ldGhvZCwgdGFrZW4gZnJvbSBqUXVlcnkgc291cmNlXG4vLyBodHRwOi8vY29kZS5qcXVlcnkuY29tL2pxdWVyeS0xLjguMC5qc1xuZnVuY3Rpb24gY2FtZWwocykgeyByZXR1cm4gcy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHMuc2xpY2UoMSk7IH1cblxuLypcbiAqIE1vZGlmaWVkIGZyb20gTW9kZXJuaXpyJ3MgdGVzdFByb3BzQWxsKClcbiAqIGh0dHA6Ly9tb2Rlcm5penIuY29tL2Rvd25sb2Fkcy9tb2Rlcm5penItbGF0ZXN0LmpzXG4gKi9cbnZhciBjc3NQcm9wcyA9IHt9LCBjc3NQcmVmaXhlcyA9IFsnV2Via2l0JywgJ08nLCAnTW96JywgJ21zJ107XG5mdW5jdGlvbiB2ZW5kb3JDc3MoZWxlbSwgcHJvcCkge1xuXHR2YXIgdWNQcm9wID0gcHJvcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3Auc2xpY2UoMSksXG5cdFx0cHJvcHMgPSAocHJvcCArICcgJyArIGNzc1ByZWZpeGVzLmpvaW4odWNQcm9wICsgJyAnKSArIHVjUHJvcCkuc3BsaXQoJyAnKSxcblx0XHRjdXIsIHZhbCwgaSA9IDA7XG5cblx0Ly8gSWYgdGhlIHByb3BlcnR5IGhhcyBhbHJlYWR5IGJlZW4gbWFwcGVkLi4uXG5cdGlmKGNzc1Byb3BzW3Byb3BdKSB7IHJldHVybiBlbGVtLmNzcyhjc3NQcm9wc1twcm9wXSk7IH1cblxuXHR3aGlsZShjdXIgPSBwcm9wc1tpKytdKSB7XG5cdFx0aWYoKHZhbCA9IGVsZW0uY3NzKGN1cikpICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGNzc1Byb3BzW3Byb3BdID0gY3VyO1xuXHRcdFx0cmV0dXJuIHZhbDtcblx0XHR9XG5cdH1cbn1cblxuLy8gUGFyc2UgYSBnaXZlbiBlbGVtZW50cyBDU1MgcHJvcGVydHkgaW50byBhbiBpbnRcbmZ1bmN0aW9uIGludENzcyhlbGVtLCBwcm9wKSB7XG5cdHJldHVybiBNYXRoLmNlaWwocGFyc2VGbG9hdCh2ZW5kb3JDc3MoZWxlbSwgcHJvcCkpKTtcbn1cblxuXG4vLyBWTUwgY3JlYXRpb24gKGZvciBJRSBvbmx5KVxuaWYoIUhBU0NBTlZBUykge1xuXHRjcmVhdGVWTUwgPSBmdW5jdGlvbih0YWcsIHByb3BzLCBzdHlsZSkge1xuXHRcdHJldHVybiAnPHF0aXB2bWw6Jyt0YWcrJyB4bWxucz1cInVybjpzY2hlbWFzLW1pY3Jvc29mdC5jb206dm1sXCIgY2xhc3M9XCJxdGlwLXZtbFwiICcrKHByb3BzfHwnJykrXG5cdFx0XHQnIHN0eWxlPVwiYmVoYXZpb3I6IHVybCgjZGVmYXVsdCNWTUwpOyAnKyhzdHlsZXx8JycpKyAnXCIgLz4nO1xuXHR9O1xufVxuXG4vLyBDYW52YXMgb25seSBkZWZpbml0aW9uc1xuZWxzZSB7XG5cdFBJWEVMX1JBVElPID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcblx0QkFDS0lOR19TVE9SRV9SQVRJTyA9IChmdW5jdGlvbigpIHtcblx0XHR2YXIgY29udGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQoJzJkJyk7XG5cdFx0cmV0dXJuIGNvbnRleHQuYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjb250ZXh0LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY29udGV4dC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG5cdFx0XHRcdGNvbnRleHQubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGNvbnRleHQub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMTtcblx0fSkoKTtcblx0U0NBTEUgPSBQSVhFTF9SQVRJTyAvIEJBQ0tJTkdfU1RPUkVfUkFUSU87XG59XG5cblxuZnVuY3Rpb24gVGlwKHF0aXAsIG9wdGlvbnMpIHtcblx0dGhpcy5fbnMgPSAndGlwJztcblx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0dGhpcy5vZmZzZXQgPSBvcHRpb25zLm9mZnNldDtcblx0dGhpcy5zaXplID0gWyBvcHRpb25zLndpZHRoLCBvcHRpb25zLmhlaWdodCBdO1xuXG5cdC8vIEluaXRpYWxpemVcblx0dGhpcy5xdGlwID0gcXRpcDtcblx0dGhpcy5pbml0KHF0aXApO1xufVxuXG4kLmV4dGVuZChUaXAucHJvdG90eXBlLCB7XG5cdGluaXQ6IGZ1bmN0aW9uKHF0aXApIHtcblx0XHR2YXIgY29udGV4dCwgdGlwO1xuXG5cdFx0Ly8gQ3JlYXRlIHRpcCBlbGVtZW50IGFuZCBwcmVwZW5kIHRvIHRoZSB0b29sdGlwXG5cdFx0dGlwID0gdGhpcy5lbGVtZW50ID0gcXRpcC5lbGVtZW50cy50aXAgPSAkKCc8ZGl2IC8+JywgeyAnY2xhc3MnOiBOQU1FU1BBQ0UrJy10aXAnIH0pLnByZXBlbmRUbyhxdGlwLnRvb2x0aXApO1xuXG5cdFx0Ly8gQ3JlYXRlIHRpcCBkcmF3aW5nIGVsZW1lbnQocylcblx0XHRpZihIQVNDQU5WQVMpIHtcblx0XHRcdC8vIHNhdmUoKSBhcyBzb29uIGFzIHdlIGNyZWF0ZSB0aGUgY2FudmFzIGVsZW1lbnQgc28gRkYyIGRvZXNuJ3QgYm9yayBvbiBvdXIgZmlyc3QgcmVzdG9yZSgpIVxuXHRcdFx0Y29udGV4dCA9ICQoJzxjYW52YXMgLz4nKS5hcHBlbmRUbyh0aGlzLmVsZW1lbnQpWzBdLmdldENvbnRleHQoJzJkJyk7XG5cblx0XHRcdC8vIFNldHVwIGNvbnN0YW50IHBhcmFtZXRlcnNcblx0XHRcdGNvbnRleHQubGluZUpvaW4gPSAnbWl0ZXInO1xuXHRcdFx0Y29udGV4dC5taXRlckxpbWl0ID0gMTAwMDAwO1xuXHRcdFx0Y29udGV4dC5zYXZlKCk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Y29udGV4dCA9IGNyZWF0ZVZNTCgnc2hhcGUnLCAnY29vcmRvcmlnaW49XCIwLDBcIicsICdwb3NpdGlvbjphYnNvbHV0ZTsnKTtcblx0XHRcdHRoaXMuZWxlbWVudC5odG1sKGNvbnRleHQgKyBjb250ZXh0KTtcblxuXHRcdFx0Ly8gUHJldmVudCBtb3VzaW5nIGRvd24gb24gdGhlIHRpcCBzaW5jZSBpdCBjYXVzZXMgcHJvYmxlbXMgd2l0aCAubGl2ZSgpIGhhbmRsaW5nIGluIElFIGR1ZSB0byBWTUxcblx0XHRcdHF0aXAuX2JpbmQoICQoJyonLCB0aXApLmFkZCh0aXApLCBbJ2NsaWNrJywgJ21vdXNlZG93biddLCBmdW5jdGlvbihldmVudCkgeyBldmVudC5zdG9wUHJvcGFnYXRpb24oKTsgfSwgdGhpcy5fbnMpO1xuXHRcdH1cblxuXHRcdC8vIEJpbmQgdXBkYXRlIGV2ZW50c1xuXHRcdHF0aXAuX2JpbmQocXRpcC50b29sdGlwLCAndG9vbHRpcG1vdmUnLCB0aGlzLnJlcG9zaXRpb24sIHRoaXMuX25zLCB0aGlzKTtcblxuXHRcdC8vIENyZWF0ZSBpdFxuXHRcdHRoaXMuY3JlYXRlKCk7XG5cdH0sXG5cblx0X3N3YXBEaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnNpemVbMF0gPSB0aGlzLm9wdGlvbnMuaGVpZ2h0O1xuXHRcdHRoaXMuc2l6ZVsxXSA9IHRoaXMub3B0aW9ucy53aWR0aDtcblx0fSxcblx0X3Jlc2V0RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5zaXplWzBdID0gdGhpcy5vcHRpb25zLndpZHRoO1xuXHRcdHRoaXMuc2l6ZVsxXSA9IHRoaXMub3B0aW9ucy5oZWlnaHQ7XG5cdH0sXG5cblx0X3VzZVRpdGxlOiBmdW5jdGlvbihjb3JuZXIpIHtcblx0XHR2YXIgdGl0bGViYXIgPSB0aGlzLnF0aXAuZWxlbWVudHMudGl0bGViYXI7XG5cdFx0cmV0dXJuIHRpdGxlYmFyICYmIChcblx0XHRcdGNvcm5lci55ID09PSBUT1AgfHwgY29ybmVyLnkgPT09IENFTlRFUiAmJiB0aGlzLmVsZW1lbnQucG9zaXRpb24oKS50b3AgKyB0aGlzLnNpemVbMV0gLyAyICsgdGhpcy5vcHRpb25zLm9mZnNldCA8IHRpdGxlYmFyLm91dGVySGVpZ2h0KFRSVUUpXG5cdFx0KTtcblx0fSxcblxuXHRfcGFyc2VDb3JuZXI6IGZ1bmN0aW9uKGNvcm5lcikge1xuXHRcdHZhciBteSA9IHRoaXMucXRpcC5vcHRpb25zLnBvc2l0aW9uLm15O1xuXG5cdFx0Ly8gRGV0ZWN0IGNvcm5lciBhbmQgbWltaWMgcHJvcGVydGllc1xuXHRcdGlmKGNvcm5lciA9PT0gRkFMU0UgfHwgbXkgPT09IEZBTFNFKSB7XG5cdFx0XHRjb3JuZXIgPSBGQUxTRTtcblx0XHR9XG5cdFx0ZWxzZSBpZihjb3JuZXIgPT09IFRSVUUpIHtcblx0XHRcdGNvcm5lciA9IG5ldyBDT1JORVIoIG15LnN0cmluZygpICk7XG5cdFx0fVxuXHRcdGVsc2UgaWYoIWNvcm5lci5zdHJpbmcpIHtcblx0XHRcdGNvcm5lciA9IG5ldyBDT1JORVIoY29ybmVyKTtcblx0XHRcdGNvcm5lci5maXhlZCA9IFRSVUU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvcm5lcjtcblx0fSxcblxuXHRfcGFyc2VXaWR0aDogZnVuY3Rpb24oY29ybmVyLCBzaWRlLCB1c2UpIHtcblx0XHR2YXIgZWxlbWVudHMgPSB0aGlzLnF0aXAuZWxlbWVudHMsXG5cdFx0XHRwcm9wID0gQk9SREVSICsgY2FtZWwoc2lkZSkgKyAnV2lkdGgnO1xuXG5cdFx0cmV0dXJuICh1c2UgPyBpbnRDc3ModXNlLCBwcm9wKSA6IFxuXHRcdFx0aW50Q3NzKGVsZW1lbnRzLmNvbnRlbnQsIHByb3ApIHx8XG5cdFx0XHRpbnRDc3ModGhpcy5fdXNlVGl0bGUoY29ybmVyKSAmJiBlbGVtZW50cy50aXRsZWJhciB8fCBlbGVtZW50cy5jb250ZW50LCBwcm9wKSB8fFxuXHRcdFx0aW50Q3NzKGVsZW1lbnRzLnRvb2x0aXAsIHByb3ApXG5cdFx0KSB8fCAwO1xuXHR9LFxuXG5cdF9wYXJzZVJhZGl1czogZnVuY3Rpb24oY29ybmVyKSB7XG5cdFx0dmFyIGVsZW1lbnRzID0gdGhpcy5xdGlwLmVsZW1lbnRzLFxuXHRcdFx0cHJvcCA9IEJPUkRFUiArIGNhbWVsKGNvcm5lci55KSArIGNhbWVsKGNvcm5lci54KSArICdSYWRpdXMnO1xuXG5cdFx0cmV0dXJuIEJST1dTRVIuaWUgPCA5ID8gMCA6XG5cdFx0XHRpbnRDc3ModGhpcy5fdXNlVGl0bGUoY29ybmVyKSAmJiBlbGVtZW50cy50aXRsZWJhciB8fCBlbGVtZW50cy5jb250ZW50LCBwcm9wKSB8fFxuXHRcdFx0aW50Q3NzKGVsZW1lbnRzLnRvb2x0aXAsIHByb3ApIHx8IDA7XG5cdH0sXG5cblx0X2ludmFsaWRDb2xvdXI6IGZ1bmN0aW9uKGVsZW0sIHByb3AsIGNvbXBhcmUpIHtcblx0XHR2YXIgdmFsID0gZWxlbS5jc3MocHJvcCk7XG5cdFx0cmV0dXJuICF2YWwgfHwgY29tcGFyZSAmJiB2YWwgPT09IGVsZW0uY3NzKGNvbXBhcmUpIHx8IElOVkFMSUQudGVzdCh2YWwpID8gRkFMU0UgOiB2YWw7XG5cdH0sXG5cblx0X3BhcnNlQ29sb3VyczogZnVuY3Rpb24oY29ybmVyKSB7XG5cdFx0dmFyIGVsZW1lbnRzID0gdGhpcy5xdGlwLmVsZW1lbnRzLFxuXHRcdFx0dGlwID0gdGhpcy5lbGVtZW50LmNzcygnY3NzVGV4dCcsICcnKSxcblx0XHRcdGJvcmRlclNpZGUgPSBCT1JERVIgKyBjYW1lbChjb3JuZXJbIGNvcm5lci5wcmVjZWRhbmNlIF0pICsgY2FtZWwoQ09MT1IpLFxuXHRcdFx0Y29sb3JFbGVtID0gdGhpcy5fdXNlVGl0bGUoY29ybmVyKSAmJiBlbGVtZW50cy50aXRsZWJhciB8fCBlbGVtZW50cy5jb250ZW50LFxuXHRcdFx0Y3NzID0gdGhpcy5faW52YWxpZENvbG91ciwgY29sb3IgPSBbXTtcblxuXHRcdC8vIEF0dGVtcHQgdG8gZGV0ZWN0IHRoZSBiYWNrZ3JvdW5kIGNvbG91ciBmcm9tIHZhcmlvdXMgZWxlbWVudHMsIGxlZnQtdG8tcmlnaHQgcHJlY2VkYW5jZVxuXHRcdGNvbG9yWzBdID0gY3NzKHRpcCwgQkdfQ09MT1IpIHx8IGNzcyhjb2xvckVsZW0sIEJHX0NPTE9SKSB8fCBjc3MoZWxlbWVudHMuY29udGVudCwgQkdfQ09MT1IpIHx8XG5cdFx0XHRjc3MoZWxlbWVudHMudG9vbHRpcCwgQkdfQ09MT1IpIHx8IHRpcC5jc3MoQkdfQ09MT1IpO1xuXG5cdFx0Ly8gQXR0ZW1wdCB0byBkZXRlY3QgdGhlIGNvcnJlY3QgYm9yZGVyIHNpZGUgY29sb3VyIGZyb20gdmFyaW91cyBlbGVtZW50cywgbGVmdC10by1yaWdodCBwcmVjZWRhbmNlXG5cdFx0Y29sb3JbMV0gPSBjc3ModGlwLCBib3JkZXJTaWRlLCBDT0xPUikgfHwgY3NzKGNvbG9yRWxlbSwgYm9yZGVyU2lkZSwgQ09MT1IpIHx8XG5cdFx0XHRjc3MoZWxlbWVudHMuY29udGVudCwgYm9yZGVyU2lkZSwgQ09MT1IpIHx8IGNzcyhlbGVtZW50cy50b29sdGlwLCBib3JkZXJTaWRlLCBDT0xPUikgfHwgZWxlbWVudHMudG9vbHRpcC5jc3MoYm9yZGVyU2lkZSk7XG5cblx0XHQvLyBSZXNldCBiYWNrZ3JvdW5kIGFuZCBib3JkZXIgY29sb3Vyc1xuXHRcdCQoJyonLCB0aXApLmFkZCh0aXApLmNzcygnY3NzVGV4dCcsIEJHX0NPTE9SKyc6JytUUkFOU1BBUkVOVCtJTVBPUlRBTlQrJzsnK0JPUkRFUisnOjAnK0lNUE9SVEFOVCsnOycpO1xuXG5cdFx0cmV0dXJuIGNvbG9yO1xuXHR9LFxuXG5cdF9jYWxjdWxhdGVTaXplOiBmdW5jdGlvbihjb3JuZXIpIHtcblx0XHR2YXIgeSA9IGNvcm5lci5wcmVjZWRhbmNlID09PSBZLFxuXHRcdFx0d2lkdGggPSB0aGlzLm9wdGlvbnMud2lkdGgsXG5cdFx0XHRoZWlnaHQgPSB0aGlzLm9wdGlvbnMuaGVpZ2h0LFxuXHRcdFx0aXNDZW50ZXIgPSBjb3JuZXIuYWJicmV2KCkgPT09ICdjJyxcblx0XHRcdGJhc2UgPSAoeSA/IHdpZHRoOiBoZWlnaHQpICogKGlzQ2VudGVyID8gMC41IDogMSksXG5cdFx0XHRwb3cgPSBNYXRoLnBvdyxcblx0XHRcdHJvdW5kID0gTWF0aC5yb3VuZCxcblx0XHRcdGJpZ0h5cCwgcmF0aW8sIHJlc3VsdCxcblxuXHRcdHNtYWxsSHlwID0gTWF0aC5zcXJ0KCBwb3coYmFzZSwgMikgKyBwb3coaGVpZ2h0LCAyKSApLFxuXHRcdGh5cCA9IFtcblx0XHRcdHRoaXMuYm9yZGVyIC8gYmFzZSAqIHNtYWxsSHlwLFxuXHRcdFx0dGhpcy5ib3JkZXIgLyBoZWlnaHQgKiBzbWFsbEh5cFxuXHRcdF07XG5cblx0XHRoeXBbMl0gPSBNYXRoLnNxcnQoIHBvdyhoeXBbMF0sIDIpIC0gcG93KHRoaXMuYm9yZGVyLCAyKSApO1xuXHRcdGh5cFszXSA9IE1hdGguc3FydCggcG93KGh5cFsxXSwgMikgLSBwb3codGhpcy5ib3JkZXIsIDIpICk7XG5cblx0XHRiaWdIeXAgPSBzbWFsbEh5cCArIGh5cFsyXSArIGh5cFszXSArIChpc0NlbnRlciA/IDAgOiBoeXBbMF0pO1xuXHRcdHJhdGlvID0gYmlnSHlwIC8gc21hbGxIeXA7XG5cblx0XHRyZXN1bHQgPSBbIHJvdW5kKHJhdGlvICogd2lkdGgpLCByb3VuZChyYXRpbyAqIGhlaWdodCkgXTtcblx0XHRyZXR1cm4geSA/IHJlc3VsdCA6IHJlc3VsdC5yZXZlcnNlKCk7XG5cdH0sXG5cblx0Ly8gVGlwIGNvb3JkaW5hdGVzIGNhbGN1bGF0b3Jcblx0X2NhbGN1bGF0ZVRpcDogZnVuY3Rpb24oY29ybmVyLCBzaXplLCBzY2FsZSkge1xuXHRcdHNjYWxlID0gc2NhbGUgfHwgMTtcblx0XHRzaXplID0gc2l6ZSB8fCB0aGlzLnNpemU7XG5cblx0XHR2YXIgd2lkdGggPSBzaXplWzBdICogc2NhbGUsXG5cdFx0XHRoZWlnaHQgPSBzaXplWzFdICogc2NhbGUsXG5cdFx0XHR3aWR0aDIgPSBNYXRoLmNlaWwod2lkdGggLyAyKSwgaGVpZ2h0MiA9IE1hdGguY2VpbChoZWlnaHQgLyAyKSxcblxuXHRcdC8vIERlZmluZSB0aXAgY29vcmRpbmF0ZXMgaW4gdGVybXMgb2YgaGVpZ2h0IGFuZCB3aWR0aCB2YWx1ZXNcblx0XHR0aXBzID0ge1xuXHRcdFx0YnI6XHRbMCwwLFx0XHR3aWR0aCxoZWlnaHQsXHR3aWR0aCwwXSxcblx0XHRcdGJsOlx0WzAsMCxcdFx0d2lkdGgsMCxcdFx0MCxoZWlnaHRdLFxuXHRcdFx0dHI6XHRbMCxoZWlnaHQsXHR3aWR0aCwwLFx0XHR3aWR0aCxoZWlnaHRdLFxuXHRcdFx0dGw6XHRbMCwwLFx0XHQwLGhlaWdodCxcdFx0d2lkdGgsaGVpZ2h0XSxcblx0XHRcdHRjOlx0WzAsaGVpZ2h0LFx0d2lkdGgyLDAsXHRcdHdpZHRoLGhlaWdodF0sXG5cdFx0XHRiYzpcdFswLDAsXHRcdHdpZHRoLDAsXHRcdHdpZHRoMixoZWlnaHRdLFxuXHRcdFx0cmM6XHRbMCwwLFx0XHR3aWR0aCxoZWlnaHQyLFx0MCxoZWlnaHRdLFxuXHRcdFx0bGM6XHRbd2lkdGgsMCxcdHdpZHRoLGhlaWdodCxcdDAsaGVpZ2h0Ml1cblx0XHR9O1xuXG5cdFx0Ly8gU2V0IGNvbW1vbiBzaWRlIHNoYXBlc1xuXHRcdHRpcHMubHQgPSB0aXBzLmJyOyB0aXBzLnJ0ID0gdGlwcy5ibDtcblx0XHR0aXBzLmxiID0gdGlwcy50cjsgdGlwcy5yYiA9IHRpcHMudGw7XG5cblx0XHRyZXR1cm4gdGlwc1sgY29ybmVyLmFiYnJldigpIF07XG5cdH0sXG5cblx0Ly8gVGlwIGNvb3JkaW5hdGVzIGRyYXdlciAoY2FudmFzKVxuXHRfZHJhd0Nvb3JkczogZnVuY3Rpb24oY29udGV4dCwgY29vcmRzKSB7XG5cdFx0Y29udGV4dC5iZWdpblBhdGgoKTtcblx0XHRjb250ZXh0Lm1vdmVUbyhjb29yZHNbMF0sIGNvb3Jkc1sxXSk7XG5cdFx0Y29udGV4dC5saW5lVG8oY29vcmRzWzJdLCBjb29yZHNbM10pO1xuXHRcdGNvbnRleHQubGluZVRvKGNvb3Jkc1s0XSwgY29vcmRzWzVdKTtcblx0XHRjb250ZXh0LmNsb3NlUGF0aCgpO1xuXHR9LFxuXG5cdGNyZWF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gRGV0ZXJtaW5lIHRpcCBjb3JuZXJcblx0XHR2YXIgYyA9IHRoaXMuY29ybmVyID0gKEhBU0NBTlZBUyB8fCBCUk9XU0VSLmllKSAmJiB0aGlzLl9wYXJzZUNvcm5lcih0aGlzLm9wdGlvbnMuY29ybmVyKTtcblxuXHRcdC8vIElmIHdlIGhhdmUgYSB0aXAgY29ybmVyLi4uXG5cdFx0dGhpcy5lbmFibGVkID0gISF0aGlzLmNvcm5lciAmJiB0aGlzLmNvcm5lci5hYmJyZXYoKSAhPT0gJ2MnO1xuXHRcdGlmKHRoaXMuZW5hYmxlZCkge1xuXHRcdFx0Ly8gQ2FjaGUgaXRcblx0XHRcdHRoaXMucXRpcC5jYWNoZS5jb3JuZXIgPSBjLmNsb25lKCk7XG5cblx0XHRcdC8vIENyZWF0ZSBpdFxuXHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHR9XG5cblx0XHQvLyBUb2dnbGUgdGlwIGVsZW1lbnRcblx0XHR0aGlzLmVsZW1lbnQudG9nZ2xlKHRoaXMuZW5hYmxlZCk7XG5cblx0XHRyZXR1cm4gdGhpcy5jb3JuZXI7XG5cdH0sXG5cblx0dXBkYXRlOiBmdW5jdGlvbihjb3JuZXIsIHBvc2l0aW9uKSB7XG5cdFx0aWYoIXRoaXMuZW5hYmxlZCkgeyByZXR1cm4gdGhpczsgfVxuXG5cdFx0dmFyIGVsZW1lbnRzID0gdGhpcy5xdGlwLmVsZW1lbnRzLFxuXHRcdFx0dGlwID0gdGhpcy5lbGVtZW50LFxuXHRcdFx0aW5uZXIgPSB0aXAuY2hpbGRyZW4oKSxcblx0XHRcdG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRjdXJTaXplID0gdGhpcy5zaXplLFxuXHRcdFx0bWltaWMgPSBvcHRpb25zLm1pbWljLFxuXHRcdFx0cm91bmQgPSBNYXRoLnJvdW5kLFxuXHRcdFx0Y29sb3IsIHByZWNlZGFuY2UsIGNvbnRleHQsXG5cdFx0XHRjb29yZHMsIGJpZ0Nvb3JkcywgdHJhbnNsYXRlLCBuZXdTaXplLCBib3JkZXI7XG5cblx0XHQvLyBSZS1kZXRlcm1pbmUgdGlwIGlmIG5vdCBhbHJlYWR5IHNldFxuXHRcdGlmKCFjb3JuZXIpIHsgY29ybmVyID0gdGhpcy5xdGlwLmNhY2hlLmNvcm5lciB8fCB0aGlzLmNvcm5lcjsgfVxuXG5cdFx0Ly8gVXNlIGNvcm5lciBwcm9wZXJ0eSBpZiB3ZSBkZXRlY3QgYW4gaW52YWxpZCBtaW1pYyB2YWx1ZVxuXHRcdGlmKG1pbWljID09PSBGQUxTRSkgeyBtaW1pYyA9IGNvcm5lcjsgfVxuXG5cdFx0Ly8gT3RoZXJ3aXNlIGluaGVyaXQgbWltaWMgcHJvcGVydGllcyBmcm9tIHRoZSBjb3JuZXIgb2JqZWN0IGFzIG5lY2Vzc2FyeVxuXHRcdGVsc2Uge1xuXHRcdFx0bWltaWMgPSBuZXcgQ09STkVSKG1pbWljKTtcblx0XHRcdG1pbWljLnByZWNlZGFuY2UgPSBjb3JuZXIucHJlY2VkYW5jZTtcblxuXHRcdFx0aWYobWltaWMueCA9PT0gJ2luaGVyaXQnKSB7IG1pbWljLnggPSBjb3JuZXIueDsgfVxuXHRcdFx0ZWxzZSBpZihtaW1pYy55ID09PSAnaW5oZXJpdCcpIHsgbWltaWMueSA9IGNvcm5lci55OyB9XG5cdFx0XHRlbHNlIGlmKG1pbWljLnggPT09IG1pbWljLnkpIHtcblx0XHRcdFx0bWltaWNbIGNvcm5lci5wcmVjZWRhbmNlIF0gPSBjb3JuZXJbIGNvcm5lci5wcmVjZWRhbmNlIF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHByZWNlZGFuY2UgPSBtaW1pYy5wcmVjZWRhbmNlO1xuXG5cdFx0Ly8gRW5zdXJlIHRoZSB0aXAgd2lkdGguaGVpZ2h0IGFyZSByZWxhdGl2ZSB0byB0aGUgdGlwIHBvc2l0aW9uXG5cdFx0aWYoY29ybmVyLnByZWNlZGFuY2UgPT09IFgpIHsgdGhpcy5fc3dhcERpbWVuc2lvbnMoKTsgfVxuXHRcdGVsc2UgeyB0aGlzLl9yZXNldERpbWVuc2lvbnMoKTsgfVxuXG5cdFx0Ly8gVXBkYXRlIG91ciBjb2xvdXJzXG5cdFx0Y29sb3IgPSB0aGlzLmNvbG9yID0gdGhpcy5fcGFyc2VDb2xvdXJzKGNvcm5lcik7XG5cblx0XHQvLyBEZXRlY3QgYm9yZGVyIHdpZHRoLCB0YWtpbmcgaW50byBhY2NvdW50IGNvbG91cnNcblx0XHRpZihjb2xvclsxXSAhPT0gVFJBTlNQQVJFTlQpIHtcblx0XHRcdC8vIEdyYWIgYm9yZGVyIHdpZHRoXG5cdFx0XHRib3JkZXIgPSB0aGlzLmJvcmRlciA9IHRoaXMuX3BhcnNlV2lkdGgoY29ybmVyLCBjb3JuZXJbY29ybmVyLnByZWNlZGFuY2VdKTtcblxuXHRcdFx0Ly8gSWYgYm9yZGVyIHdpZHRoIGlzbid0IHplcm8sIHVzZSBib3JkZXIgY29sb3IgYXMgZmlsbCBpZiBpdCdzIG5vdCBpbnZhbGlkICgxLjAgc3R5bGUgdGlwcylcblx0XHRcdGlmKG9wdGlvbnMuYm9yZGVyICYmIGJvcmRlciA8IDEgJiYgIUlOVkFMSUQudGVzdChjb2xvclsxXSkpIHsgY29sb3JbMF0gPSBjb2xvclsxXTsgfVxuXG5cdFx0XHQvLyBTZXQgYm9yZGVyIHdpZHRoICh1c2UgZGV0ZWN0ZWQgYm9yZGVyIHdpZHRoIGlmIG9wdGlvbnMuYm9yZGVyIGlzIHRydWUpXG5cdFx0XHR0aGlzLmJvcmRlciA9IGJvcmRlciA9IG9wdGlvbnMuYm9yZGVyICE9PSBUUlVFID8gb3B0aW9ucy5ib3JkZXIgOiBib3JkZXI7XG5cdFx0fVxuXG5cdFx0Ly8gQm9yZGVyIGNvbG91ciB3YXMgaW52YWxpZCwgc2V0IGJvcmRlciB0byB6ZXJvXG5cdFx0ZWxzZSB7IHRoaXMuYm9yZGVyID0gYm9yZGVyID0gMDsgfVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIHRpcCBzaXplXG5cdFx0bmV3U2l6ZSA9IHRoaXMuc2l6ZSA9IHRoaXMuX2NhbGN1bGF0ZVNpemUoY29ybmVyKTtcblx0XHR0aXAuY3NzKHtcblx0XHRcdHdpZHRoOiBuZXdTaXplWzBdLFxuXHRcdFx0aGVpZ2h0OiBuZXdTaXplWzFdLFxuXHRcdFx0bGluZUhlaWdodDogbmV3U2l6ZVsxXSsncHgnXG5cdFx0fSk7XG5cblx0XHQvLyBDYWxjdWxhdGUgdGlwIHRyYW5zbGF0aW9uXG5cdFx0aWYoY29ybmVyLnByZWNlZGFuY2UgPT09IFkpIHtcblx0XHRcdHRyYW5zbGF0ZSA9IFtcblx0XHRcdFx0cm91bmQobWltaWMueCA9PT0gTEVGVCA/IGJvcmRlciA6IG1pbWljLnggPT09IFJJR0hUID8gbmV3U2l6ZVswXSAtIGN1clNpemVbMF0gLSBib3JkZXIgOiAobmV3U2l6ZVswXSAtIGN1clNpemVbMF0pIC8gMiksXG5cdFx0XHRcdHJvdW5kKG1pbWljLnkgPT09IFRPUCA/IG5ld1NpemVbMV0gLSBjdXJTaXplWzFdIDogMClcblx0XHRcdF07XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dHJhbnNsYXRlID0gW1xuXHRcdFx0XHRyb3VuZChtaW1pYy54ID09PSBMRUZUID8gbmV3U2l6ZVswXSAtIGN1clNpemVbMF0gOiAwKSxcblx0XHRcdFx0cm91bmQobWltaWMueSA9PT0gVE9QID8gYm9yZGVyIDogbWltaWMueSA9PT0gQk9UVE9NID8gbmV3U2l6ZVsxXSAtIGN1clNpemVbMV0gLSBib3JkZXIgOiAobmV3U2l6ZVsxXSAtIGN1clNpemVbMV0pIC8gMilcblx0XHRcdF07XG5cdFx0fVxuXG5cdFx0Ly8gQ2FudmFzIGRyYXdpbmcgaW1wbGVtZW50YXRpb25cblx0XHRpZihIQVNDQU5WQVMpIHtcblx0XHRcdC8vIEdyYWIgY2FudmFzIGNvbnRleHQgYW5kIGNsZWFyL3NhdmUgaXRcblx0XHRcdGNvbnRleHQgPSBpbm5lclswXS5nZXRDb250ZXh0KCcyZCcpO1xuXHRcdFx0Y29udGV4dC5yZXN0b3JlKCk7IGNvbnRleHQuc2F2ZSgpO1xuXHRcdFx0Y29udGV4dC5jbGVhclJlY3QoMCwwLDYwMDAsNjAwMCk7XG5cblx0XHRcdC8vIENhbGN1bGF0ZSBjb29yZGluYXRlc1xuXHRcdFx0Y29vcmRzID0gdGhpcy5fY2FsY3VsYXRlVGlwKG1pbWljLCBjdXJTaXplLCBTQ0FMRSk7XG5cdFx0XHRiaWdDb29yZHMgPSB0aGlzLl9jYWxjdWxhdGVUaXAobWltaWMsIHRoaXMuc2l6ZSwgU0NBTEUpO1xuXG5cdFx0XHQvLyBTZXQgdGhlIGNhbnZhcyBzaXplIHVzaW5nIGNhbGN1bGF0ZWQgc2l6ZVxuXHRcdFx0aW5uZXIuYXR0cihXSURUSCwgbmV3U2l6ZVswXSAqIFNDQUxFKS5hdHRyKEhFSUdIVCwgbmV3U2l6ZVsxXSAqIFNDQUxFKTtcblx0XHRcdGlubmVyLmNzcyhXSURUSCwgbmV3U2l6ZVswXSkuY3NzKEhFSUdIVCwgbmV3U2l6ZVsxXSk7XG5cblx0XHRcdC8vIERyYXcgdGhlIG91dGVyLXN0cm9rZSB0aXBcblx0XHRcdHRoaXMuX2RyYXdDb29yZHMoY29udGV4dCwgYmlnQ29vcmRzKTtcblx0XHRcdGNvbnRleHQuZmlsbFN0eWxlID0gY29sb3JbMV07XG5cdFx0XHRjb250ZXh0LmZpbGwoKTtcblxuXHRcdFx0Ly8gRHJhdyB0aGUgYWN0dWFsIHRpcFxuXHRcdFx0Y29udGV4dC50cmFuc2xhdGUodHJhbnNsYXRlWzBdICogU0NBTEUsIHRyYW5zbGF0ZVsxXSAqIFNDQUxFKTtcblx0XHRcdHRoaXMuX2RyYXdDb29yZHMoY29udGV4dCwgY29vcmRzKTtcblx0XHRcdGNvbnRleHQuZmlsbFN0eWxlID0gY29sb3JbMF07XG5cdFx0XHRjb250ZXh0LmZpbGwoKTtcblx0XHR9XG5cblx0XHQvLyBWTUwgKElFIFByb3ByaWV0YXJ5IGltcGxlbWVudGF0aW9uKVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gQ2FsY3VsYXRlIGNvb3JkaW5hdGVzXG5cdFx0XHRjb29yZHMgPSB0aGlzLl9jYWxjdWxhdGVUaXAobWltaWMpO1xuXG5cdFx0XHQvLyBTZXR1cCBjb29yZGluYXRlcyBzdHJpbmdcblx0XHRcdGNvb3JkcyA9ICdtJyArIGNvb3Jkc1swXSArICcsJyArIGNvb3Jkc1sxXSArICcgbCcgKyBjb29yZHNbMl0gK1xuXHRcdFx0XHQnLCcgKyBjb29yZHNbM10gKyAnICcgKyBjb29yZHNbNF0gKyAnLCcgKyBjb29yZHNbNV0gKyAnIHhlJztcblxuXHRcdFx0Ly8gU2V0dXAgVk1MLXNwZWNpZmljIG9mZnNldCBmb3IgcGl4ZWwtcGVyZmVjdGlvblxuXHRcdFx0dHJhbnNsYXRlWzJdID0gYm9yZGVyICYmIC9eKHJ8YikvaS50ZXN0KGNvcm5lci5zdHJpbmcoKSkgP1xuXHRcdFx0XHRCUk9XU0VSLmllID09PSA4ID8gMiA6IDEgOiAwO1xuXG5cdFx0XHQvLyBTZXQgaW5pdGlhbCBDU1Ncblx0XHRcdGlubmVyLmNzcyh7XG5cdFx0XHRcdGNvb3Jkc2l6ZTogbmV3U2l6ZVswXStib3JkZXIgKyAnICcgKyBuZXdTaXplWzFdK2JvcmRlcixcblx0XHRcdFx0YW50aWFsaWFzOiAnJysobWltaWMuc3RyaW5nKCkuaW5kZXhPZihDRU5URVIpID4gLTEpLFxuXHRcdFx0XHRsZWZ0OiB0cmFuc2xhdGVbMF0gLSB0cmFuc2xhdGVbMl0gKiBOdW1iZXIocHJlY2VkYW5jZSA9PT0gWCksXG5cdFx0XHRcdHRvcDogdHJhbnNsYXRlWzFdIC0gdHJhbnNsYXRlWzJdICogTnVtYmVyKHByZWNlZGFuY2UgPT09IFkpLFxuXHRcdFx0XHR3aWR0aDogbmV3U2l6ZVswXSArIGJvcmRlcixcblx0XHRcdFx0aGVpZ2h0OiBuZXdTaXplWzFdICsgYm9yZGVyXG5cdFx0XHR9KVxuXHRcdFx0LmVhY2goZnVuY3Rpb24oaSkge1xuXHRcdFx0XHR2YXIgJHRoaXMgPSAkKHRoaXMpO1xuXG5cdFx0XHRcdC8vIFNldCBzaGFwZSBzcGVjaWZpYyBhdHRyaWJ1dGVzXG5cdFx0XHRcdCR0aGlzWyAkdGhpcy5wcm9wID8gJ3Byb3AnIDogJ2F0dHInIF0oe1xuXHRcdFx0XHRcdGNvb3Jkc2l6ZTogbmV3U2l6ZVswXStib3JkZXIgKyAnICcgKyBuZXdTaXplWzFdK2JvcmRlcixcblx0XHRcdFx0XHRwYXRoOiBjb29yZHMsXG5cdFx0XHRcdFx0ZmlsbGNvbG9yOiBjb2xvclswXSxcblx0XHRcdFx0XHRmaWxsZWQ6ICEhaSxcblx0XHRcdFx0XHRzdHJva2VkOiAhaVxuXHRcdFx0XHR9KVxuXHRcdFx0XHQudG9nZ2xlKCEhKGJvcmRlciB8fCBpKSk7XG5cblx0XHRcdFx0Ly8gQ2hlY2sgaWYgYm9yZGVyIGlzIGVuYWJsZWQgYW5kIGFkZCBzdHJva2UgZWxlbWVudFxuXHRcdFx0XHQhaSAmJiAkdGhpcy5odG1sKCBjcmVhdGVWTUwoXG5cdFx0XHRcdFx0J3N0cm9rZScsICd3ZWlnaHQ9XCInK2JvcmRlcioyKydweFwiIGNvbG9yPVwiJytjb2xvclsxXSsnXCIgbWl0ZXJsaW1pdD1cIjEwMDBcIiBqb2luc3R5bGU9XCJtaXRlclwiJ1xuXHRcdFx0XHQpICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvLyBPcGVyYSBidWcgIzM1NyAtIEluY29ycmVjdCB0aXAgcG9zaXRpb25cblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vQ3JhZ2E4OS9xVGlwMi9pc3N1ZXMvMzY3XG5cdFx0d2luZG93Lm9wZXJhICYmIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRlbGVtZW50cy50aXAuY3NzKHtcblx0XHRcdFx0ZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG5cdFx0XHRcdHZpc2liaWxpdHk6ICd2aXNpYmxlJ1xuXHRcdFx0fSk7XG5cdFx0fSwgMSk7XG5cblx0XHQvLyBQb3NpdGlvbiBpZiBuZWVkZWRcblx0XHRpZihwb3NpdGlvbiAhPT0gRkFMU0UpIHsgdGhpcy5jYWxjdWxhdGUoY29ybmVyLCBuZXdTaXplKTsgfVxuXHR9LFxuXG5cdGNhbGN1bGF0ZTogZnVuY3Rpb24oY29ybmVyLCBzaXplKSB7XG5cdFx0aWYoIXRoaXMuZW5hYmxlZCkgeyByZXR1cm4gRkFMU0U7IH1cblxuXHRcdHZhciBzZWxmID0gdGhpcyxcblx0XHRcdGVsZW1lbnRzID0gdGhpcy5xdGlwLmVsZW1lbnRzLFxuXHRcdFx0dGlwID0gdGhpcy5lbGVtZW50LFxuXHRcdFx0dXNlck9mZnNldCA9IHRoaXMub3B0aW9ucy5vZmZzZXQsXG5cdFx0XHRwb3NpdGlvbiA9IHt9LFxuXHRcdFx0cHJlY2VkYW5jZSwgY29ybmVycztcblxuXHRcdC8vIEluaGVyaXQgY29ybmVyIGlmIG5vdCBwcm92aWRlZFxuXHRcdGNvcm5lciA9IGNvcm5lciB8fCB0aGlzLmNvcm5lcjtcblx0XHRwcmVjZWRhbmNlID0gY29ybmVyLnByZWNlZGFuY2U7XG5cblx0XHQvLyBEZXRlcm1pbmUgd2hpY2ggdGlwIGRpbWVuc2lvbiB0byB1c2UgZm9yIGFkanVzdG1lbnRcblx0XHRzaXplID0gc2l6ZSB8fCB0aGlzLl9jYWxjdWxhdGVTaXplKGNvcm5lcik7XG5cblx0XHQvLyBTZXR1cCBjb3JuZXJzIGFuZCBvZmZzZXQgYXJyYXlcblx0XHRjb3JuZXJzID0gWyBjb3JuZXIueCwgY29ybmVyLnkgXTtcblx0XHRpZihwcmVjZWRhbmNlID09PSBYKSB7IGNvcm5lcnMucmV2ZXJzZSgpOyB9XG5cblx0XHQvLyBDYWxjdWxhdGUgdGlwIHBvc2l0aW9uXG5cdFx0JC5lYWNoKGNvcm5lcnMsIGZ1bmN0aW9uKGksIHNpZGUpIHtcblx0XHRcdHZhciBiLCBiYywgYnI7XG5cblx0XHRcdGlmKHNpZGUgPT09IENFTlRFUikge1xuXHRcdFx0XHRiID0gcHJlY2VkYW5jZSA9PT0gWSA/IExFRlQgOiBUT1A7XG5cdFx0XHRcdHBvc2l0aW9uWyBiIF0gPSAnNTAlJztcblx0XHRcdFx0cG9zaXRpb25bTUFSR0lOKyctJyArIGJdID0gLU1hdGgucm91bmQoc2l6ZVsgcHJlY2VkYW5jZSA9PT0gWSA/IDAgOiAxIF0gLyAyKSArIHVzZXJPZmZzZXQ7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0YiA9IHNlbGYuX3BhcnNlV2lkdGgoY29ybmVyLCBzaWRlLCBlbGVtZW50cy50b29sdGlwKTtcblx0XHRcdFx0YmMgPSBzZWxmLl9wYXJzZVdpZHRoKGNvcm5lciwgc2lkZSwgZWxlbWVudHMuY29udGVudCk7XG5cdFx0XHRcdGJyID0gc2VsZi5fcGFyc2VSYWRpdXMoY29ybmVyKTtcblxuXHRcdFx0XHRwb3NpdGlvblsgc2lkZSBdID0gTWF0aC5tYXgoLXNlbGYuYm9yZGVyLCBpID8gYmMgOiB1c2VyT2Zmc2V0ICsgKGJyID4gYiA/IGJyIDogLWIpKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEFkanVzdCBmb3IgdGlwIHNpemVcblx0XHRwb3NpdGlvblsgY29ybmVyW3ByZWNlZGFuY2VdIF0gLT0gc2l6ZVsgcHJlY2VkYW5jZSA9PT0gWCA/IDAgOiAxIF07XG5cblx0XHQvLyBTZXQgYW5kIHJldHVybiBuZXcgcG9zaXRpb25cblx0XHR0aXAuY3NzKHsgbWFyZ2luOiAnJywgdG9wOiAnJywgYm90dG9tOiAnJywgbGVmdDogJycsIHJpZ2h0OiAnJyB9KS5jc3MocG9zaXRpb24pO1xuXHRcdHJldHVybiBwb3NpdGlvbjtcblx0fSxcblxuXHRyZXBvc2l0aW9uOiBmdW5jdGlvbihldmVudCwgYXBpLCBwb3MpIHtcblx0XHRpZighdGhpcy5lbmFibGVkKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGNhY2hlID0gYXBpLmNhY2hlLFxuXHRcdFx0bmV3Q29ybmVyID0gdGhpcy5jb3JuZXIuY2xvbmUoKSxcblx0XHRcdGFkanVzdCA9IHBvcy5hZGp1c3RlZCxcblx0XHRcdG1ldGhvZCA9IGFwaS5vcHRpb25zLnBvc2l0aW9uLmFkanVzdC5tZXRob2Quc3BsaXQoJyAnKSxcblx0XHRcdGhvcml6b250YWwgPSBtZXRob2RbMF0sXG5cdFx0XHR2ZXJ0aWNhbCA9IG1ldGhvZFsxXSB8fCBtZXRob2RbMF0sXG5cdFx0XHRzaGlmdCA9IHsgbGVmdDogRkFMU0UsIHRvcDogRkFMU0UsIHg6IDAsIHk6IDAgfSxcblx0XHRcdG9mZnNldCwgY3NzID0ge30sIHByb3BzO1xuXG5cdFx0ZnVuY3Rpb24gc2hpZnRmbGlwKGRpcmVjdGlvbiwgcHJlY2VkYW5jZSwgcG9wcG9zaXRlLCBzaWRlLCBvcHBvc2l0ZSkge1xuXHRcdFx0Ly8gSG9yaXpvbnRhbCAtIFNoaWZ0IG9yIGZsaXAgbWV0aG9kXG5cdFx0XHRpZihkaXJlY3Rpb24gPT09IFNISUZUICYmIG5ld0Nvcm5lci5wcmVjZWRhbmNlID09PSBwcmVjZWRhbmNlICYmIGFkanVzdFtzaWRlXSAmJiBuZXdDb3JuZXJbcG9wcG9zaXRlXSAhPT0gQ0VOVEVSKSB7XG5cdFx0XHRcdG5ld0Nvcm5lci5wcmVjZWRhbmNlID0gbmV3Q29ybmVyLnByZWNlZGFuY2UgPT09IFggPyBZIDogWDtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYoZGlyZWN0aW9uICE9PSBTSElGVCAmJiBhZGp1c3Rbc2lkZV0pe1xuXHRcdFx0XHRuZXdDb3JuZXJbcHJlY2VkYW5jZV0gPSBuZXdDb3JuZXJbcHJlY2VkYW5jZV0gPT09IENFTlRFUiA/XG5cdFx0XHRcdFx0YWRqdXN0W3NpZGVdID4gMCA/IHNpZGUgOiBvcHBvc2l0ZSA6XG5cdFx0XHRcdFx0bmV3Q29ybmVyW3ByZWNlZGFuY2VdID09PSBzaWRlID8gb3Bwb3NpdGUgOiBzaWRlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHNoaWZ0b25seSh4eSwgc2lkZSwgb3Bwb3NpdGUpIHtcblx0XHRcdGlmKG5ld0Nvcm5lclt4eV0gPT09IENFTlRFUikge1xuXHRcdFx0XHRjc3NbTUFSR0lOKyctJytzaWRlXSA9IHNoaWZ0W3h5XSA9IG9mZnNldFtNQVJHSU4rJy0nK3NpZGVdIC0gYWRqdXN0W3NpZGVdO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHByb3BzID0gb2Zmc2V0W29wcG9zaXRlXSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0XHRbIGFkanVzdFtzaWRlXSwgLW9mZnNldFtzaWRlXSBdIDogWyAtYWRqdXN0W3NpZGVdLCBvZmZzZXRbc2lkZV0gXTtcblxuXHRcdFx0XHRpZiggKHNoaWZ0W3h5XSA9IE1hdGgubWF4KHByb3BzWzBdLCBwcm9wc1sxXSkpID4gcHJvcHNbMF0gKSB7XG5cdFx0XHRcdFx0cG9zW3NpZGVdIC09IGFkanVzdFtzaWRlXTtcblx0XHRcdFx0XHRzaGlmdFtzaWRlXSA9IEZBTFNFO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y3NzWyBvZmZzZXRbb3Bwb3NpdGVdICE9PSB1bmRlZmluZWQgPyBvcHBvc2l0ZSA6IHNpZGUgXSA9IHNoaWZ0W3h5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJZiBvdXIgdGlwIHBvc2l0aW9uIGlzbid0IGZpeGVkIGUuZy4gZG9lc24ndCBhZGp1c3Qgd2l0aCB2aWV3cG9ydC4uLlxuXHRcdGlmKHRoaXMuY29ybmVyLmZpeGVkICE9PSBUUlVFKSB7XG5cdFx0XHQvLyBQZXJmb3JtIHNoaWZ0L2ZsaXAgYWRqdXN0bWVudHNcblx0XHRcdHNoaWZ0ZmxpcChob3Jpem9udGFsLCBYLCBZLCBMRUZULCBSSUdIVCk7XG5cdFx0XHRzaGlmdGZsaXAodmVydGljYWwsIFksIFgsIFRPUCwgQk9UVE9NKTtcblxuXHRcdFx0Ly8gVXBkYXRlIGFuZCByZWRyYXcgdGhlIHRpcCBpZiBuZWVkZWQgKGNoZWNrIGNhY2hlZCBkZXRhaWxzIG9mIGxhc3QgZHJhd24gdGlwKVxuXHRcdFx0aWYobmV3Q29ybmVyLnN0cmluZygpICE9PSBjYWNoZS5jb3JuZXIuc3RyaW5nKCkgfHwgY2FjaGUuY29ybmVyVG9wICE9PSBhZGp1c3QudG9wIHx8IGNhY2hlLmNvcm5lckxlZnQgIT09IGFkanVzdC5sZWZ0KSB7XG5cdFx0XHRcdHRoaXMudXBkYXRlKG5ld0Nvcm5lciwgRkFMU0UpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldHVwIHRpcCBvZmZzZXQgcHJvcGVydGllc1xuXHRcdG9mZnNldCA9IHRoaXMuY2FsY3VsYXRlKG5ld0Nvcm5lcik7XG5cblx0XHQvLyBSZWFkanVzdCBvZmZzZXQgb2JqZWN0IHRvIG1ha2UgaXQgbGVmdC90b3Bcblx0XHRpZihvZmZzZXQucmlnaHQgIT09IHVuZGVmaW5lZCkgeyBvZmZzZXQubGVmdCA9IC1vZmZzZXQucmlnaHQ7IH1cblx0XHRpZihvZmZzZXQuYm90dG9tICE9PSB1bmRlZmluZWQpIHsgb2Zmc2V0LnRvcCA9IC1vZmZzZXQuYm90dG9tOyB9XG5cdFx0b2Zmc2V0LnVzZXIgPSB0aGlzLm9mZnNldDtcblxuXHRcdC8vIFBlcmZvcm0gc2hpZnQgYWRqdXN0bWVudHNcblx0XHRzaGlmdC5sZWZ0ID0gaG9yaXpvbnRhbCA9PT0gU0hJRlQgJiYgISFhZGp1c3QubGVmdDtcblx0XHRpZihzaGlmdC5sZWZ0KSB7XG5cdFx0XHRzaGlmdG9ubHkoWCwgTEVGVCwgUklHSFQpO1xuXHRcdH1cblx0XHRzaGlmdC50b3AgPSB2ZXJ0aWNhbCA9PT0gU0hJRlQgJiYgISFhZGp1c3QudG9wO1xuXHRcdGlmKHNoaWZ0LnRvcCkge1xuXHRcdFx0c2hpZnRvbmx5KFksIFRPUCwgQk9UVE9NKTtcblx0XHR9XG5cblx0XHQvKlxuXHRcdCogSWYgdGhlIHRpcCBpcyBhZGp1c3RlZCBpbiBib3RoIGRpbWVuc2lvbnMsIG9yIGluIGFcblx0XHQqIGRpcmVjdGlvbiB0aGF0IHdvdWxkIGNhdXNlIGl0IHRvIGJlIGFueXdoZXJlIGJ1dCB0aGVcblx0XHQqIG91dGVyIGJvcmRlciwgaGlkZSBpdCFcblx0XHQqL1xuXHRcdHRoaXMuZWxlbWVudC5jc3MoY3NzKS50b2dnbGUoXG5cdFx0XHQhKHNoaWZ0LnggJiYgc2hpZnQueSB8fCBuZXdDb3JuZXIueCA9PT0gQ0VOVEVSICYmIHNoaWZ0LnkgfHwgbmV3Q29ybmVyLnkgPT09IENFTlRFUiAmJiBzaGlmdC54KVxuXHRcdCk7XG5cblx0XHQvLyBBZGp1c3QgcG9zaXRpb24gdG8gYWNjb21vZGF0ZSB0aXAgZGltZW5zaW9uc1xuXHRcdHBvcy5sZWZ0IC09IG9mZnNldC5sZWZ0LmNoYXJBdCA/IG9mZnNldC51c2VyIDpcblx0XHRcdGhvcml6b250YWwgIT09IFNISUZUIHx8IHNoaWZ0LnRvcCB8fCAhc2hpZnQubGVmdCAmJiAhc2hpZnQudG9wID8gb2Zmc2V0LmxlZnQgKyB0aGlzLmJvcmRlciA6IDA7XG5cdFx0cG9zLnRvcCAtPSBvZmZzZXQudG9wLmNoYXJBdCA/IG9mZnNldC51c2VyIDpcblx0XHRcdHZlcnRpY2FsICE9PSBTSElGVCB8fCBzaGlmdC5sZWZ0IHx8ICFzaGlmdC5sZWZ0ICYmICFzaGlmdC50b3AgPyBvZmZzZXQudG9wICsgdGhpcy5ib3JkZXIgOiAwO1xuXG5cdFx0Ly8gQ2FjaGUgZGV0YWlsc1xuXHRcdGNhY2hlLmNvcm5lckxlZnQgPSBhZGp1c3QubGVmdDsgY2FjaGUuY29ybmVyVG9wID0gYWRqdXN0LnRvcDtcblx0XHRjYWNoZS5jb3JuZXIgPSBuZXdDb3JuZXIuY2xvbmUoKTtcblx0fSxcblxuXHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHQvLyBVbmJpbmQgZXZlbnRzXG5cdFx0dGhpcy5xdGlwLl91bmJpbmQodGhpcy5xdGlwLnRvb2x0aXAsIHRoaXMuX25zKTtcblxuXHRcdC8vIFJlbW92ZSB0aGUgdGlwIGVsZW1lbnQocylcblx0XHRpZih0aGlzLnF0aXAuZWxlbWVudHMudGlwKSB7XG5cdFx0XHR0aGlzLnF0aXAuZWxlbWVudHMudGlwLmZpbmQoJyonKVxuXHRcdFx0XHQucmVtb3ZlKCkuZW5kKCkucmVtb3ZlKCk7XG5cdFx0fVxuXHR9XG59KTtcblxuVElQID0gUExVR0lOUy50aXAgPSBmdW5jdGlvbihhcGkpIHtcblx0cmV0dXJuIG5ldyBUaXAoYXBpLCBhcGkub3B0aW9ucy5zdHlsZS50aXApO1xufTtcblxuLy8gSW5pdGlhbGl6ZSB0aXAgb24gcmVuZGVyXG5USVAuaW5pdGlhbGl6ZSA9ICdyZW5kZXInO1xuXG4vLyBTZXR1cCBwbHVnaW4gc2FuaXRpemF0aW9uIG9wdGlvbnNcblRJUC5zYW5pdGl6ZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0aWYob3B0aW9ucy5zdHlsZSAmJiAndGlwJyBpbiBvcHRpb25zLnN0eWxlKSB7XG5cdFx0dmFyIG9wdHMgPSBvcHRpb25zLnN0eWxlLnRpcDtcblx0XHRpZih0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHsgb3B0cyA9IG9wdGlvbnMuc3R5bGUudGlwID0geyBjb3JuZXI6IG9wdHMgfTsgfVxuXHRcdGlmKCEoL3N0cmluZ3xib29sZWFuL2kpLnRlc3QodHlwZW9mIG9wdHMuY29ybmVyKSkgeyBvcHRzLmNvcm5lciA9IFRSVUU7IH1cblx0fVxufTtcblxuLy8gQWRkIG5ldyBvcHRpb24gY2hlY2tzIGZvciB0aGUgcGx1Z2luXG5DSEVDS1MudGlwID0ge1xuXHQnXnBvc2l0aW9uLm15fHN0eWxlLnRpcC4oY29ybmVyfG1pbWljfGJvcmRlcikkJzogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gTWFrZSBzdXJlIGEgdGlwIGNhbiBiZSBkcmF3blxuXHRcdHRoaXMuY3JlYXRlKCk7XG5cblx0XHQvLyBSZXBvc2l0aW9uIHRoZSB0b29sdGlwXG5cdFx0dGhpcy5xdGlwLnJlcG9zaXRpb24oKTtcblx0fSxcblx0J15zdHlsZS50aXAuKGhlaWdodHx3aWR0aCkkJzogZnVuY3Rpb24ob2JqKSB7XG5cdFx0Ly8gUmUtc2V0IGRpbWVuc2lvbnMgYW5kIHJlZHJhdyB0aGUgdGlwXG5cdFx0dGhpcy5zaXplID0gWyBvYmoud2lkdGgsIG9iai5oZWlnaHQgXTtcblx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdFx0Ly8gUmVwb3NpdGlvbiB0aGUgdG9vbHRpcFxuXHRcdHRoaXMucXRpcC5yZXBvc2l0aW9uKCk7XG5cdH0sXG5cdCdeY29udGVudC50aXRsZXxzdHlsZS4oY2xhc3Nlc3x3aWRnZXQpJCc6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudXBkYXRlKCk7XG5cdH1cbn07XG5cbi8vIEV4dGVuZCBvcmlnaW5hbCBxVGlwIGRlZmF1bHRzXG4kLmV4dGVuZChUUlVFLCBRVElQLmRlZmF1bHRzLCB7XG5cdHN0eWxlOiB7XG5cdFx0dGlwOiB7XG5cdFx0XHRjb3JuZXI6IFRSVUUsXG5cdFx0XHRtaW1pYzogRkFMU0UsXG5cdFx0XHR3aWR0aDogNixcblx0XHRcdGhlaWdodDogNixcblx0XHRcdGJvcmRlcjogVFJVRSxcblx0XHRcdG9mZnNldDogMFxuXHRcdH1cblx0fVxufSk7XG47dmFyIE1PREFMLCBPVkVSTEFZLFxuXHRNT0RBTENMQVNTID0gJ3F0aXAtbW9kYWwnLFxuXHRNT0RBTFNFTEVDVE9SID0gJy4nK01PREFMQ0xBU1M7XG5cbk9WRVJMQVkgPSBmdW5jdGlvbigpXG57XG5cdHZhciBzZWxmID0gdGhpcyxcblx0XHRmb2N1c2FibGVFbGVtcyA9IHt9LFxuXHRcdGN1cnJlbnQsXG5cdFx0cHJldlN0YXRlLFxuXHRcdGVsZW07XG5cblx0Ly8gTW9kaWZpZWQgY29kZSBmcm9tIGpRdWVyeSBVSSAxLjEwLjAgc291cmNlXG5cdC8vIGh0dHA6Ly9jb2RlLmpxdWVyeS5jb20vdWkvMS4xMC4wL2pxdWVyeS11aS5qc1xuXHRmdW5jdGlvbiBmb2N1c2FibGUoZWxlbWVudCkge1xuXHRcdC8vIFVzZSB0aGUgZGVmaW5lZCBmb2N1c2FibGUgY2hlY2tlciB3aGVuIHBvc3NpYmxlXG5cdFx0aWYoJC5leHByWyc6J10uZm9jdXNhYmxlKSB7IHJldHVybiAkLmV4cHJbJzonXS5mb2N1c2FibGU7IH1cblxuXHRcdHZhciBpc1RhYkluZGV4Tm90TmFOID0gIWlzTmFOKCQuYXR0cihlbGVtZW50LCAndGFiaW5kZXgnKSksXG5cdFx0XHRub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUgJiYgZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0bWFwLCBtYXBOYW1lLCBpbWc7XG5cblx0XHRpZignYXJlYScgPT09IG5vZGVOYW1lKSB7XG5cdFx0XHRtYXAgPSBlbGVtZW50LnBhcmVudE5vZGU7XG5cdFx0XHRtYXBOYW1lID0gbWFwLm5hbWU7XG5cdFx0XHRpZighZWxlbWVudC5ocmVmIHx8ICFtYXBOYW1lIHx8IG1hcC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnbWFwJykge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpbWcgPSAkKCdpbWdbdXNlbWFwPSMnICsgbWFwTmFtZSArICddJylbMF07XG5cdFx0XHRyZXR1cm4gISFpbWcgJiYgaW1nLmlzKCc6dmlzaWJsZScpO1xuXHRcdH1cblxuXHRcdHJldHVybiAvaW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbnxvYmplY3QvLnRlc3QoIG5vZGVOYW1lICkgP1xuXHRcdFx0IWVsZW1lbnQuZGlzYWJsZWQgOlxuXHRcdFx0J2EnID09PSBub2RlTmFtZSA/XG5cdFx0XHRcdGVsZW1lbnQuaHJlZiB8fCBpc1RhYkluZGV4Tm90TmFOIDpcblx0XHRcdFx0aXNUYWJJbmRleE5vdE5hTlxuXHRcdDtcblx0fVxuXG5cdC8vIEZvY3VzIGlucHV0cyB1c2luZyBjYWNoZWQgZm9jdXNhYmxlIGVsZW1lbnRzIChzZWUgdXBkYXRlKCkpXG5cdGZ1bmN0aW9uIGZvY3VzSW5wdXRzKGJsdXJFbGVtcykge1xuXHRcdC8vIEJsdXJyaW5nIGJvZHkgZWxlbWVudCBpbiBJRSBjYXVzZXMgd2luZG93Lm9wZW4gd2luZG93cyB0byB1bmZvY3VzIVxuXHRcdGlmKGZvY3VzYWJsZUVsZW1zLmxlbmd0aCA8IDEgJiYgYmx1ckVsZW1zLmxlbmd0aCkgeyBibHVyRWxlbXMubm90KCdib2R5JykuYmx1cigpOyB9XG5cblx0XHQvLyBGb2N1cyB0aGUgaW5wdXRzXG5cdFx0ZWxzZSB7IGZvY3VzYWJsZUVsZW1zLmZpcnN0KCkuZm9jdXMoKTsgfVxuXHR9XG5cblx0Ly8gU3RlYWwgZm9jdXMgZnJvbSBlbGVtZW50cyBvdXRzaWRlIHRvb2x0aXBcblx0ZnVuY3Rpb24gc3RlYWxGb2N1cyhldmVudCkge1xuXHRcdGlmKCFlbGVtLmlzKCc6dmlzaWJsZScpKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIHRhcmdldCA9ICQoZXZlbnQudGFyZ2V0KSxcblx0XHRcdHRvb2x0aXAgPSBjdXJyZW50LnRvb2x0aXAsXG5cdFx0XHRjb250YWluZXIgPSB0YXJnZXQuY2xvc2VzdChTRUxFQ1RPUiksXG5cdFx0XHR0YXJnZXRPblRvcDtcblxuXHRcdC8vIERldGVybWluZSBpZiBpbnB1dCBjb250YWluZXIgdGFyZ2V0IGlzIGFib3ZlIHRoaXNcblx0XHR0YXJnZXRPblRvcCA9IGNvbnRhaW5lci5sZW5ndGggPCAxID8gRkFMU0UgOlxuXHRcdFx0cGFyc2VJbnQoY29udGFpbmVyWzBdLnN0eWxlLnpJbmRleCwgMTApID4gcGFyc2VJbnQodG9vbHRpcFswXS5zdHlsZS56SW5kZXgsIDEwKTtcblxuXHRcdC8vIElmIHdlJ3JlIHNob3dpbmcgYSBtb2RhbCwgYnV0IGZvY3VzIGhhcyBsYW5kZWQgb24gYW4gaW5wdXQgYmVsb3dcblx0XHQvLyB0aGlzIG1vZGFsLCBkaXZlcnQgZm9jdXMgdG8gdGhlIGZpcnN0IHZpc2libGUgaW5wdXQgaW4gdGhpcyBtb2RhbFxuXHRcdC8vIG9yIGlmIHdlIGNhbid0IGZpbmQgb25lLi4uIHRoZSB0b29sdGlwIGl0c2VsZlxuXHRcdGlmKCF0YXJnZXRPblRvcCAmJiB0YXJnZXQuY2xvc2VzdChTRUxFQ1RPUilbMF0gIT09IHRvb2x0aXBbMF0pIHtcblx0XHRcdGZvY3VzSW5wdXRzKHRhcmdldCk7XG5cdFx0fVxuXHR9XG5cblx0JC5leHRlbmQoc2VsZiwge1xuXHRcdGluaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gQ3JlYXRlIGRvY3VtZW50IG92ZXJsYXlcblx0XHRcdGVsZW0gPSBzZWxmLmVsZW0gPSAkKCc8ZGl2IC8+Jywge1xuXHRcdFx0XHRpZDogJ3F0aXAtb3ZlcmxheScsXG5cdFx0XHRcdGh0bWw6ICc8ZGl2PjwvZGl2PicsXG5cdFx0XHRcdG1vdXNlZG93bjogZnVuY3Rpb24oKSB7IHJldHVybiBGQUxTRTsgfVxuXHRcdFx0fSlcblx0XHRcdC5oaWRlKCk7XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBjYW4ndCBmb2N1cyBhbnl0aGluZyBvdXRzaWRlIHRoZSB0b29sdGlwXG5cdFx0XHQkKGRvY3VtZW50LmJvZHkpLmJpbmQoJ2ZvY3VzaW4nK01PREFMU0VMRUNUT1IsIHN0ZWFsRm9jdXMpO1xuXG5cdFx0XHQvLyBBcHBseSBrZXlib2FyZCBcIkVzY2FwZSBrZXlcIiBjbG9zZSBoYW5kbGVyXG5cdFx0XHQkKGRvY3VtZW50KS5iaW5kKCdrZXlkb3duJytNT0RBTFNFTEVDVE9SLCBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRpZihjdXJyZW50ICYmIGN1cnJlbnQub3B0aW9ucy5zaG93Lm1vZGFsLmVzY2FwZSAmJiBldmVudC5rZXlDb2RlID09PSAyNykge1xuXHRcdFx0XHRcdGN1cnJlbnQuaGlkZShldmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBBcHBseSBjbGljayBoYW5kbGVyIGZvciBibHVyIG9wdGlvblxuXHRcdFx0ZWxlbS5iaW5kKCdjbGljaycrTU9EQUxTRUxFQ1RPUiwgZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0aWYoY3VycmVudCAmJiBjdXJyZW50Lm9wdGlvbnMuc2hvdy5tb2RhbC5ibHVyKSB7XG5cdFx0XHRcdFx0Y3VycmVudC5oaWRlKGV2ZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHJldHVybiBzZWxmO1xuXHRcdH0sXG5cblx0XHR1cGRhdGU6IGZ1bmN0aW9uKGFwaSkge1xuXHRcdFx0Ly8gVXBkYXRlIGN1cnJlbnQgQVBJIHJlZmVyZW5jZVxuXHRcdFx0Y3VycmVudCA9IGFwaTtcblxuXHRcdFx0Ly8gVXBkYXRlIGZvY3VzYWJsZSBlbGVtZW50cyBpZiBlbmFibGVkXG5cdFx0XHRpZihhcGkub3B0aW9ucy5zaG93Lm1vZGFsLnN0ZWFsZm9jdXMgIT09IEZBTFNFKSB7XG5cdFx0XHRcdGZvY3VzYWJsZUVsZW1zID0gYXBpLnRvb2x0aXAuZmluZCgnKicpLmZpbHRlcihmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gZm9jdXNhYmxlKHRoaXMpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdGVsc2UgeyBmb2N1c2FibGVFbGVtcyA9IFtdOyB9XG5cdFx0fSxcblxuXHRcdHRvZ2dsZTogZnVuY3Rpb24oYXBpLCBzdGF0ZSwgZHVyYXRpb24pIHtcblx0XHRcdHZhciB0b29sdGlwID0gYXBpLnRvb2x0aXAsXG5cdFx0XHRcdG9wdGlvbnMgPSBhcGkub3B0aW9ucy5zaG93Lm1vZGFsLFxuXHRcdFx0XHRlZmZlY3QgPSBvcHRpb25zLmVmZmVjdCxcblx0XHRcdFx0dHlwZSA9IHN0YXRlID8gJ3Nob3cnOiAnaGlkZScsXG5cdFx0XHRcdHZpc2libGUgPSBlbGVtLmlzKCc6dmlzaWJsZScpLFxuXHRcdFx0XHR2aXNpYmxlTW9kYWxzID0gJChNT0RBTFNFTEVDVE9SKS5maWx0ZXIoJzp2aXNpYmxlOm5vdCg6YW5pbWF0ZWQpJykubm90KHRvb2x0aXApO1xuXG5cdFx0XHQvLyBTZXQgYWN0aXZlIHRvb2x0aXAgQVBJIHJlZmVyZW5jZVxuXHRcdFx0c2VsZi51cGRhdGUoYXBpKTtcblxuXHRcdFx0Ly8gSWYgdGhlIG1vZGFsIGNhbiBzdGVhbCB0aGUgZm9jdXMuLi5cblx0XHRcdC8vIEJsdXIgdGhlIGN1cnJlbnQgaXRlbSBhbmQgZm9jdXMgYW55dGhpbmcgaW4gdGhlIG1vZGFsIHdlIGFuXG5cdFx0XHRpZihzdGF0ZSAmJiBvcHRpb25zLnN0ZWFsZm9jdXMgIT09IEZBTFNFKSB7XG5cdFx0XHRcdGZvY3VzSW5wdXRzKCAkKCc6Zm9jdXMnKSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUb2dnbGUgYmFja2Ryb3AgY3Vyc29yIHN0eWxlIG9uIHNob3dcblx0XHRcdGVsZW0udG9nZ2xlQ2xhc3MoJ2JsdXJzJywgb3B0aW9ucy5ibHVyKTtcblxuXHRcdFx0Ly8gQXBwZW5kIHRvIGJvZHkgb24gc2hvd1xuXHRcdFx0aWYoc3RhdGUpIHtcblx0XHRcdFx0ZWxlbS5hcHBlbmRUbyhkb2N1bWVudC5ib2R5KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUHJldmVudCBtb2RhbCBmcm9tIGNvbmZsaWN0aW5nIHdpdGggc2hvdy5zb2xvLCBhbmQgZG9uJ3QgaGlkZSBiYWNrZHJvcCBpcyBvdGhlciBtb2RhbHMgYXJlIHZpc2libGVcblx0XHRcdGlmKGVsZW0uaXMoJzphbmltYXRlZCcpICYmIHZpc2libGUgPT09IHN0YXRlICYmIHByZXZTdGF0ZSAhPT0gRkFMU0UgfHwgIXN0YXRlICYmIHZpc2libGVNb2RhbHMubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiBzZWxmO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdG9wIGFsbCBhbmltYXRpb25zXG5cdFx0XHRlbGVtLnN0b3AoVFJVRSwgRkFMU0UpO1xuXG5cdFx0XHQvLyBVc2UgY3VzdG9tIGZ1bmN0aW9uIGlmIHByb3ZpZGVkXG5cdFx0XHRpZigkLmlzRnVuY3Rpb24oZWZmZWN0KSkge1xuXHRcdFx0XHRlZmZlY3QuY2FsbChlbGVtLCBzdGF0ZSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIG5vIGVmZmVjdCB0eXBlIGlzIHN1cHBsaWVkLCB1c2UgYSBzaW1wbGUgdG9nZ2xlXG5cdFx0XHRlbHNlIGlmKGVmZmVjdCA9PT0gRkFMU0UpIHtcblx0XHRcdFx0ZWxlbVsgdHlwZSBdKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFVzZSBiYXNpYyBmYWRlIGZ1bmN0aW9uXG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0ZWxlbS5mYWRlVG8oIHBhcnNlSW50KGR1cmF0aW9uLCAxMCkgfHwgOTAsIHN0YXRlID8gMSA6IDAsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmKCFzdGF0ZSkgeyBlbGVtLmhpZGUoKTsgfVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVzZXQgcG9zaXRpb24gYW5kIGRldGFjaCBmcm9tIGJvZHkgb24gaGlkZVxuXHRcdFx0aWYoIXN0YXRlKSB7XG5cdFx0XHRcdGVsZW0ucXVldWUoZnVuY3Rpb24obmV4dCkge1xuXHRcdFx0XHRcdGVsZW0uY3NzKHsgbGVmdDogJycsIHRvcDogJycgfSk7XG5cdFx0XHRcdFx0aWYoISQoTU9EQUxTRUxFQ1RPUikubGVuZ3RoKSB7IGVsZW0uZGV0YWNoKCk7IH1cblx0XHRcdFx0XHRuZXh0KCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWNoZSB0aGUgc3RhdGVcblx0XHRcdHByZXZTdGF0ZSA9IHN0YXRlO1xuXG5cdFx0XHQvLyBJZiB0aGUgdG9vbHRpcCBpcyBkZXN0cm95ZWQsIHNldCByZWZlcmVuY2UgdG8gbnVsbFxuXHRcdFx0aWYoY3VycmVudC5kZXN0cm95ZWQpIHsgY3VycmVudCA9IE5VTEw7IH1cblxuXHRcdFx0cmV0dXJuIHNlbGY7XG5cdFx0fVxuXHR9KTtcblxuXHRzZWxmLmluaXQoKTtcbn07XG5PVkVSTEFZID0gbmV3IE9WRVJMQVkoKTtcblxuZnVuY3Rpb24gTW9kYWwoYXBpLCBvcHRpb25zKSB7XG5cdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdHRoaXMuX25zID0gJy1tb2RhbCc7XG5cblx0dGhpcy5xdGlwID0gYXBpO1xuXHR0aGlzLmluaXQoYXBpKTtcbn1cblxuJC5leHRlbmQoTW9kYWwucHJvdG90eXBlLCB7XG5cdGluaXQ6IGZ1bmN0aW9uKHF0aXApIHtcblx0XHR2YXIgdG9vbHRpcCA9IHF0aXAudG9vbHRpcDtcblxuXHRcdC8vIElmIG1vZGFsIGlzIGRpc2FibGVkLi4uIHJldHVyblxuXHRcdGlmKCF0aGlzLm9wdGlvbnMub24pIHsgcmV0dXJuIHRoaXM7IH1cblxuXHRcdC8vIFNldCBvdmVybGF5IHJlZmVyZW5jZVxuXHRcdHF0aXAuZWxlbWVudHMub3ZlcmxheSA9IE9WRVJMQVkuZWxlbTtcblxuXHRcdC8vIEFkZCB1bmlxdWUgYXR0cmlidXRlIHNvIHdlIGNhbiBncmFiIG1vZGFsIHRvb2x0aXBzIGVhc2lseSB2aWEgYSBTRUxFQ1RPUiwgYW5kIHNldCB6LWluZGV4XG5cdFx0dG9vbHRpcC5hZGRDbGFzcyhNT0RBTENMQVNTKS5jc3MoJ3otaW5kZXgnLCBRVElQLm1vZGFsX3ppbmRleCArICQoTU9EQUxTRUxFQ1RPUikubGVuZ3RoKTtcblxuXHRcdC8vIEFwcGx5IG91ciBzaG93L2hpZGUvZm9jdXMgbW9kYWwgZXZlbnRzXG5cdFx0cXRpcC5fYmluZCh0b29sdGlwLCBbJ3Rvb2x0aXBzaG93JywgJ3Rvb2x0aXBoaWRlJ10sIGZ1bmN0aW9uKGV2ZW50LCBhcGksIGR1cmF0aW9uKSB7XG5cdFx0XHR2YXIgb0V2ZW50ID0gZXZlbnQub3JpZ2luYWxFdmVudDtcblxuXHRcdFx0Ly8gTWFrZSBzdXJlIG1vdXNlb3V0IGRvZXNuJ3QgdHJpZ2dlciBhIGhpZGUgd2hlbiBzaG93aW5nIHRoZSBtb2RhbCBhbmQgbW91c2luZyBvbnRvIGJhY2tkcm9wXG5cdFx0XHRpZihldmVudC50YXJnZXQgPT09IHRvb2x0aXBbMF0pIHtcblx0XHRcdFx0aWYob0V2ZW50ICYmIGV2ZW50LnR5cGUgPT09ICd0b29sdGlwaGlkZScgJiYgL21vdXNlKGxlYXZlfGVudGVyKS8udGVzdChvRXZlbnQudHlwZSkgJiYgJChvRXZlbnQucmVsYXRlZFRhcmdldCkuY2xvc2VzdChPVkVSTEFZLmVsZW1bMF0pLmxlbmd0aCkge1xuXHRcdFx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWVtcHR5ICovXG5cdFx0XHRcdFx0dHJ5IHsgZXZlbnQucHJldmVudERlZmF1bHQoKTsgfVxuXHRcdFx0XHRcdGNhdGNoKGUpIHt9XG5cdFx0XHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1lbXB0eSAqL1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYoIW9FdmVudCB8fCBvRXZlbnQgJiYgb0V2ZW50LnR5cGUgIT09ICd0b29sdGlwc29sbycpIHtcblx0XHRcdFx0XHR0aGlzLnRvZ2dsZShldmVudCwgZXZlbnQudHlwZSA9PT0gJ3Rvb2x0aXBzaG93JywgZHVyYXRpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSwgdGhpcy5fbnMsIHRoaXMpO1xuXG5cdFx0Ly8gQWRqdXN0IG1vZGFsIHotaW5kZXggb24gdG9vbHRpcCBmb2N1c1xuXHRcdHF0aXAuX2JpbmQodG9vbHRpcCwgJ3Rvb2x0aXBmb2N1cycsIGZ1bmN0aW9uKGV2ZW50LCBhcGkpIHtcblx0XHRcdC8vIElmIGZvY3VzIHdhcyBjYW5jZWxsZWQgYmVmb3JlIGl0IHJlYWNoZWQgdXMsIGRvbid0IGRvIGFueXRoaW5nXG5cdFx0XHRpZihldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCBldmVudC50YXJnZXQgIT09IHRvb2x0aXBbMF0pIHsgcmV0dXJuOyB9XG5cblx0XHRcdHZhciBxdGlwcyA9ICQoTU9EQUxTRUxFQ1RPUiksXG5cblx0XHRcdC8vIEtlZXAgdGhlIG1vZGFsJ3MgbG93ZXIgdGhhbiBvdGhlciwgcmVndWxhciBxdGlwc1xuXHRcdFx0bmV3SW5kZXggPSBRVElQLm1vZGFsX3ppbmRleCArIHF0aXBzLmxlbmd0aCxcblx0XHRcdGN1ckluZGV4ID0gcGFyc2VJbnQodG9vbHRpcFswXS5zdHlsZS56SW5kZXgsIDEwKTtcblxuXHRcdFx0Ly8gU2V0IG92ZXJsYXkgei1pbmRleFxuXHRcdFx0T1ZFUkxBWS5lbGVtWzBdLnN0eWxlLnpJbmRleCA9IG5ld0luZGV4IC0gMTtcblxuXHRcdFx0Ly8gUmVkdWNlIG1vZGFsIHotaW5kZXgncyBhbmQga2VlcCB0aGVtIHByb3Blcmx5IG9yZGVyZWRcblx0XHRcdHF0aXBzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmKHRoaXMuc3R5bGUuekluZGV4ID4gY3VySW5kZXgpIHtcblx0XHRcdFx0XHR0aGlzLnN0eWxlLnpJbmRleCAtPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gRmlyZSBibHVyIGV2ZW50IGZvciBmb2N1c2VkIHRvb2x0aXBcblx0XHRcdHF0aXBzLmZpbHRlcignLicgKyBDTEFTU19GT0NVUykucXRpcCgnYmx1cicsIGV2ZW50Lm9yaWdpbmFsRXZlbnQpO1xuXG5cdFx0XHQvLyBTZXQgdGhlIG5ldyB6LWluZGV4XG5cdFx0XHR0b29sdGlwLmFkZENsYXNzKENMQVNTX0ZPQ1VTKVswXS5zdHlsZS56SW5kZXggPSBuZXdJbmRleDtcblxuXHRcdFx0Ly8gU2V0IGN1cnJlbnRcblx0XHRcdE9WRVJMQVkudXBkYXRlKGFwaSk7XG5cblx0XHRcdC8vIFByZXZlbnQgZGVmYXVsdCBoYW5kbGluZ1xuXHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tZW1wdHkgKi9cblx0XHRcdHRyeSB7IGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IH1cblx0XHRcdGNhdGNoKGUpIHt9XG5cdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWVtcHR5ICovXG5cdFx0fSwgdGhpcy5fbnMsIHRoaXMpO1xuXG5cdFx0Ly8gRm9jdXMgYW55IG90aGVyIHZpc2libGUgbW9kYWxzIHdoZW4gdGhpcyBvbmUgaGlkZXNcblx0XHRxdGlwLl9iaW5kKHRvb2x0aXAsICd0b29sdGlwaGlkZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRpZihldmVudC50YXJnZXQgPT09IHRvb2x0aXBbMF0pIHtcblx0XHRcdFx0JChNT0RBTFNFTEVDVE9SKS5maWx0ZXIoJzp2aXNpYmxlJykubm90KHRvb2x0aXApLmxhc3QoKS5xdGlwKCdmb2N1cycsIGV2ZW50KTtcblx0XHRcdH1cblx0XHR9LCB0aGlzLl9ucywgdGhpcyk7XG5cdH0sXG5cblx0dG9nZ2xlOiBmdW5jdGlvbihldmVudCwgc3RhdGUsIGR1cmF0aW9uKSB7XG5cdFx0Ly8gTWFrZSBzdXJlIGRlZmF1bHQgZXZlbnQgaGFzbid0IGJlZW4gcHJldmVudGVkXG5cdFx0aWYoZXZlbnQgJiYgZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHsgcmV0dXJuIHRoaXM7IH1cblxuXHRcdC8vIFRvZ2dsZSBpdFxuXHRcdE9WRVJMQVkudG9nZ2xlKHRoaXMucXRpcCwgISFzdGF0ZSwgZHVyYXRpb24pO1xuXHR9LFxuXG5cdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIFJlbW92ZSBtb2RhbCBjbGFzc1xuXHRcdHRoaXMucXRpcC50b29sdGlwLnJlbW92ZUNsYXNzKE1PREFMQ0xBU1MpO1xuXG5cdFx0Ly8gUmVtb3ZlIGJvdW5kIGV2ZW50c1xuXHRcdHRoaXMucXRpcC5fdW5iaW5kKHRoaXMucXRpcC50b29sdGlwLCB0aGlzLl9ucyk7XG5cblx0XHQvLyBEZWxldGUgZWxlbWVudCByZWZlcmVuY2Vcblx0XHRPVkVSTEFZLnRvZ2dsZSh0aGlzLnF0aXAsIEZBTFNFKTtcblx0XHRkZWxldGUgdGhpcy5xdGlwLmVsZW1lbnRzLm92ZXJsYXk7XG5cdH1cbn0pO1xuXG5cbk1PREFMID0gUExVR0lOUy5tb2RhbCA9IGZ1bmN0aW9uKGFwaSkge1xuXHRyZXR1cm4gbmV3IE1vZGFsKGFwaSwgYXBpLm9wdGlvbnMuc2hvdy5tb2RhbCk7XG59O1xuXG4vLyBTZXR1cCBzYW5pdGl6dGlvbiBydWxlc1xuTU9EQUwuc2FuaXRpemUgPSBmdW5jdGlvbihvcHRzKSB7XG5cdGlmKG9wdHMuc2hvdykge1xuXHRcdGlmKHR5cGVvZiBvcHRzLnNob3cubW9kYWwgIT09ICdvYmplY3QnKSB7IG9wdHMuc2hvdy5tb2RhbCA9IHsgb246ICEhb3B0cy5zaG93Lm1vZGFsIH07IH1cblx0XHRlbHNlIGlmKHR5cGVvZiBvcHRzLnNob3cubW9kYWwub24gPT09ICd1bmRlZmluZWQnKSB7IG9wdHMuc2hvdy5tb2RhbC5vbiA9IFRSVUU7IH1cblx0fVxufTtcblxuLy8gQmFzZSB6LWluZGV4IGZvciBhbGwgbW9kYWwgdG9vbHRpcHMgKHVzZSBxVGlwIGNvcmUgei1pbmRleCBhcyBhIGJhc2UpXG4vKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cblFUSVAubW9kYWxfemluZGV4ID0gUVRJUC56aW5kZXggLSAyMDA7XG4vKiBlc2xpbnQtZW5hYmxlIGNhbWVsY2FzZSAqL1xuXG4vLyBQbHVnaW4gbmVlZHMgdG8gYmUgaW5pdGlhbGl6ZWQgb24gcmVuZGVyXG5NT0RBTC5pbml0aWFsaXplID0gJ3JlbmRlcic7XG5cbi8vIFNldHVwIG9wdGlvbiBzZXQgY2hlY2tzXG5DSEVDS1MubW9kYWwgPSB7XG5cdCdec2hvdy5tb2RhbC4ob258Ymx1cikkJzogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gSW5pdGlhbGlzZVxuXHRcdHRoaXMuZGVzdHJveSgpO1xuXHRcdHRoaXMuaW5pdCgpO1xuXG5cdFx0Ly8gU2hvdyB0aGUgbW9kYWwgaWYgbm90IHZpc2libGUgYWxyZWFkeSBhbmQgdG9vbHRpcCBpcyB2aXNpYmxlXG5cdFx0dGhpcy5xdGlwLmVsZW1zLm92ZXJsYXkudG9nZ2xlKFxuXHRcdFx0dGhpcy5xdGlwLnRvb2x0aXBbMF0ub2Zmc2V0V2lkdGggPiAwXG5cdFx0KTtcblx0fVxufTtcblxuLy8gRXh0ZW5kIG9yaWdpbmFsIGFwaSBkZWZhdWx0c1xuJC5leHRlbmQoVFJVRSwgUVRJUC5kZWZhdWx0cywge1xuXHRzaG93OiB7XG5cdFx0bW9kYWw6IHtcblx0XHRcdG9uOiBGQUxTRSxcblx0XHRcdGVmZmVjdDogVFJVRSxcblx0XHRcdGJsdXI6IFRSVUUsXG5cdFx0XHRzdGVhbGZvY3VzOiBUUlVFLFxuXHRcdFx0ZXNjYXBlOiBUUlVFXG5cdFx0fVxuXHR9XG59KTtcbjtQTFVHSU5TLnZpZXdwb3J0ID0gZnVuY3Rpb24oYXBpLCBwb3NpdGlvbiwgcG9zT3B0aW9ucywgdGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCwgZWxlbVdpZHRoLCBlbGVtSGVpZ2h0KVxue1xuXHR2YXIgdGFyZ2V0ID0gcG9zT3B0aW9ucy50YXJnZXQsXG5cdFx0dG9vbHRpcCA9IGFwaS5lbGVtZW50cy50b29sdGlwLFxuXHRcdG15ID0gcG9zT3B0aW9ucy5teSxcblx0XHRhdCA9IHBvc09wdGlvbnMuYXQsXG5cdFx0YWRqdXN0ID0gcG9zT3B0aW9ucy5hZGp1c3QsXG5cdFx0bWV0aG9kID0gYWRqdXN0Lm1ldGhvZC5zcGxpdCgnICcpLFxuXHRcdG1ldGhvZFggPSBtZXRob2RbMF0sXG5cdFx0bWV0aG9kWSA9IG1ldGhvZFsxXSB8fCBtZXRob2RbMF0sXG5cdFx0dmlld3BvcnQgPSBwb3NPcHRpb25zLnZpZXdwb3J0LFxuXHRcdGNvbnRhaW5lciA9IHBvc09wdGlvbnMuY29udGFpbmVyLFxuXHRcdGFkanVzdGVkID0geyBsZWZ0OiAwLCB0b3A6IDAgfSxcblx0XHRmaXhlZCwgbmV3TXksIGNvbnRhaW5lck9mZnNldCwgY29udGFpbmVyU3RhdGljLFxuXHRcdHZpZXdwb3J0V2lkdGgsIHZpZXdwb3J0SGVpZ2h0LCB2aWV3cG9ydFNjcm9sbCwgdmlld3BvcnRPZmZzZXQ7XG5cblx0Ly8gSWYgdmlld3BvcnQgaXMgbm90IGEgalF1ZXJ5IGVsZW1lbnQsIG9yIGl0J3MgdGhlIHdpbmRvdy9kb2N1bWVudCwgb3Igbm8gYWRqdXN0bWVudCBtZXRob2QgaXMgdXNlZC4uLiByZXR1cm5cblx0aWYoIXZpZXdwb3J0LmpxdWVyeSB8fCB0YXJnZXRbMF0gPT09IHdpbmRvdyB8fCB0YXJnZXRbMF0gPT09IGRvY3VtZW50LmJvZHkgfHwgYWRqdXN0Lm1ldGhvZCA9PT0gJ25vbmUnKSB7XG5cdFx0cmV0dXJuIGFkanVzdGVkO1xuXHR9XG5cblx0Ly8gQ2FjaCBjb250YWluZXIgZGV0YWlsc1xuXHRjb250YWluZXJPZmZzZXQgPSBjb250YWluZXIub2Zmc2V0KCkgfHwgYWRqdXN0ZWQ7XG5cdGNvbnRhaW5lclN0YXRpYyA9IGNvbnRhaW5lci5jc3MoJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnO1xuXG5cdC8vIENhY2hlIG91ciB2aWV3cG9ydCBkZXRhaWxzXG5cdGZpeGVkID0gdG9vbHRpcC5jc3MoJ3Bvc2l0aW9uJykgPT09ICdmaXhlZCc7XG5cdHZpZXdwb3J0V2lkdGggPSB2aWV3cG9ydFswXSA9PT0gd2luZG93ID8gdmlld3BvcnQud2lkdGgoKSA6IHZpZXdwb3J0Lm91dGVyV2lkdGgoRkFMU0UpO1xuXHR2aWV3cG9ydEhlaWdodCA9IHZpZXdwb3J0WzBdID09PSB3aW5kb3cgPyB2aWV3cG9ydC5oZWlnaHQoKSA6IHZpZXdwb3J0Lm91dGVySGVpZ2h0KEZBTFNFKTtcblx0dmlld3BvcnRTY3JvbGwgPSB7IGxlZnQ6IGZpeGVkID8gMCA6IHZpZXdwb3J0LnNjcm9sbExlZnQoKSwgdG9wOiBmaXhlZCA/IDAgOiB2aWV3cG9ydC5zY3JvbGxUb3AoKSB9O1xuXHR2aWV3cG9ydE9mZnNldCA9IHZpZXdwb3J0Lm9mZnNldCgpIHx8IGFkanVzdGVkO1xuXG5cdC8vIEdlbmVyaWMgY2FsY3VsYXRpb24gbWV0aG9kXG5cdGZ1bmN0aW9uIGNhbGN1bGF0ZShzaWRlLCBvdGhlclNpZGUsIHR5cGUsIGFkanVzdG1lbnQsIHNpZGUxLCBzaWRlMiwgbGVuZ3RoTmFtZSwgdGFyZ2V0TGVuZ3RoLCBlbGVtTGVuZ3RoKSB7XG5cdFx0dmFyIGluaXRpYWxQb3MgPSBwb3NpdGlvbltzaWRlMV0sXG5cdFx0XHRteVNpZGUgPSBteVtzaWRlXSxcblx0XHRcdGF0U2lkZSA9IGF0W3NpZGVdLFxuXHRcdFx0aXNTaGlmdCA9IHR5cGUgPT09IFNISUZULFxuXHRcdFx0bXlMZW5ndGggPSBteVNpZGUgPT09IHNpZGUxID8gZWxlbUxlbmd0aCA6IG15U2lkZSA9PT0gc2lkZTIgPyAtZWxlbUxlbmd0aCA6IC1lbGVtTGVuZ3RoIC8gMixcblx0XHRcdGF0TGVuZ3RoID0gYXRTaWRlID09PSBzaWRlMSA/IHRhcmdldExlbmd0aCA6IGF0U2lkZSA9PT0gc2lkZTIgPyAtdGFyZ2V0TGVuZ3RoIDogLXRhcmdldExlbmd0aCAvIDIsXG5cdFx0XHRzaWRlT2Zmc2V0ID0gdmlld3BvcnRTY3JvbGxbc2lkZTFdICsgdmlld3BvcnRPZmZzZXRbc2lkZTFdIC0gKGNvbnRhaW5lclN0YXRpYyA/IDAgOiBjb250YWluZXJPZmZzZXRbc2lkZTFdKSxcblx0XHRcdG92ZXJmbG93MSA9IHNpZGVPZmZzZXQgLSBpbml0aWFsUG9zLFxuXHRcdFx0b3ZlcmZsb3cyID0gaW5pdGlhbFBvcyArIGVsZW1MZW5ndGggLSAobGVuZ3RoTmFtZSA9PT0gV0lEVEggPyB2aWV3cG9ydFdpZHRoIDogdmlld3BvcnRIZWlnaHQpIC0gc2lkZU9mZnNldCxcblx0XHRcdG9mZnNldCA9IG15TGVuZ3RoIC0gKG15LnByZWNlZGFuY2UgPT09IHNpZGUgfHwgbXlTaWRlID09PSBteVtvdGhlclNpZGVdID8gYXRMZW5ndGggOiAwKSAtIChhdFNpZGUgPT09IENFTlRFUiA/IHRhcmdldExlbmd0aCAvIDIgOiAwKTtcblxuXHRcdC8vIHNoaWZ0XG5cdFx0aWYoaXNTaGlmdCkge1xuXHRcdFx0b2Zmc2V0ID0gKG15U2lkZSA9PT0gc2lkZTEgPyAxIDogLTEpICogbXlMZW5ndGg7XG5cblx0XHRcdC8vIEFkanVzdCBwb3NpdGlvbiBidXQga2VlcCBpdCB3aXRoaW4gdmlld3BvcnQgZGltZW5zaW9uc1xuXHRcdFx0cG9zaXRpb25bc2lkZTFdICs9IG92ZXJmbG93MSA+IDAgPyBvdmVyZmxvdzEgOiBvdmVyZmxvdzIgPiAwID8gLW92ZXJmbG93MiA6IDA7XG5cdFx0XHRwb3NpdGlvbltzaWRlMV0gPSBNYXRoLm1heChcblx0XHRcdFx0LWNvbnRhaW5lck9mZnNldFtzaWRlMV0gKyB2aWV3cG9ydE9mZnNldFtzaWRlMV0sXG5cdFx0XHRcdGluaXRpYWxQb3MgLSBvZmZzZXQsXG5cdFx0XHRcdE1hdGgubWluKFxuXHRcdFx0XHRcdE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0LWNvbnRhaW5lck9mZnNldFtzaWRlMV0gKyB2aWV3cG9ydE9mZnNldFtzaWRlMV0gKyAobGVuZ3RoTmFtZSA9PT0gV0lEVEggPyB2aWV3cG9ydFdpZHRoIDogdmlld3BvcnRIZWlnaHQpLFxuXHRcdFx0XHRcdFx0aW5pdGlhbFBvcyArIG9mZnNldFxuXHRcdFx0XHRcdCksXG5cdFx0XHRcdFx0cG9zaXRpb25bc2lkZTFdLFxuXG5cdFx0XHRcdFx0Ly8gTWFrZSBzdXJlIHdlIGRvbid0IGFkanVzdCBjb21wbGV0ZSBvZmYgdGhlIGVsZW1lbnQgd2hlbiB1c2luZyAnY2VudGVyJ1xuXHRcdFx0XHRcdG15U2lkZSA9PT0gJ2NlbnRlcicgPyBpbml0aWFsUG9zIC0gbXlMZW5ndGggOiAxRTlcblx0XHRcdFx0KVxuXHRcdFx0KTtcblxuXHRcdH1cblxuXHRcdC8vIGZsaXAvZmxpcGludmVydFxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gVXBkYXRlIGFkanVzdG1lbnQgYW1vdW50IGRlcGVuZGluZyBvbiBpZiB1c2luZyBmbGlwaW52ZXJ0IG9yIGZsaXBcblx0XHRcdGFkanVzdG1lbnQgKj0gdHlwZSA9PT0gRkxJUElOVkVSVCA/IDIgOiAwO1xuXG5cdFx0XHQvLyBDaGVjayBmb3Igb3ZlcmZsb3cgb24gdGhlIGxlZnQvdG9wXG5cdFx0XHRpZihvdmVyZmxvdzEgPiAwICYmIChteVNpZGUgIT09IHNpZGUxIHx8IG92ZXJmbG93MiA+IDApKSB7XG5cdFx0XHRcdHBvc2l0aW9uW3NpZGUxXSAtPSBvZmZzZXQgKyBhZGp1c3RtZW50O1xuXHRcdFx0XHRuZXdNeS5pbnZlcnQoc2lkZSwgc2lkZTEpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDaGVjayBmb3Igb3ZlcmZsb3cgb24gdGhlIGJvdHRvbS9yaWdodFxuXHRcdFx0ZWxzZSBpZihvdmVyZmxvdzIgPiAwICYmIChteVNpZGUgIT09IHNpZGUyIHx8IG92ZXJmbG93MSA+IDApICApIHtcblx0XHRcdFx0cG9zaXRpb25bc2lkZTFdIC09IChteVNpZGUgPT09IENFTlRFUiA/IC1vZmZzZXQgOiBvZmZzZXQpICsgYWRqdXN0bWVudDtcblx0XHRcdFx0bmV3TXkuaW52ZXJ0KHNpZGUsIHNpZGUyKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlIGhhdmVuJ3QgbWFkZSB0aGluZ3Mgd29yc2Ugd2l0aCB0aGUgYWRqdXN0bWVudCBhbmQgcmVzZXQgaWYgc29cblx0XHRcdGlmKHBvc2l0aW9uW3NpZGUxXSA8IHZpZXdwb3J0U2Nyb2xsW3NpZGUxXSAmJiAtcG9zaXRpb25bc2lkZTFdID4gb3ZlcmZsb3cyKSB7XG5cdFx0XHRcdHBvc2l0aW9uW3NpZGUxXSA9IGluaXRpYWxQb3M7IG5ld015ID0gbXkuY2xvbmUoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcG9zaXRpb25bc2lkZTFdIC0gaW5pdGlhbFBvcztcblx0fVxuXG5cdC8vIFNldCBuZXdNeSBpZiB1c2luZyBmbGlwIG9yIGZsaXBpbnZlcnQgbWV0aG9kc1xuXHRpZihtZXRob2RYICE9PSAnc2hpZnQnIHx8IG1ldGhvZFkgIT09ICdzaGlmdCcpIHsgbmV3TXkgPSBteS5jbG9uZSgpOyB9XG5cblx0Ly8gQWRqdXN0IHBvc2l0aW9uIGJhc2VkIG9udmlld3BvcnQgYW5kIGFkanVzdG1lbnQgb3B0aW9uc1xuXHRhZGp1c3RlZCA9IHtcblx0XHRsZWZ0OiBtZXRob2RYICE9PSAnbm9uZScgPyBjYWxjdWxhdGUoIFgsIFksIG1ldGhvZFgsIGFkanVzdC54LCBMRUZULCBSSUdIVCwgV0lEVEgsIHRhcmdldFdpZHRoLCBlbGVtV2lkdGggKSA6IDAsXG5cdFx0dG9wOiBtZXRob2RZICE9PSAnbm9uZScgPyBjYWxjdWxhdGUoIFksIFgsIG1ldGhvZFksIGFkanVzdC55LCBUT1AsIEJPVFRPTSwgSEVJR0hULCB0YXJnZXRIZWlnaHQsIGVsZW1IZWlnaHQgKSA6IDAsXG5cdFx0bXk6IG5ld015XG5cdH07XG5cblx0cmV0dXJuIGFkanVzdGVkO1xufTtcbjtQTFVHSU5TLnBvbHlzID0ge1xuXHQvLyBQT0xZIGFyZWEgY29vcmRpbmF0ZSBjYWxjdWxhdG9yXG5cdC8vXHRTcGVjaWFsIHRoYW5rcyB0byBFZCBDcmFkb2NrIGZvciBoZWxwaW5nIG91dCB3aXRoIHRoaXMuXG5cdC8vXHRVc2VzIGEgYmluYXJ5IHNlYXJjaCBhbGdvcml0aG0gdG8gZmluZCBzdWl0YWJsZSBjb29yZGluYXRlcy5cblx0cG9seWdvbjogZnVuY3Rpb24oYmFzZUNvb3JkcywgY29ybmVyKSB7XG5cdFx0dmFyIHJlc3VsdCA9IHtcblx0XHRcdHdpZHRoOiAwLCBoZWlnaHQ6IDAsXG5cdFx0XHRwb3NpdGlvbjoge1xuXHRcdFx0XHR0b3A6IDFlMTAsIHJpZ2h0OiAwLFxuXHRcdFx0XHRib3R0b206IDAsIGxlZnQ6IDFlMTBcblx0XHRcdH0sXG5cdFx0XHRhZGp1c3RhYmxlOiBGQUxTRVxuXHRcdH0sXG5cdFx0aSA9IDAsIG5leHQsXG5cdFx0Y29vcmRzID0gW10sXG5cdFx0Y29tcGFyZVggPSAxLCBjb21wYXJlWSA9IDEsXG5cdFx0cmVhbFggPSAwLCByZWFsWSA9IDAsXG5cdFx0bmV3V2lkdGgsIG5ld0hlaWdodDtcblxuXHRcdC8vIEZpcnN0IHBhc3MsIHNhbml0aXplIGNvb3JkcyBhbmQgZGV0ZXJtaW5lIG91dGVyIGVkZ2VzXG5cdFx0aSA9IGJhc2VDb29yZHMubGVuZ3RoOyBcblx0XHR3aGlsZShpLS0pIHtcblx0XHRcdG5leHQgPSBbIHBhcnNlSW50KGJhc2VDb29yZHNbLS1pXSwgMTApLCBwYXJzZUludChiYXNlQ29vcmRzW2krMV0sIDEwKSBdO1xuXG5cdFx0XHRpZihuZXh0WzBdID4gcmVzdWx0LnBvc2l0aW9uLnJpZ2h0KXsgcmVzdWx0LnBvc2l0aW9uLnJpZ2h0ID0gbmV4dFswXTsgfVxuXHRcdFx0aWYobmV4dFswXSA8IHJlc3VsdC5wb3NpdGlvbi5sZWZ0KXsgcmVzdWx0LnBvc2l0aW9uLmxlZnQgPSBuZXh0WzBdOyB9XG5cdFx0XHRpZihuZXh0WzFdID4gcmVzdWx0LnBvc2l0aW9uLmJvdHRvbSl7IHJlc3VsdC5wb3NpdGlvbi5ib3R0b20gPSBuZXh0WzFdOyB9XG5cdFx0XHRpZihuZXh0WzFdIDwgcmVzdWx0LnBvc2l0aW9uLnRvcCl7IHJlc3VsdC5wb3NpdGlvbi50b3AgPSBuZXh0WzFdOyB9XG5cblx0XHRcdGNvb3Jkcy5wdXNoKG5leHQpO1xuXHRcdH1cblxuXHRcdC8vIENhbGN1bGF0ZSBoZWlnaHQgYW5kIHdpZHRoIGZyb20gb3V0ZXIgZWRnZXNcblx0XHRuZXdXaWR0aCA9IHJlc3VsdC53aWR0aCA9IE1hdGguYWJzKHJlc3VsdC5wb3NpdGlvbi5yaWdodCAtIHJlc3VsdC5wb3NpdGlvbi5sZWZ0KTtcblx0XHRuZXdIZWlnaHQgPSByZXN1bHQuaGVpZ2h0ID0gTWF0aC5hYnMocmVzdWx0LnBvc2l0aW9uLmJvdHRvbSAtIHJlc3VsdC5wb3NpdGlvbi50b3ApO1xuXG5cdFx0Ly8gSWYgaXQncyB0aGUgY2VudGVyIGNvcm5lci4uLlxuXHRcdGlmKGNvcm5lci5hYmJyZXYoKSA9PT0gJ2MnKSB7XG5cdFx0XHRyZXN1bHQucG9zaXRpb24gPSB7XG5cdFx0XHRcdGxlZnQ6IHJlc3VsdC5wb3NpdGlvbi5sZWZ0ICsgcmVzdWx0LndpZHRoIC8gMixcblx0XHRcdFx0dG9wOiByZXN1bHQucG9zaXRpb24udG9wICsgcmVzdWx0LmhlaWdodCAvIDJcblx0XHRcdH07XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gU2Vjb25kIHBhc3MsIHVzZSBhIGJpbmFyeSBzZWFyY2ggYWxnb3JpdGhtIHRvIGxvY2F0ZSBtb3N0IHN1aXRhYmxlIGNvb3JkaW5hdGVcblx0XHRcdHdoaWxlKG5ld1dpZHRoID4gMCAmJiBuZXdIZWlnaHQgPiAwICYmIGNvbXBhcmVYID4gMCAmJiBjb21wYXJlWSA+IDApXG5cdFx0XHR7XG5cdFx0XHRcdG5ld1dpZHRoID0gTWF0aC5mbG9vcihuZXdXaWR0aCAvIDIpO1xuXHRcdFx0XHRuZXdIZWlnaHQgPSBNYXRoLmZsb29yKG5ld0hlaWdodCAvIDIpO1xuXG5cdFx0XHRcdGlmKGNvcm5lci54ID09PSBMRUZUKXsgY29tcGFyZVggPSBuZXdXaWR0aDsgfVxuXHRcdFx0XHRlbHNlIGlmKGNvcm5lci54ID09PSBSSUdIVCl7IGNvbXBhcmVYID0gcmVzdWx0LndpZHRoIC0gbmV3V2lkdGg7IH1cblx0XHRcdFx0ZWxzZXsgY29tcGFyZVggKz0gTWF0aC5mbG9vcihuZXdXaWR0aCAvIDIpOyB9XG5cblx0XHRcdFx0aWYoY29ybmVyLnkgPT09IFRPUCl7IGNvbXBhcmVZID0gbmV3SGVpZ2h0OyB9XG5cdFx0XHRcdGVsc2UgaWYoY29ybmVyLnkgPT09IEJPVFRPTSl7IGNvbXBhcmVZID0gcmVzdWx0LmhlaWdodCAtIG5ld0hlaWdodDsgfVxuXHRcdFx0XHRlbHNleyBjb21wYXJlWSArPSBNYXRoLmZsb29yKG5ld0hlaWdodCAvIDIpOyB9XG5cblx0XHRcdFx0aSA9IGNvb3Jkcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlKGktLSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmKGNvb3Jkcy5sZW5ndGggPCAyKXsgYnJlYWs7IH1cblxuXHRcdFx0XHRcdHJlYWxYID0gY29vcmRzW2ldWzBdIC0gcmVzdWx0LnBvc2l0aW9uLmxlZnQ7XG5cdFx0XHRcdFx0cmVhbFkgPSBjb29yZHNbaV1bMV0gLSByZXN1bHQucG9zaXRpb24udG9wO1xuXG5cdFx0XHRcdFx0aWYoXG5cdFx0XHRcdFx0XHRjb3JuZXIueCA9PT0gTEVGVCAmJiByZWFsWCA+PSBjb21wYXJlWCB8fFxuXHRcdFx0XHRcdFx0Y29ybmVyLnggPT09IFJJR0hUICYmIHJlYWxYIDw9IGNvbXBhcmVYIHx8XG5cdFx0XHRcdFx0XHRjb3JuZXIueCA9PT0gQ0VOVEVSICYmIChyZWFsWCA8IGNvbXBhcmVYIHx8IHJlYWxYID4gcmVzdWx0LndpZHRoIC0gY29tcGFyZVgpIHx8XG5cdFx0XHRcdFx0XHRjb3JuZXIueSA9PT0gVE9QICYmIHJlYWxZID49IGNvbXBhcmVZIHx8XG5cdFx0XHRcdFx0XHRjb3JuZXIueSA9PT0gQk9UVE9NICYmIHJlYWxZIDw9IGNvbXBhcmVZIHx8XG5cdFx0XHRcdFx0XHRjb3JuZXIueSA9PT0gQ0VOVEVSICYmIChyZWFsWSA8IGNvbXBhcmVZIHx8IHJlYWxZID4gcmVzdWx0LmhlaWdodCAtIGNvbXBhcmVZKSkge1xuXHRcdFx0XHRcdFx0Y29vcmRzLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJlc3VsdC5wb3NpdGlvbiA9IHsgbGVmdDogY29vcmRzWzBdWzBdLCB0b3A6IGNvb3Jkc1swXVsxXSB9O1xuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH0sXG5cblx0cmVjdDogZnVuY3Rpb24oYXgsIGF5LCBieCwgYnkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0d2lkdGg6IE1hdGguYWJzKGJ4IC0gYXgpLFxuXHRcdFx0aGVpZ2h0OiBNYXRoLmFicyhieSAtIGF5KSxcblx0XHRcdHBvc2l0aW9uOiB7XG5cdFx0XHRcdGxlZnQ6IE1hdGgubWluKGF4LCBieCksXG5cdFx0XHRcdHRvcDogTWF0aC5taW4oYXksIGJ5KVxuXHRcdFx0fVxuXHRcdH07XG5cdH0sXG5cblx0X2FuZ2xlczoge1xuXHRcdHRjOiAzIC8gMiwgdHI6IDcgLyA0LCB0bDogNSAvIDQsXG5cdFx0YmM6IDEgLyAyLCBicjogMSAvIDQsIGJsOiAzIC8gNCxcblx0XHRyYzogMiwgbGM6IDEsIGM6IDBcblx0fSxcblx0ZWxsaXBzZTogZnVuY3Rpb24oY3gsIGN5LCByeCwgcnksIGNvcm5lcikge1xuXHRcdHZhciBjID0gUExVR0lOUy5wb2x5cy5fYW5nbGVzWyBjb3JuZXIuYWJicmV2KCkgXSxcblx0XHRcdHJ4YyA9IGMgPT09IDAgPyAwIDogcnggKiBNYXRoLmNvcyggYyAqIE1hdGguUEkgKSxcblx0XHRcdHJ5cyA9IHJ5ICogTWF0aC5zaW4oIGMgKiBNYXRoLlBJICk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0d2lkdGg6IHJ4ICogMiAtIE1hdGguYWJzKHJ4YyksXG5cdFx0XHRoZWlnaHQ6IHJ5ICogMiAtIE1hdGguYWJzKHJ5cyksXG5cdFx0XHRwb3NpdGlvbjoge1xuXHRcdFx0XHRsZWZ0OiBjeCArIHJ4Yyxcblx0XHRcdFx0dG9wOiBjeSArIHJ5c1xuXHRcdFx0fSxcblx0XHRcdGFkanVzdGFibGU6IEZBTFNFXG5cdFx0fTtcblx0fSxcblx0Y2lyY2xlOiBmdW5jdGlvbihjeCwgY3ksIHIsIGNvcm5lcikge1xuXHRcdHJldHVybiBQTFVHSU5TLnBvbHlzLmVsbGlwc2UoY3gsIGN5LCByLCByLCBjb3JuZXIpO1xuXHR9XG59O1xuO1BMVUdJTlMuc3ZnID0gZnVuY3Rpb24oYXBpLCBzdmcsIGNvcm5lcilcbntcblx0dmFyIGVsZW0gPSBzdmdbMF0sXG5cdFx0cm9vdCA9ICQoZWxlbS5vd25lclNWR0VsZW1lbnQpLFxuXHRcdG93bmVyRG9jdW1lbnQgPSBlbGVtLm93bmVyRG9jdW1lbnQsXG5cdFx0c3Ryb2tlV2lkdGgyID0gKHBhcnNlSW50KHN2Zy5jc3MoJ3N0cm9rZS13aWR0aCcpLCAxMCkgfHwgMCkgLyAyLFxuXHRcdGZyYW1lT2Zmc2V0LCBtdHgsIHRyYW5zZm9ybWVkLFxuXHRcdGxlbiwgbmV4dCwgaSwgcG9pbnRzLFxuXHRcdHJlc3VsdCwgcG9zaXRpb247XG5cblx0Ly8gQXNjZW5kIHRoZSBwYXJlbnROb2RlIGNoYWluIHVudGlsIHdlIGZpbmQgYW4gZWxlbWVudCB3aXRoIGdldEJCb3goKVxuXHR3aGlsZSghZWxlbS5nZXRCQm94KSB7IGVsZW0gPSBlbGVtLnBhcmVudE5vZGU7IH1cblx0aWYoIWVsZW0uZ2V0QkJveCB8fCAhZWxlbS5wYXJlbnROb2RlKSB7IHJldHVybiBGQUxTRTsgfVxuXG5cdC8vIERldGVybWluZSB3aGljaCBzaGFwZSBjYWxjdWxhdGlvbiB0byB1c2Vcblx0c3dpdGNoKGVsZW0ubm9kZU5hbWUpIHtcblx0XHRjYXNlICdlbGxpcHNlJzpcblx0XHRjYXNlICdjaXJjbGUnOlxuXHRcdFx0cmVzdWx0ID0gUExVR0lOUy5wb2x5cy5lbGxpcHNlKFxuXHRcdFx0XHRlbGVtLmN4LmJhc2VWYWwudmFsdWUsXG5cdFx0XHRcdGVsZW0uY3kuYmFzZVZhbC52YWx1ZSxcblx0XHRcdFx0KGVsZW0ucnggfHwgZWxlbS5yKS5iYXNlVmFsLnZhbHVlICsgc3Ryb2tlV2lkdGgyLFxuXHRcdFx0XHQoZWxlbS5yeSB8fCBlbGVtLnIpLmJhc2VWYWwudmFsdWUgKyBzdHJva2VXaWR0aDIsXG5cdFx0XHRcdGNvcm5lclxuXHRcdFx0KTtcblx0XHRicmVhaztcblxuXHRcdGNhc2UgJ2xpbmUnOlxuXHRcdGNhc2UgJ3BvbHlnb24nOlxuXHRcdGNhc2UgJ3BvbHlsaW5lJzpcblx0XHRcdC8vIERldGVybWluZSBwb2ludHMgb2JqZWN0IChsaW5lIGhhcyBub25lLCBzbyBtaW1pYyB1c2luZyBhcnJheSlcblx0XHRcdHBvaW50cyA9IGVsZW0ucG9pbnRzIHx8IFtcblx0XHRcdFx0eyB4OiBlbGVtLngxLmJhc2VWYWwudmFsdWUsIHk6IGVsZW0ueTEuYmFzZVZhbC52YWx1ZSB9LFxuXHRcdFx0XHR7IHg6IGVsZW0ueDIuYmFzZVZhbC52YWx1ZSwgeTogZWxlbS55Mi5iYXNlVmFsLnZhbHVlIH1cblx0XHRcdF07XG5cblx0XHRcdGZvcihyZXN1bHQgPSBbXSwgaSA9IC0xLCBsZW4gPSBwb2ludHMubnVtYmVyT2ZJdGVtcyB8fCBwb2ludHMubGVuZ3RoOyArK2kgPCBsZW47KSB7XG5cdFx0XHRcdG5leHQgPSBwb2ludHMuZ2V0SXRlbSA/IHBvaW50cy5nZXRJdGVtKGkpIDogcG9pbnRzW2ldO1xuXHRcdFx0XHRyZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIFtuZXh0LngsIG5leHQueV0pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXN1bHQgPSBQTFVHSU5TLnBvbHlzLnBvbHlnb24ocmVzdWx0LCBjb3JuZXIpO1xuXHRcdGJyZWFrO1xuXG5cdFx0Ly8gVW5rbm93biBzaGFwZSBvciByZWN0YW5nbGU/IFVzZSBib3VuZGluZyBib3hcblx0XHRkZWZhdWx0OlxuXHRcdFx0cmVzdWx0ID0gZWxlbS5nZXRCQm94KCk7XG5cdFx0XHRyZXN1bHQgPSB7XG5cdFx0XHRcdHdpZHRoOiByZXN1bHQud2lkdGgsXG5cdFx0XHRcdGhlaWdodDogcmVzdWx0LmhlaWdodCxcblx0XHRcdFx0cG9zaXRpb246IHtcblx0XHRcdFx0XHRsZWZ0OiByZXN1bHQueCxcblx0XHRcdFx0XHR0b3A6IHJlc3VsdC55XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0YnJlYWs7XG5cdH1cblxuXHQvLyBTaG9ydGN1dCBhc3NpZ25tZW50c1xuXHRwb3NpdGlvbiA9IHJlc3VsdC5wb3NpdGlvbjtcblx0cm9vdCA9IHJvb3RbMF07XG5cblx0Ly8gQ29udmVydCBwb3NpdGlvbiBpbnRvIGEgcGl4ZWwgdmFsdWVcblx0aWYocm9vdC5jcmVhdGVTVkdQb2ludCkge1xuXHRcdG10eCA9IGVsZW0uZ2V0U2NyZWVuQ1RNKCk7XG5cdFx0cG9pbnRzID0gcm9vdC5jcmVhdGVTVkdQb2ludCgpO1xuXG5cdFx0cG9pbnRzLnggPSBwb3NpdGlvbi5sZWZ0O1xuXHRcdHBvaW50cy55ID0gcG9zaXRpb24udG9wO1xuXHRcdHRyYW5zZm9ybWVkID0gcG9pbnRzLm1hdHJpeFRyYW5zZm9ybSggbXR4ICk7XG5cdFx0cG9zaXRpb24ubGVmdCA9IHRyYW5zZm9ybWVkLng7XG5cdFx0cG9zaXRpb24udG9wID0gdHJhbnNmb3JtZWQueTtcblx0fVxuXG5cdC8vIENoZWNrIHRoZSBlbGVtZW50IGlzIG5vdCBpbiBhIGNoaWxkIGRvY3VtZW50LCBhbmQgaWYgc28sIGFkanVzdCBmb3IgZnJhbWUgZWxlbWVudHMgb2Zmc2V0XG5cdGlmKG93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50ICYmIGFwaS5wb3NpdGlvbi50YXJnZXQgIT09ICdtb3VzZScpIHtcblx0XHRmcmFtZU9mZnNldCA9ICQoKG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgb3duZXJEb2N1bWVudC5wYXJlbnRXaW5kb3cpLmZyYW1lRWxlbWVudCkub2Zmc2V0KCk7XG5cdFx0aWYoZnJhbWVPZmZzZXQpIHtcblx0XHRcdHBvc2l0aW9uLmxlZnQgKz0gZnJhbWVPZmZzZXQubGVmdDtcblx0XHRcdHBvc2l0aW9uLnRvcCArPSBmcmFtZU9mZnNldC50b3A7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWRqdXN0IGJ5IHNjcm9sbCBvZmZzZXQgb2Ygb3duZXIgZG9jdW1lbnRcblx0b3duZXJEb2N1bWVudCA9ICQob3duZXJEb2N1bWVudCk7XG5cdHBvc2l0aW9uLmxlZnQgKz0gb3duZXJEb2N1bWVudC5zY3JvbGxMZWZ0KCk7XG5cdHBvc2l0aW9uLnRvcCArPSBvd25lckRvY3VtZW50LnNjcm9sbFRvcCgpO1xuXG5cdHJldHVybiByZXN1bHQ7XG59O1xuO1BMVUdJTlMuaW1hZ2VtYXAgPSBmdW5jdGlvbihhcGksIGFyZWEsIGNvcm5lcilcbntcblx0aWYoIWFyZWEuanF1ZXJ5KSB7IGFyZWEgPSAkKGFyZWEpOyB9XG5cblx0dmFyIHNoYXBlID0gKGFyZWEuYXR0cignc2hhcGUnKSB8fCAncmVjdCcpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgncG9seScsICdwb2x5Z29uJyksXG5cdFx0aW1hZ2UgPSAkKCdpbWdbdXNlbWFwPVwiIycrYXJlYS5wYXJlbnQoJ21hcCcpLmF0dHIoJ25hbWUnKSsnXCJdJyksXG5cdFx0Y29vcmRzU3RyaW5nID0gJC50cmltKGFyZWEuYXR0cignY29vcmRzJykpLFxuXHRcdGNvb3Jkc0FycmF5ID0gY29vcmRzU3RyaW5nLnJlcGxhY2UoLywkLywgJycpLnNwbGl0KCcsJyksXG5cdFx0aW1hZ2VPZmZzZXQsIGNvb3JkcywgaSwgcmVzdWx0LCBsZW47XG5cblx0Ly8gSWYgd2UgY2FuJ3QgZmluZCB0aGUgaW1hZ2UgdXNpbmcgdGhlIG1hcC4uLlxuXHRpZighaW1hZ2UubGVuZ3RoKSB7IHJldHVybiBGQUxTRTsgfVxuXG5cdC8vIFBhc3MgY29vcmRpbmF0ZXMgc3RyaW5nIGlmIHBvbHlnb25cblx0aWYoc2hhcGUgPT09ICdwb2x5Z29uJykge1xuXHRcdHJlc3VsdCA9IFBMVUdJTlMucG9seXMucG9seWdvbihjb29yZHNBcnJheSwgY29ybmVyKTtcblx0fVxuXG5cdC8vIE90aGVyd2lzZSBwYXJzZSB0aGUgY29vcmRpbmF0ZXMgYW5kIHBhc3MgdGhlbSBhcyBhcmd1bWVudHNcblx0ZWxzZSBpZihQTFVHSU5TLnBvbHlzW3NoYXBlXSkge1xuXHRcdGZvcihpID0gLTEsIGxlbiA9IGNvb3Jkc0FycmF5Lmxlbmd0aCwgY29vcmRzID0gW107ICsraSA8IGxlbjspIHtcblx0XHRcdGNvb3Jkcy5wdXNoKCBwYXJzZUludChjb29yZHNBcnJheVtpXSwgMTApICk7XG5cdFx0fVxuXG5cdFx0cmVzdWx0ID0gUExVR0lOUy5wb2x5c1tzaGFwZV0uYXBwbHkoXG5cdFx0XHR0aGlzLCBjb29yZHMuY29uY2F0KGNvcm5lcilcblx0XHQpO1xuXHR9XG5cblx0Ly8gSWYgbm8gc2hhcHJlIGNhbGN1bGF0aW9uIG1ldGhvZCB3YXMgZm91bmQsIHJldHVybiBmYWxzZVxuXHRlbHNlIHsgcmV0dXJuIEZBTFNFOyB9XG5cblx0Ly8gTWFrZSBzdXJlIHdlIGFjY291bnQgZm9yIHBhZGRpbmcgYW5kIGJvcmRlcnMgb24gdGhlIGltYWdlXG5cdGltYWdlT2Zmc2V0ID0gaW1hZ2Uub2Zmc2V0KCk7XG5cdGltYWdlT2Zmc2V0LmxlZnQgKz0gTWF0aC5jZWlsKChpbWFnZS5vdXRlcldpZHRoKEZBTFNFKSAtIGltYWdlLndpZHRoKCkpIC8gMik7XG5cdGltYWdlT2Zmc2V0LnRvcCArPSBNYXRoLmNlaWwoKGltYWdlLm91dGVySGVpZ2h0KEZBTFNFKSAtIGltYWdlLmhlaWdodCgpKSAvIDIpO1xuXG5cdC8vIEFkZCBpbWFnZSBwb3NpdGlvbiB0byBvZmZzZXQgY29vcmRpbmF0ZXNcblx0cmVzdWx0LnBvc2l0aW9uLmxlZnQgKz0gaW1hZ2VPZmZzZXQubGVmdDtcblx0cmVzdWx0LnBvc2l0aW9uLnRvcCArPSBpbWFnZU9mZnNldC50b3A7XG5cblx0cmV0dXJuIHJlc3VsdDtcbn07XG47dmFyIElFNixcblxuLypcbiAqIEJHSUZyYW1lIGFkYXB0aW9uIChodHRwOi8vcGx1Z2lucy5qcXVlcnkuY29tL3Byb2plY3QvYmdpZnJhbWUpXG4gKiBTcGVjaWFsIHRoYW5rcyB0byBCcmFuZG9uIEFhcm9uXG4gKi9cbkJHSUZSQU1FID0gJzxpZnJhbWUgY2xhc3M9XCJxdGlwLWJnaWZyYW1lXCIgZnJhbWVib3JkZXI9XCIwXCIgdGFiaW5kZXg9XCItMVwiIHNyYz1cImphdmFzY3JpcHQ6XFwnXFwnO1wiICcgK1xuXHQnIHN0eWxlPVwiZGlzcGxheTpibG9jazsgcG9zaXRpb246YWJzb2x1dGU7IHotaW5kZXg6LTE7IGZpbHRlcjphbHBoYShvcGFjaXR5PTApOyAnICtcblx0XHQnLW1zLWZpbHRlcjpcInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5BbHBoYShPcGFjaXR5PTApXCI7XCI+PC9pZnJhbWU+JztcblxuZnVuY3Rpb24gSWU2KGFwaSkge1xuXHR0aGlzLl9ucyA9ICdpZTYnO1xuXG5cdHRoaXMucXRpcCA9IGFwaTtcblx0dGhpcy5pbml0KGFwaSk7XG59XG5cbiQuZXh0ZW5kKEllNi5wcm90b3R5cGUsIHtcblx0X3Njcm9sbCA6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvdmVybGF5ID0gdGhpcy5xdGlwLmVsZW1lbnRzLm92ZXJsYXk7XG5cdFx0b3ZlcmxheSAmJiAob3ZlcmxheVswXS5zdHlsZS50b3AgPSAkKHdpbmRvdykuc2Nyb2xsVG9wKCkgKyAncHgnKTtcblx0fSxcblxuXHRpbml0OiBmdW5jdGlvbihxdGlwKSB7XG5cdFx0dmFyIHRvb2x0aXAgPSBxdGlwLnRvb2x0aXA7XG5cblx0XHQvLyBDcmVhdGUgdGhlIEJHSUZyYW1lIGVsZW1lbnQgaWYgbmVlZGVkXG5cdFx0aWYoJCgnc2VsZWN0LCBvYmplY3QnKS5sZW5ndGggPCAxKSB7XG5cdFx0XHR0aGlzLmJnaWZyYW1lID0gcXRpcC5lbGVtZW50cy5iZ2lmcmFtZSA9ICQoQkdJRlJBTUUpLmFwcGVuZFRvKHRvb2x0aXApO1xuXG5cdFx0XHQvLyBVcGRhdGUgQkdJRnJhbWUgb24gdG9vbHRpcCBtb3ZlXG5cdFx0XHRxdGlwLl9iaW5kKHRvb2x0aXAsICd0b29sdGlwbW92ZScsIHRoaXMuYWRqdXN0QkdJRnJhbWUsIHRoaXMuX25zLCB0aGlzKTtcblx0XHR9XG5cblx0XHQvLyByZWRyYXcoKSBjb250YWluZXIgZm9yIHdpZHRoL2hlaWdodCBjYWxjdWxhdGlvbnNcblx0XHR0aGlzLnJlZHJhd0NvbnRhaW5lciA9ICQoJzxkaXYvPicsIHsgaWQ6IE5BTUVTUEFDRSsnLXJjb250YWluZXInIH0pXG5cdFx0XHQuYXBwZW5kVG8oZG9jdW1lbnQuYm9keSk7XG5cblx0XHQvLyBGaXh1cCBtb2RhbCBwbHVnaW4gaWYgcHJlc2VudCB0b29cblx0XHRpZiggcXRpcC5lbGVtZW50cy5vdmVybGF5ICYmIHF0aXAuZWxlbWVudHMub3ZlcmxheS5hZGRDbGFzcygncXRpcG1vZGFsLWllNmZpeCcpICkge1xuXHRcdFx0cXRpcC5fYmluZCh3aW5kb3csIFsnc2Nyb2xsJywgJ3Jlc2l6ZSddLCB0aGlzLl9zY3JvbGwsIHRoaXMuX25zLCB0aGlzKTtcblx0XHRcdHF0aXAuX2JpbmQodG9vbHRpcCwgWyd0b29sdGlwc2hvdyddLCB0aGlzLl9zY3JvbGwsIHRoaXMuX25zLCB0aGlzKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgZGltZW5zaW9uc1xuXHRcdHRoaXMucmVkcmF3KCk7XG5cdH0sXG5cblx0YWRqdXN0QkdJRnJhbWU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0b29sdGlwID0gdGhpcy5xdGlwLnRvb2x0aXAsXG5cdFx0XHRkaW1lbnNpb25zID0ge1xuXHRcdFx0XHRoZWlnaHQ6IHRvb2x0aXAub3V0ZXJIZWlnaHQoRkFMU0UpLFxuXHRcdFx0XHR3aWR0aDogdG9vbHRpcC5vdXRlcldpZHRoKEZBTFNFKVxuXHRcdFx0fSxcblx0XHRcdHBsdWdpbiA9IHRoaXMucXRpcC5wbHVnaW5zLnRpcCxcblx0XHRcdHRpcCA9IHRoaXMucXRpcC5lbGVtZW50cy50aXAsXG5cdFx0XHR0aXBBZGp1c3QsIG9mZnNldDtcblxuXHRcdC8vIEFkanVzdCBib3JkZXIgb2Zmc2V0XG5cdFx0b2Zmc2V0ID0gcGFyc2VJbnQodG9vbHRpcC5jc3MoJ2JvcmRlckxlZnRXaWR0aCcpLCAxMCkgfHwgMDtcblx0XHRvZmZzZXQgPSB7IGxlZnQ6IC1vZmZzZXQsIHRvcDogLW9mZnNldCB9O1xuXG5cdFx0Ly8gQWRqdXN0IGZvciB0aXBzIHBsdWdpblxuXHRcdGlmKHBsdWdpbiAmJiB0aXApIHtcblx0XHRcdHRpcEFkanVzdCA9IHBsdWdpbi5jb3JuZXIucHJlY2VkYW5jZSA9PT0gJ3gnID8gW1dJRFRILCBMRUZUXSA6IFtIRUlHSFQsIFRPUF07XG5cdFx0XHRvZmZzZXRbIHRpcEFkanVzdFsxXSBdIC09IHRpcFsgdGlwQWRqdXN0WzBdIF0oKTtcblx0XHR9XG5cblx0XHQvLyBVcGRhdGUgYmdpZnJhbWVcblx0XHR0aGlzLmJnaWZyYW1lLmNzcyhvZmZzZXQpLmNzcyhkaW1lbnNpb25zKTtcblx0fSxcblxuXHQvLyBNYXgvbWluIHdpZHRoIHNpbXVsYXRvciBmdW5jdGlvblxuXHRyZWRyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdGlmKHRoaXMucXRpcC5yZW5kZXJlZCA8IDEgfHwgdGhpcy5kcmF3aW5nKSB7IHJldHVybiB0aGlzOyB9XG5cblx0XHR2YXIgdG9vbHRpcCA9IHRoaXMucXRpcC50b29sdGlwLFxuXHRcdFx0c3R5bGUgPSB0aGlzLnF0aXAub3B0aW9ucy5zdHlsZSxcblx0XHRcdGNvbnRhaW5lciA9IHRoaXMucXRpcC5vcHRpb25zLnBvc2l0aW9uLmNvbnRhaW5lcixcblx0XHRcdHBlcmMsIHdpZHRoLCBtYXgsIG1pbjtcblxuXHRcdC8vIFNldCBkcmF3aW5nIGZsYWdcblx0XHR0aGlzLnF0aXAuZHJhd2luZyA9IDE7XG5cblx0XHQvLyBJZiB0b29sdGlwIGhhcyBhIHNldCBoZWlnaHQvd2lkdGgsIGp1c3Qgc2V0IGl0Li4uIGxpa2UgYSBib3NzIVxuXHRcdGlmKHN0eWxlLmhlaWdodCkgeyB0b29sdGlwLmNzcyhIRUlHSFQsIHN0eWxlLmhlaWdodCk7IH1cblx0XHRpZihzdHlsZS53aWR0aCkgeyB0b29sdGlwLmNzcyhXSURUSCwgc3R5bGUud2lkdGgpOyB9XG5cblx0XHQvLyBTaW11bGF0ZSBtYXgvbWluIHdpZHRoIGlmIG5vdCBzZXQgd2lkdGggcHJlc2VudC4uLlxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gUmVzZXQgd2lkdGggYW5kIGFkZCBmbHVpZCBjbGFzc1xuXHRcdFx0dG9vbHRpcC5jc3MoV0lEVEgsICcnKS5hcHBlbmRUbyh0aGlzLnJlZHJhd0NvbnRhaW5lcik7XG5cblx0XHRcdC8vIEdyYWIgb3VyIHRvb2x0aXAgd2lkdGggKGFkZCAxIGlmIG9kZCBzbyB3ZSBkb24ndCBnZXQgd3JhcHBpbmcgcHJvYmxlbXMuLiBodXp6YWghKVxuXHRcdFx0d2lkdGggPSB0b29sdGlwLndpZHRoKCk7XG5cdFx0XHRpZih3aWR0aCAlIDIgPCAxKSB7IHdpZHRoICs9IDE7IH1cblxuXHRcdFx0Ly8gR3JhYiBvdXIgbWF4L21pbiBwcm9wZXJ0aWVzXG5cdFx0XHRtYXggPSB0b29sdGlwLmNzcygnbWF4V2lkdGgnKSB8fCAnJztcblx0XHRcdG1pbiA9IHRvb2x0aXAuY3NzKCdtaW5XaWR0aCcpIHx8ICcnO1xuXG5cdFx0XHQvLyBQYXJzZSBpbnRvIHByb3BlciBwaXhlbCB2YWx1ZXNcblx0XHRcdHBlcmMgPSAobWF4ICsgbWluKS5pbmRleE9mKCclJykgPiAtMSA/IGNvbnRhaW5lci53aWR0aCgpIC8gMTAwIDogMDtcblx0XHRcdG1heCA9IChtYXguaW5kZXhPZignJScpID4gLTEgPyBwZXJjIDogMSAqIHBhcnNlSW50KG1heCwgMTApKSB8fCB3aWR0aDtcblx0XHRcdG1pbiA9IChtaW4uaW5kZXhPZignJScpID4gLTEgPyBwZXJjIDogMSAqIHBhcnNlSW50KG1pbiwgMTApKSB8fCAwO1xuXG5cdFx0XHQvLyBEZXRlcm1pbmUgbmV3IGRpbWVuc2lvbiBzaXplIGJhc2VkIG9uIG1heC9taW4vY3VycmVudCB2YWx1ZXNcblx0XHRcdHdpZHRoID0gbWF4ICsgbWluID8gTWF0aC5taW4oTWF0aC5tYXgod2lkdGgsIG1pbiksIG1heCkgOiB3aWR0aDtcblxuXHRcdFx0Ly8gU2V0IHRoZSBuZXdseSBjYWxjdWxhdGVkIHdpZHRoIGFuZCByZW12b2UgZmx1aWQgY2xhc3Ncblx0XHRcdHRvb2x0aXAuY3NzKFdJRFRILCBNYXRoLnJvdW5kKHdpZHRoKSkuYXBwZW5kVG8oY29udGFpbmVyKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgZHJhd2luZyBmbGFnXG5cdFx0dGhpcy5kcmF3aW5nID0gMDtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIFJlbW92ZSBpZnJhbWVcblx0XHR0aGlzLmJnaWZyYW1lICYmIHRoaXMuYmdpZnJhbWUucmVtb3ZlKCk7XG5cblx0XHQvLyBSZW1vdmUgYm91bmQgZXZlbnRzXG5cdFx0dGhpcy5xdGlwLl91bmJpbmQoW3dpbmRvdywgdGhpcy5xdGlwLnRvb2x0aXBdLCB0aGlzLl9ucyk7XG5cdH1cbn0pO1xuXG5JRTYgPSBQTFVHSU5TLmllNiA9IGZ1bmN0aW9uKGFwaSkge1xuXHQvLyBQcm9jZWVkIG9ubHkgaWYgdGhlIGJyb3dzZXIgaXMgSUU2XG5cdHJldHVybiBCUk9XU0VSLmllID09PSA2ID8gbmV3IEllNihhcGkpIDogRkFMU0U7XG59O1xuXG5JRTYuaW5pdGlhbGl6ZSA9ICdyZW5kZXInO1xuXG5DSEVDS1MuaWU2ID0ge1xuXHQnXmNvbnRlbnR8c3R5bGUkJzogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5yZWRyYXcoKTtcblx0fVxufTtcbjt9KSk7XG59KCB3aW5kb3csIGRvY3VtZW50ICkpO1xuIiwiLyohXG4qIHNjcmVlbmZ1bGxcbiogdjUuMC4yIC0gMjAyMC0wMi0xM1xuKiAoYykgU2luZHJlIFNvcmh1czsgTUlUIExpY2Vuc2VcbiovXG4oZnVuY3Rpb24gKCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIGRvY3VtZW50ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cuZG9jdW1lbnQgOiB7fTtcblx0dmFyIGlzQ29tbW9uanMgPSB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cztcblxuXHR2YXIgZm4gPSAoZnVuY3Rpb24gKCkge1xuXHRcdHZhciB2YWw7XG5cblx0XHR2YXIgZm5NYXAgPSBbXG5cdFx0XHRbXG5cdFx0XHRcdCdyZXF1ZXN0RnVsbHNjcmVlbicsXG5cdFx0XHRcdCdleGl0RnVsbHNjcmVlbicsXG5cdFx0XHRcdCdmdWxsc2NyZWVuRWxlbWVudCcsXG5cdFx0XHRcdCdmdWxsc2NyZWVuRW5hYmxlZCcsXG5cdFx0XHRcdCdmdWxsc2NyZWVuY2hhbmdlJyxcblx0XHRcdFx0J2Z1bGxzY3JlZW5lcnJvcidcblx0XHRcdF0sXG5cdFx0XHQvLyBOZXcgV2ViS2l0XG5cdFx0XHRbXG5cdFx0XHRcdCd3ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbicsXG5cdFx0XHRcdCd3ZWJraXRFeGl0RnVsbHNjcmVlbicsXG5cdFx0XHRcdCd3ZWJraXRGdWxsc2NyZWVuRWxlbWVudCcsXG5cdFx0XHRcdCd3ZWJraXRGdWxsc2NyZWVuRW5hYmxlZCcsXG5cdFx0XHRcdCd3ZWJraXRmdWxsc2NyZWVuY2hhbmdlJyxcblx0XHRcdFx0J3dlYmtpdGZ1bGxzY3JlZW5lcnJvcidcblxuXHRcdFx0XSxcblx0XHRcdC8vIE9sZCBXZWJLaXRcblx0XHRcdFtcblx0XHRcdFx0J3dlYmtpdFJlcXVlc3RGdWxsU2NyZWVuJyxcblx0XHRcdFx0J3dlYmtpdENhbmNlbEZ1bGxTY3JlZW4nLFxuXHRcdFx0XHQnd2Via2l0Q3VycmVudEZ1bGxTY3JlZW5FbGVtZW50Jyxcblx0XHRcdFx0J3dlYmtpdENhbmNlbEZ1bGxTY3JlZW4nLFxuXHRcdFx0XHQnd2Via2l0ZnVsbHNjcmVlbmNoYW5nZScsXG5cdFx0XHRcdCd3ZWJraXRmdWxsc2NyZWVuZXJyb3InXG5cblx0XHRcdF0sXG5cdFx0XHRbXG5cdFx0XHRcdCdtb3pSZXF1ZXN0RnVsbFNjcmVlbicsXG5cdFx0XHRcdCdtb3pDYW5jZWxGdWxsU2NyZWVuJyxcblx0XHRcdFx0J21vekZ1bGxTY3JlZW5FbGVtZW50Jyxcblx0XHRcdFx0J21vekZ1bGxTY3JlZW5FbmFibGVkJyxcblx0XHRcdFx0J21vemZ1bGxzY3JlZW5jaGFuZ2UnLFxuXHRcdFx0XHQnbW96ZnVsbHNjcmVlbmVycm9yJ1xuXHRcdFx0XSxcblx0XHRcdFtcblx0XHRcdFx0J21zUmVxdWVzdEZ1bGxzY3JlZW4nLFxuXHRcdFx0XHQnbXNFeGl0RnVsbHNjcmVlbicsXG5cdFx0XHRcdCdtc0Z1bGxzY3JlZW5FbGVtZW50Jyxcblx0XHRcdFx0J21zRnVsbHNjcmVlbkVuYWJsZWQnLFxuXHRcdFx0XHQnTVNGdWxsc2NyZWVuQ2hhbmdlJyxcblx0XHRcdFx0J01TRnVsbHNjcmVlbkVycm9yJ1xuXHRcdFx0XVxuXHRcdF07XG5cblx0XHR2YXIgaSA9IDA7XG5cdFx0dmFyIGwgPSBmbk1hcC5sZW5ndGg7XG5cdFx0dmFyIHJldCA9IHt9O1xuXG5cdFx0Zm9yICg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhbCA9IGZuTWFwW2ldO1xuXHRcdFx0aWYgKHZhbCAmJiB2YWxbMV0gaW4gZG9jdW1lbnQpIHtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHJldFtmbk1hcFswXVtpXV0gPSB2YWxbaV07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0pKCk7XG5cblx0dmFyIGV2ZW50TmFtZU1hcCA9IHtcblx0XHRjaGFuZ2U6IGZuLmZ1bGxzY3JlZW5jaGFuZ2UsXG5cdFx0ZXJyb3I6IGZuLmZ1bGxzY3JlZW5lcnJvclxuXHR9O1xuXG5cdHZhciBzY3JlZW5mdWxsID0ge1xuXHRcdHJlcXVlc3Q6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG5cdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdFx0XHR2YXIgb25GdWxsU2NyZWVuRW50ZXJlZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR0aGlzLm9mZignY2hhbmdlJywgb25GdWxsU2NyZWVuRW50ZXJlZCk7XG5cdFx0XHRcdFx0cmVzb2x2ZSgpO1xuXHRcdFx0XHR9LmJpbmQodGhpcyk7XG5cblx0XHRcdFx0dGhpcy5vbignY2hhbmdlJywgb25GdWxsU2NyZWVuRW50ZXJlZCk7XG5cblx0XHRcdFx0ZWxlbWVudCA9IGVsZW1lbnQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0XHRcdHZhciByZXR1cm5Qcm9taXNlID0gZWxlbWVudFtmbi5yZXF1ZXN0RnVsbHNjcmVlbl0oKTtcblxuXHRcdFx0XHRpZiAocmV0dXJuUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcblx0XHRcdFx0XHRyZXR1cm5Qcm9taXNlLnRoZW4ob25GdWxsU2NyZWVuRW50ZXJlZCkuY2F0Y2gocmVqZWN0KTtcblx0XHRcdFx0fVxuXHRcdFx0fS5iaW5kKHRoaXMpKTtcblx0XHR9LFxuXHRcdGV4aXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHRcdGlmICghdGhpcy5pc0Z1bGxzY3JlZW4pIHtcblx0XHRcdFx0XHRyZXNvbHZlKCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIG9uRnVsbFNjcmVlbkV4aXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dGhpcy5vZmYoJ2NoYW5nZScsIG9uRnVsbFNjcmVlbkV4aXQpO1xuXHRcdFx0XHRcdHJlc29sdmUoKTtcblx0XHRcdFx0fS5iaW5kKHRoaXMpO1xuXG5cdFx0XHRcdHRoaXMub24oJ2NoYW5nZScsIG9uRnVsbFNjcmVlbkV4aXQpO1xuXG5cdFx0XHRcdHZhciByZXR1cm5Qcm9taXNlID0gZG9jdW1lbnRbZm4uZXhpdEZ1bGxzY3JlZW5dKCk7XG5cblx0XHRcdFx0aWYgKHJldHVyblByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG5cdFx0XHRcdFx0cmV0dXJuUHJvbWlzZS50aGVuKG9uRnVsbFNjcmVlbkV4aXQpLmNhdGNoKHJlamVjdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0uYmluZCh0aGlzKSk7XG5cdFx0fSxcblx0XHR0b2dnbGU6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pc0Z1bGxzY3JlZW4gPyB0aGlzLmV4aXQoKSA6IHRoaXMucmVxdWVzdChlbGVtZW50KTtcblx0XHR9LFxuXHRcdG9uY2hhbmdlOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0XHRcdHRoaXMub24oJ2NoYW5nZScsIGNhbGxiYWNrKTtcblx0XHR9LFxuXHRcdG9uZXJyb3I6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHRcdFx0dGhpcy5vbignZXJyb3InLCBjYWxsYmFjayk7XG5cdFx0fSxcblx0XHRvbjogZnVuY3Rpb24gKGV2ZW50LCBjYWxsYmFjaykge1xuXHRcdFx0dmFyIGV2ZW50TmFtZSA9IGV2ZW50TmFtZU1hcFtldmVudF07XG5cdFx0XHRpZiAoZXZlbnROYW1lKSB7XG5cdFx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBjYWxsYmFjaywgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0b2ZmOiBmdW5jdGlvbiAoZXZlbnQsIGNhbGxiYWNrKSB7XG5cdFx0XHR2YXIgZXZlbnROYW1lID0gZXZlbnROYW1lTWFwW2V2ZW50XTtcblx0XHRcdGlmIChldmVudE5hbWUpIHtcblx0XHRcdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGNhbGxiYWNrLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRyYXc6IGZuXG5cdH07XG5cblx0aWYgKCFmbikge1xuXHRcdGlmIChpc0NvbW1vbmpzKSB7XG5cdFx0XHRtb2R1bGUuZXhwb3J0cyA9IHtpc0VuYWJsZWQ6IGZhbHNlfTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0d2luZG93LnNjcmVlbmZ1bGwgPSB7aXNFbmFibGVkOiBmYWxzZX07XG5cdFx0fVxuXG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc2NyZWVuZnVsbCwge1xuXHRcdGlzRnVsbHNjcmVlbjoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiBCb29sZWFuKGRvY3VtZW50W2ZuLmZ1bGxzY3JlZW5FbGVtZW50XSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRlbGVtZW50OiB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiBkb2N1bWVudFtmbi5mdWxsc2NyZWVuRWxlbWVudF07XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRpc0VuYWJsZWQ6IHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Ly8gQ29lcmNlIHRvIGJvb2xlYW4gaW4gY2FzZSBvZiBvbGQgV2ViS2l0XG5cdFx0XHRcdHJldHVybiBCb29sZWFuKGRvY3VtZW50W2ZuLmZ1bGxzY3JlZW5FbmFibGVkXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHRpZiAoaXNDb21tb25qcykge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gc2NyZWVuZnVsbDtcblx0fSBlbHNlIHtcblx0XHR3aW5kb3cuc2NyZWVuZnVsbCA9IHNjcmVlbmZ1bGw7XG5cdH1cbn0pKCk7XG4iLCIoZnVuY3Rpb24oKSB7XG4gIHZhciBjcnlwdCA9IHJlcXVpcmUoJ2NyeXB0JyksXG4gICAgICB1dGY4ID0gcmVxdWlyZSgnY2hhcmVuYycpLnV0ZjgsXG4gICAgICBiaW4gPSByZXF1aXJlKCdjaGFyZW5jJykuYmluLFxuXG4gIC8vIFRoZSBjb3JlXG4gIHNoYTEgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgIC8vIENvbnZlcnQgdG8gYnl0ZSBhcnJheVxuICAgIGlmIChtZXNzYWdlLmNvbnN0cnVjdG9yID09IFN0cmluZylcbiAgICAgIG1lc3NhZ2UgPSB1dGY4LnN0cmluZ1RvQnl0ZXMobWVzc2FnZSk7XG4gICAgZWxzZSBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEJ1ZmZlci5pc0J1ZmZlciA9PSAnZnVuY3Rpb24nICYmIEJ1ZmZlci5pc0J1ZmZlcihtZXNzYWdlKSlcbiAgICAgIG1lc3NhZ2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChtZXNzYWdlLCAwKTtcbiAgICBlbHNlIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlKSlcbiAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLnRvU3RyaW5nKCk7XG5cbiAgICAvLyBvdGhlcndpc2UgYXNzdW1lIGJ5dGUgYXJyYXlcblxuICAgIHZhciBtICA9IGNyeXB0LmJ5dGVzVG9Xb3JkcyhtZXNzYWdlKSxcbiAgICAgICAgbCAgPSBtZXNzYWdlLmxlbmd0aCAqIDgsXG4gICAgICAgIHcgID0gW10sXG4gICAgICAgIEgwID0gIDE3MzI1ODQxOTMsXG4gICAgICAgIEgxID0gLTI3MTczMzg3OSxcbiAgICAgICAgSDIgPSAtMTczMjU4NDE5NCxcbiAgICAgICAgSDMgPSAgMjcxNzMzODc4LFxuICAgICAgICBINCA9IC0xMDA5NTg5Nzc2O1xuXG4gICAgLy8gUGFkZGluZ1xuICAgIG1bbCA+PiA1XSB8PSAweDgwIDw8ICgyNCAtIGwgJSAzMik7XG4gICAgbVsoKGwgKyA2NCA+Pj4gOSkgPDwgNCkgKyAxNV0gPSBsO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSArPSAxNikge1xuICAgICAgdmFyIGEgPSBIMCxcbiAgICAgICAgICBiID0gSDEsXG4gICAgICAgICAgYyA9IEgyLFxuICAgICAgICAgIGQgPSBIMyxcbiAgICAgICAgICBlID0gSDQ7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgODA7IGorKykge1xuXG4gICAgICAgIGlmIChqIDwgMTYpXG4gICAgICAgICAgd1tqXSA9IG1baSArIGpdO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgbiA9IHdbaiAtIDNdIF4gd1tqIC0gOF0gXiB3W2ogLSAxNF0gXiB3W2ogLSAxNl07XG4gICAgICAgICAgd1tqXSA9IChuIDw8IDEpIHwgKG4gPj4+IDMxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ID0gKChIMCA8PCA1KSB8IChIMCA+Pj4gMjcpKSArIEg0ICsgKHdbal0gPj4+IDApICsgKFxuICAgICAgICAgICAgICAgIGogPCAyMCA/IChIMSAmIEgyIHwgfkgxICYgSDMpICsgMTUxODUwMDI0OSA6XG4gICAgICAgICAgICAgICAgaiA8IDQwID8gKEgxIF4gSDIgXiBIMykgKyAxODU5Nzc1MzkzIDpcbiAgICAgICAgICAgICAgICBqIDwgNjAgPyAoSDEgJiBIMiB8IEgxICYgSDMgfCBIMiAmIEgzKSAtIDE4OTQwMDc1ODggOlxuICAgICAgICAgICAgICAgICAgICAgICAgIChIMSBeIEgyIF4gSDMpIC0gODk5NDk3NTE0KTtcblxuICAgICAgICBINCA9IEgzO1xuICAgICAgICBIMyA9IEgyO1xuICAgICAgICBIMiA9IChIMSA8PCAzMCkgfCAoSDEgPj4+IDIpO1xuICAgICAgICBIMSA9IEgwO1xuICAgICAgICBIMCA9IHQ7XG4gICAgICB9XG5cbiAgICAgIEgwICs9IGE7XG4gICAgICBIMSArPSBiO1xuICAgICAgSDIgKz0gYztcbiAgICAgIEgzICs9IGQ7XG4gICAgICBINCArPSBlO1xuICAgIH1cblxuICAgIHJldHVybiBbSDAsIEgxLCBIMiwgSDMsIEg0XTtcbiAgfSxcblxuICAvLyBQdWJsaWMgQVBJXG4gIGFwaSA9IGZ1bmN0aW9uIChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgdmFyIGRpZ2VzdGJ5dGVzID0gY3J5cHQud29yZHNUb0J5dGVzKHNoYTEobWVzc2FnZSkpO1xuICAgIHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMuYXNCeXRlcyA/IGRpZ2VzdGJ5dGVzIDpcbiAgICAgICAgb3B0aW9ucyAmJiBvcHRpb25zLmFzU3RyaW5nID8gYmluLmJ5dGVzVG9TdHJpbmcoZGlnZXN0Ynl0ZXMpIDpcbiAgICAgICAgY3J5cHQuYnl0ZXNUb0hleChkaWdlc3RieXRlcyk7XG4gIH07XG5cbiAgYXBpLl9ibG9ja3NpemUgPSAxNjtcbiAgYXBpLl9kaWdlc3RzaXplID0gMjA7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBhcGk7XG59KSgpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5sZXQgZmFzdFByb3RvID0gbnVsbDtcblxuLy8gQ3JlYXRlcyBhbiBvYmplY3Qgd2l0aCBwZXJtYW5lbnRseSBmYXN0IHByb3BlcnRpZXMgaW4gVjguIFNlZSBUb29uIFZlcndhZXN0J3Ncbi8vIHBvc3QgaHR0cHM6Ly9tZWRpdW0uY29tL0B0dmVyd2Flcy9zZXR0aW5nLXVwLXByb3RvdHlwZXMtaW4tdjgtZWM5Yzk0OTFkZmUyIzVmNjJcbi8vIGZvciBtb3JlIGRldGFpbHMuIFVzZSAlSGFzRmFzdFByb3BlcnRpZXMob2JqZWN0KSBhbmQgdGhlIE5vZGUuanMgZmxhZ1xuLy8gLS1hbGxvdy1uYXRpdmVzLXN5bnRheCB0byBjaGVjayB3aGV0aGVyIGFuIG9iamVjdCBoYXMgZmFzdCBwcm9wZXJ0aWVzLlxuZnVuY3Rpb24gRmFzdE9iamVjdChvKSB7XG5cdC8vIEEgcHJvdG90eXBlIG9iamVjdCB3aWxsIGhhdmUgXCJmYXN0IHByb3BlcnRpZXNcIiBlbmFibGVkIG9uY2UgaXQgaXMgY2hlY2tlZFxuXHQvLyBhZ2FpbnN0IHRoZSBpbmxpbmUgcHJvcGVydHkgY2FjaGUgb2YgYSBmdW5jdGlvbiwgZS5nLiBmYXN0UHJvdG8ucHJvcGVydHk6XG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92OC92OC9ibG9iLzYuMC4xMjIvdGVzdC9tanN1bml0L2Zhc3QtcHJvdG90eXBlLmpzI0w0OC1MNjNcblx0aWYgKGZhc3RQcm90byAhPT0gbnVsbCAmJiB0eXBlb2YgZmFzdFByb3RvLnByb3BlcnR5KSB7XG5cdFx0Y29uc3QgcmVzdWx0ID0gZmFzdFByb3RvO1xuXHRcdGZhc3RQcm90byA9IEZhc3RPYmplY3QucHJvdG90eXBlID0gbnVsbDtcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cdGZhc3RQcm90byA9IEZhc3RPYmplY3QucHJvdG90eXBlID0gbyA9PSBudWxsID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IG87XG5cdHJldHVybiBuZXcgRmFzdE9iamVjdDtcbn1cblxuLy8gSW5pdGlhbGl6ZSB0aGUgaW5saW5lIHByb3BlcnR5IGNhY2hlIG9mIEZhc3RPYmplY3RcbkZhc3RPYmplY3QoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0b0Zhc3Rwcm9wZXJ0aWVzKG8pIHtcblx0cmV0dXJuIEZhc3RPYmplY3Qobyk7XG59O1xuIl19
