(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
module.exports={
    "client_id": "scalar",
    "client_ver": "2.5.12",
    "id": "user@example.com",
    "api_key": "abcd-hashkey-from-somewhere-else"
}
},{}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AnnotationManager = void 0;

var _annotation = require("./annotation.js");

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var AnnotationManager = /*#__PURE__*/function () {
  function AnnotationManager() {
    _classCallCheck(this, AnnotationManager);

    this.annotations = [];
    this.onomyVocabulary = [];
  }

  _createClass(AnnotationManager, [{
    key: "PopulateFromJSON",
    value: function PopulateFromJSON(json) {
      if (json.length == 0) {
        console.warn("JSON contains no annotations.");
      }

      if ('undefined' == typeof json.items) {
        // Version 1
        var _iterator = _createForOfIteratorHelper(json),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var object = _step.value;
            this.RegisterAnnotation(object);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      } else {
        // Version 2
        var _iterator2 = _createForOfIteratorHelper(json.items[0].items),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _object = _step2.value;
            this.RegisterAnnotation(_object, JSON.parse(JSON.stringify(json.items[0])));
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
    }
  }, {
    key: "RegisterAnnotation",
    value: function RegisterAnnotation(jsonObject, canvasObject) {
      //console.log("Registering new annotation with ID " + jsonObject.id);
      var anno = new _annotation.Annotation(jsonObject, canvasObject);
      this.annotations.push(anno);
    }
  }, {
    key: "RemoveAnnotation",
    value: function RemoveAnnotation(id) {
      this.annotations = this.annotations.filter(function (obj) {
        if ('undefined' == typeof obj.items) {
          // Version 1
          return id !== obj.id;
        } else {
          // Version 2
          return id !== obj.items[0].items[0].items[0].id;
        }
      });
    }
    /**
     * Update the given annotation in the stored array
     */

  }, {
    key: "UpdateAnnotation",
    value: function UpdateAnnotation(annotation, oldID) {
      //console.log("Updating annotation ID " + oldID + " to " + annotation.metadata.id);
      this.RemoveAnnotation(oldID); //this.RegisterAnnotation(annotation);

      this.PopulateFromJSON(annotation);
    }
  }, {
    key: "AnnotationsAtTime",
    value: function AnnotationsAtTime(time) {
      // TODO: Reenable with some kind of force parameter
      // // If the last time requested is asked for again, just give back the cached result
      // if(timeMS == this.lastTimeRequested){
      //     //console.log("Using cache");
      //     return this.cached;
      // }
      // this.lastTimeRequested = timeMS;
      // Filter all loaded annotations that fit within the range query.
      var filtered = this.annotations.filter(function (item) {
        return item.beginTime <= time && time <= item.endTime;
      });
      this.cached = filtered;
      return filtered;
    }
  }, {
    key: "GetOnomyVocabulary",
    value: function GetOnomyVocabulary() {
      return this.onomyVocabulary;
    }
  }, {
    key: "UpdateOnomyVocabulary",
    value: function UpdateOnomyVocabulary(vocabulary) {
      this.onomyVocabulary = vocabulary;
    }
  }]);

  return AnnotationManager;
}();

exports.AnnotationManager = AnnotationManager;

},{"./annotation.js":3}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Annotation = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/// A wrapper for JSON objects.
var Annotation = /*#__PURE__*/function () {
  function Annotation() {
    var json = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var canvas = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck(this, Annotation);

    var version = "v2";

    if (json) {
      if ('undefined' == typeof json.items) {
        version = "v1";
      } else {
        version = "v2";
      }
    } // ver1


    if (version == "v1") {
      this["@context"] = "http://www.w3.org/ns/anno.jsonld";
      this["request"] = {
        "client_id": "scalar",
        "client_ver": "2.5.12",
        "items": {
          "native": false,
          "id": "__CHECK_CONFIG_FILE__ID__",
          "api_key": "__CHECK_CONFIG_FILE__API_KEY__",
          "action": "TOBEFILLED",
          "format": "json"
        }
      };
      this["type"] = "Annotation";
      this["motivation"] = "highlighting";
      this["body"] = [];
      this["target"] = {};
      this["annotation_version"] = "v1";
      this.readConfig(version);

      if (json) {
        Object.assign(this, json);
      }
    } else {
      // ver2 docs/webannotation_spec/sample_2.0.json
      this["@context"] = ["http://www.w3.org/ns/anno.jsonld", "http://iiif.io/api/presentation/3/context.json"];
      this["service"] = [{
        "client_id": "scalar",
        "client_ver": "2.5.12",
        "items": {
          "native": false,
          "id": "__CHECK_CONFIG_FILE__ID__",
          "api_key": "__CHECK_CONFIG_FILE__API_KEY__",
          "action": "TOBEFILLED",
          "format": "json"
        }
      }];
      this["type"] = "Manifest";
      this["items"] = [];

      if (canvas) {
        this["items"].push(canvas); // The "Canvas"

        this["items"][0].items = [json]; // The "AnnotationPage" + "Annotation"
      }

      this["annotation_version"] = "v2";
      this.readConfig(version);
    }

    if (json) {
      // Compute read only easy access properties
      this.recalculate();
    }
  }

  _createClass(Annotation, [{
    key: "readConfig",
    value: function readConfig(version) {
      var config = require("../annotator-config.json");

      if (version == "v1") {
        // ver1
        this["request"]["client_id"] = config.client_id;
        this["request"]["client_ver"] = config.client_ver;
        this["request"]["items"]["native"] = config["native"];
        this["request"]["items"]["id"] = config.id;
        this["request"]["items"]["api_key"] = config.api_key;
      } else {
        // ver2
        this["service"][0]["client_id"] = config.client_id;
        this["service"][0]["client_ver"] = config.client_ver;
        this["service"][0]["items"]["native"] = config["native"];
        this["service"][0]["items"]["id"] = config.id;
        this["service"][0]["items"]["api_key"] = config.api_key;
      }
    } /// Compute read only easy access properties

  }, {
    key: "recalculate",
    value: function recalculate() {
      console.log(this);

      if ('undefined' == typeof this.items) {
        // Version 1
        var timeSlice = this.target.selector.filter(function (item) {
          return item.type === "FragmentSelector";
        })[0].value;
      } else {
        // Version 2
        var timeSlice = this.items[0].items[0].items[0].target.selector.value;
      }

      timeSlice = timeSlice.replace('#t=npt:', 't=');
      timeSlice = timeSlice.replace("t=", ""); /// Start time in seconds

      this.beginTime = parseFloat(timeSlice.split(",")[0]); /// End time in seconds

      this.endTime = parseFloat(timeSlice.split(",")[1]);
      console.log('beginTime: ' + this.beginTime + ' endTime: ' + this.endTime); /// Extract tags from annotation

      if ('undefined' == typeof this.items) {
        // Version 1
        this.tags = this.body.filter(function (item) {
          return item.purpose === "tagging";
        }).map(function (item) {
          return item.value;
        });
      } else {
        // Version 2
        this.tags = [];

        for (var j = 0; j < this.items[0].items[0].items[0].body.length; j++) {
          if (this.items[0].items[0].items[0].body[j].purpose != 'tagging') continue;

          if ('undefined' != typeof this.items[0].items[0].items[0].body[j].value) {
            // Basic tag
            this.tags.push(this.items[0].items[0].items[0].body[j].value);
          } else if ('undefined' != typeof this.items[0].items[0].items[0].body[j].source) {
            // Onomy tag
            this.tags.push(this.items[0].items[0].items[0].body[j].source.label['en']); // TODO: english hard-coded here
          }
        }
      }

      console.log('Tags: ' + this.tags); // Start and end poly points

      this.polyStart = null;
      this.polyEnd = null;
      var pointsSelector = [];

      if ('undefined' == typeof this.items) {
        // Version 1
        pointsSelector = this.target.selector.filter(function (item) {
          return item.type === "SvgSelector";
        });
      } else {
        // Version 2
        pointsSelector = 'undefined' != typeof this.items[0].items[0].items[0].target.selector.refinedBy ? [this.items[0].items[0].items[0].target.selector.refinedBy] : [];
      }

      if (pointsSelector.length > 0) {
        var pointsSvg = pointsSelector[0].value;
        var regExString = new RegExp("(?:points=')(.*?)(?:')", "ig");
        var pointsRE = regExString.exec(pointsSvg)[1];
        var pointsData = pointsRE.trim().split(" ").map(function (item) {
          return item.split(",");
        });
        this.polyStart = pointsData;
        var parser = new DOMParser();
        var xmlDoc = parser.parseFromString(pointsSvg, "text/xml");

        if (xmlDoc.getElementsByTagName("animate").length) {
          // If there is no animation element, create an "animation" from the static points
          pointsRE = xmlDoc.getElementsByTagName("animate")[0].getAttribute("to");
          pointsData = pointsRE.trim().split(" ").map(function (item) {
            return item.split(",");
          });
          this.polyEnd = pointsData;
        }
      }

      console.log('polyStart: ');
      console.log(this.polyStart);
      console.log('polyEnd: ');
      console.log(this.polyEnd);
    }
  }, {
    key: "getPoly",
    value: function getPoly() {
      var pointsSelector = [];

      if ('undefined' == typeof this.items) {
        // Version 1
        pointsSelector = this.target.selector.filter(function (item) {
          return item.type === "SvgSelector";
        });
      } else {
        // Version 2
        pointsSelector = 'undefined' != typeof this.items[0].items[0].items[0].target.selector.refinedBy ? [this.items[0].items[0].items[0].target.selector.refinedBy] : [];
      }

      if (pointsSelector.length == 0) return null; // Parse the points array from the annotation

      var pointsSvg = pointsSelector[0].value;
      var regExString = new RegExp("(?:points=')(.*?)(?:')", "ig"); //set ig flag for global search and case insensitive

      var pointsRE = regExString.exec(pointsSvg)[1];
      var pointsData = pointsRE.trim().split(" ").map(function (item) {
        return item.split(",");
      });
      return pointsData;
    }
  }, {
    key: "getSVGPolyPoints",
    value: function getSVGPolyPoints() {
      var pointsSelector = [];

      if ('undefined' == typeof this.items) {
        // Version 1
        pointsSelector = this.target.selector.filter(function (item) {
          return item.type === "SvgSelector";
        });
      } else {
        // Version 2
        pointsSelector = 'undefined' != typeof this.items[0].items[0].items[0].target.selector.refinedBy ? [this.items[0].items[0].items[0].target.selector.refinedBy] : [];
      }

      if (pointsSelector.length == 0) return null; // Parse the points array from the annotation

      var pointsSvg = pointsSelector[0].value;
      var parser = new DOMParser();
      var xmlDoc = parser.parseFromString(pointsSvg, "text/xml");

      if (!xmlDoc.getElementsByTagName("animate").length) {
        // If there is no animation element, create an "animation" from the static points
        var points = this.getPoly();
        return [points, points];
      } else {
        return [xmlDoc.getElementsByTagName("animate")[0].getAttribute("from"), xmlDoc.getElementsByTagName("animate")[0].getAttribute("to")];
      }
    }
  }]);

  return Annotation;
}();

exports.Annotation = Annotation;

},{"../annotator-config.json":1}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VideoAnnotator = void 0;

var _serverInterface = require("./server-interface.js");

var _annotationManager = require("./annotation-manager.js");

var _tickBar = require("./components/tick-bar.js");

var _polygonOverlay = require("./components/polygon-overlay.js");

var _preferenceManager = require("../utils/preference-manager.js");

var _annotationGui = require("./components/annotation-gui.js");

var _infoContainer = require("./components/info-container.js");

var _indexContainer = require("./components/index-container.js");

var _sessionManager = require("./session-manager.js");

var _messageOverlay = require("./components/message-overlay.js");

var _annotation2 = require("./annotation.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var sha1 = require('sha1');

var VideoAnnotator = /*#__PURE__*/function () {
  function VideoAnnotator(args) {
    var _this = this;

    _classCallCheck(this, VideoAnnotator);

    console.log("[VideoAnnotator] Creating VideoAnnotator..."); //Parse arguments
    //This is actually required

    if (typeof args.player === 'undefined') {
      console.log('Called for a new VideoAnnotator without passing a player!');
      return false;
    }

    this.player = args.player; // Bring in the argument from the constructor
    //These config options are required for saving annotations to a server

    this.serverURL = typeof args.serverURL === 'undefined' ? '' : args.serverURL;
    this.tagsURL = typeof args.tagsURL === 'undefined' ? '' : args.tagsURL;
    this.apiKey = typeof args.apiKey === 'undefined' ? '' : args.apiKey; //If apiKey is set and cmsUsername and cmsEmail are passed, we'll auto login later

    this.cmsUsername = typeof args.cmsUsername === 'undefined' ? '' : args.cmsUsername;
    this.cmsEmail = typeof args.cmsEmail === 'undefined' ? '' : args.cmsEmail; //This config option is required for using a static annotation file

    this.localURL = typeof args.localURL === 'undefined' ? '' : args.localURL; //Optional params
    //Removes the editing interface

    this.kioskMode = typeof args.kioskMode === 'undefined' ? '' : args.kioskMode; //Shows the 'open manifest' button if kioskMode is off

    this.showManifest = typeof args.showManifest === 'undefined' ? false : args.showManifest; //Allows passing in a function that overrides the default annotation renderer

    this.renderer = typeof args.renderer === 'undefined' ? false : args.renderer; //Allows passing in a function that overrides the default annotation renderer

    this.unrenderer = typeof args.unrenderer === 'undefined' ? false : args.unrenderer; //Determines whether or not the annotation container is cleared every time it updates

    this.clearContainer = typeof args.clearContainer === 'undefined' ? true : args.clearContainer; //Determines whether or not to create a navigable index of annotations

    this.displayIndex = typeof args.displayIndex === 'undefined' ? false : args.displayIndex; //Determine the language of the annotation

    this.onomyLanguage = typeof args.onomyLanguage === 'undefined' ? '' : args.onomyLanguage;
    this.onomyVocabulary = []; //localURL implies kiosk mode

    if (this.localURL != '') this.kioskMode = true; //additional data from annotations collected from scalar to be added in API 2.0 

    this.contentLabel = "";
    this.artURL = "";
    this.annotationPageURL = "";
    this.Wrap();
    this.PopulateControls(); //may need to move this below the this.server block later?

    this.messageOverlay = new _messageOverlay.MessageOverlay(this);
    this.annotationManager = new _annotationManager.AnnotationManager();
    this.sessionManager = new _sessionManager.SessionManager(this); //load onomy vocabulary

    $.ajax(this.gui.GetTagsQuery()).done(function (vocabulary) {
      //console.log("OnomyVocabulary is loaded");
      var parsedVocabulary = _this.gui.OnomyVocabularProcess(vocabulary, _this.onomyLanguage);

      _this.annotationManager.UpdateOnomyVocabulary(parsedVocabulary);

      _this.onomyVocabulary = parsedVocabulary;
    }); //localURL takes precendence - if it is anything but '' then do not load from server

    if (this.localURL == '') {
      this.server = new _serverInterface.ServerInterface(this);
      this.server.SetBaseURL(this.serverURL); // Load annotations from server based on the player's video URL

      this.server.FetchAnnotations('location', this.player.videoElement.currentSrc).done(function (json) {
        if ('undefined' == typeof json.items) {
          // Version 1
          //json.shift()  // Assume first node is a content node
          for (var j = json.length - 1; j >= 0; j--) {
            if (json[j].type != "Annotation") {
              var annotation_info = json[j];
              _this.contentLabel = annotation_info["dcterms:title"];
              _this.artURL = annotation_info["art:url"];
              console.log(annotation_info["dcterms:title"]);
              json.splice(j, 1);
            } else {
              for (var k = 0; k < json[j].target.selector.length; k++) {
                if ('FragmentSelector' != json[j].target.selector[k].type) continue;
                json[j].target.selector[k].value = json[j].target.selector[k].value.replace('#t=npt:', 't=');
              }
            }
          }
        } else {
          // Version 2
          _this.contentLabel = json.label.en[0];
          _this.artURL = json.items[0].content.id;
          _this.annotationPageURL = json.items[0].items[0].items[0].id;
        }

        _this.annotationManager.PopulateFromJSON(json);

        _this.AnnotationsLoaded();
      }); //auto-login if not in kiosk mode, and we have the cms variables and API key

      if (!this.kioskMode) {
        if (this.apiKey && this.cmsEmail && this.cmsUsername) {
          this.server.LogOut();
          this.server.LogIn(this.cmsUsername, sha1(this.cmsEmail)).done(function () {
            console.log("[Main] CMS login success");
          }).fail(function () {
            console.log("[Main] CMS login failed");
          });
        }
      }
    } else {
      console.log('Loading local cache file: ' + this.localURL);
      $.ajax({
        url: this.localURL,
        type: "GET",
        dataType: "json",
        async: true
      }).done(function (data) {
        console.log("Fetched ".concat(data.length, " annotations from local cache."));
        var json = data;

        if ('undefined' == typeof json.items) {
          // Version 1
          //json.shift()  // Assume first node is a content node
          for (var j = json.length - 1; j >= 0; j--) {
            if (json[j].type != "Annotation") {
              var annotation_info = json[j];
              _this.contentLabel = annotation_info["dcterms:title"];
              _this.artURL = annotation_info["art:url"];
              console.log(annotation_info["dcterms:title"]);
              json.splice(j, 1);
            } else {
              for (var k = 0; k < json[j].target.selector.length; k++) {
                if ('FragmentSelector' != json[j].target.selector[k].type) continue;
                json[j].target.selector[k].value = json[j].target.selector[k].value.replace('#t=npt:', 't=');
              }
            }
          }
        } else {
          // Version 2
          _this.contentLabel = json.label.en[0];
          _this.artURL = json.items[0].content.id;
        }

        _this.annotationManager.PopulateFromJSON(data);

        _this.AnnotationsLoaded();
      }).fail(function (response) {
        console.log(response);
        console.error("Error fetching annotations from local cache\"\n".concat(response.responseJSON.detail, "."));

        _this.annotator.messageOverlay.ShowError("Could not retrieve annotations!<br>(".concat(response.responseJSON.detail, ")"));
      });
    }

    this.player.$container.on("OnTimeUpdate", function (event, time) {
      _this.OnTimeUpdate(time);
    });
    this.$container.on("OnPolyClicked", function (event, annotation) {
      // Edit a poly when clicked, but only if the editor isn't already open
      if (!_this.gui.open) {
        _this.$addAnnotationButton.button("disable");

        _this.gui.BeginEditing(annotation);
      }
    });
    this.$container.on("OnPolygonClicked", function (event, annotation) {
      console.log("OnPolygonClicked event captured");
    });
    this.$container.on("OnAnimationClicked", function (event, annotation) {
      console.log("OnAnimationClicked event captured");
    });
    this.gui.$container.on("OnGUIClosed", function (event) {
      _this.$addAnnotationButton.button("enable");
    });
    this.url = this.player.videoElement.currentSrc;
    console.log("[VideoAnnotator] Annotator created for video.");
  }

  _createClass(VideoAnnotator, [{
    key: "readConfig",
    value: function readConfig() {
      var config = require("../annotator-config.json");

      this.apiKey = config.api_key;
    }
    /**
     * Creates the divs that surround the video player.
     */

  }, {
    key: "Wrap",
    value: function Wrap() {
      // Wrap the video player with this container. Can't use .wrap due to duplication issues    
      var videoContainer = $(this.player.$container).parent();
      var waldorfContainer = $("<div class='waldorf-container'></div>");
      waldorfContainer.insertBefore($(this.player.$container));
      waldorfContainer.append(this.player.$container);
      this.$container = videoContainer.parent(); // Set the container to the width of the video player

      this.$container.width(this.player.$container.width()); // Allow the video player container to grow
      //this.player.$container.width("100%");
      //this.player.$container.height("100%");
      // Copy the video styles to the container
      // console.log(this.player.originalStyles);

      this.$container.css(this.player.originalStyles);
    }
  }, {
    key: "PopulateControls",
    value: function PopulateControls() {
      var _this2 = this;

      // Create the tick bar
      this.tickBar = new _tickBar.TickBar(this); // Create the polygon overlay

      this.polyOverlay = new _polygonOverlay.PolygonOverlay(this);

      if (!this.kioskMode && this.showManifest) {
        this.$debugControls = $("<div class='waldorf-debug-controls'></div>").appendTo(this.$container);
        var $showAllAnnotationsButton = this.$debugControls.append('<button>Open Annotation Manifest in New Window</button>');
        $showAllAnnotationsButton.click(function () {
          var url = _this2.player.videoElement.currentSrc;

          _this2.server.FetchAnnotations("location", url).done(function (json) {
            var win = window.open();

            if (win === null) {
              console.error("Couldn't show annotation manifest; please allow pop-ups.");

              _this2.messageOverlay.ShowError("Couldn't show annotation manifest; please allow pop-ups.");
            } else {
              win.document.open();
              win.document.write("<title>Annotation Manifest for ".concat(url, "</title>"));
              win.document.write("<pre>");
              win.document.write(JSON.stringify(json, null, 2).escapeHTML());
              win.document.write("</pre>");
              win.document.close();
            }
          });
        });
      } // Wrap all the buttons with the list tag
      //this.$debugControls.wrapInner("<ul></ul>");
      // Wrap each button with the list element tag
      //this.$debugControls.find("button").wrap("<li></li>");
      // Create the info container


      this.infoContainer = new _infoContainer.InfoContainer(this);
      if (this.displayIndex) this.indexContainer = new _indexContainer.IndexContainer(this); // Inject the annotation edit button into the toolbar

      if (!this.kioskMode) {
        this.$addAnnotationButton = $("<button>Add New Annotation</button>").button({
          icon: "fa fa-plus",
          showLabel: false
        }).click(function () {
          _this2.$addAnnotationButton.button("disable");

          _this2.gui.BeginEditing();
        });
        this.player.controlBar.RegisterElement(this.$addAnnotationButton, 3, 'flex-end'); // Inject the annotation upload button into the toolbar

        this.$uploadAnnotationButton = $("<button type='file'>Import Annotation From File</button>").button({
          icon: "fa fa-upload",
          showLabel: false
        }).click(function () {
          _this2.LoadFromFile();
        });
        this.player.controlBar.RegisterElement(this.$uploadAnnotationButton, 2, 'flex-end');
      }

      this.gui = new _annotationGui.AnnotationGUI(this);
    }
  }, {
    key: "AnnotationsLoaded",
    value: function AnnotationsLoaded() {
      //Send annotation loaded event
      this.$container.trigger("OnAnnotationsLoaded", this.annotationManager);
    }
  }, {
    key: "OnTimeUpdate",
    value: function OnTimeUpdate(time) {
      this.annotationsNow = this.annotationManager.AnnotationsAtTime(time);

      if (this.annotationsNow.equals(this.lastAnnotationSet)) {
        this.SetAnnotationTimePosition(time);
        return;
      }

      this.lastAnnotationSet = this.annotationsNow;
      this.UpdateViews();
    }
  }, {
    key: "SetAnnotationTimePosition",
    value: function SetAnnotationTimePosition(time) {
      //console.log("time: " + time);
      //Check safari and multiple geometric annotation
      if (this.IsSafari() && this.annotationsNow.length > 1) {
        var msg = "Multiple geometric annotations are detected.<br>";
        msg += "Safari doesn't support multiple geometric annotations.<br>";
        msg += "Chrome or Firefox are recommended.";
        this.messageOverlay.ShowMessage(msg, 2.0);
        return; //no animation for safari browser with multiple geometric annotation
      }

      for (var i = 0; i < this.annotationsNow.length; i++) {
        var annotation_id = this.annotationsNow[i].id;

        if (this.polyOverlay.svgElementsHash[annotation_id]) {
          this.polyOverlay.svgElementsHash[annotation_id].animate.beginElement();
          var time_diff = time - this.annotationsNow[i].beginTime;
          var current_time = this.polyOverlay.svgElementsHash[annotation_id].svgElement.getCurrentTime(); //console.log("\t i:" + i + " (" + annotation_id + "), svg current_time:" + current_time + ", animate time_diff: " + time_diff);

          this.polyOverlay.svgElementsHash[annotation_id].svgElement.setCurrentTime(current_time + time_diff);
          this.polyOverlay.svgElementsHash[annotation_id].animate.endElement();
        }
      }
    }
  }, {
    key: "UpdateViews",
    value: function UpdateViews() {
      //console.log("annotator.js:267 UpdateViews");
      this.annotationsNow = this.annotationManager.AnnotationsAtTime(this.player.videoElement.currentTime); // Update the info container

      this.infoContainer.Rebuild(this.annotationsNow, this.clearContainer);
      this.$container.trigger("OnNewAnnotationSet", [this.annotationsNow]);
      this.SetAnnotationTimePosition(this.player.videoElement.currentTime);
    }
  }, {
    key: "GetAnnotations",
    value: function GetAnnotations() {
      var ordered = this.annotationManager.annotations.slice();

      var orderByStart = function orderByStart(a, b) {
        var aTime = a.beginTime;
        var bTime = b.beginTime;
        return aTime < bTime ? -1 : aTime > bTime ? 1 : 0;
      };

      ordered.sort(orderByStart);
      return ordered;
    }
  }, {
    key: "RegisterNewAnnotation",
    value: function RegisterNewAnnotation(annotation) {
      //console.log(annotation);
      //this.annotationManager.RegisterAnnotation(annotation);
      this.annotationManager.PopulateFromJSON(annotation); // Throw event for listening objects (e.g. tick-bar)

      this.$container.trigger("OnAnnotationRegistered", [annotation]); // Update dependent views

      this.UpdateViews();
    }
  }, {
    key: "UpdateAnnotation",
    value: function UpdateAnnotation(annotation, oldID) {
      this.annotationManager.UpdateAnnotation(annotation, oldID); // Throw event for listening objects (e.g. tick-bar)

      this.$container.trigger("OnAnnotationRemoved", [oldID]);
      this.$container.trigger("OnAnnotationRegistered", [annotation]); // Update dependent views

      this.UpdateViews();
    }
  }, {
    key: "DeregisterAnnotation",
    value: function DeregisterAnnotation(annotation) {
      var id = '';

      if ('undefined' == typeof annotation.items) {
        // Ver 1
        id = annotation.id;
      } else {
        // Ver 2
        id = annotation.items[0].items[0].items[0].id;
      }

      this.annotationManager.RemoveAnnotation(id); //this.annotationsNow = this.annotationManager.AnnotationsAtTime(this.player.videoElement.currentTime);
      // Throw event for listening objects (e.g. tick-bar)

      this.$container.trigger("OnAnnotationRemoved", [id]); // Update dependent views

      this.UpdateViews();
    }
  }, {
    key: "LoadFromFile",
    value: function LoadFromFile() {
      var _this3 = this;

      // Create the dialog
      var $container = $("<div class='waldorf-session-modal' title='Import Annotation'></div>"); // Outermost HTML

      var $headText = $("<p class='validateTips'>Annotations must be W3C OA compliant in JSON format.</p>").appendTo($container);
      var $errorText = $("<p class='validateTips modal-error-text'></p>").appendTo($container);
      $errorText.hide();
      var $form = $("<form></form>").appendTo($container);
      var $importField;
      $("<label for='importFile'>Select File</label>").appendTo($form);
      $importField = $("<input type='file' name='importFile' class='file ui-widget-content ui-corner-all'>").appendTo($form);
      $form.wrapInner("<fieldset />");

      var error = function error(message) {
        console.error(message);
        $errorText.html(message);
        $errorText.show();
      };

      var self = this;
      $importField.on('change', function () {
        var files = $importField.get(0).files;
        var fr = new FileReader();

        fr.onload = function (localFile) {
          // If the JSON is malformed, show an error and stop here.
          try {
            JSON.parse(localFile.target.result);
          } catch (e) {
            error("JSON file is malformed!");
            return;
          }

          var localJson = JSON.parse(localFile.target.result);

          if (typeof localJson.target != "undefined") {
            var annotation = new _annotation2.Annotation(localJson);

            if (_this3.ValidateAnnotation(annotation)) {
              // Open the GUI and populate it with this annotation's data.
              _this3.gui.BeginEditing(annotation, true);

              _this3.gui.CommitAnnotationToServer(function () {
                return;
              });
            } else {
              error("JSON is invalid!");
            }
          } else {
            for (var i = 0; i < localJson.length; i++) {
              var _annotation = new _annotation2.Annotation(localJson[i]);

              if (_this3.ValidateAnnotation(_annotation)) {
                // Open the GUI and populate it with this annotation's data.
                _this3.gui.BeginEditing(_annotation, true);

                _this3.gui.CommitAnnotationToServer(function (annotation) {
                  _this3.RegisterNewAnnotation(annotation);

                  _this3.gui.Close();
                });
              } else {
                error("JSON is invalid!");
              }
            }
          }

          $dialog.dialog("close");
        };

        fr.readAsText(files[0]);
      });
      var $dialog = $container.dialog({
        autoOpen: true,
        draggable: false,
        modal: true,
        buttons: {
          Cancel: function Cancel() {
            $dialog.dialog("close");
          }
        },
        close: function close() {
          $dialog.find("form")[0].reset();
          $dialog.find("input").removeClass("ui-state-error"); //this.OnModalClose();
        }
      });
    }
  }, {
    key: "ValidateAnnotation",
    value: function ValidateAnnotation(annotation) {
      // TODO: Validate annotation here. Return false if any
      // required properties are not present.
      return true;
    } // checking whether the browser is safari or not

  }, {
    key: "IsSafari",
    value: function IsSafari() {
      //ref: https://stackoverflow.com/questions/49872111/detect-safari-and-stop-script
      var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      return isSafari;
    }
  }]);

  return VideoAnnotator;
}();

exports.VideoAnnotator = VideoAnnotator;

},{"../annotator-config.json":1,"../utils/preference-manager.js":19,"./annotation-manager.js":2,"./annotation.js":3,"./components/annotation-gui.js":5,"./components/index-container.js":6,"./components/info-container.js":7,"./components/message-overlay.js":8,"./components/polygon-overlay.js":10,"./components/tick-bar.js":11,"./server-interface.js":12,"./session-manager.js":13,"sha1":227}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AnnotationGUI = void 0;

var _time = require("../../utils/time.js");

var _polygonEditor = require("./polygon-editor.js");

var _annotation = require("../annotation.js");

var _types = require("@babel/types");

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var AnnotationGUI = /*#__PURE__*/function () {
  function AnnotationGUI(annotator) {
    var _this = this;

    _classCallCheck(this, AnnotationGUI);

    this.annotator = annotator;
    this.Create();
    this.open = false; //Hide the container

    this.isVisible = false;
    this.$container.makeVisible(false);
    this.polyEditor = new _polygonEditor.PolygonEditor(this.annotator);
    this.annotator.$container.on("OnPolygonEditingEnded", function () {
      _this.SetVisible(true);

      _this.polyEditor.ShowJustPolygon();
    });
  }

  _createClass(AnnotationGUI, [{
    key: "Create",
    value: function Create() {
      var _this2 = this;

      /*
       * //new UI
       * 
       */
      this.$container = $("<div id='create-dialog' class='ui-widget-content center'>").appendTo(this.annotator.player.$container);
      this.$container.draggable();
      this.$title = $("<div class='dialog-title'>Create Annotation</div>").appendTo(this.$container); // Make cancel button

      var $exitButton = $("<button>Exit Annotation Editing</button>").button({
        icons: {
          primary: 'fa fa-remove'
        },
        showLabel: false
      });
      $exitButton.css("float", "right");
      $exitButton.attr('title', "Exit annotation editing");
      $exitButton.addClass("waldorf-cancel-button");
      $exitButton.click(function () {
        _this2.polyEditor.ResetPolygons();

        _this2.Close();
      });
      this.RegisterElement($exitButton, this.$title, -1);
      this.$tabs = $("<div id='tabs'></div>").appendTo(this.$container);
      var $tabUI = $("<ul></ul>");
      var $startUI = $("<li><a href='#start_tab'>Start </a></li>");
      var $bodyUI = $("<li><a href='#body_tab'>Body </a></li>");
      var $stopUI = $("<li><a href='#stop_tab'>Stop </a></li>");
      this.RegisterElement($tabUI, this.$tabs, -1);
      this.RegisterElement($startUI, $tabUI, -1);
      this.RegisterElement($bodyUI, $tabUI, -1);
      this.RegisterElement($stopUI, $tabUI, -1); //Create tabs

      var $startTab = $("<div id='start_tab' class='ui-field-contain'></div>");
      this.RegisterElement($startTab, this.$tabs, -1);
      var $bodyTab = $("<div id='body_tab'></div>");
      this.RegisterElement($bodyTab, this.$tabs, -1);
      var $stopTab = $("<div id='stop_tab'></div>");
      this.RegisterElement($stopTab, this.$tabs, -1); //Begin filling start tab
      // Make "Start time" label and field

      this.$timeStartField = $('<input type="text" name="time-start" id="time-start" value=""><br><br>');
      this.$timeStartField.width(72);
      this.$timeStartField.css("font-family", "Courier, monospace");
      this.$timeStartField.css("margin-right", "2px");
      this.$timeStartField.addClass("ui-widget ui-widget-content ui-corner-all");
      this.$timeStartField.attr('title', "Start time (hh:mm:ss.ss)");
      this.$timeStartField.on('keypress', function (event) {
        if (event.keyCode == 46 || event.keyCode >= 48 && event.keyCode <= 58) {
          //0-9, period, and colon
          return true;
        }

        return false;
      }); //add start marker button

      this.$startTimeMarker = $("<button style='padding:0; line-height:1.4'>Set Start</button> ").button({
        icon: "fa fa-map-marker",
        showLabel: false
      }).click(function () {
        _this2.$timeStartField[0].value = (0, _time.GetFormattedTime)(_this2.annotator.player.videoElement.currentTime);
      });
      this.RegisterElement(this.$startTimeMarker, $startTab, -2);
      $("<label for='time-start'>Start Time: </label> ").appendTo($startTab);
      this.$timeStartField.appendTo($startTab); //Make "Edit polygon" button

      var $editPolyButton = $("<button style='padding:0; line-height:1.4'>Edit Polygon</button>").button({
        icon: "fa fa-pencil",
        showLabel: false
      }).click(function () {
        _this2.SetVisible(false); //console.log("annotation-gui:353 Create");


        _this2.polyEditor.BeginEditing('start');
      });
      $editPolyButton.attr('title', "Edit polygon");
      this.RegisterElement($editPolyButton, $startTab, -1);
      var $startTargetLabel = $("<label>Start Target</label> ");
      $startTargetLabel.css("color", "white");
      this.RegisterElement($startTargetLabel, $startTab, -1); //start point polygon is added (This seems to be unused? JPB 2021-09-16)
      // this.$startPolygonSet = $("<button style='padding:0; line-height:1.4'>Start Polygon Set</button>").button({
      //     icon: "fa fa-check-square-o",
      //     showLabel: false
      // });
      // //this.$startPolygonSet.css("visibility", "inherit");
      // this.$startPolygonSet.css("visibility", "hidden");
      // this.$startPolygonSet.addClass("waldorf-confirm-button");
      //this.RegisterElement(this.$startPolygonSet, $startTab, -2); 
      // Add tags input field

      this.$tagsField = $('<select class="form-control" multiple="multiple"></select>');
      this.$tagsField.width("100%");
      this.$tagsField.css("margin-top", "-8px");
      this.RegisterElement(this.$tagsField, $bodyTab, -1);
      this.$tagsField.select2({
        tags: true,
        placeholder: "Tags",
        ajax: this.GetTagsQuery(),
        selectOnBlur: true,
        // Allow manually entered text in drop down.
        createTag: function createTag(params) {
          return {
            id: params.term,
            text: params.term,
            newOption: true
          };
        }
      }); // Add custom class for bringing the dropdown to the front (fullscreen fix)

      this.$tagsField.data('select2').$dropdown.addClass("select2-dropdown-annotator"); // Make notes text field

      this.$textField = $('<textarea type="text" name="anno-text" id="anno-text" value="" placeholder="Notes">');
      this.$textField.css("margin-top", "2px");
      this.$textField.width("98.5%");
      this.$textField.addClass("ui-widget ui-widget-content ui-corner-all");
      this.$textField.attr('title', 'Annotation text');
      this.$textField.css("flex-grow", 2);
      this.RegisterElement(this.$textField, $bodyTab, -1); // Make "Stop time" label and field

      this.$timeEndField = $('<input type="text" name="time-stop" id="time-stop" value=""><br><br>');
      this.$timeEndField.width(72);
      this.$timeEndField.css("font-family", "Courier, monospace");
      this.$timeEndField.css("margin-right", "2px");
      this.$timeEndField.addClass("ui-widget ui-widget-content ui-corner-all");
      this.$timeEndField.attr('title', "Start time (hh:mm:ss.ss)");
      this.$timeEndField.on('keypress', function (event) {
        if (event.keyCode == 46 || event.keyCode >= 48 && event.keyCode <= 58) {
          //0-9, period, and colon
          return true;
        }

        return false;
      }); //add end marker button

      this.$endTimeMarker = $("<button style='padding:0; line-height:1.4'>Set End</button>").button({
        icon: "fa fa-map-marker",
        showLabel: false
      }).click(function () {
        _this2.$timeEndField[0].value = (0, _time.GetFormattedTime)(_this2.annotator.player.videoElement.currentTime);
      });
      this.RegisterElement(this.$endTimeMarker, $stopTab, -2);
      $("<label for='stop_time'>Stop Time: </label> ").appendTo($stopTab);
      this.$timeEndField.appendTo($stopTab); //Make "Edit polygon" button

      var $editStopPolyButton = $("<button style='padding:0; line-height:1.4'>Edit Polygon</button>").button({
        icon: "fa fa-pencil",
        showLabel: false
      }).click(function () {
        _this2.SetVisible(false); //console.log("annotation-gui:353 Create");


        _this2.polyEditor.BeginEditing('stop');
      });
      $editStopPolyButton.attr('title', "Edit polygon");
      this.RegisterElement($editStopPolyButton, $stopTab, -1);
      var $stopTargetLabel = $("<label>Stop Target</label> ");
      $stopTargetLabel.css("color", "white");
      this.RegisterElement($stopTargetLabel, $stopTab, -1); //stop point polygon is added

      this.$endPolygonSet = $("<button style='padding:0; line-height:1.4'>End Polygon Set</button>").button({
        icon: "fa fa-check-square-o",
        showLabel: false
      }); //this.$endPolygonSet.css("visibility", "inherit");

      this.$endPolygonSet.css("visibility", "hidden"); //this.$endPolygonSet.addClass("waldorf-confirm-button");
      //Add some error checking...

      this.$timeEndField.blur(function () {
        var e = $(_this2.$timeEndField).val();
        var s = $(_this2.$timeStartField).val();

        if ((0, _time.GetSecondsFromHMS)(s + 1) > (0, _time.GetSecondsFromHMS)(e)) {
          $(_this2.$timeEndField).val((0, _time.GetFormattedTime)((0, _time.GetSecondsFromHMS)(s) + .01));
        }
      });
      this.$timeStartField.blur(function () {
        var e = $(_this2.$timeEndField).val();
        var s = $(_this2.$timeStartField).val();

        if ((0, _time.GetSecondsFromHMS)(s + 1) > (0, _time.GetSecondsFromHMS)(e)) {
          $(_this2.$timeEndField).val((0, _time.GetFormattedTime)((0, _time.GetSecondsFromHMS)(s) + .01));
        }
      });
      this.RegisterElement(this.$endPolygonSet, $stopTab, -2);
      var $buttonPanel = $("<div class='button_panel'></div>").appendTo(this.$container); // Make delete button. This should only appear if we're editing, not if it's a new annotation

      this.$deleteButton = $("<button>Delete Annotation</button>").button({
        // icon: "fa fa-bomb",
        showLabel: true
      });
      this.$deleteButton.hide();
      this.$deleteButton.attr('title', "Delete annotation");
      this.$deleteButton.click(function () {
        _this2.annotator.server.DeleteAnnotation(_this2.originalAnnotation, function () {
          _this2.annotator.DeregisterAnnotation(_this2.originalAnnotation);

          _this2.Close();
        });
      });
      this.RegisterElement(this.$deleteButton, $buttonPanel, -1); // Make cancel button

      var $cancelButton = $("<br><br><button>Cancel</button>").button({
        showLabel: true
      }).click(function () {
        _this2.polyEditor.ResetPolygons();

        _this2.Close();
      });
      $cancelButton.css("float", "right");
      $cancelButton.attr('title', "Exit annotation editing"); //$cancel_button.addClass("waldorf-cancel-button");

      this.RegisterElement($cancelButton, $buttonPanel, -1); // Make save button

      var $saveButton = $("<button>Save</button>").button({
        showLabel: true
      }).click(function () {
        _this2.CommitAnnotationToServer(function (annotation, oldID) {
          if (_this2.editMode) {
            _this2.annotator.UpdateAnnotation(annotation, oldID);
          } else {
            _this2.annotator.RegisterNewAnnotation(annotation);
          }

          _this2.polyEditor.ResetPolygons();

          _this2.Close();
        });
      });
      $saveButton.css("float", "left");
      this.RegisterElement($saveButton, $buttonPanel, -1); //https://stackoverflow.com/questions/13837304/jquery-ui-non-ajax-tab-loading-whole-website-into-itself

      $('base').remove();
      this.$tabs.tabs().addClass('ui-tabs-vertical'); //let $script_section = $
      //this.$container.hide();
    }
  }, {
    key: "RegisterElement",
    value: function RegisterElement($element, $container, order) {
      var justification = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'flex-start';
      $element.css('order', order);
      $element.css('align-self', justification); // Sets grow [shrink] [basis]
      //$element.css('flex', '0 0 auto');

      $container.append($element);
    }
  }, {
    key: "SetVisible",
    value: function SetVisible(isVisible) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      //console.log(isVisible + " " + duration);
      if (isVisible) {
        this.$container.fadeTo(duration, 1.0);
        this.$container.makeVisible(true);
      } else {
        this.$container.stop(true, true);
        this.$container.fadeTo(duration, 0.0);
        this.$container.makeVisible(false);
      }

      this.isVisible = isVisible;
    }
  }, {
    key: "ToggleOpen",
    value: function ToggleOpen() {
      if (this.open) {
        this.Close();
      } else {
        this.Open();
      }
    }
  }, {
    key: "Open",
    value: function Open() {
      this.SetVisible(true);
      this.open = true;
      this.polyEditor.Done(); // Disable autofading when the gui is visible

      this.annotator.player.SetAutoFade(false);
    }
  }, {
    key: "Close",
    value: function Close() {
      this.SetVisible(false);
      this.open = false;
      this.polyEditor.Done(); // Re-enable autofading when the gui is hidden

      this.annotator.player.SetAutoFade(true);
      this.$container.trigger("OnGUIClosed");
    }
  }, {
    key: "ToggleVisible",
    value: function ToggleVisible() {
      this.SetVisible(!this.isVisible, 0);
    }
  }, {
    key: "BeginEditing",
    value: function BeginEditing() {
      var annotation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var forceNew = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      // Open the GUI if it isn't already
      this.Open(); // Populate data from the passed in annotation

      if (annotation || forceNew) {
        // Populate the fields from the annotation
        this.editMode = true; // Flip edit mode back to false if forceNew. We want to
        // populate from the entire passed in annotation, but treat
        // it as new.

        if (forceNew) this.editMode = false;
        this.originalAnnotation = annotation;
        console.log("Populated from an existing annotation");
        console.log(annotation);
        this.$timeStartField.val((0, _time.GetFormattedTime)(annotation.beginTime));
        this.$timeEndField.val((0, _time.GetFormattedTime)(annotation.endTime));

        if ('undefined' == typeof annotation.items) {
          // Version 1
          this.$textField.val(annotation.body.filter(function (item) {
            return item.purpose == "describing";
          })[0].value); // Version 1 doesn't have a this.id context
        } else {
          // Version 2
          this.$textField.val(annotation.items[0].items[0].items[0].body.filter(function (item) {
            return item.purpose == "describing";
          })[0].value);
          this.id = annotation.items[0].items[0].items[0].id;
        } // Reset the tags field


        this.$tagsField.val("").trigger("change");
        this.$tagsField.find("option").remove();

        var _iterator = _createForOfIteratorHelper(annotation.tags),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var tag = _step.value;
            this.$tagsField.append("<option value='" + tag + "' selected>" + tag + "</option>");
            this.$tagsField.trigger("change");
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        this.polyEditor.InitPoly(annotation.getPoly());
        this.polyEditor.ShowJustPolygon(); // Propagate the polygon editor's polygons array with polygons from the annotation

        this.polyEditor.$polygons = [];

        if (annotation.polyStart != null) {
          this.polyEditor.$polygons.push(annotation.polyStart);

          if (annotation.polyEnd != null) {
            this.polyEditor.$polygons.push(annotation.polyEnd);
          }
        }
      } // Insert template data if no annotation is given
      else {
          // Populate fields if no annotation is given
          this.editMode = false;
          this.originalAnnotation = null;
          console.log("Populated with template data");
          this.$timeStartField.val((0, _time.GetFormattedTime)(this.annotator.player.videoElement.currentTime));
          this.$timeEndField.val((0, _time.GetFormattedTime)(this.annotator.player.videoElement.duration));
          this.$textField.val(""); // Reset the tags field

          this.$tagsField.val("").trigger("change");
          this.$tagsField.find("option").remove();
          this.polyEditor.InitPoly();
        } // Modify GUI based on edit mode


      if (this.editMode) {
        this.$title.text("Edit Annotation");
        this.$deleteButton.button("enable");
      } else {
        this.$title.text("Create Annotation");
        this.$deleteButton.button("disable");
      }
    }
  }, {
    key: "CommitAnnotationToServer",
    value: function CommitAnnotationToServer(callback) {
      if (this.editMode) {
        console.log("Sending edited annotation to server...");
        this.annotator.server.EditAnnotation(callback);
      } else {
        console.log("Sending new annotation to server...");
        this.annotator.server.PostAnnotation(callback);
      }
    } // Build an object from the data.

  }, {
    key: "GetAnnotationObject",
    value: function GetAnnotationObject() {
      var annotation = new _annotation.Annotation();

      if ('undefined' == typeof annotation.items) {
        // Version 1
        annotation["body"] = this.BuildAnnotationBodyV1();
        annotation["target"] = this.BuildAnnotationTarget(true);
      } else {
        // Version 2
        annotation["label"] = {
          "en": [this.annotator.contentLabel]
        };
        annotation["items"] = this.BuildAnnotationItems();
      } // Recompute read-only access properties after all other properties have been set


      annotation.recalculate(); // Clone the object so we don't modify anything by changing this object

      var clone = JSON.parse(JSON.stringify(annotation));
      return clone;
    }
  }, {
    key: "BuildAnnotationItems",
    value: function BuildAnnotationItems() {
      var buildTime = new Date().toISOString(); //"2020-08-16T12:00:00Z"

      var videoDuration = this.annotator.player.videoElement.duration;
      var videoWidth = this.annotator.player.videoElement.videoWidth;
      var videoHeight = this.annotator.player.videoElement.videoHeight; // let videoDimension = this.annotator.player.GetVideoDimensions()
      // videoWidth = videoDimension.width;
      // videoHeight = videoDimension.height;

      var items = [{
        "id": this.annotator.url,
        //TODO: scalar specific url - should be supplied to plugin 
        "type": "Canvas",
        "height": videoHeight,
        "width": videoWidth,
        "duration": videoDuration,
        "content": {
          "id": this.annotator.url,
          "type": "Video",
          "height": videoHeight,
          "width": videoWidth,
          "duration": videoDuration,
          "label": {
            "en": this.annotator.contentLabel //"dcterms:title" from the annotation json file from scalar

          },
          "description": {
            "en": ""
          }
        },
        "items": [{
          "id": this.annotator.url,
          "type": "AnnotationPage",
          "generator": "http://github.com/anvc/scalar",
          "generated": buildTime,
          "items": [{
            "id": this.id,
            // URL to the annotation-page
            "type": "Annotation",
            "generator": "http://github.com/novomancy/waldorf-scalar",
            "motivation": "highlighting",
            "creator": this.BuildCreatorTemplate(),
            "created": buildTime,
            "rights": "https://creativecommons.org/licenses/by/4.0/",
            "body": this.BuildAnnotationBodyV2(),
            "target": this.BuildAnnotationTarget(false)
          }]
        }]
      }];
      return items;
    }
  }, {
    key: "BuildCreatorTemplate",
    value: function BuildCreatorTemplate() {
      return {
        "type": "Person",
        "nickname": localStorage.getItem('waldorf_user_name'),
        "email_sha1": localStorage.getItem('waldorf_user_email')
      };
    } //Build with tags entries from onomy

  }, {
    key: "BuildAnnotationBodyV2",
    value: function BuildAnnotationBodyV2() {
      var body = []; // Build text descriptor

      var bodyText = {
        "type": "TextualBody",
        "value": this.$textField.val(),
        "format": "text/plain",
        "language": "en",
        "purpose": "describing"
      };
      body.push(bodyText); // Build tag descriptors
      //let tags = this.$tagsField.select2("data").map((item) => { return item.text; });

      var selected_tags = this.$tagsField.select2("data").map(function (item) {
        return {
          id: item.id,
          text: item.text
        };
      });
      var onomy_map = this.annotator.annotationManager.onomyVocabulary.results.reduce(function (acc, curr) {
        acc[curr['id']] = curr;
        return acc;
      }, {});

      var _iterator2 = _createForOfIteratorHelper(selected_tags),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var tag = _step2.value;
          var onomy_ref = onomy_map[tag.id];
          var bodyTag = {};

          if (onomy_ref) {
            bodyTag = {
              "type": "SpecificResource",
              "purpose": "tagging",
              "source": {
                "id": onomy_ref.terms_id,
                "format": "application/json",
                "label": {
                  "en": onomy_ref.text
                },
                "description": {
                  "en": onomy_ref.comment
                }
              }
            };
          } else {
            bodyTag = {
              "type": "TextualBody",
              "purpose": "tagging",
              "value": tag.text
            };
          }

          body.push(bodyTag);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return body;
    }
  }, {
    key: "BuildAnnotationBodyV1",
    value: function BuildAnnotationBodyV1() {
      var body = []; // Build text descriptor

      var bodyText = {
        "type": "TextualBody",
        "value": this.$textField.val(),
        "format": "text/plain",
        "language": "en",
        "purpose": "describing"
      };
      body.push(bodyText); // Build tag descriptors

      var tags = this.$tagsField.select2("data").map(function (item) {
        return item.text;
      });

      var _iterator3 = _createForOfIteratorHelper(tags),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var tagStr = _step3.value;
          var bodyTag = {
            "type": "TextualBody",
            "purpose": "tagging",
            "value": tagStr
          };
          body.push(bodyTag);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      return body;
    } //used both v1 and v2

  }, {
    key: "BuildAnnotationTarget",
    value: function BuildAnnotationTarget(selectorsInArray) {
      if ('undefined' == typeof selectorsInArray) selectorsInArray = false;
      var target = {
        "id": this.annotator.url,
        // URL of the video
        "type": "Video"
      };
      var selectors = [];
      var safeEndTime = (0, _time.GetSecondsFromHMS)(this.$timeStartField.val());

      if ((0, _time.GetSecondsFromHMS)(this.$timeEndField.val()) > (0, _time.GetSecondsFromHMS)(this.$timeStartField.val())) {
        safeEndTime = (0, _time.GetSecondsFromHMS)(this.$timeEndField.val());
      }

      var startTime = (0, _time.GetSecondsFromHMS)(this.$timeStartField.val()); // Build time selector

      var timeSelector = {
        "type": "FragmentSelector",
        "conformsTo": "http://www.w3.org/TR/media-frags/",
        // See media fragment specification
        "value": "t=".concat(startTime, ",").concat(safeEndTime) // Time interval in seconds

      }; //Build SvgSelector

      if (typeof this.polyEditor.$vertices.start != 'undefined' && this.polyEditor.$vertices.start.length > 0) {
        var pointsStr = this.polyEditor.$vertices.start.map(function (item) {
          return "".concat(item[0], ",").concat(item[1]);
        }).join(" ");
        var value = "<svg viewBox='0 0 100 100' preserveAspectRatio='none'>";
        value += "<polygon points='" + pointsStr + "' />";

        if (this.polyEditor.IsAnimated()) {
          var animeStr = this.polyEditor.$vertices.stop.map(function (item) {
            return "".concat(item[0], ",").concat(item[1]);
          }).join(" ");
          value += "<animate attributeName='points' from='" + pointsStr + "' to='" + animeStr + "'";
          value += " start='" + startTime + "' end='" + safeEndTime + "' />";
        }

        value += "</svg>";
        var polygonSelector = {
          "type": "SvgSelector",
          "conformsTo": "http://www.w3.org/TR/SVG/",
          //added for v2
          "value": "".concat(value) // http://stackoverflow.com/a/24898728

        };

        if (selectorsInArray) {
          selectors.push(polygonSelector);
        } else {
          timeSelector["refinedBy"] = polygonSelector;
        }
      }

      if (selectorsInArray) {
        selectors.push(timeSelector);
        target["selector"] = selectors;
      } else {
        target["selector"] = timeSelector;
      }

      return target;
    }
  }, {
    key: "GetTagsQuery",
    value: function GetTagsQuery() {
      if (this.annotator.annotationManager != undefined && this.annotator.annotationManager.onomyVocabulary.length > 0) {
        return this.annotator.annotationManager.onomyVocabulary;
      }

      return {
        url: this.annotator.tagsURL,
        dataType: 'json',
        delay: 250,
        cache: true,
        onomyLanguage: this.annotator.onomyLanguage,
        annotationManager: this.annotator.annotationManager,
        parseFunction: this.OnomyVocabularProcess,
        processResults: function processResults(data) {
          return this.ajaxOptions.parseFunction(data, this.ajaxOptions.onomyLanguage);
        }
      };
    }
  }, {
    key: "OnomyVocabularProcess",
    value: function OnomyVocabularProcess(data, onomyLanguage) {
      // Parse the labels into the format expected by Select2
      // multilingual tags
      var multilingual_tags = [];
      var m_comments = {};
      var comments = {};
      var m_index = 1;
      var tags = [];
      var index = 1;

      var _iterator4 = _createForOfIteratorHelper(data["terms"]),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var term = _step4.value;
          //if onomyLanguage is defined collect multilingual tags
          var terms_id = term["rdfs:about"];
          var terms_comment = term["rdfs:comment"];

          if (onomyLanguage != '' && term['labels'] != undefined) {
            var t_label = "";
            var t_comment = ""; //get labels

            var _iterator5 = _createForOfIteratorHelper(term["labels"]),
                _step5;

            try {
              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                var label = _step5.value;
                var xml_lang = label["xml:lang"];
                var m_label = label["rdfs:label"];

                if (xml_lang == onomyLanguage && m_label && m_label.trim != "") {
                  t_label = m_label;
                }
              } //get comments

            } catch (err) {
              _iterator5.e(err);
            } finally {
              _iterator5.f();
            }

            var _iterator6 = _createForOfIteratorHelper(term['comments']),
                _step6;

            try {
              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                var _label = _step6.value;
                var _xml_lang = _label["xml:lang"];
                var m_comment = _label["rdfs:comments"]; //TODO: change to comment after fixing Onomy

                if (_xml_lang == onomyLanguage && m_comment) {
                  t_comment = m_comment;
                }
              } // use the term comment value if comment is blank

            } catch (err) {
              _iterator6.e(err);
            } finally {
              _iterator6.f();
            }

            if (t_comment == undefined || t_comment.trim == "") {
              t_comment = terms_comment;
            }

            multilingual_tags.push({
              id: m_index,
              text: t_label,
              terms_id: terms_id,
              comment: t_comment
            });
            m_index++;
          }

          tags.push({
            id: index,
            text: term["rdfs:label"],
            terms_id: term["rdfs:about"],
            comment: term["rdfs:comment"]
          });
          index++;
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      var return_tags = multilingual_tags;

      if (return_tags.length == 0) {
        return_tags = tags;
      } //console.log("return_tags");
      //console.log(return_tags);


      return {
        results: return_tags
      };
    }
  }]);

  return AnnotationGUI;
}();

exports.AnnotationGUI = AnnotationGUI;

},{"../../utils/time.js":22,"../annotation.js":3,"./polygon-editor.js":9,"@babel/types":72}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IndexContainer = void 0;

var _time = require("../../utils/time.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var sha1 = require('sha1');

var IndexContainer = /*#__PURE__*/function () {
  function IndexContainer(annotator) {
    var _this = this;

    _classCallCheck(this, IndexContainer);

    console.log("[Index Container] Creating annotation index");
    this.annotator = annotator;
    var container = $(".waldorf-index");

    if (container.length > 0) {
      this.$container = container.first();
    } else {
      this.$container = $("<div class='waldorf-index' aria-live='polite' role='navigation'></div>").appendTo(this.annotator.$container);
    }

    this.annotationList = $("<ul class='waldorf-annotation-list' role='menubar'></ul>").appendTo(this.$container); // Attach event handlers

    this.annotator.$container.on("OnAnnotationsLoaded", function (event, annotationManager) {
      return _this.Rebuild();
    });
    this.annotator.$container.on("OnAnnotationRegistered", function (event, annotation) {
      return _this.Rebuild();
    });
    this.annotator.$container.on("OnAnnotationRemoved", function (event, id) {
      return _this.Rebuild();
    });
  }

  _createClass(IndexContainer, [{
    key: "Rebuild",
    value: function Rebuild() {
      this.annotationList.empty(); // if(this.annotator.unrenderer) this.annotator.unrenderer(this.annotator);
      // let plural = annotations.length == 1 ? "" : "s";
      // let totalAnnotations = this.annotator.annotationManager.annotations.length;
      // this.$container.html(`<p>Showing ${annotations.length} annotation${plural} (${totalAnnotations} total).</p>`);
      // Add each annotation to the readout

      var ordered = this.annotator.GetAnnotations();

      for (var i = 0; i < ordered.length; i++) {
        this.annotationList.append(this.MakeContainer(this.annotator, ordered[i], i));
      }
    }
  }, {
    key: "MakeContainer",
    value: function MakeContainer(annotator, annotation) {
      //TODO: ARIA and general screen reader compatibility
      var $panel = $("<li role='presentation' data-creator=" + annotation.creator.email + " data-tags='" + annotation.tags.join(", ").replace("'", "%27") + "'></li>"); //let text = JSON.stringify(annotation.AsOpenAnnotation(), null, 2);

      var headerText = (0, _time.GetFormattedTime)(annotation.beginTime) + " - " + (0, _time.GetFormattedTime)(annotation.endTime); // Add clickable header that brings up the edit interface.

      var $header = $("<a href='' title='Go to Annotation' role='menuitem'>" + headerText + "</a><br>");
      $header.click(function (event) {
        event.preventDefault();
        annotator.player.videoElement.currentTime = annotation.beginTime; // if(annotator.player.videoElement.annotationTimeout) clearTimeout(annotator.player.videoElement.annotationTimeout);
        // annotator.player.videoElement.annotationTimeout = setTimeout(function(){
        //     annotator.player.videoElement.pause()}, (annotation.endTime-annotation.beginTime) * 1000
        // );
        //annotator.player.videoElement.src=annotator.url + "#t=" + annotation.beginTime +","+annotation.endTime;
        //annotator.player.videoElement.play();

        annotator.player.Play();
        annotator.player.endTime = annotation.endTime;

        if (annotation.beginTime + 1 > annotation.endTime) {
          annotator.player.Pause();
        }
      });
      $panel.append($header);
      var $content = $("<p></p>");
      $content.append("<b>Text: </b> " + annotation.body.filter(function (item) {
        return item.purpose === "describing";
      })[0].value);
      $content.append("<br>");
      $content.append("<b>Tags: </b> " + annotation.tags.join(", "));
      $content.append("<br>");
      $panel.append($content);
      $panel.appendTo(annotator.$annotationList); // console.log($panel);

      return $panel;
    }
  }]);

  return IndexContainer;
}();

exports.IndexContainer = IndexContainer;

},{"../../utils/time.js":22,"sha1":227}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InfoContainer = void 0;

var _time = require("../../utils/time.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var sha1 = require('sha1');

var InfoContainer = /*#__PURE__*/function () {
  function InfoContainer(annotator) {
    _classCallCheck(this, InfoContainer);

    this.annotator = annotator;
    var container = $(".waldorf-info");

    if (container.length > 0) {
      this.$container = container.first();
    } else {
      this.$container = $("<div class='waldorf-info' aria-live='polite' aria-atomic='true'></div>").appendTo(this.annotator.$container);
    }
  }

  _createClass(InfoContainer, [{
    key: "Rebuild",
    value: function Rebuild(annotations, clearContainer) {
      if (clearContainer) this.$container.empty();
      if (this.annotator.unrenderer) this.annotator.unrenderer(this.annotator); // let plural = annotations.length == 1 ? "" : "s";
      // let totalAnnotations = this.annotator.annotationManager.annotations.length;
      // this.$container.html(`<p>Showing ${annotations.length} annotation${plural} (${totalAnnotations} total).</p>`);
      // Add each annotation to the readout

      var renderer = this.annotator.renderer === false ? this.MakeContainer : this.annotator.renderer;

      for (var i = 0; i < annotations.length; i++) {
        this.$container.append(renderer(this.annotator, annotations[i], i));
      }
    }
  }, {
    key: "MakeContainer",
    value: function MakeContainer(annotator, annotation, index) {
      var $panel = $("<p></p>").appendTo($("<div></div>").appendTo(annotator.$container)); //let text = JSON.stringify(annotation.AsOpenAnnotation(), null, 2);
      // Add clickable header that brings up the edit interface.

      var $header = $("<b>Annotation ".concat(index + 1, ":</b><br>"));

      if (annotator.kioskMode == false) {
        $header = $("<a href='' title='Edit Annotation'><b>Annotation ".concat(index + 1, ":</b><br></a>"));
        $header.click(function (event) {
          event.preventDefault();
          annotator.gui.BeginEditing(annotation);
        });
      }

      $panel.append($header);
      var $content = $("<p></p>");

      if ('undefined' == typeof annotation.items) {
        // Version 1
        var annotation_body = annotation.body.filter(function (item) {
          return item.purpose === "describing";
        })[0];
        var annotation_creator = annotation.creator != null ? annotation.creator : {};
      } else {
        // Version 2
        var annotation_body = annotation.items[0].items[0].items[0].body.filter(function (item) {
          return item.purpose === "describing";
        })[0];
        var annotation_creator = annotation.items[0].items[0].items[0].creator;
      }

      $content.append("<b>Text: </b> " + annotation_body.value);
      $content.append("<br>");
      $content.append("<b>Tags: </b> " + annotation.tags.join(", "));
      $content.append("<br>");
      $content.append("<b>Time: </b> " + (0, _time.GetFormattedTime)(annotation.beginTime) + " - " + (0, _time.GetFormattedTime)(annotation.endTime));
      $content.append("<br>");
      $content.append("<b>Submitter:</b> " + ('undefined' != typeof annotation_creator.nickname && annotation_creator.nickname.length ? annotation_creator.nickname : "<i>Not available</i>")); //$paragraph.append("<strong>Annotation " + (index + 1) + ":</strong><br><pre>" + text.escapeHTML() + "</pre>");

      $panel.append($content);
      return $panel;
    }
  }]);

  return InfoContainer;
}();

exports.InfoContainer = InfoContainer;

},{"../../utils/time.js":22,"sha1":227}],8:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MessageOverlay = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var MessageOverlay = /*#__PURE__*/function () {
  function MessageOverlay(annotator) {
    _classCallCheck(this, MessageOverlay);

    this.annotator = annotator;
    this.$container = $("<div class='waldorf-message-overlay'></div>");
    this.$container.appendTo(this.annotator.player.$container);
    this.$text = $("<p role='alert' aria-live='assertive' aria-atomic='true'></p>").appendTo(this.$container);
    this.$container.fadeOut(0);
  }

  _createClass(MessageOverlay, [{
    key: "ShowError",
    value: function ShowError(message) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3.0;
      this.$container.addClass("waldorf-message-overlay-error");

      this._ShowText(message, duration);
    }
  }, {
    key: "ShowMessage",
    value: function ShowMessage(message) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5.0;
      this.$container.removeClass("waldorf-message-overlay-error");

      this._ShowText(message, duration);
    }
  }, {
    key: "_ShowText",
    value: function _ShowText(message) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5.0;
      this.$text.html(message); //this.$container.stop(true, true);

      this.$container.finish();
      this.$container.fadeIn(0).delay(duration * 1000).fadeOut(400);
    }
  }]);

  return MessageOverlay;
}();

exports.MessageOverlay = MessageOverlay;

},{}],9:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PolygonEditor = void 0;

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Manages the creating or editing of a single polygon on the video.
 * Consists of a toolbar, an overlay, and the polygon inside the overlay.
 *
 * Click to place or remove a draggable point. Points should be
 * put down in clockwise order.
 */
var PolygonEditor = /*#__PURE__*/function () {
  function PolygonEditor(annotator) {
    var _this = this;

    _classCallCheck(this, PolygonEditor);

    this.annotator = annotator;
    this.baseZ = 2147483649;
    this.$breadcrumbs = [];
    this.$vertices = {
      'start': [],
      'stop': []
    }; //arrays of vertices for start/stop polys

    this.$polygons = {
      'start': null,
      'stop': null
    }; //DOM nodes for the actual polygons
    // this.$tempBreadCrumbs = [];

    this.$startStop = null; // Create the video overlay

    this.$clickSurface = $("<div class='waldorf-edit-overlay waldorf-vp-click-surface'></div>").appendTo(this.annotator.player.$container); //this.$clickSurface.css("z-index", this.baseZ);

    this.$clickSurface.click(function (event) {
      _this.OnSurfaceClick(event);
    }); // Initialize the polygon DOM nodes

    this.$polygons.start = $("<div class='waldorf-start-poly'></div>").appendTo(this.$clickSurface);
    this.$polygons.start.css("z-index", this.baseZ + 1);
    this.$polygons.stop = $("<div class='waldorf-stop-poly'></div>").appendTo(this.$clickSurface);
    this.$polygons.stop.css("z-index", this.baseZ + 1);
    this.ResizeOverlay();
    this.annotator.player.$container.on("OnFullscreenChange", function (event, setFullscreen) {
      return _this.ResizeOverlay();
    }); // Create the toolbar up top
    // this.$bar = $("<div class='waldorf-vp-post'></div>").appendTo(this.annotator.player.$container);
    // this.$postToolbar = $("<div class='flex-toolbar'></div>").appendTo(this.$bar);
    // Invisible expanding divider
    //-3//this.$postToolbar.append($("<div><p style='color:white'>Edit Polygon</p></div>").css("flex-grow", 1).css("order", 0));
    // Make "Collect Polygon state" button
    // this.$capPolyButton = $("<button>Capture Polygon</button>").button({
    //     icon: "fa fa-camera-retro",
    //     showLabel: false
    // }).click(() => {
    //     //this.SetVisible(false);
    //     //this.GetPoints();
    //     // Build polygon selector
    //     // let points = this.GetPoints();
    //     // if(points.length > 0) {
    //     //     let pointsStr = points.map(item => { return `${item[0]},${item[1]}` }).join(" ");
    //     //     let polygonSelector = {
    //     //         "type": "SvgSelector",
    //     //         "value": `<svg:svg viewBox='0 0 100 100' preserveAspectRatio='none'><polygon points='${pointsStr}' /></svg:svg>` // http://stackoverflow.com/a/24898728
    //     //     }
    //     //     tmpSelectors.push(polygonSelector);
    //     // }
    //     // console.log("tmpSelectors");
    //     // console.log(tmpSelectors);
    //     this.annotator.AddPolygonSet(this.annotator.annotation.getPoly());
    // });
    // this.$capPolyButton.css("margin-right", "15px");
    // this.$capPolyButton.attr('title', "Capture polygon");
    //-3//this.RegisterElement(this.$capPolyButton, this.$postToolbar, 1, 'flex-end');
    // Create undo button
    // this.$undoButton = $("<button>Remove Last Point</button>").button({
    //     icon: "fa fa-undo",
    //     showLabel: false
    // });
    // this.$undoButton.css("margin-right", "15px");
    // this.$undoButton.attr('title', "Remove last point");
    // this.$undoButton.click(() => {
    //     this.RemoveLastBreadcrumb();
    // });
    //-3//this.RegisterElement(this.$undoButton, this.$postToolbar, 1, 'flex-end');
    // Create the confirm button
    // this.$confirmButton = $("<button>Finish polygon</button>").button({
    //     icon: "fa fa-check",
    //     showLabel: false
    // });
    // this.$confirmButton.attr('title', "Finish polygon");
    // this.$confirmButton.addClass("waldorf-confirm-button");
    // this.$confirmButton.click(() => {
    //     this.originalJSON = this.GetJSON();
    //     this.Done();
    //     this.annotator.$container.trigger("OnPolygonEditingEnded");
    // });
    // //-3//this.RegisterElement(this.$confirmButton, this.$postToolbar, 3, 'flex-end');
    // // Create the cancel button
    // this.$cancelButton = $("<button>Stop polygon editing</button>").button({
    //     icon: "fa fa-remove",
    //     showLabel: false
    // });
    // this.$cancelButton.addClass("waldorf-cancel-button");
    // this.$cancelButton.attr('title', "Stop polygon editing");
    // this.$cancelButton.click(() => {
    //     //Restore the original state
    //     this.Restore();
    //     this.Done();
    //     this.annotator.$container.trigger("OnPolygonEditingEnded");
    // });
    // //-3//this.RegisterElement(this.$cancelButton, this.$postToolbar, 2, 'flex-end');
    // $(window).resize(() => this.ResizeOverlay());

    /* 
    * new UI
    */

    this.$editDialog = $("<div id='edit-dialog' class='waldorf-edit-overlay waldorf-vp-click-surface'></div>").appendTo(this.annotator.player.$container);
    this.$editDialog.draggable();
    this.$editDialog.css('z-index', this.baseZ + 100);
    this.$editDialog.click(function (event) {
      _this.OnSurfaceClick(event);
    });
    this.$space = $("<div>&nbsp;</div><hr>");
    this.RegisterElement(this.$space, this.$editDialog, 1, 'flex-end'); // Create undo button

    this.$undoButton = $("<button>Remove Last Point</button>").button({
      icon: "fa fa-undo",
      showLabel: false
    });
    this.$undoButton.css("margin", "0px 5px 4px 5px");
    this.$undoButton.attr('title', "Remove last point");
    this.$undoButton.css('z-index', this.baseZ + 105);
    this.$undoButton.click(function () {
      _this.RemoveLastBreadcrumb();
    });
    this.RegisterElement(this.$undoButton, this.$editDialog, 1, 'flex-end'); // Make "Collect Polygon state" button

    this.$capPolyButton = $("<button>Capture Polygon</button>").button({
      icon: "fa fa-camera-retro",
      showLabel: false
    }).click(function () {
      _this.AddPolygonSet();
    });
    this.$capPolyButton.css("margin", "0px 5px 4px 5px");
    this.$capPolyButton.attr('title', "Capture Polygon");
    this.$capPolyButton.css('z-index', this.baseZ + 105);
    this.RegisterElement(this.$capPolyButton, this.$editDialog, 1, 'flex-end'); // Create the cancel button

    this.$cancelButton = $("<button>Stop polygon editing</button>").button({
      icon: "fa fa-remove",
      showLabel: false
    });
    this.$cancelButton.css("margin", "0px 5px 4px 5px");
    this.$cancelButton.addClass("waldorf-cancel-button");
    this.$cancelButton.attr('title', "Stop Polygon Editing");
    this.$cancelButton.click(function () {
      //Restore the original state
      //this.Restore();
      _this.RemoveAllBreadcrumbs();

      _this.annotator.$container.trigger("OnPolygonEditingEnded");

      _this.Done();
    });
    this.RegisterElement(this.$cancelButton, this.$editDialog, 2, 'flex-end');
    $(window).resize(function () {
      return _this.ResizeOverlay();
    });
    this.Done();
  }

  _createClass(PolygonEditor, [{
    key: "OnSurfaceClick",
    value: function OnSurfaceClick(event) {
      if ($(event.currentTarget).attr("id") == "edit-dialog" || this.$startStop != "start") {
        return;
      } // Add a breadcrumb on click, but only for the start polygon. End vertices can only be dragged


      var target = $(event.currentTarget);
      var x = event.pageX - target.offset().left;
      var y = event.pageY - target.offset().top;
      var xPercent = x / target.width() * 100;
      var yPercent = y / target.height() * 100;
      this.AddBreadcrumb(xPercent, yPercent); //this.newPolyPoints.push([xPercent.toFixed(3), yPercent.toFixed(3)]);

      this.UpdatePolyClipping();
    }
    /**
     * Creates a new breadcrumb at the given (x, y) point on the
     * clickSurface, where x and y are percentages from 0 to 100.
     */

  }, {
    key: "AddBreadcrumb",
    value: function AddBreadcrumb(xPercent, yPercent) {
      var _this2 = this;

      var $breadcrumb = $("<div class='breadcrumb'></div>");
      $breadcrumb.appendTo(this.$clickSurface);
      $breadcrumb.css("position", "absolute"); // Percentage representations of breadcrumb width and height

      var offPercentX = $breadcrumb.outerWidth() / this.$clickSurface.width() * 100;
      var offPercentY = $breadcrumb.outerHeight() / this.$clickSurface.height() * 100; // Percentage representations of breadcrumb width and height

      $breadcrumb.css("left", (xPercent - offPercentX / 2).toString() + "%");
      $breadcrumb.css("top", (yPercent - offPercentY / 2).toString() + "%"); //$breadcrumb.css("z-index", this.baseZ - 50);

      $breadcrumb.draggable({
        //containment: "parent",
        drag: function drag() {
          // Recalculate percentages (mangled by jQuery UI draggable code)
          // See http://stackoverflow.com/a/23673462
          var l = 100 * parseFloat($breadcrumb.css("left")) / parseFloat($breadcrumb.parent().css("width")) + "%";
          var t = 100 * parseFloat($breadcrumb.css("top")) / parseFloat($breadcrumb.parent().css("height")) + "%";
          $breadcrumb.css("left", l);
          $breadcrumb.css("top", t);

          _this2.UpdatePolyClipping();
        }
      });

      if (this.$startStop == "start") {
        //breadcrumbs can only be added or removed in the first polygon
        $breadcrumb.click(function (event) {
          // Remove the breadcrumb on click
          event.stopPropagation();
          $breadcrumb.remove();

          _this2.$breadcrumbs.splice(_this2.$breadcrumbs.indexOf($breadcrumb), 1);

          _this2.UpdatePolyClipping();

          _this2.UpdateBreadcrumbColoring();
        });
      }

      this.$breadcrumbs.push($breadcrumb); //this.UpdatePolyClipping();

      this.UpdateBreadcrumbColoring();
    }
    /**
     * Removes the last-placed breadcrumb from the list
     * and updates the view.
     */

  }, {
    key: "RemoveLastBreadcrumb",
    value: function RemoveLastBreadcrumb() {
      var $removed = this.$breadcrumbs.pop();
      $removed.remove();
      this.UpdatePolyClipping();
      this.UpdateBreadcrumbColoring();
    }
  }, {
    key: "RemoveAllBreadcrumbs",
    value: function RemoveAllBreadcrumbs() {
      console.log("Removing all breadcrumbs");

      while (this.$breadcrumbs.length > 0) {
        this.RemoveLastBreadcrumb();
      }
    }
    /**
     * Gets the center of the breadcrumb as an (x, y) pair
     * representing the percentage distance from the top and left
     * of the click surface (0% - 100%).
     */

  }, {
    key: "GetCenterPercentage",
    value: function GetCenterPercentage($breadcrumb) {
      var topPercent = $breadcrumb.position().top / $breadcrumb.parent().height() * 100;
      var leftPercent = $breadcrumb.position().left / $breadcrumb.parent().width() * 100; // Percentage values for the dimensions of the breadcrumb relative to the click surface

      var offPercentX = $breadcrumb.outerWidth() / $breadcrumb.parent().width() * 100;
      var offPercentY = $breadcrumb.outerHeight() / $breadcrumb.parent().height() * 100;
      return {
        x: leftPercent + offPercentX / 2.0,
        y: topPercent + offPercentY / 2.0
      };
    }
  }, {
    key: "Reset",
    value: function Reset() {
      // Remove all breadcrumbs
      var _iterator = _createForOfIteratorHelper(this.$breadcrumbs),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var $breadcrumb = _step.value;
          $breadcrumb.remove();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      this.$breadcrumbs = []; // Remove the poly if it already exists
      // if(this.$poly != null){
      //     this.$poly.remove();
      // }
    }
  }, {
    key: "ResetPolygons",
    value: function ResetPolygons() {
      console.log("resetting polygons");

      if (this.$polygons.start) {
        console.log("reset start poly");
        this.$polygons.start.makeVisible(false);
        this.$polygons.start.css("clip-path", "");
      }

      if (this.$polygons.stop) {
        this.$polygons.stop.makeVisible(false);
        this.$polygons.stop.css("clip-path", "");
      }

      this.$vertices = {
        'start': [],
        'stop': []
      };
      this.UpdatePolyClipping();
      this.RemoveAllBreadcrumbs();
    }
  }, {
    key: "Restore",
    value: function Restore() {
      this.InitPoly(this.originalJSON);
    }
  }, {
    key: "InitPoly",
    value: function InitPoly() {
      var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      this.Reset(); // If JSON was specified, generate breadcrumbs from it.

      if (points != null) {
        // Put down the breadcrumbs
        var _iterator2 = _createForOfIteratorHelper(points),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var point = _step2.value;
            this.AddBreadcrumb(point[0], point[1]);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }

      this.UpdatePolyClipping();
      this.originalJSON = points;
    }
  }, {
    key: "DrawPolygons",
    value: function DrawPolygons() {
      var _this3 = this;

      this.RemoveAllBreadcrumbs();

      if (this.$vertices.start != []) {
        //let startPolygon = this.$vertices.start; //.map(item => { return `${item[0]},${item[1]}` }).join(" ");;
        // Create the poly objects
        // this.$polygons.start = $("<div class='waldorf-start-poly'></div>").appendTo(this.$clickSurface);
        // this.$polygons.start.css("z-index", this.baseZ + 1000);
        if (this.$vertices.start.length < 3) {
          this.$polygons.start.makeVisible(false);
          this.$polygons.start.clipPath([], {
            svgDefId: 'annotatorStartPolySvg'
          });
        } else {
          this.$polygons.start.makeVisible(true);
          this.$polygons.start.clipPath(this.$vertices.start, {
            isPercentage: true,
            svgDefId: 'annotatorStartPolySvg'
          });

          if (this.$startStop == "start") {
            this.$vertices.start.map(function (point) {
              _this3.AddBreadcrumb(point[0], point[1]);
            });
          }
        }
      }

      if (this.$vertices.stop != []) {
        // this.$stopPoly.remove();
        // this.$stopPoly = $("<div class='waldorf-stop-poly'></div>").appendTo(this.$clickSurface);
        // this.$stopPoly.css("z-index", this.baseZ + 1000);
        if (this.$vertices.stop.length < 3) {
          this.$polygons.stop.clipPath([], {
            svgDefId: 'annotatorStopPolySvg'
          });
        } else {
          this.$polygons.stop.clipPath(this.$vertices.stop, {
            isPercentage: true,
            svgDefId: 'annotatorStopPolySvg'
          });

          if (this.$startStop == "stop") {
            this.$vertices.stop.map(function (point) {
              _this3.AddBreadcrumb(point[0], point[1]);
            });
          }
        }
      }
    }
  }, {
    key: "UpdatePolyClipping",
    value: function UpdatePolyClipping() {
      var _this4 = this;

      if (this.$startStop == null) return;
      var svgId = this.$startStop == "start" ? "annotatorStartPolySvg" : "annotatorStopPolySvg";

      if (this.$breadcrumbs.length < 3) {
        this.$polygons[this.$startStop].makeVisible(false);
        this.$polygons[this.$startStop].clipPath([], {
          svgDefId: svgId
        });
      } else {
        var points = this.$breadcrumbs.map(function ($crumb) {
          var pos = _this4.GetCenterPercentage($crumb);

          return [pos.x, pos.y];
        });
        this.$polygons[this.$startStop].makeVisible(true);
        this.$polygons[this.$startStop].clipPath(points, {
          isPercentage: true,
          svgDefId: svgId
        });
      }
    }
  }, {
    key: "UpdateBreadcrumbColoring",
    value: function UpdateBreadcrumbColoring() {
      for (var i = 0; i < this.$breadcrumbs.length; i++) {
        var $crumb = this.$breadcrumbs[i]; // Recolor each breadcrumb

        var color = "#000000";

        if (i == this.$breadcrumbs.length - 1) {
          color = "#FF0000";
        } else if (i == 0) {
          color = "#00FF00";
        }

        this.$breadcrumbs[i].css("border-color", color);
      }
    }
    /**
     * Gets an array of percentages representing the x and y percentages of each
     * point in the polygon.
     */

  }, {
    key: "GetJSON",
    value: function GetJSON() {
      // Extract the coordinates from the crumbs and put them in the array
      var points = [];

      var _iterator3 = _createForOfIteratorHelper(this.$breadcrumbs),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var crumb = _step3.value;
          var point = this.GetCenterPercentage(crumb);
          points.push([point.x.toString(), point.y.toString()]);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      return JSON.stringify(points);
    }
    /**
     * Gets an array of percentages representing the x and y percentages of each
     * point in the polygon.
     */

  }, {
    key: "GetPoints",
    value: function GetPoints() {
      var points = [];

      var _iterator4 = _createForOfIteratorHelper(this.$breadcrumbs),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var crumb = _step4.value;
          var point = this.GetCenterPercentage(crumb);
          points.push([point.x, point.y]);
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      return points;
    }
    /**
     * Determines if all start vertices match stop vertices
     * returns true if the vertices don't match exactly
     */

  }, {
    key: "IsAnimated",
    value: function IsAnimated() {
      var comp = this.$vertices.start;
      var startString = JSON.stringify(comp);
      comp = this.$vertices.stop;
      var stopString = JSON.stringify(comp);
      return JSON.stringify(startString) != JSON.stringify(stopString);
    }
  }, {
    key: "BeginEditing",
    value: function BeginEditing(startStop) {
      this.$startStop = startStop; //startStop is either 'start' or 'stop', depending on which polygon is being edited

      this.$clickSurface.makeVisible(true);
      this.$editDialog.makeVisible(true);
      this.$polygons.start.makeVisible(true);
      this.$polygons.stop.makeVisible(true); //-3//this.$bar.makeVisible(true);

      this.DrawPolygons();
      this.UpdatePolyClipping();
    }
  }, {
    key: "Done",
    value: function Done() {
      this.$clickSurface.makeVisible(false);
      this.$editDialog.makeVisible(false);
      this.$polygons.start.makeVisible(false);
      this.$polygons.stop.makeVisible(false); //-3//this.$bar.makeVisible(false);
    }
  }, {
    key: "ResizeOverlay",
    value: function ResizeOverlay() {
      // Resize video overlay to fit actual video dimensions
      var videoDims = this.annotator.player.GetVideoDimensions();
      this.$clickSurface.css('width', videoDims.width);
      this.$clickSurface.css('height', videoDims.height);
      var heightDiff = (this.annotator.player.$video.height() - videoDims.height) / 2;
      this.$clickSurface.css('top', heightDiff);
      var widthDiff = (this.annotator.player.$video.width() - videoDims.width) / 2;
      this.$clickSurface.css('left', widthDiff);
      this.$polygons.start.width(videoDims.width);
      this.$polygons.start.height(videoDims.height);
      this.$polygons.start.css("top", heightDiff);
      this.$polygons.start.css("left", widthDiff);
      this.$polygons.start.css("position", "absolute");
      this.$polygons.start.makeVisible(false);
      this.$polygons.stop.width(videoDims.width);
      this.$polygons.stop.height(videoDims.height);
      this.$polygons.stop.css("top", heightDiff);
      this.$polygons.stop.css("left", widthDiff);
      this.$polygons.stop.css("position", "absolute");
      this.$polygons.stop.makeVisible(false);
    }
  }, {
    key: "RegisterElement",
    value: function RegisterElement($element, $container, order) {
      var justification = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'flex-start';
      $element.css('order', order);
      $element.css('align-self', justification); // Sets grow [shrink] [basis]
      //$element.css('flex', '0 0 auto');

      $container.append($element);
    }
  }, {
    key: "ShowJustPolygon",
    value: function ShowJustPolygon() {
      this.$polygons.start.makeVisible(true);
      this.$polygons.stop.makeVisible(true);
    }
  }, {
    key: "AddPolygonSet",
    value: function AddPolygonSet() {
      //This is saving a set of breadcrumbs into the vertices for a polygon
      this.$vertices[this.$startStop] = this.GetPoints();

      if (this.$startStop == "start" && this.$vertices.stop.length != this.$vertices.start.length) {
        this.$vertices.stop = this.GetPoints();
      }

      this.RemoveAllBreadcrumbs();
      this.annotator.messageOverlay.ShowMessage("Captured " + this.$startStop + " polygon."); // if (this.$vertices.length > 1) {
      //     this.$polygons = [];
      //     this.$tempBreadCrumbs = [];
      // }
      // if (!this.$polygons.length) {
      //     this.$polygons.start = this.GetPoints();
      //     this.$tempBreadCrumbs[0] = [this.$breadcrumbs];
      //     var msg = "Successfully captured first polygon.";
      // } else {
      //     this.$polygons.stop = this.GetPoints();
      //     this.$tempBreadCrumbs[1] = [this.$breadcrumbs];
      //     var msg = "Successfully captured second polygon.";
      // } 

      this.annotator.$container.trigger("OnPolygonEditingEnded");
      this.Done();
    }
  }]);

  return PolygonEditor;
}();

exports.PolygonEditor = PolygonEditor;

},{}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PolygonOverlay = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var PolygonOverlay = /*#__PURE__*/function () {
  function PolygonOverlay(annotator) {
    var _this = this;

    _classCallCheck(this, PolygonOverlay);

    this.annotator = annotator;
    this.polyElements = [];
    this.svgElements = [];
    this.animateElements = [];
    this.baseZ = 2147483649;
    this.lastAnnotations = [];
    this.svgElementsHash = {}; // Create the video overlay

    this.$videoOverlay = $("<div class='waldorf-video-overlay'></div>").appendTo(this.annotator.player.$container);
    this.ResizeOverlay();
    this.annotator.player.$container.on("OnFullscreenChange", function (event, setFullscreen) {
      return _this.ResizeOverlay();
    });
    this.annotator.$container.on("OnNewAnnotationSet", function (event, annotations) {
      return _this.Update(annotations);
    });
    this.videoDims = this.annotator.player.GetVideoDimensions();
    $(window).resize(function () {
      return _this.ResizeOverlay();
    });
  }

  _createClass(PolygonOverlay, [{
    key: "Update",
    value: function Update(annotations) {
      this.Clear(); // let prevSet = new Set(this.lastAnnotations);
      // let newSet = new Set(annotations);
      // // in newSet and not in prevSet
      // let toAdd = new Set(
      //     [...newSet].filter(x => !prevSet.has(x)));
      // // in prevAnnotations and not in annotations
      // let toDestroy = new Set(
      //     [...prevSet].filter(x => !newSet.has(x)));
      // console.log(Array.from(toAdd));
      // console.log(Array.from(toDestroy));
      //Sort polygon order by size (ascending)
      // polygons.sort(function(a, b) {
      //     return this.GetArea(a) > this.GetArea(b);
      // })

      for (var i = 0; i < annotations.length; i++) {
        var annotationPolyPoints = annotations[i].getPoly();

        if (annotationPolyPoints == null) {
          // Ignore this annotation if it has no polygon
          continue;
        }

        var svgPolyPoints = annotations[i].getSVGPolyPoints();
        var duration = annotations[i].endTime - annotations[i].beginTime; // Create the poly object

        var $svg = void 0;

        if (this.svgElements.length == 0) {
          $svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
          $svg.setAttribute('width', '100%');
          $svg.setAttribute('height', '100%');
          $svg.setAttribute('viewBox', '0 0 100 100');
          $svg.setAttribute('preserveAspectRatio', 'none'); //$svg.addEventListener("click", this.ClickEvent);

          this.$videoOverlay.append($svg);
          this.svgElements.push($svg);
        } else {
          $svg = this.svgElements[0];
        }

        var $polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        $polygon.setAttribute('points', svgPolyPoints[0]);
        $polygon.setAttribute('fill', 'rgba(0, 118, 255, 0.55)');
        $svg.appendChild($polygon);
        var $animate = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
        $animate.setAttribute('attributeName', 'points');
        $animate.setAttribute('fill', 'freeze');
        $animate.setAttribute('from', svgPolyPoints[0]);
        $animate.setAttribute('to', svgPolyPoints[1]);
        $animate.setAttribute('begin', 'indefinite');
        $animate.setAttribute('dur', duration + "s");
        $polygon.appendChild($animate);
        var $svgHash = {
          svgElement: $svg,
          polygon: $polygon,
          animate: $animate,
          beginTime: annotations[i].beginTime
        };
        this.svgElementsHash[annotations[i].id] = $svgHash; // Create the poly object
        // let $poly = $("<div class='waldorf-overlay-poly'></div>").appendTo(this.$videoOverlay);
        // $poly.clipPath(annotationPolyPoints, {
        //     isPercentage: true,
        //     svgDefId: 'annotatorPolySvg'
        // });
        // $poly.click(() => {
        //     this.annotator.$container.trigger("OnPolyClicked", annotations[i]);
        // });
        // this.AddTooltip($poly, annotations[i]);
        // this.polyElements.push($poly);

        this.polyElements.push($polygon);
        this.animateElements.push($animate);
      } //this.lastAnnotations = annotations;

    }
  }, {
    key: "ClickEvent",
    value: function ClickEvent(event) {
      console.log("animate is clicked");
    }
  }, {
    key: "AddTooltip",
    value: function AddTooltip($poly, annotation) {
      $.fn.qtip.zindex = this.baseZ + 1;
      $poly.qtip({
        content: {
          title: annotation.id,
          text: annotation.body.filter(function (item) {
            return item.purpose === "describing";
          })[0].value
        },
        position: {
          my: 'bottom right',
          at: 'top left',
          target: 'mouse',
          // Follow the mouse
          adjust: {
            mouse: true,
            method: "shift shift" // horizontal, vertical

          },
          viewport: this.annotator.player.$container
        },
        hide: {
          delay: 0 // No hide delay by default

        },
        style: {
          classes: 'qtip-dark qtip-rounded annotator-qtip'
        }
      });
    }
  }, {
    key: "Clear",
    value: function Clear() {
      // Clear all  animate element from the DOM
      for (var ai = 0; ai < this.animateElements.length; ai++) {
        //this.polyElements[i].data("qtip").destroy(true);
        this.animateElements[ai].remove();
      } // Clear all polygons 


      for (var pi = 0; pi < this.polyElements.length; pi++) {
        this.polyElements[pi].remove();
      } // Clear all  svg elements from the DOM


      for (var si = 0; si < this.svgElements.length; si++) {
        this.svgElements[si].remove();
      } // Mark the array as empty


      this.animateElements = [];
      this.polyElements = [];
      this.svgElements = [];
      this.svgElementsHash = {};
    }
  }, {
    key: "ResizeOverlay",
    value: function ResizeOverlay() {
      // Resize video overlay to fit actual video dimensions
      var videoDims = this.annotator.player.GetVideoDimensions();
      this.$videoOverlay.css('width', videoDims.width);
      this.$videoOverlay.css('height', videoDims.height);
      var heightDiff = (this.annotator.player.$video.height() - videoDims.height) / 2;
      this.$videoOverlay.css('top', heightDiff);
      var widthDiff = (this.annotator.player.$video.width() - videoDims.width) / 2;
      this.$videoOverlay.css('left', widthDiff);
    }
  }, {
    key: "getPlayerSize",
    value: function getPlayerSize() {
      return this.annotator.player.GetVideoDimensions();
    }
  }]);

  return PolygonOverlay;
}();

exports.PolygonOverlay = PolygonOverlay;

},{}],11:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TickBar = void 0;

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var TickBar = /*#__PURE__*/function () {
  function TickBar(annotator) {
    var _this = this;

    _classCallCheck(this, TickBar);

    this.annotator = annotator;
    this.ticks = []; // Create the element

    this.$tickBar = $("<div class='waldorf-tickbar'></div>");
    this.annotator.player.controlBar.$container.append(this.$tickBar); // Attach event handlers

    this.annotator.$container.on("OnAnnotationsLoaded", function (event, annotationManager) {
      return _this.LoadAnnotations(annotationManager);
    });
    this.annotator.$container.on("OnAnnotationRegistered", function (event, annotation) {
      return _this.LoadAnnotation(annotation);
    });
    this.annotator.$container.on("OnAnnotationRemoved", function (event, id) {
      return _this.RemoveAnnotation(id);
    });
  }

  _createClass(TickBar, [{
    key: "LoadAnnotations",
    value: function LoadAnnotations(annotationManager) {
      this.Clear();

      var _iterator = _createForOfIteratorHelper(annotationManager.annotations),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var annotation = _step.value;
          this.LoadAnnotation(annotation);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }, {
    key: "LoadAnnotation",
    value: function LoadAnnotation(annotation) {
      var $tick = $("<div class='waldorf-tickbar-tick'></div>").appendTo(this.$tickBar); // Add the ID of the annotation to its corresponding tick so we can reference it later

      if ('undefined' == typeof annotation.items) {
        // Ver 1
        $tick.data("annotation-id", annotation.id);
      } else {
        // Ver 2
        $tick.data("annotation-id", annotation.items[0].items[0].items[0].id);
      }

      var beginTime = annotation.beginTime;
      var beginPercent = beginTime / this.annotator.player.videoElement.duration;
      $tick.css('left', (beginPercent * 100).toString() + "%");
      var endTime = annotation.endTime;
      var endPercent = endTime / this.annotator.player.videoElement.duration;
      $tick.css('width', ((endPercent - beginPercent) * 100).toString() + "%");
      this.ticks.push($tick);
    }
  }, {
    key: "RemoveAnnotation",
    value: function RemoveAnnotation(id) {
      //console.log("Removing tick " + id);
      // Remove the object from the document, and the array
      var newTicks = [];

      var _iterator2 = _createForOfIteratorHelper(this.ticks),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var $tick = _step2.value;
          console.log('Tick: ' + $tick.data("annotation-id"));

          if ($tick.data("annotation-id") == id) {
            console.log("Removed tick ".concat(id));
            $tick.remove();
          } else {
            newTicks.push($tick);
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      this.ticks = newTicks;
    }
  }, {
    key: "Clear",
    value: function Clear() {
      var _iterator3 = _createForOfIteratorHelper(this.ticks),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var $tick = _step3.value;
          $tick.remove();
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      this.ticks = [];
    }
  }]);

  return TickBar;
}();

exports.TickBar = TickBar;

},{}],12:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ServerInterface = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var sha1 = require('sha1');

var ServerInterface = /*#__PURE__*/function () {
  function ServerInterface(annotator) {
    _classCallCheck(this, ServerInterface);

    this.annotator = annotator; //localStorage.removeItem('waldorf_auth_token');
  }

  _createClass(ServerInterface, [{
    key: "SetBaseURL",
    value: function SetBaseURL(url) {
      this.baseURL = url;
    }
  }, {
    key: "make_base_auth",
    value: function make_base_auth(user, password) {
      var tok = user + ':' + password;
      var hash = btoa(tok);
      return 'Basic ' + hash;
    }
  }, {
    key: "make_write_auth",
    value: function make_write_auth(text) {
      if (this.annotator.apiKey) {
        return 'ApiKey ' + text;
      } else {
        return 'Token ' + text;
      }
    }
  }, {
    key: "LoggedIn",
    value: function LoggedIn() {
      if (this.annotator.apiKey) {
        // Return true if an email has been entered
        var user_email = localStorage.getItem('waldorf_user_email');
        return user_email !== null;
      } else {
        // Return true if a token has been registered
        var auth_token = localStorage.getItem('waldorf_auth_token');
        return auth_token !== null;
      }
    }
  }, {
    key: "LogIn",
    value: function LogIn(username, password) {
      var _this = this;

      // If API key is used, just store the email address
      if (this.annotator.apiKey) {
        console.log("[Server Interface] Successfully logged in.");
        localStorage.setItem('waldorf_user_email', password);
        localStorage.setItem('waldorf_user_name', username);
        this.annotator.messageOverlay.ShowMessage("Logged in as " + username);
        return $.Deferred().resolve();
      }

      return $.ajax({
        url: this.baseURL + "/api/login",
        type: "POST",
        async: true,
        context: this,
        beforeSend: function beforeSend(xhr) {
          xhr.setRequestHeader('Authorization', this.make_base_auth(username, password));
        }
      }).done(function (data) {
        console.log("[Server Interface] Successfully logged in.");
        localStorage.setItem('waldorf_auth_token', data.auth_token);
      }).fail(function (response) {
        console.error("[Server Interface] Could not log in.");

        _this.annotator.messageOverlay.ShowError("Could not log in!");
      });
    }
  }, {
    key: "LogOut",
    value: function LogOut() {
      // If API key is used, just remove the email from local storage.
      if (this.annotator.apiKey) {
        console.log("[Server Interface] Successfully logged out.");
        localStorage.removeItem('waldorf_user_email');
        localStorage.removeItem('waldorf_user_name');
        return $.Deferred().resolve();
      }

      return $.ajax({
        url: this.baseURL + "/api/logout",
        type: "DELETE",
        async: true,
        context: this,
        beforeSend: function beforeSend(xhr) {
          var auth_token = localStorage.getItem('waldorf_auth_token') || "";
          console.log("[Server Interface] token: ".concat(auth_token));
          xhr.setRequestHeader('Authorization', this.make_write_auth(auth_token));
        }
      }).done(function (data) {
        console.log("[Server Interface] Successfully logged out.");
        localStorage.removeItem('waldorf_auth_token');
      }).fail(function (response) {
        console.error("[Server Interface] Could not log out.");
        localStorage.removeItem('waldorf_auth_token');
      });
    }
  }, {
    key: "FetchAnnotations",
    value: function FetchAnnotations(searchKey, searchParam) {
      //This is replaced by this.baseURL, which is defined in config
      //var book_url = 'http://scalar.usc.edu/dev/semantic-annotation-tool/';  // This will be defined in the Book's JS
      //https://scalar.usc.edu/dev/semantic-annotation-tool/rdf/file/media/Inception%20Corgi%20Flop.mp4?format=oac&prov=1&rec=2
      // var ajax_url = this.baseURL + 'rdf/file/' + searchParam.replace(this.baseURL, '') + '?format=oac&prov=1&rec=2';
      var ajax_url = this.baseURL + 'rdf/file/' + searchParam.replace(this.baseURL, '') + '?format=iiif&prov=1&rec=2'; //console.log("ajax_url: " + ajax_url);

      return $.ajax({
        url: ajax_url,
        type: "GET",
        jsonp: "callback",
        dataType: "jsonp",
        async: true
      }).done(function (data) {
        console.log('[Server Interface] Fetched ' + ('undefined' == typeof data.items ? data.length - 1 : data.items[0].items.length) + ' annotations for ' + searchKey + ': "' + searchParam + '".');
      }).fail(function (response) {
        var returned_response = response.responseJSON.error.code[0].value + " : " + response.responseJSON.error.message[0].value;
        console.error('[Server Interface] Error fetching annotations for ' + searchKey + ': "' + searchParam + '"\n ' + returned_response);

        _this2.annotator.messageOverlay.ShowError('Could not retrieve annotations!<br>(' + returned_response + ')');
      });
    }
  }, {
    key: "PostAnnotation",
    value: function PostAnnotation(callback) {
      var _this3 = this;

      console.log("Posting annotation...");
      var annotation = this.annotator.gui.GetAnnotationObject();
      console.log(annotation);
      var key;

      if (this.annotator.apiKey) {
        key = this.annotator.apiKey;
        var email_storage = localStorage.getItem('waldorf_user_email');
        var name_storage = localStorage.getItem('waldorf_user_name');
        if (name_storage == null) name_storage = email_storage;
      } else {
        key = localStorage.getItem('waldorf_auth_token');
      }

      if (this.annotator.apiKey) {
        if (annotation["creator"] == null) annotation["creator"] = {};
        annotation["creator"]["email"] = localStorage.getItem('waldorf_user_email');
        annotation["creator"]["nickname"] = localStorage.getItem('waldorf_user_name');
      }

      if (annotation["annotation_version"] == "v1") {
        annotation["request"]["items"]["action"] = "add";
        delete annotation["items"];
      } else {
        annotation["service"][0]["items"]["action"] = "add";
        delete annotation["target"];
        delete annotation["body"];
      }

      delete annotation["annotation_version"];
      annotation["id"] = this.baseURL + "api/add";
      console.log("PostAnnotation payload: " + JSON.stringify(annotation));
      $.ajax({
        //url: this.baseURL + "/api/addAnnotation",
        url: this.baseURL + "api/add",
        type: "POST",
        dataType: 'json',
        // Necessary for Rails to see this data type correctly
        contentType: 'application/json',
        // Necessary for Rails to see this data type correctly
        data: JSON.stringify(annotation),
        // Stringify necessary for Rails to see this data type correctly
        async: true,
        context: this,
        beforeSend: function beforeSend(xhr) {
          xhr.setRequestHeader('Authorization', this.make_write_auth(key));
        },
        success: function success(data) {
          console.log("Successfully posted new annotation.");

          _this3.annotator.messageOverlay.ShowMessage("Successfully created new annotation.");

          annotation.id = data.id; // Append the ID given by the response

          if (callback) callback(annotation);
        },
        error: function error(response) {
          var returned_response = "undefined error while editing the annotation";

          if (response.responseJSON) {
            returned_response = response.responseJSON.error.code[0].value + " : " + response.responseJSON.error.message[0].value;
          }

          console.error("Could not edit the annotation! Message:\n ".concat(returned_response));

          _this3.annotator.messageOverlay.ShowError("Could not edit the annotation!<br>(".concat(returned_response, ")"));
        }
      });
    }
  }, {
    key: "EditAnnotation",
    value: function EditAnnotation(callback) {
      var _this4 = this;

      console.log("Editing annotation...");
      var annotation = this.annotator.gui.GetAnnotationObject();
      console.log(annotation);
      var key;

      if (this.annotator.apiKey) {
        key = this.annotator.apiKey;
        var email_storage = localStorage.getItem('waldorf_user_email');
        var name_storage = localStorage.getItem('waldorf_user_name');
        if (name_storage == null) name_storage = email_storage;
      } else {
        key = localStorage.getItem('waldorf_auth_token');
      }

      if (this.annotator.apiKey) {
        if (annotation["creator"] == null) annotation["creator"] = {};
        annotation["creator"]["email"] = localStorage.getItem('waldorf_user_email');
        annotation["creator"]["nickname"] = localStorage.getItem('waldorf_user_name');
      }

      if (annotation["annotation_version"] == "v1") {
        annotation["request"]["items"]["action"] = "update";
        delete annotation["items"];
      } else {
        annotation["service"][0]["items"]["action"] = "update";
        delete annotation["target"];
        delete annotation["body"];
      }

      delete annotation["annotation_version"];
      var oldID = '';

      if ('undefined' == typeof annotation.items) {
        // Version 1
        oldID = annotation.id;
      } else {
        // Version 2
        oldID = annotation.items[0].items[0].items[0].id;
      }

      console.log("Modifying annotation: " + oldID);
      $.ajax({
        url: this.baseURL + "api/update",
        type: "POST",
        dataType: 'json',
        contentType: 'application/json',
        data: JSON.stringify(annotation),
        async: true,
        context: this,
        beforeSend: function beforeSend(xhr) {
          xhr.setRequestHeader('Authorization', this.make_write_auth(key));
        },
        success: function success(data) {
          //console.log(annotation);
          annotation.id = data.id; // Append the ID given by the response
          //console.log("Successfully edited the annotation. (ID is now " + data.id + ")");

          _this4.annotator.messageOverlay.ShowMessage("Successfully edited the anotation.");

          if (callback) callback(annotation, oldID);
        },
        error: function error(response) {
          //console.error(`Could not edit the annotation! Message:\n ${response.responseJSON.detail}`);
          //this.annotator.messageOverlay.ShowError(`Could not edit the annotation!<br>(${response.responseJSON.detail})`);
          var returned_response = "undefined error while editing the annotation";

          if (response.responseJSON) {
            returned_response = response.responseJSON.error.code[0].value + " : " + response.responseJSON.error.message[0].value;
          }

          console.error("Could not edit the annotation! Message:\n ".concat(returned_response));

          _this4.annotator.messageOverlay.ShowError("Could not edit the annotation!<br>(".concat(returned_response, ")"));
        }
      });
    }
  }, {
    key: "DeleteAnnotation",
    value: function DeleteAnnotation(annotation, callback) {
      var _this5 = this;

      if (!confirm('Are you sure you wish to delete this annotation?')) {
        return;
      }

      var key;

      if (this.annotator.apiKey) {
        key = this.annotator.apiKey;
        var email_storage = localStorage.getItem('waldorf_user_email');
        var name_storage = localStorage.getItem('waldorf_user_name');
        if (name_storage == null) name_storage = email_storage;
      } else {
        key = localStorage.getItem('waldorf_auth_token');
      }

      if (this.annotator.apiKey) {
        if (annotation["creator"] == null) annotation["creator"] = {};
        annotation["creator"]["email"] = localStorage.getItem('waldorf_user_email');
        annotation["creator"]["nickname"] = localStorage.getItem('waldorf_user_name');
      }

      if (annotation["annotation_version"] == "v1") {
        annotation["request"]["items"]["action"] = "update";
        delete annotation["items"];
      } else {
        annotation["service"][0]["items"]["action"] = "update";
        delete annotation["target"];
        delete annotation["body"];
      }

      delete annotation["annotation_version"];
      var oldID = '';

      if ('undefined' == typeof annotation.items) {
        // Version 1
        oldID = annotation.id;
      } else {
        // Version 2
        oldID = annotation.items[0].items[0].items[0].id;
      }

      console.log("Deleting annotation: " + oldID);

      if ('undefined' == typeof annotation.items) {
        // Version 1
        var del_data = {
          "scalar:urn": "urn:scalar:version:" + annotation.id,
          "native": annotation.request.items["native"],
          "action": "DELETE",
          "api_key": annotation.request.items.api_key,
          "id": annotation.request.items.id
        };
        return $.post(this.baseURL + "api/delete", del_data, function (response) {
          {
            console.log("Delete error response");
            console.log(response);
            console.log(response.responseText);
          }
        }).done(function (response) {
          console.log("Successfully deleted the annotation.");

          _this5.annotator.messageOverlay.ShowMessage("Successfully deleted the annotation.");

          if (callback) callback(annotation, oldID);
        }).fail(function (response) {
          var returned_response = "undefined failure while deleting the annotation";

          if (response.responseJSON) {
            response.responseJSON.error.code[0].value + " : " + response.responseJSON.error.message[0].value;
          }

          console.error("Could not delete the annotation. Message:\n ".concat(returned_response));

          _this5.annotator.messageOverlay.ShowError("Could not delete the annotation!<br>(".concat(returned_response, ")"));
        });
      } else {
        // Version 2
        annotation["service"][0]["items"]["action"] = "delete";
        delete annotation["target"];
        delete annotation["body"];
        delete annotation["annotation_version"];
        $.ajax({
          url: this.baseURL + "api/delete",
          type: "POST",
          dataType: 'json',
          contentType: 'application/json',
          data: JSON.stringify(annotation),
          async: true,
          context: this,
          beforeSend: function beforeSend(xhr) {
            xhr.setRequestHeader('Authorization', this.make_write_auth(key));
          },
          success: function success(data) {
            _this5.annotator.messageOverlay.ShowMessage("Successfully deleted the anotation.");

            if (callback) callback(annotation, oldID);
          },
          error: function error(response) {
            var returned_response = "undefined error while deleting the annotation";

            if (response.responseJSON) {
              returned_response = response.responseJSON.error.code[0].value + " : " + response.responseJSON.error.message[0].value;
            }

            console.error("Could not delete the annotation! Message:\n ".concat(returned_response));

            _this5.annotator.messageOverlay.ShowError("Could not delete the annotation!<br>(".concat(returned_response, ")"));
          }
        });
      }
    }
  }]);

  return ServerInterface;
}();

exports.ServerInterface = ServerInterface;

},{"sha1":227}],13:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SessionManager = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var sha1 = require('sha1');
/**
 * Manages the user session for communicating with the backend.
 */


var SessionManager = /*#__PURE__*/function () {
  function SessionManager(annotator) {
    var _this = this;

    _classCallCheck(this, SessionManager);

    console.log("[Session Manager] Creating SessionManager...");
    this.annotator = annotator;
    this.modalOpen = false; // Inject the button for logging in/out into the toolbar

    if (!annotator.kioskMode && annotator.cmsEmail == '') {
      this.$userButton = $("<button>Session</button>").button({
        icon: "fa fa-user",
        showLabel: false
      }).click(function () {
        _this.PresentModal();
      });
      this.annotator.player.controlBar.RegisterElement(this.$userButton, 1, 'flex-end');
    } //this.$dialog.dialog("open");


    console.log("[Session Manager] SessionManager created.");
  }

  _createClass(SessionManager, [{
    key: "ShowLoginModal",
    value: function ShowLoginModal() {
      var _this2 = this;

      // Create the dialog
      var $container = $("<div class='waldorf-session-modal' title='Log In'></div>"); // Outermost HTML

      var $headText = $("<p class='validateTips'>All fields are required.</p>").appendTo($container);
      var $form = $("<form></form>").appendTo($container);
      var $nicknameField;
      var $usernameField;
      var $passwordField;

      if (this.annotator.apiKey) {
        $("<label for='username'>Name</label>").appendTo($form);
        $nicknameField = $("<input type='text' name='username' value='' class='text ui-widget-content ui-corner-all'>").appendTo($form);
        $("<label for='username'>Email Address</label>").appendTo($form);
        $usernameField = $("<input type='text' name='email' value='' class='text ui-widget-content ui-corner-all'>").appendTo($form);
      } else {
        $("<label for='username'>Username</label>").appendTo($form);
        $usernameField = $("<input type='text' name='username' value='' class='text ui-widget-content ui-corner-all'>").appendTo($form);
        $("<label for='password'>Password</label>").appendTo($form);
        $passwordField = $("<input type='password' name='password' value='' class='text ui-widget-content ui-corner-all'>").appendTo($form);
      }

      $form.wrapInner("<fieldset />");

      var login = function login() {
        if (_this2.annotator.apiKey) {
          var nickName = $nicknameField.val();
          var userName = sha1($usernameField.val());

          _this2.annotator.server.LogIn(nickName, userName).done(function () {
            console.log("API key login success");
            $dialog.dialog("close");
          }).fail(function () {
            $headText.html("<p>Invalid email address.</p>");
            $headText.css("color", "red");
          });
        } else {
          var userPass = sha1($passwordField.val());

          _this2.annotator.server.LogIn($usernameField.val(), userPass).done(function () {
            $dialog.dialog("close");
          }).fail(function () {
            $headText.html("<p>Invalid username or password.</p>");
            $headText.css("color", "red");
          });
        }
      };

      var $dialog = $container.dialog({
        autoOpen: true,
        draggable: false,
        modal: true,
        buttons: {
          "Log In": login,
          Cancel: function Cancel() {
            $dialog.dialog("close");
          }
        },
        close: function close() {
          $dialog.find("form")[0].reset();
          $dialog.find("input").removeClass("ui-state-error");

          _this2.OnModalClose();
        }
      });
    }
  }, {
    key: "ShowLogoutModal",
    value: function ShowLogoutModal() {
      var _this3 = this;

      var $container = $("<div title='Log Out'></div>");
      var $headText = $container.html("<p class='validateTips'>Are you sure you want to log out?</p>");
      var $dialog = $container.dialog({
        autoOpen: true,
        draggable: false,
        modal: true,
        buttons: {
          "Log Out": function LogOut() {
            _this3.annotator.server.LogOut().done(function () {
              $dialog.dialog("close");
            });
          },
          Cancel: function Cancel() {
            $dialog.dialog("close");
          }
        },
        close: function close() {
          _this3.OnModalClose();
        }
      });
    }
  }, {
    key: "PresentModal",
    value: function PresentModal() {
      // Early out if the modal is already open
      if (this.modalOpen) return; // Turn off fullscreen if it's on

      this.annotator.player.SetFullscreen(false);

      if (this.annotator.server.LoggedIn()) {
        this.ShowLogoutModal();
      } else {
        this.ShowLoginModal();
      }

      this.OnModalOpen();
    }
  }, {
    key: "OnModalOpen",
    value: function OnModalOpen() {
      this.$userButton.button("disable");
      this.modalOpen = true;
    }
  }, {
    key: "OnModalClose",
    value: function OnModalClose() {
      this.$userButton.button("enable");
      this.modalOpen = false;
    }
  }]);

  return SessionManager;
}();

exports.SessionManager = SessionManager;

},{"sha1":227}],14:[function(require,module,exports){
module.exports={
    "configFile": "annotator-config.json"
}
},{}],15:[function(require,module,exports){
"use strict";

require("./vendor.js");

require("./utils/array-extensions.js");

require("./utils/jquery-extensions.js");

require("./utils/string-extensions.js");

var _preferenceManager = require("./utils/preference-manager.js");

var _requirements = require("./utils/requirements.js");

var _videoPlayer = require("./video-player/video-player.js");

/*
Entry point for the whole project. Any jQuery extensions should
be registered here.
*/
// Import npm module dependencies
$.fn.annotate = function (args) {
  // let serverURL = args.serverURL || '';
  // let tagsURL = args.tagsURL || '';
  // let apiKey = args.apiKey || '';
  // let kioskMode = args.kioskMode || false;
  // let localURL = args.localURL || '';
  // let renderer = function(...) || false;
  // Error out early if "this" is not a video
  if ($(this).prop('tagName').toLowerCase() != "video") {
    console.error("Cannot wrap a non-video element!");
    return;
  }

  if (!(0, _requirements.VerifyRequirements)()) {
    return;
  } // preferences.GetJSON((data) => {
  //     //console.log(data);
  // });


  new _videoPlayer.AnnotatorVideoPlayer($(this), args);
};

},{"./utils/array-extensions.js":16,"./utils/jquery-extensions.js":18,"./utils/preference-manager.js":19,"./utils/requirements.js":20,"./utils/string-extensions.js":21,"./vendor.js":23,"./video-player/video-player.js":26}],16:[function(require,module,exports){
"use strict";

// From http://stackoverflow.com/a/14853974/7138792
// Warn if overriding existing method
if (Array.prototype.equals) console.warn("Overriding existing Array.prototype.equals. Possible causes: New API defines the method, \
    there's a framework conflict or you've got double inclusions in your code."); // attach the .equals method to Array's prototype to call it on any array

Array.prototype.equals = function (array) {
  // if the other array is a falsy value, return
  if (!array) return false; // compare lengths - can save a lot of time 

  if (this.length != array.length) return false;

  for (var i = 0, l = this.length; i < l; i++) {
    // Check if we have nested arrays
    if (this[i] instanceof Array && array[i] instanceof Array) {
      // recurse into the nested arrays
      if (!this[i].equals(array[i])) return false;
    } else if (this[i] != array[i]) {
      // Warning - two different object instances will never be equal: {x:20} != {x:20}
      return false;
    }
  }

  return true;
}; // Hide method from for-in loops


Object.defineProperty(Array.prototype, "equals", {
  enumerable: false
});

},{}],17:[function(require,module,exports){
(function (global){
"use strict";

/*!
 * jQuery clip-path-polygon Plugin v0.1.15 (2020-06-24)
 * jQuery plugin that makes easy to use clip-path on whatever tag under different browsers
 * https://github.com/andrusieczko/clip-path-polygon
 * 
 * Copyright 2020 Karol Andrusieczko
 * Released under MIT license
 */
var globalVariable = window || root;

var jQuery = jQuery || globalVariable.jQuery || (typeof window !== "undefined" ? window['$'] : typeof global !== "undefined" ? global['$'] : null);

(function ($) {
  var id = 0;

  var ClipPath = function ClipPath(jQuery, $el, points, options) {
    this.$ = jQuery;
    this.$el = $el;
    this.points = points;
    this.svgDefId = 'clipPathPolygonGenId' + id++;
    this.processOptions(options);
  };

  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = ClipPath;
    }

    exports.ClipPath = ClipPath;
  } else {
    globalVariable.ClipPath = ClipPath;
  }

  ClipPath.prototype = {
    $: null,
    $el: null,
    points: null,
    isForWebkit: true,
    isForSvg: true,
    svgDefId: null,
    isPercentage: false,
    create: function create() {
      this._createClipPath(this.points);
    },
    _createClipPath: function _createClipPath(points) {
      this._createSvgDefs();

      if (this.isForSvg) {
        this._createSvgBasedClipPath(points);
      }

      if (this.isForWebkit) {
        this._createWebkitClipPath(points);
      }
    },
    _createWebkitClipPath: function _createWebkitClipPath(points) {
      var clipPath = "polygon(" + this._translatePoints(points, true, this.isPercentage) + ")";
      this.$el.css('-webkit-clip-path', clipPath);
    },
    _createSvgBasedClipPath: function _createSvgBasedClipPath(points) {
      var clipPath = "polygon(" + this._translatePoints(points, true, this.isPercentage) + ")";
      this.$el.css('clip-path', clipPath);
    },
    // Firefox no longer seems to work with this but does with the webkit version, so I copied it above.
    // _createSvgBasedClipPath: function(points) {
    //   this.$('#' + this.svgDefId + '').find('polygon').attr('points', this._translatePoints(points, false, this.isPercentage));
    //   this.$el.css('clip-path', 'url(#' + this.svgDefId + ')');
    // },
    _translatePoints: function _translatePoints(points, withUnit, isPercentage) {
      var result = [];

      for (var i in points) {
        var x = this._handlePxs(points[i][0], withUnit, isPercentage);

        var y = this._handlePxs(points[i][1], withUnit, isPercentage);

        result.push(x + ' ' + y);
      }

      return result.join(', ');
    },
    _handlePxs: function _handlePxs(number, withUnit, isPercentage) {
      if (number === 0) {
        return number;
      }

      if (!withUnit) {
        if (isPercentage) {
          return number / 100;
        }

        return number;
      }

      return number + (isPercentage ? "%" : "px");
    },
    _createSvgElement: function _createSvgElement(elementName) {
      return this.$(document.createElementNS('http://www.w3.org/2000/svg', elementName));
    },
    _createSvgDefs: function _createSvgDefs() {
      if (this.$('#' + this.svgDefId + '').length === 0) {
        var $svg = this._createSvgElement('svg').attr('width', 0).attr('height', 0).css({
          'position': 'absolute',
          'visibility': 'hidden',
          'width': 0,
          'height': 0
        });

        var $defs = this._createSvgElement('defs');

        $svg.append($defs);

        var $clippath = this._createSvgElement('clipPath').attr('id', this.svgDefId);

        if (this.isPercentage) {
          $clippath.get(0).setAttribute('clipPathUnits', 'objectBoundingBox');
        }

        $defs.append($clippath);

        var $polygon = this._createSvgElement('polygon');

        $clippath.append($polygon);
        this.$('body').append($svg);
      }
    },
    processOptions: function processOptions(options) {
      this.isForWebkit = options && typeof options.isForWebkit !== "undefined" ? options.isForWebkit : this.isForWebkit;
      this.isForSvg = options && typeof options.isForSvg !== "undefined" ? options.isForSvg : this.isForSvg;
      this.isPercentage = options && options.isPercentage || this.isPercentage;
      this.svgDefId = options && options.svgDefId || this.svgDefId;
    }
  };

  $.fn.clipPath = function (points, options) {
    return this.each(function () {
      var $el = $(this);
      var clipPath = new ClipPath($, $el, points, options);
      clipPath.create();
    });
  };
}).call(void 0, jQuery);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],18:[function(require,module,exports){
"use strict";

/**
 * Sets the visibility of the element while disabling interaction.
 * Doesn't mess with jQuery's positioning calculations like show()
 * and hide().
 */
$.fn.makeVisible = function (show) {
  if (show) {
    $(this).css({
      "visibility": "visible",
      "pointer-events": ""
    });
  } else {
    $(this).css({
      "visibility": "hidden",
      "pointer-events": "none"
    });
  }
};
/*
Copyright 2014 Mike Dunn
http://upshots.org/
Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:
The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

https://github.com/moagrius/copycss

*/


$.fn.getStyles = function (only, except) {
  // the map to return with requested styles and values as KVP
  var product = {}; // the style object from the DOM element we need to iterate through

  var style; // recycle the name of the style attribute

  var name; // if it's a limited list, no need to run through the entire style object

  if (only && only instanceof Array) {
    for (var i = 0, l = only.length; i < l; i++) {
      // since we have the name already, just return via built-in .css method
      name = only[i];
      product[name] = this.css(name);
    }
  } else {
    // prevent from empty selector
    if (this.length) {
      // otherwise, we need to get everything
      var dom = this.get(0); // standards

      if (window.getComputedStyle) {
        // convenience methods to turn css case ('background-image') to camel ('backgroundImage')
        var pattern = /\-([a-z])/g;

        var uc = function uc(a, b) {
          return b.toUpperCase();
        };

        var camelize = function camelize(string) {
          return string.replace(pattern, uc);
        }; // make sure we're getting a good reference


        if (style = window.getComputedStyle(dom, null)) {
          var camel, value; // opera doesn't give back style.length - use truthy since a 0 length may as well be skipped anyways

          if (style.length) {
            for (var i = 0, l = style.length; i < l; i++) {
              name = style[i];
              camel = camelize(name);
              value = style.getPropertyValue(name);
              product[camel] = value;
            }
          } else {
            // opera
            for (name in style) {
              camel = camelize(name);
              value = style.getPropertyValue(name) || style[name];
              product[camel] = value;
            }
          }
        }
      } // IE - first try currentStyle, then normal style object - don't bother with runtimeStyle
      else if (style = dom.currentStyle) {
          for (name in style) {
            product[name] = style[name];
          }
        } else if (style = dom.style) {
          for (name in style) {
            if (typeof style[name] != 'function') {
              product[name] = style[name];
            }
          }
        }
    }
  } // remove any styles specified...
  // be careful on blacklist - sometimes vendor-specific values aren't obvious but will be visible...  e.g., excepting 'color' will still let '-webkit-text-fill-color' through, which will in fact color the text


  if (except && except instanceof Array) {
    for (var i = 0, l = except.length; i < l; i++) {
      name = except[i];
      delete product[name];
    }
  } // one way out so we can process blacklist in one spot


  return product;
}; // sugar - source is the selector, dom element or jQuery instance to copy from - only and except are optional


$.fn.copyCSS = function (source, only, except) {
  var styles = source.getStyles(only, except);
  this.css(styles);
  return this;
};

},{}],19:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.preferences = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// Bring in build config options
var metaconfig = require("../config.json");

var PreferenceManager = /*#__PURE__*/function () {
  function PreferenceManager() {
    _classCallCheck(this, PreferenceManager);
  }

  _createClass(PreferenceManager, [{
    key: "GetJSON",
    value: function GetJSON(callback) {
      var _this = this;

      //let loc = window.location.pathname;
      //let dir = loc.substring(0, loc.lastIndexOf('/'));
      var dir = "./dist/"; //console.log(dir + metaconfig.configFile);

      if (this.cachedJSON != null) {
        callback(this.cached);
      } else {
        $.ajax({
          dataType: "json",
          url: dir + metaconfig.configFile,
          success: function success(data) {
            _this.cachedJSON = data;
            callback(_this.cachedJSON);
          }
        });
      }
    }
  }]);

  return PreferenceManager;
}();

var preferences = new PreferenceManager();
exports.preferences = preferences;

},{"../config.json":14}],20:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VerifyRequirements = VerifyRequirements;

/**
 * Returns false if running on an unsupported platform or missing jQuery, otherwise true.
 * 
 */
function VerifyRequirements() {
  // Stop running if we're on an unsupported platform (mobile for now)
  // if( /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ) {
  //     console.error("Platform is unsupported!");
  //     //let unsupportedDiv = document.createElement("div");
  //     //unsupportedDiv.appendChild(document.createTextNode("Your platform is unsupported!"));
  //     //document.body.appendChild(unsupportedDiv);
  //     return false;
  // }
  // Check if we don't have jQuery loaded
  if (!window.jQuery) {
    console.error("JQuery must be present!"); //let unsupportedDiv = document.createElement("div");
    //unsupportedDiv.appendChild(document.createTextNode("Your platform is unsupported!"));
    //document.body.appendChild(unsupportedDiv);

    return false;
  }

  return true;
}

},{}],21:[function(require,module,exports){
"use strict";

/**
 * Escapes the string so it can embed directly in an HTML document.
 */
// http://stackoverflow.com/a/12034334
Object.defineProperty(String.prototype, 'escapeHTML', {
  value: function value() {
    var entityMap = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;',
      '/': '&#x2F;',
      '`': '&#x60;',
      '=': '&#x3D;'
    };
    return String(this).replace(/[&<>"'`=\/]/g, function (s) {
      return entityMap[s];
    });
  }
});

},{}],22:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GetFormattedTime = GetFormattedTime;
exports.GetSecondsFromHMS = GetSecondsFromHMS;

// http://stackoverflow.com/a/34841026
function GetFormattedTime(timeInSeconds) {
  if (isNaN(timeInSeconds)) return 0;
  var time = timeInSeconds | 0; //Truncate to integer

  var hours = Math.floor(time / 3600) % 24;
  var minutes = Math.floor(time / 60) % 60;
  var seconds = time % 60;
  var formatted = [hours, minutes, seconds].map(function (v) {
    return v < 10 ? "0" + v : v;
  }).filter(function (v, i) {
    return v !== "00" || i > 0;
  }).join(":");

  if (formatted.charAt(0) == "0") {
    formatted = formatted.substr(1);
  }

  var ms = (timeInSeconds % 1).toFixed(2);
  formatted += ms.toString().substr(1);
  return formatted;
} // From http://stackoverflow.com/a/9640417/7138792


function GetSecondsFromHMS(hms) {
  var parts = hms.split('.');
  var ms = "0";
  if (parts.length > 1) ms = '.' + parts[1];
  var p = parts[0].split(':'),
      s = 0,
      m = 1;

  while (p.length > 0) {
    s += m * parseInt(p.pop(), 10);
    m *= 60;
  }

  s += parseFloat(ms);
  return s;
}

},{}],23:[function(require,module,exports){
"use strict";

require("qtip2");

/**
 * Use this file to import what you need from the bundled npm modules.
 */
// Must import from node_modules folder or it won't see the shimmed jquery instance
// Removed from here because they weren't being loaded in the right order - JPB
// import '../node_modules/select2/dist/js/select2.js';
// import "../node_modules/select2/dist/css/select2.css";
//require("../node_modules/qtip2/dist/jquery.qtip.min.js");
//import "../node_modules/qtip2/dist/jquery.qtip.min.css";
require("./utils/clip-path-polygon-1.0.15.js"); //let screenfull = require('screenfull');
//import screenfull from "screenfull";
// CDN resources
// Font-Awesome
//$("head").append($("<script src='https://use.fontawesome.com/a703e2e5bf.js'></script>"));

},{"./utils/clip-path-polygon-1.0.15.js":17,"qtip2":225}],24:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SeekbarTooltip = void 0;

var _time = require("../utils/time.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var SeekbarTooltip = /*#__PURE__*/function () {
  function SeekbarTooltip($parent, player) {
    var _this = this;

    _classCallCheck(this, SeekbarTooltip);

    this.$parent = $parent;
    this.player = player;
    this.$tooltip = $("<div class='waldorf-seekbar-tooltip'></div>").appendTo($parent);
    this.text = "Test";
    this.$content = $("<p>" + this.text + "</p>").appendTo(this.$tooltip);
    this.hoverOffset = -10;
    this.padding = 5;
    this.Hide();
    this.$parent.mousemove(function (event) {
      _this.Show(); //Add and update tooltip on mouse movement to show where the mouse is hovering.


      var mouseX = event.pageX - player.$container.offset().left;

      var percent = mouseX / _this.$parent.width();

      var timeAtCursor = percent * player.videoElement.duration;

      _this.Move(mouseX, 0);

      _this.SetContent((0, _time.GetFormattedTime)(timeAtCursor));
    });
    this.$parent.mouseout(function () {
      _this.Hide();
    });
  }

  _createClass(SeekbarTooltip, [{
    key: "Move",
    value: function Move(x, y) {
      // Get initial positions
      var left = x - this.GetWidth() / 2;
      var top = y - this.GetHeight() + this.hoverOffset; // Offset if necessary (keep on-screen)

      if (left - this.padding < 0) {
        left = this.padding;
      }

      if (left + this.padding + this.GetWidth() > this.$parent.width()) {
        left = this.$parent.width() - this.GetWidth() - this.padding;
      } // Apply positions


      this.$tooltip.css({
        top: top,
        left: left
      });
    }
  }, {
    key: "GetWidth",
    value: function GetWidth() {
      return this.$tooltip.width();
    }
  }, {
    key: "GetHeight",
    value: function GetHeight() {
      return this.$tooltip.height();
    }
  }, {
    key: "Show",
    value: function Show() {
      this.$tooltip.makeVisible(true);
    }
  }, {
    key: "Hide",
    value: function Hide() {
      this.$tooltip.makeVisible(false);
    }
  }, {
    key: "SetContent",
    value: function SetContent(text) {
      //console.log(text);
      this.$content.text(text);
    }
  }]);

  return SeekbarTooltip;
}();

exports.SeekbarTooltip = SeekbarTooltip;

},{"../utils/time.js":22}],25:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VideoPlayerBar = void 0;

var _time = require("../utils/time.js");

var _seekbarTooltip = require("./seekbar-tooltip.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var VideoPlayerBar = /*#__PURE__*/function () {
  function VideoPlayerBar(player) {
    var _this = this;

    _classCallCheck(this, VideoPlayerBar);

    this.player = player;
    this.$container = $("<div class='waldorf-player-toolbar flex-toolbar'></div>").appendTo(player.$container);
    this.PopulateElements();
    this.scrubbingTimeSlider = false;
    this.videoPlayingBeforeTimeScrub = false; // Hook up to events from video player

    this.player.$container.on("OnVisibilityChange", function (event, isVisible, duration) {
      return _this.SetVisible(isVisible, duration);
    });
    this.player.$container.on("OnPlayStateChange", function (event, playing) {
      return _this.OnPlayStateChange(playing);
    });
    this.player.$container.on("OnTimeUpdate", function (event, time) {
      return _this.OnTimeUpdate(time);
    });
    this.player.$container.on("OnMuteStateChange", function (event, muted) {
      return _this.OnMuteStateChange(muted);
    });
    this.player.$container.on("OnVolumeChange", function (event, volume) {
      return _this.OnVolumeChange(volume);
    });
  }

  _createClass(VideoPlayerBar, [{
    key: "PopulateElements",
    value: function PopulateElements() {
      var _this2 = this;

      this.$seekBar = $("<div id='seek-bar'><div id='seek-handle' class='ui-slider-handle'></div></div>");
      var $seekSlider = this.$seekBar.slider({
        min: 0.0,
        max: 1.0,
        step: 0.001
      });
      $seekSlider.on("slide", function () {
        return _this2.UpdateVideoTime();
      });
      $seekSlider.on("slidestart", function () {
        return _this2.TimeDragStarted();
      });
      $seekSlider.on("slidestop", function () {
        _this2.TimeDragFinished();

        _this2.UpdateVideoTime();
      });
      this.$container.append(this.$seekBar);
      this.seekbarTooltip = new _seekbarTooltip.SeekbarTooltip(this.$seekBar, this.player);
      this.$seekProgress = $("<div id='seek-fill'></div>");
      this.$container.append(this.$seekProgress); //Jump Back button

      this.$jumpBackButton = $("<button>Jump Back</button>").button({
        icon: "fa fa-fast-backward",
        showLabel: false
      }).click(function () {
        return _this2.player.JumpBackward();
      });
      this.RegisterElement(this.$jumpBackButton, -8); //Nudge Back button

      this.$nudgeBackButton = $("<button>Nudge Back</button>").button({
        icon: "fa fa-step-backward",
        showLabel: false
      }).click(function () {
        return _this2.player.StepBackward();
      });
      this.RegisterElement(this.$nudgeBackButton, -7); // Play button

      this.$playButton = $("<button>Play</button>").button({
        icon: "fa fa-play",
        showLabel: false
      }).click(function () {
        return _this2.player.TogglePlayState();
      });
      this.RegisterElement(this.$playButton, -6); //Nudge button

      this.$nudgeButton = $("<button>Nudge</button>").button({
        icon: "fa fa-step-forward",
        showLabel: false
      }).click(function () {
        return _this2.player.StepForward();
      });
      this.RegisterElement(this.$nudgeButton, -5); //Jump button

      this.$jumpButton = $("<button>Nudge</button>").button({
        icon: "fa fa-fast-forward",
        showLabel: false
      }).click(function () {
        return _this2.player.JumpForward();
      });
      this.RegisterElement(this.$jumpButton, -4); // Time text

      var zero = (0, _time.GetFormattedTime)(0.000);
      this.$timeText = $("<p>${zero}/${zero}</p>");
      this.RegisterElement(this.$timeText, -3); // Mute button

      this.$muteButton = $("<button>Mute</button>").button({
        icon: "fa fa-volume-up",
        showLabel: false
      }).click(function () {
        return _this2.player.ToggleMuteState();
      });
      this.RegisterElement(this.$muteButton, -2); // Volume bar

      this.$volumeBar = $("<div id='volume-bar'><div id='volume-handle' class='ui-slider-handle'></div></div>");
      this.$volumeBar.slider({
        range: "min",
        max: 1.0,
        value: 1.0,
        step: 0.05
      }).on("slide", function (event, ui) {
        return _this2.player.SetVolume(ui.value);
      });
      this.RegisterElement(this.$volumeBar, -1); // Fullscreen button

      this.$fullScreenButton = $("<button>Fullscreen</button>").button({
        icon: "fa fa-arrows-alt",
        showLabel: false
      }).click(function () {
        return _this2.player.ToggleFullscreen();
      });
      this.RegisterElement(this.$fullScreenButton, 999, 'flex-end'); // Create empty element between left floating and right floating toolbar items to space them out properly

      this.$container.append($("<div></div>").css("flex-grow", 1).css("order", 0)); //Initialize controls

      this.OnTimeUpdate();
      this.$volumeBar.slider("value", this.player.videoElement.volume);
    }
  }, {
    key: "RegisterElement",
    value: function RegisterElement($element, order) {
      var justification = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'flex-start';
      $element.css('order', order);
      $element.css('align-self', justification); // Sets grow [shrink] [basis]
      //$element.css('flex', '0 0 auto');

      this.$container.append($element);
    }
  }, {
    key: "SetVisible",
    value: function SetVisible(isVisible, duration) {
      var _this3 = this;

      //console.log(isVisible + " " + duration);
      this.$container.stop(true, true);

      if (isVisible) {
        this.$container.fadeTo(duration, 1.0, function () {
          _this3.$container.makeVisible(true);
        });
      } else {
        this.$container.fadeTo(duration, 0.0, function () {
          _this3.$container.makeVisible(false);
        });
      }
    }
  }, {
    key: "UpdateVideoTime",
    value: function UpdateVideoTime() {
      // Calculate the new time
      var time = this.player.videoElement.duration * this.$seekBar.slider("value");
      this.player.endTime = false;
      this.player.videoElement.currentTime = time;
    }
  }, {
    key: "TimeDragStarted",
    value: function TimeDragStarted() {
      this.videoPlayingBeforeTimeScrub = !this.player.videoElement.paused;
      this.player.videoElement.pause();
    }
  }, {
    key: "TimeDragFinished",
    value: function TimeDragFinished() {
      // Start playing the video again if it was playing before the scrub started
      if (this.videoPlayingBeforeTimeScrub) {
        this.player.videoElement.play();
      }
    } ///
    /// ----- Event Listeners -----
    /// The following update the visual state of the bar
    /// upon changes to the video player. These are hooked
    /// up in the constructor.
    ///

  }, {
    key: "OnPlayStateChange",
    value: function OnPlayStateChange(playing) {
      this.$playButton.button("option", {
        icon: playing ? "fa fa-pause" : "fa fa-play"
      });
    }
  }, {
    key: "OnTimeUpdate",
    value: function OnTimeUpdate(time) {
      //console.log("video-player-bar.js:185 OnTimeUpdate is called");
      var duration = this.player.videoElement.duration; // Update the time text

      this.$timeText.text((0, _time.GetFormattedTime)(time) + "/" + (0, _time.GetFormattedTime)(duration));
      var progress = time / duration;
      this.$seekProgress.width((progress * 100).toString() + "%");
    }
  }, {
    key: "OnVolumeChange",
    value: function OnVolumeChange(volume) {
      this.$volumeBar.slider("value", volume);
    }
  }, {
    key: "OnMuteStateChange",
    value: function OnMuteStateChange(muted) {
      this.$muteButton.button("option", {
        icon: muted ? "fa fa-volume-up" : "fa fa-volume-off"
      });
    }
  }]);

  return VideoPlayerBar;
}();

exports.VideoPlayerBar = VideoPlayerBar;

},{"../utils/time.js":22,"./seekbar-tooltip.js":24}],26:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AnnotatorVideoPlayer = void 0;

var _videoPlayerBar = require("./video-player-bar.js");

var _annotator = require("../annotator/annotator.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

//import * as screenfull from "screenfull";
//import 'jquery-ui/dist/jquery-ui.js';
var screenfull = require('screenfull');

var AnnotatorVideoPlayer = /*#__PURE__*/function () {
  function AnnotatorVideoPlayer($video, annotatorArgs) {
    var _this = this;

    _classCallCheck(this, AnnotatorVideoPlayer);

    console.log("[AnnotatorVideoPlayer] Creating AnnotatorVideoPlayer for video...");
    this.$video = $video;
    this.videoElement = this.$video.get(0); // Store the original styling of the video element before we alter it

    this.originalStyles = this.$video.getStyles(null, ["height", "WebkitTextFillColor", "color"]); //["width", "top", "left", "margin", "padding"]

    this.Wrap();
    this.PopulateControls();
    this.SetVisible(true); // Hook up events

    this.HookUpEvents(); // Play / pause the video when clicked.

    this.$video.on("click", function () {
      return _this.TogglePlayState();
    });
    this.allowAutoFade = true; /// Inactivity timer for the mouse.

    this.mouseTimer = null; /// Set to true if the time slider is currently being dragged by the user.

    this.draggingTimeSlider = false; /// Seconds before the UI fades due to mouse inactivity.

    this.idleSecondsBeforeFade = 3;
    this.fadeDuration = 300;
    this.endTime = false;
    this.$container.mousemove(function () {
      return _this.OnMouseMove();
    });
    this.SetAutoFade(true); // If screenfull is enabled, create the event to handle it.

    if (screenfull !== 'undefined') {
      screenfull.onchange(function () {
        _this.OnFullscreenChange();

        _this.$container.trigger("OnFullscreenChange");
      });
    }

    this.videoElement.ontimeupdate = function () {
      _this.OnTimeUpdate(_this.videoElement.currentTime);
    };

    this.$container.on("OnVideoReady", function () {
      if (annotatorArgs.annotator == null) {
        console.log("[AnnotatorVideoPlayer] Player sent OnVideoReady, attempting to wrap with annotator..."); // Add annotator once video has loaded

        console.log("[AnnotatorVideoPlayer] Wrapping video with annotator...");
        annotatorArgs.player = _this;
        annotatorArgs.annotator = new _annotator.VideoAnnotator(annotatorArgs);
        if (typeof annotatorArgs.callback == "function") annotatorArgs.callback(annotatorArgs.annotator);
      }
    });

    this.videoElement.onloadedmetadata = function () {
      _this.$container.trigger("OnVideoReady");
    };

    if (this.videoElement.duration != null) {
      // If the metadata is already prepared, throw the event since
      // onloadedmetadata won't be fired
      this.$container.trigger("OnVideoReady");
    }

    console.log("[AnnotatorVideoPlayer] AnnotatorVideoPlayer created for video.");
  }

  _createClass(AnnotatorVideoPlayer, [{
    key: "Wrap",
    value: function Wrap() {
      // Remove the default controls from the video
      this.videoElement.removeAttribute("controls"); // Wrap the video element with the container

      this.$container = this.$video.wrap("<div class='waldorf-video-player'></div>").parent(); // Resize container to fit the dimensions of the video

      this.$container.width(this.$video.width());
      this.$container.height(this.$video.height());
    }
  }, {
    key: "PopulateControls",
    value: function PopulateControls() {
      this.controlBar = new _videoPlayerBar.VideoPlayerBar(this);
    }
  }, {
    key: "SetVisible",
    value: function SetVisible(isVisible) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this.$container.trigger("OnVisibilityChange", [isVisible, duration]);
    }
  }, {
    key: "HookUpEvents",
    value: function HookUpEvents() {}
  }, {
    key: "TogglePlayState",
    value: function TogglePlayState() {
      if (this.videoElement.paused) {
        this.Play();
      } else {
        this.Pause();
      }
    }
  }, {
    key: "StepForward",
    value: function StepForward() {
      var newTime = this.videoElement.currentTime + 0.1;
      this.videoElement.currentTime = newTime > this.videoElement.duration ? this.videoElement.duration : newTime;
    }
  }, {
    key: "JumpForward",
    value: function JumpForward() {
      var newTime = this.videoElement.currentTime + 1;
      this.videoElement.currentTime = newTime > this.videoElement.duration ? this.videoElement.duration : newTime;
    }
  }, {
    key: "StepBackward",
    value: function StepBackward() {
      var newTime = this.videoElement.currentTime - 0.1;
      this.videoElement.currentTime = newTime < 0 ? 0 : newTime;
    }
  }, {
    key: "JumpBackward",
    value: function JumpBackward() {
      var newTime = this.videoElement.currentTime - 1;
      this.videoElement.currentTime = newTime < 0 ? 0 : newTime;
    }
  }, {
    key: "Play",
    value: function Play() {
      this.videoElement.play();
      if (this.endTime) this.endTime = false;
      this.SetAutoFade(true);
      this.$container.trigger("OnPlayStateChange", !this.videoElement.paused);
    }
  }, {
    key: "Pause",
    value: function Pause() {
      if (this.endTime) this.endTime = false;
      this.videoElement.pause();
      this.SetAutoFade(false);
      this.$container.trigger("OnPlayStateChange", !this.videoElement.paused);
    }
  }, {
    key: "ToggleMuteState",
    value: function ToggleMuteState() {
      var muted = this.videoElement.muted;
      this.videoElement.muted = !muted;
      this.$container.trigger("OnMuteStateChange", muted);
    }
  }, {
    key: "SetVolume",
    value: function SetVolume(volume) {
      this.videoElement.volume = volume;
      this.$container.trigger("OnVolumeChange", volume);
    }
  }, {
    key: "ToggleFullscreen",
    value: function ToggleFullscreen() {
      if (screenfull === 'undefined') return;
      screenfull.toggle(this.$container[0]);
    }
  }, {
    key: "OnFullscreenChange",
    value: function OnFullscreenChange() {
      if (screenfull.isFullscreen) {
        this.$container.addClass("waldorf-fullscreen");
      } else {
        this.$container.removeClass("waldorf-fullscreen");
      }
    }
  }, {
    key: "SetFullscreen",
    value: function SetFullscreen(fullscreen) {
      if (screenfull === 'undefined' || !screenfull.enabled) {
        return;
      }

      if (fullscreen) {
        screenfull.request(this.$container[0]);
      } else {
        screenfull.exit();
      }
    }
    /**
     * Called when the mouse moves in the video container.
     */

  }, {
    key: "OnMouseMove",
    value: function OnMouseMove() {
      // Reset the timer
      clearTimeout(this.mouseTimer);
      this.mouseTimer = 0; // Restart fading if allowed to

      if (this.allowAutoFade) {
        this.RestartFading();
      }
    }
  }, {
    key: "OnTimeUpdate",
    value: function OnTimeUpdate(time) {
      if (this.endTime && this.endTime <= this.videoElement.currentTime) {
        this.Pause();
        this.endTime = false;
      }

      this.$container.trigger("OnTimeUpdate", time);
    }
  }, {
    key: "RestartFading",
    value: function RestartFading() {
      var _this2 = this;

      // Restore visibility
      this.SetVisible(true, this.fadeDuration); // Start the timer over again

      this.mouseTimer = setTimeout(function () {
        _this2.SetVisible(false, _this2.fadeDuration);
      }, this.idleSecondsBeforeFade * 1000);
    }
  }, {
    key: "SetAutoFade",
    value: function SetAutoFade(allow) {
      this.allowAutoFade = allow; // Reset the mouse timer

      clearTimeout(this.mouseTimer);
      this.mouseTimer = 0; // Make elements visible

      this.SetVisible(true); // Restart the fading behavior if desired

      if (allow) {
        this.RestartFading();
      }
    } // IsPlaying(){
    //     // http://stackoverflow.com/a/31133401
    //     return !!(this.videoElement.currentTime > 0 && !this.videoElement.paused && 
    //               !this.videoElement.ended && this.videoElement.readyState > 2);
    // }
    // From https://gist.github.com/Nateowami/7a947e93f09c45a1097e783dc00560e1

  }, {
    key: "GetVideoDimensions",
    value: function GetVideoDimensions() {
      var video = this.videoElement; // Ratio of the video's intrisic dimensions

      var videoRatio = video.videoWidth / video.videoHeight; // The width and height of the video element

      var width = video.offsetWidth;
      var height = video.offsetHeight; // The ratio of the element's width to its height

      var elementRatio = width / height; // If the video element is short and wide

      if (elementRatio > videoRatio) width = height * videoRatio; // It must be tall and thin, or exactly equal to the original ratio
      else height = width / videoRatio;
      return {
        width: width,
        height: height
      };
    }
  }]);

  return AnnotatorVideoPlayer;
}();

exports.AnnotatorVideoPlayer = AnnotatorVideoPlayer;

},{"../annotator/annotator.js":4,"./video-player-bar.js":25,"screenfull":226}],27:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isIdentifierStart = isIdentifierStart;
exports.isIdentifierChar = isIdentifierChar;
exports.isIdentifierName = isIdentifierName;
let nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08c7\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\u9ffc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7ca\ua7f5-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
let nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf\u1ac0\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
const nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
const nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
const astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
const astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];

function isInAstralSet(code, set) {
  let pos = 0x10000;

  for (let i = 0, length = set.length; i < length; i += 2) {
    pos += set[i];
    if (pos > code) return false;
    pos += set[i + 1];
    if (pos >= code) return true;
  }

  return false;
}

function isIdentifierStart(code) {
  if (code < 65) return code === 36;
  if (code <= 90) return true;
  if (code < 97) return code === 95;
  if (code <= 122) return true;

  if (code <= 0xffff) {
    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
  }

  return isInAstralSet(code, astralIdentifierStartCodes);
}

function isIdentifierChar(code) {
  if (code < 48) return code === 36;
  if (code < 58) return true;
  if (code < 65) return false;
  if (code <= 90) return true;
  if (code < 97) return code === 95;
  if (code <= 122) return true;

  if (code <= 0xffff) {
    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
  }

  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}

function isIdentifierName(name) {
  let isFirst = true;

  for (let _i = 0, _Array$from = Array.from(name); _i < _Array$from.length; _i++) {
    const char = _Array$from[_i];
    const cp = char.codePointAt(0);

    if (isFirst) {
      if (!isIdentifierStart(cp)) {
        return false;
      }

      isFirst = false;
    } else if (!isIdentifierChar(cp)) {
      return false;
    }
  }

  return !isFirst;
}
},{}],28:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "isIdentifierName", {
  enumerable: true,
  get: function () {
    return _identifier.isIdentifierName;
  }
});
Object.defineProperty(exports, "isIdentifierChar", {
  enumerable: true,
  get: function () {
    return _identifier.isIdentifierChar;
  }
});
Object.defineProperty(exports, "isIdentifierStart", {
  enumerable: true,
  get: function () {
    return _identifier.isIdentifierStart;
  }
});
Object.defineProperty(exports, "isReservedWord", {
  enumerable: true,
  get: function () {
    return _keyword.isReservedWord;
  }
});
Object.defineProperty(exports, "isStrictBindOnlyReservedWord", {
  enumerable: true,
  get: function () {
    return _keyword.isStrictBindOnlyReservedWord;
  }
});
Object.defineProperty(exports, "isStrictBindReservedWord", {
  enumerable: true,
  get: function () {
    return _keyword.isStrictBindReservedWord;
  }
});
Object.defineProperty(exports, "isStrictReservedWord", {
  enumerable: true,
  get: function () {
    return _keyword.isStrictReservedWord;
  }
});
Object.defineProperty(exports, "isKeyword", {
  enumerable: true,
  get: function () {
    return _keyword.isKeyword;
  }
});

var _identifier = require("./identifier");

var _keyword = require("./keyword");
},{"./identifier":27,"./keyword":29}],29:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isReservedWord = isReservedWord;
exports.isStrictReservedWord = isStrictReservedWord;
exports.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
exports.isStrictBindReservedWord = isStrictBindReservedWord;
exports.isKeyword = isKeyword;
const reservedWords = {
  keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
  strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
  strictBind: ["eval", "arguments"]
};
const keywords = new Set(reservedWords.keyword);
const reservedWordsStrictSet = new Set(reservedWords.strict);
const reservedWordsStrictBindSet = new Set(reservedWords.strictBind);

function isReservedWord(word, inModule) {
  return inModule && word === "await" || word === "enum";
}

function isStrictReservedWord(word, inModule) {
  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
}

function isStrictBindOnlyReservedWord(word) {
  return reservedWordsStrictBindSet.has(word);
}

function isStrictBindReservedWord(word, inModule) {
  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
}

function isKeyword(word) {
  return keywords.has(word);
}
},{}],30:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assertNode;

var _isNode = _interopRequireDefault(require("../validators/isNode"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function assertNode(node) {
  if (!(0, _isNode.default)(node)) {
    var _node$type;

    const type = (_node$type = node == null ? void 0 : node.type) != null ? _node$type : JSON.stringify(node);
    throw new TypeError(`Not a valid node of type "${type}"`);
  }
}
},{"../validators/isNode":94}],31:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assertArrayExpression = assertArrayExpression;
exports.assertAssignmentExpression = assertAssignmentExpression;
exports.assertBinaryExpression = assertBinaryExpression;
exports.assertInterpreterDirective = assertInterpreterDirective;
exports.assertDirective = assertDirective;
exports.assertDirectiveLiteral = assertDirectiveLiteral;
exports.assertBlockStatement = assertBlockStatement;
exports.assertBreakStatement = assertBreakStatement;
exports.assertCallExpression = assertCallExpression;
exports.assertCatchClause = assertCatchClause;
exports.assertConditionalExpression = assertConditionalExpression;
exports.assertContinueStatement = assertContinueStatement;
exports.assertDebuggerStatement = assertDebuggerStatement;
exports.assertDoWhileStatement = assertDoWhileStatement;
exports.assertEmptyStatement = assertEmptyStatement;
exports.assertExpressionStatement = assertExpressionStatement;
exports.assertFile = assertFile;
exports.assertForInStatement = assertForInStatement;
exports.assertForStatement = assertForStatement;
exports.assertFunctionDeclaration = assertFunctionDeclaration;
exports.assertFunctionExpression = assertFunctionExpression;
exports.assertIdentifier = assertIdentifier;
exports.assertIfStatement = assertIfStatement;
exports.assertLabeledStatement = assertLabeledStatement;
exports.assertStringLiteral = assertStringLiteral;
exports.assertNumericLiteral = assertNumericLiteral;
exports.assertNullLiteral = assertNullLiteral;
exports.assertBooleanLiteral = assertBooleanLiteral;
exports.assertRegExpLiteral = assertRegExpLiteral;
exports.assertLogicalExpression = assertLogicalExpression;
exports.assertMemberExpression = assertMemberExpression;
exports.assertNewExpression = assertNewExpression;
exports.assertProgram = assertProgram;
exports.assertObjectExpression = assertObjectExpression;
exports.assertObjectMethod = assertObjectMethod;
exports.assertObjectProperty = assertObjectProperty;
exports.assertRestElement = assertRestElement;
exports.assertReturnStatement = assertReturnStatement;
exports.assertSequenceExpression = assertSequenceExpression;
exports.assertParenthesizedExpression = assertParenthesizedExpression;
exports.assertSwitchCase = assertSwitchCase;
exports.assertSwitchStatement = assertSwitchStatement;
exports.assertThisExpression = assertThisExpression;
exports.assertThrowStatement = assertThrowStatement;
exports.assertTryStatement = assertTryStatement;
exports.assertUnaryExpression = assertUnaryExpression;
exports.assertUpdateExpression = assertUpdateExpression;
exports.assertVariableDeclaration = assertVariableDeclaration;
exports.assertVariableDeclarator = assertVariableDeclarator;
exports.assertWhileStatement = assertWhileStatement;
exports.assertWithStatement = assertWithStatement;
exports.assertAssignmentPattern = assertAssignmentPattern;
exports.assertArrayPattern = assertArrayPattern;
exports.assertArrowFunctionExpression = assertArrowFunctionExpression;
exports.assertClassBody = assertClassBody;
exports.assertClassExpression = assertClassExpression;
exports.assertClassDeclaration = assertClassDeclaration;
exports.assertExportAllDeclaration = assertExportAllDeclaration;
exports.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
exports.assertExportNamedDeclaration = assertExportNamedDeclaration;
exports.assertExportSpecifier = assertExportSpecifier;
exports.assertForOfStatement = assertForOfStatement;
exports.assertImportDeclaration = assertImportDeclaration;
exports.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
exports.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
exports.assertImportSpecifier = assertImportSpecifier;
exports.assertMetaProperty = assertMetaProperty;
exports.assertClassMethod = assertClassMethod;
exports.assertObjectPattern = assertObjectPattern;
exports.assertSpreadElement = assertSpreadElement;
exports.assertSuper = assertSuper;
exports.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
exports.assertTemplateElement = assertTemplateElement;
exports.assertTemplateLiteral = assertTemplateLiteral;
exports.assertYieldExpression = assertYieldExpression;
exports.assertAwaitExpression = assertAwaitExpression;
exports.assertImport = assertImport;
exports.assertBigIntLiteral = assertBigIntLiteral;
exports.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
exports.assertOptionalMemberExpression = assertOptionalMemberExpression;
exports.assertOptionalCallExpression = assertOptionalCallExpression;
exports.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
exports.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
exports.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
exports.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;
exports.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;
exports.assertClassImplements = assertClassImplements;
exports.assertDeclareClass = assertDeclareClass;
exports.assertDeclareFunction = assertDeclareFunction;
exports.assertDeclareInterface = assertDeclareInterface;
exports.assertDeclareModule = assertDeclareModule;
exports.assertDeclareModuleExports = assertDeclareModuleExports;
exports.assertDeclareTypeAlias = assertDeclareTypeAlias;
exports.assertDeclareOpaqueType = assertDeclareOpaqueType;
exports.assertDeclareVariable = assertDeclareVariable;
exports.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
exports.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;
exports.assertDeclaredPredicate = assertDeclaredPredicate;
exports.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
exports.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
exports.assertFunctionTypeParam = assertFunctionTypeParam;
exports.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
exports.assertInferredPredicate = assertInferredPredicate;
exports.assertInterfaceExtends = assertInterfaceExtends;
exports.assertInterfaceDeclaration = assertInterfaceDeclaration;
exports.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;
exports.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;
exports.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
exports.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
exports.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
exports.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;
exports.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
exports.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
exports.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;
exports.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
exports.assertObjectTypeIndexer = assertObjectTypeIndexer;
exports.assertObjectTypeProperty = assertObjectTypeProperty;
exports.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
exports.assertOpaqueType = assertOpaqueType;
exports.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
exports.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;
exports.assertStringTypeAnnotation = assertStringTypeAnnotation;
exports.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;
exports.assertThisTypeAnnotation = assertThisTypeAnnotation;
exports.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
exports.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
exports.assertTypeAlias = assertTypeAlias;
exports.assertTypeAnnotation = assertTypeAnnotation;
exports.assertTypeCastExpression = assertTypeCastExpression;
exports.assertTypeParameter = assertTypeParameter;
exports.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
exports.assertTypeParameterInstantiation = assertTypeParameterInstantiation;
exports.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
exports.assertVariance = assertVariance;
exports.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
exports.assertEnumDeclaration = assertEnumDeclaration;
exports.assertEnumBooleanBody = assertEnumBooleanBody;
exports.assertEnumNumberBody = assertEnumNumberBody;
exports.assertEnumStringBody = assertEnumStringBody;
exports.assertEnumSymbolBody = assertEnumSymbolBody;
exports.assertEnumBooleanMember = assertEnumBooleanMember;
exports.assertEnumNumberMember = assertEnumNumberMember;
exports.assertEnumStringMember = assertEnumStringMember;
exports.assertEnumDefaultedMember = assertEnumDefaultedMember;
exports.assertJSXAttribute = assertJSXAttribute;
exports.assertJSXClosingElement = assertJSXClosingElement;
exports.assertJSXElement = assertJSXElement;
exports.assertJSXEmptyExpression = assertJSXEmptyExpression;
exports.assertJSXExpressionContainer = assertJSXExpressionContainer;
exports.assertJSXSpreadChild = assertJSXSpreadChild;
exports.assertJSXIdentifier = assertJSXIdentifier;
exports.assertJSXMemberExpression = assertJSXMemberExpression;
exports.assertJSXNamespacedName = assertJSXNamespacedName;
exports.assertJSXOpeningElement = assertJSXOpeningElement;
exports.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
exports.assertJSXText = assertJSXText;
exports.assertJSXFragment = assertJSXFragment;
exports.assertJSXOpeningFragment = assertJSXOpeningFragment;
exports.assertJSXClosingFragment = assertJSXClosingFragment;
exports.assertNoop = assertNoop;
exports.assertPlaceholder = assertPlaceholder;
exports.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;
exports.assertArgumentPlaceholder = assertArgumentPlaceholder;
exports.assertBindExpression = assertBindExpression;
exports.assertClassProperty = assertClassProperty;
exports.assertPipelineTopicExpression = assertPipelineTopicExpression;
exports.assertPipelineBareFunction = assertPipelineBareFunction;
exports.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference;
exports.assertClassPrivateProperty = assertClassPrivateProperty;
exports.assertClassPrivateMethod = assertClassPrivateMethod;
exports.assertImportAttribute = assertImportAttribute;
exports.assertDecorator = assertDecorator;
exports.assertDoExpression = assertDoExpression;
exports.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
exports.assertPrivateName = assertPrivateName;
exports.assertRecordExpression = assertRecordExpression;
exports.assertTupleExpression = assertTupleExpression;
exports.assertDecimalLiteral = assertDecimalLiteral;
exports.assertTSParameterProperty = assertTSParameterProperty;
exports.assertTSDeclareFunction = assertTSDeclareFunction;
exports.assertTSDeclareMethod = assertTSDeclareMethod;
exports.assertTSQualifiedName = assertTSQualifiedName;
exports.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;
exports.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;
exports.assertTSPropertySignature = assertTSPropertySignature;
exports.assertTSMethodSignature = assertTSMethodSignature;
exports.assertTSIndexSignature = assertTSIndexSignature;
exports.assertTSAnyKeyword = assertTSAnyKeyword;
exports.assertTSBooleanKeyword = assertTSBooleanKeyword;
exports.assertTSBigIntKeyword = assertTSBigIntKeyword;
exports.assertTSNeverKeyword = assertTSNeverKeyword;
exports.assertTSNullKeyword = assertTSNullKeyword;
exports.assertTSNumberKeyword = assertTSNumberKeyword;
exports.assertTSObjectKeyword = assertTSObjectKeyword;
exports.assertTSStringKeyword = assertTSStringKeyword;
exports.assertTSSymbolKeyword = assertTSSymbolKeyword;
exports.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
exports.assertTSUnknownKeyword = assertTSUnknownKeyword;
exports.assertTSVoidKeyword = assertTSVoidKeyword;
exports.assertTSThisType = assertTSThisType;
exports.assertTSFunctionType = assertTSFunctionType;
exports.assertTSConstructorType = assertTSConstructorType;
exports.assertTSTypeReference = assertTSTypeReference;
exports.assertTSTypePredicate = assertTSTypePredicate;
exports.assertTSTypeQuery = assertTSTypeQuery;
exports.assertTSTypeLiteral = assertTSTypeLiteral;
exports.assertTSArrayType = assertTSArrayType;
exports.assertTSTupleType = assertTSTupleType;
exports.assertTSOptionalType = assertTSOptionalType;
exports.assertTSRestType = assertTSRestType;
exports.assertTSNamedTupleMember = assertTSNamedTupleMember;
exports.assertTSUnionType = assertTSUnionType;
exports.assertTSIntersectionType = assertTSIntersectionType;
exports.assertTSConditionalType = assertTSConditionalType;
exports.assertTSInferType = assertTSInferType;
exports.assertTSParenthesizedType = assertTSParenthesizedType;
exports.assertTSTypeOperator = assertTSTypeOperator;
exports.assertTSIndexedAccessType = assertTSIndexedAccessType;
exports.assertTSMappedType = assertTSMappedType;
exports.assertTSLiteralType = assertTSLiteralType;
exports.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;
exports.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
exports.assertTSInterfaceBody = assertTSInterfaceBody;
exports.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
exports.assertTSAsExpression = assertTSAsExpression;
exports.assertTSTypeAssertion = assertTSTypeAssertion;
exports.assertTSEnumDeclaration = assertTSEnumDeclaration;
exports.assertTSEnumMember = assertTSEnumMember;
exports.assertTSModuleDeclaration = assertTSModuleDeclaration;
exports.assertTSModuleBlock = assertTSModuleBlock;
exports.assertTSImportType = assertTSImportType;
exports.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;
exports.assertTSExternalModuleReference = assertTSExternalModuleReference;
exports.assertTSNonNullExpression = assertTSNonNullExpression;
exports.assertTSExportAssignment = assertTSExportAssignment;
exports.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;
exports.assertTSTypeAnnotation = assertTSTypeAnnotation;
exports.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;
exports.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;
exports.assertTSTypeParameter = assertTSTypeParameter;
exports.assertExpression = assertExpression;
exports.assertBinary = assertBinary;
exports.assertScopable = assertScopable;
exports.assertBlockParent = assertBlockParent;
exports.assertBlock = assertBlock;
exports.assertStatement = assertStatement;
exports.assertTerminatorless = assertTerminatorless;
exports.assertCompletionStatement = assertCompletionStatement;
exports.assertConditional = assertConditional;
exports.assertLoop = assertLoop;
exports.assertWhile = assertWhile;
exports.assertExpressionWrapper = assertExpressionWrapper;
exports.assertFor = assertFor;
exports.assertForXStatement = assertForXStatement;
exports.assertFunction = assertFunction;
exports.assertFunctionParent = assertFunctionParent;
exports.assertPureish = assertPureish;
exports.assertDeclaration = assertDeclaration;
exports.assertPatternLike = assertPatternLike;
exports.assertLVal = assertLVal;
exports.assertTSEntityName = assertTSEntityName;
exports.assertLiteral = assertLiteral;
exports.assertImmutable = assertImmutable;
exports.assertUserWhitespacable = assertUserWhitespacable;
exports.assertMethod = assertMethod;
exports.assertObjectMember = assertObjectMember;
exports.assertProperty = assertProperty;
exports.assertUnaryLike = assertUnaryLike;
exports.assertPattern = assertPattern;
exports.assertClass = assertClass;
exports.assertModuleDeclaration = assertModuleDeclaration;
exports.assertExportDeclaration = assertExportDeclaration;
exports.assertModuleSpecifier = assertModuleSpecifier;
exports.assertFlow = assertFlow;
exports.assertFlowType = assertFlowType;
exports.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
exports.assertFlowDeclaration = assertFlowDeclaration;
exports.assertFlowPredicate = assertFlowPredicate;
exports.assertEnumBody = assertEnumBody;
exports.assertEnumMember = assertEnumMember;
exports.assertJSX = assertJSX;
exports.assertPrivate = assertPrivate;
exports.assertTSTypeElement = assertTSTypeElement;
exports.assertTSType = assertTSType;
exports.assertTSBaseType = assertTSBaseType;
exports.assertNumberLiteral = assertNumberLiteral;
exports.assertRegexLiteral = assertRegexLiteral;
exports.assertRestProperty = assertRestProperty;
exports.assertSpreadProperty = assertSpreadProperty;

var _is = _interopRequireDefault(require("../../validators/is"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function assert(type, node, opts) {
  if (!(0, _is.default)(type, node, opts)) {
    throw new Error(`Expected type "${type}" with option ${JSON.stringify(opts)}, ` + `but instead got "${node.type}".`);
  }
}

function assertArrayExpression(node, opts = {}) {
  assert("ArrayExpression", node, opts);
}

function assertAssignmentExpression(node, opts = {}) {
  assert("AssignmentExpression", node, opts);
}

function assertBinaryExpression(node, opts = {}) {
  assert("BinaryExpression", node, opts);
}

function assertInterpreterDirective(node, opts = {}) {
  assert("InterpreterDirective", node, opts);
}

function assertDirective(node, opts = {}) {
  assert("Directive", node, opts);
}

function assertDirectiveLiteral(node, opts = {}) {
  assert("DirectiveLiteral", node, opts);
}

function assertBlockStatement(node, opts = {}) {
  assert("BlockStatement", node, opts);
}

function assertBreakStatement(node, opts = {}) {
  assert("BreakStatement", node, opts);
}

function assertCallExpression(node, opts = {}) {
  assert("CallExpression", node, opts);
}

function assertCatchClause(node, opts = {}) {
  assert("CatchClause", node, opts);
}

function assertConditionalExpression(node, opts = {}) {
  assert("ConditionalExpression", node, opts);
}

function assertContinueStatement(node, opts = {}) {
  assert("ContinueStatement", node, opts);
}

function assertDebuggerStatement(node, opts = {}) {
  assert("DebuggerStatement", node, opts);
}

function assertDoWhileStatement(node, opts = {}) {
  assert("DoWhileStatement", node, opts);
}

function assertEmptyStatement(node, opts = {}) {
  assert("EmptyStatement", node, opts);
}

function assertExpressionStatement(node, opts = {}) {
  assert("ExpressionStatement", node, opts);
}

function assertFile(node, opts = {}) {
  assert("File", node, opts);
}

function assertForInStatement(node, opts = {}) {
  assert("ForInStatement", node, opts);
}

function assertForStatement(node, opts = {}) {
  assert("ForStatement", node, opts);
}

function assertFunctionDeclaration(node, opts = {}) {
  assert("FunctionDeclaration", node, opts);
}

function assertFunctionExpression(node, opts = {}) {
  assert("FunctionExpression", node, opts);
}

function assertIdentifier(node, opts = {}) {
  assert("Identifier", node, opts);
}

function assertIfStatement(node, opts = {}) {
  assert("IfStatement", node, opts);
}

function assertLabeledStatement(node, opts = {}) {
  assert("LabeledStatement", node, opts);
}

function assertStringLiteral(node, opts = {}) {
  assert("StringLiteral", node, opts);
}

function assertNumericLiteral(node, opts = {}) {
  assert("NumericLiteral", node, opts);
}

function assertNullLiteral(node, opts = {}) {
  assert("NullLiteral", node, opts);
}

function assertBooleanLiteral(node, opts = {}) {
  assert("BooleanLiteral", node, opts);
}

function assertRegExpLiteral(node, opts = {}) {
  assert("RegExpLiteral", node, opts);
}

function assertLogicalExpression(node, opts = {}) {
  assert("LogicalExpression", node, opts);
}

function assertMemberExpression(node, opts = {}) {
  assert("MemberExpression", node, opts);
}

function assertNewExpression(node, opts = {}) {
  assert("NewExpression", node, opts);
}

function assertProgram(node, opts = {}) {
  assert("Program", node, opts);
}

function assertObjectExpression(node, opts = {}) {
  assert("ObjectExpression", node, opts);
}

function assertObjectMethod(node, opts = {}) {
  assert("ObjectMethod", node, opts);
}

function assertObjectProperty(node, opts = {}) {
  assert("ObjectProperty", node, opts);
}

function assertRestElement(node, opts = {}) {
  assert("RestElement", node, opts);
}

function assertReturnStatement(node, opts = {}) {
  assert("ReturnStatement", node, opts);
}

function assertSequenceExpression(node, opts = {}) {
  assert("SequenceExpression", node, opts);
}

function assertParenthesizedExpression(node, opts = {}) {
  assert("ParenthesizedExpression", node, opts);
}

function assertSwitchCase(node, opts = {}) {
  assert("SwitchCase", node, opts);
}

function assertSwitchStatement(node, opts = {}) {
  assert("SwitchStatement", node, opts);
}

function assertThisExpression(node, opts = {}) {
  assert("ThisExpression", node, opts);
}

function assertThrowStatement(node, opts = {}) {
  assert("ThrowStatement", node, opts);
}

function assertTryStatement(node, opts = {}) {
  assert("TryStatement", node, opts);
}

function assertUnaryExpression(node, opts = {}) {
  assert("UnaryExpression", node, opts);
}

function assertUpdateExpression(node, opts = {}) {
  assert("UpdateExpression", node, opts);
}

function assertVariableDeclaration(node, opts = {}) {
  assert("VariableDeclaration", node, opts);
}

function assertVariableDeclarator(node, opts = {}) {
  assert("VariableDeclarator", node, opts);
}

function assertWhileStatement(node, opts = {}) {
  assert("WhileStatement", node, opts);
}

function assertWithStatement(node, opts = {}) {
  assert("WithStatement", node, opts);
}

function assertAssignmentPattern(node, opts = {}) {
  assert("AssignmentPattern", node, opts);
}

function assertArrayPattern(node, opts = {}) {
  assert("ArrayPattern", node, opts);
}

function assertArrowFunctionExpression(node, opts = {}) {
  assert("ArrowFunctionExpression", node, opts);
}

function assertClassBody(node, opts = {}) {
  assert("ClassBody", node, opts);
}

function assertClassExpression(node, opts = {}) {
  assert("ClassExpression", node, opts);
}

function assertClassDeclaration(node, opts = {}) {
  assert("ClassDeclaration", node, opts);
}

function assertExportAllDeclaration(node, opts = {}) {
  assert("ExportAllDeclaration", node, opts);
}

function assertExportDefaultDeclaration(node, opts = {}) {
  assert("ExportDefaultDeclaration", node, opts);
}

function assertExportNamedDeclaration(node, opts = {}) {
  assert("ExportNamedDeclaration", node, opts);
}

function assertExportSpecifier(node, opts = {}) {
  assert("ExportSpecifier", node, opts);
}

function assertForOfStatement(node, opts = {}) {
  assert("ForOfStatement", node, opts);
}

function assertImportDeclaration(node, opts = {}) {
  assert("ImportDeclaration", node, opts);
}

function assertImportDefaultSpecifier(node, opts = {}) {
  assert("ImportDefaultSpecifier", node, opts);
}

function assertImportNamespaceSpecifier(node, opts = {}) {
  assert("ImportNamespaceSpecifier", node, opts);
}

function assertImportSpecifier(node, opts = {}) {
  assert("ImportSpecifier", node, opts);
}

function assertMetaProperty(node, opts = {}) {
  assert("MetaProperty", node, opts);
}

function assertClassMethod(node, opts = {}) {
  assert("ClassMethod", node, opts);
}

function assertObjectPattern(node, opts = {}) {
  assert("ObjectPattern", node, opts);
}

function assertSpreadElement(node, opts = {}) {
  assert("SpreadElement", node, opts);
}

function assertSuper(node, opts = {}) {
  assert("Super", node, opts);
}

function assertTaggedTemplateExpression(node, opts = {}) {
  assert("TaggedTemplateExpression", node, opts);
}

function assertTemplateElement(node, opts = {}) {
  assert("TemplateElement", node, opts);
}

function assertTemplateLiteral(node, opts = {}) {
  assert("TemplateLiteral", node, opts);
}

function assertYieldExpression(node, opts = {}) {
  assert("YieldExpression", node, opts);
}

function assertAwaitExpression(node, opts = {}) {
  assert("AwaitExpression", node, opts);
}

function assertImport(node, opts = {}) {
  assert("Import", node, opts);
}

function assertBigIntLiteral(node, opts = {}) {
  assert("BigIntLiteral", node, opts);
}

function assertExportNamespaceSpecifier(node, opts = {}) {
  assert("ExportNamespaceSpecifier", node, opts);
}

function assertOptionalMemberExpression(node, opts = {}) {
  assert("OptionalMemberExpression", node, opts);
}

function assertOptionalCallExpression(node, opts = {}) {
  assert("OptionalCallExpression", node, opts);
}

function assertAnyTypeAnnotation(node, opts = {}) {
  assert("AnyTypeAnnotation", node, opts);
}

function assertArrayTypeAnnotation(node, opts = {}) {
  assert("ArrayTypeAnnotation", node, opts);
}

function assertBooleanTypeAnnotation(node, opts = {}) {
  assert("BooleanTypeAnnotation", node, opts);
}

function assertBooleanLiteralTypeAnnotation(node, opts = {}) {
  assert("BooleanLiteralTypeAnnotation", node, opts);
}

function assertNullLiteralTypeAnnotation(node, opts = {}) {
  assert("NullLiteralTypeAnnotation", node, opts);
}

function assertClassImplements(node, opts = {}) {
  assert("ClassImplements", node, opts);
}

function assertDeclareClass(node, opts = {}) {
  assert("DeclareClass", node, opts);
}

function assertDeclareFunction(node, opts = {}) {
  assert("DeclareFunction", node, opts);
}

function assertDeclareInterface(node, opts = {}) {
  assert("DeclareInterface", node, opts);
}

function assertDeclareModule(node, opts = {}) {
  assert("DeclareModule", node, opts);
}

function assertDeclareModuleExports(node, opts = {}) {
  assert("DeclareModuleExports", node, opts);
}

function assertDeclareTypeAlias(node, opts = {}) {
  assert("DeclareTypeAlias", node, opts);
}

function assertDeclareOpaqueType(node, opts = {}) {
  assert("DeclareOpaqueType", node, opts);
}

function assertDeclareVariable(node, opts = {}) {
  assert("DeclareVariable", node, opts);
}

function assertDeclareExportDeclaration(node, opts = {}) {
  assert("DeclareExportDeclaration", node, opts);
}

function assertDeclareExportAllDeclaration(node, opts = {}) {
  assert("DeclareExportAllDeclaration", node, opts);
}

function assertDeclaredPredicate(node, opts = {}) {
  assert("DeclaredPredicate", node, opts);
}

function assertExistsTypeAnnotation(node, opts = {}) {
  assert("ExistsTypeAnnotation", node, opts);
}

function assertFunctionTypeAnnotation(node, opts = {}) {
  assert("FunctionTypeAnnotation", node, opts);
}

function assertFunctionTypeParam(node, opts = {}) {
  assert("FunctionTypeParam", node, opts);
}

function assertGenericTypeAnnotation(node, opts = {}) {
  assert("GenericTypeAnnotation", node, opts);
}

function assertInferredPredicate(node, opts = {}) {
  assert("InferredPredicate", node, opts);
}

function assertInterfaceExtends(node, opts = {}) {
  assert("InterfaceExtends", node, opts);
}

function assertInterfaceDeclaration(node, opts = {}) {
  assert("InterfaceDeclaration", node, opts);
}

function assertInterfaceTypeAnnotation(node, opts = {}) {
  assert("InterfaceTypeAnnotation", node, opts);
}

function assertIntersectionTypeAnnotation(node, opts = {}) {
  assert("IntersectionTypeAnnotation", node, opts);
}

function assertMixedTypeAnnotation(node, opts = {}) {
  assert("MixedTypeAnnotation", node, opts);
}

function assertEmptyTypeAnnotation(node, opts = {}) {
  assert("EmptyTypeAnnotation", node, opts);
}

function assertNullableTypeAnnotation(node, opts = {}) {
  assert("NullableTypeAnnotation", node, opts);
}

function assertNumberLiteralTypeAnnotation(node, opts = {}) {
  assert("NumberLiteralTypeAnnotation", node, opts);
}

function assertNumberTypeAnnotation(node, opts = {}) {
  assert("NumberTypeAnnotation", node, opts);
}

function assertObjectTypeAnnotation(node, opts = {}) {
  assert("ObjectTypeAnnotation", node, opts);
}

function assertObjectTypeInternalSlot(node, opts = {}) {
  assert("ObjectTypeInternalSlot", node, opts);
}

function assertObjectTypeCallProperty(node, opts = {}) {
  assert("ObjectTypeCallProperty", node, opts);
}

function assertObjectTypeIndexer(node, opts = {}) {
  assert("ObjectTypeIndexer", node, opts);
}

function assertObjectTypeProperty(node, opts = {}) {
  assert("ObjectTypeProperty", node, opts);
}

function assertObjectTypeSpreadProperty(node, opts = {}) {
  assert("ObjectTypeSpreadProperty", node, opts);
}

function assertOpaqueType(node, opts = {}) {
  assert("OpaqueType", node, opts);
}

function assertQualifiedTypeIdentifier(node, opts = {}) {
  assert("QualifiedTypeIdentifier", node, opts);
}

function assertStringLiteralTypeAnnotation(node, opts = {}) {
  assert("StringLiteralTypeAnnotation", node, opts);
}

function assertStringTypeAnnotation(node, opts = {}) {
  assert("StringTypeAnnotation", node, opts);
}

function assertSymbolTypeAnnotation(node, opts = {}) {
  assert("SymbolTypeAnnotation", node, opts);
}

function assertThisTypeAnnotation(node, opts = {}) {
  assert("ThisTypeAnnotation", node, opts);
}

function assertTupleTypeAnnotation(node, opts = {}) {
  assert("TupleTypeAnnotation", node, opts);
}

function assertTypeofTypeAnnotation(node, opts = {}) {
  assert("TypeofTypeAnnotation", node, opts);
}

function assertTypeAlias(node, opts = {}) {
  assert("TypeAlias", node, opts);
}

function assertTypeAnnotation(node, opts = {}) {
  assert("TypeAnnotation", node, opts);
}

function assertTypeCastExpression(node, opts = {}) {
  assert("TypeCastExpression", node, opts);
}

function assertTypeParameter(node, opts = {}) {
  assert("TypeParameter", node, opts);
}

function assertTypeParameterDeclaration(node, opts = {}) {
  assert("TypeParameterDeclaration", node, opts);
}

function assertTypeParameterInstantiation(node, opts = {}) {
  assert("TypeParameterInstantiation", node, opts);
}

function assertUnionTypeAnnotation(node, opts = {}) {
  assert("UnionTypeAnnotation", node, opts);
}

function assertVariance(node, opts = {}) {
  assert("Variance", node, opts);
}

function assertVoidTypeAnnotation(node, opts = {}) {
  assert("VoidTypeAnnotation", node, opts);
}

function assertEnumDeclaration(node, opts = {}) {
  assert("EnumDeclaration", node, opts);
}

function assertEnumBooleanBody(node, opts = {}) {
  assert("EnumBooleanBody", node, opts);
}

function assertEnumNumberBody(node, opts = {}) {
  assert("EnumNumberBody", node, opts);
}

function assertEnumStringBody(node, opts = {}) {
  assert("EnumStringBody", node, opts);
}

function assertEnumSymbolBody(node, opts = {}) {
  assert("EnumSymbolBody", node, opts);
}

function assertEnumBooleanMember(node, opts = {}) {
  assert("EnumBooleanMember", node, opts);
}

function assertEnumNumberMember(node, opts = {}) {
  assert("EnumNumberMember", node, opts);
}

function assertEnumStringMember(node, opts = {}) {
  assert("EnumStringMember", node, opts);
}

function assertEnumDefaultedMember(node, opts = {}) {
  assert("EnumDefaultedMember", node, opts);
}

function assertJSXAttribute(node, opts = {}) {
  assert("JSXAttribute", node, opts);
}

function assertJSXClosingElement(node, opts = {}) {
  assert("JSXClosingElement", node, opts);
}

function assertJSXElement(node, opts = {}) {
  assert("JSXElement", node, opts);
}

function assertJSXEmptyExpression(node, opts = {}) {
  assert("JSXEmptyExpression", node, opts);
}

function assertJSXExpressionContainer(node, opts = {}) {
  assert("JSXExpressionContainer", node, opts);
}

function assertJSXSpreadChild(node, opts = {}) {
  assert("JSXSpreadChild", node, opts);
}

function assertJSXIdentifier(node, opts = {}) {
  assert("JSXIdentifier", node, opts);
}

function assertJSXMemberExpression(node, opts = {}) {
  assert("JSXMemberExpression", node, opts);
}

function assertJSXNamespacedName(node, opts = {}) {
  assert("JSXNamespacedName", node, opts);
}

function assertJSXOpeningElement(node, opts = {}) {
  assert("JSXOpeningElement", node, opts);
}

function assertJSXSpreadAttribute(node, opts = {}) {
  assert("JSXSpreadAttribute", node, opts);
}

function assertJSXText(node, opts = {}) {
  assert("JSXText", node, opts);
}

function assertJSXFragment(node, opts = {}) {
  assert("JSXFragment", node, opts);
}

function assertJSXOpeningFragment(node, opts = {}) {
  assert("JSXOpeningFragment", node, opts);
}

function assertJSXClosingFragment(node, opts = {}) {
  assert("JSXClosingFragment", node, opts);
}

function assertNoop(node, opts = {}) {
  assert("Noop", node, opts);
}

function assertPlaceholder(node, opts = {}) {
  assert("Placeholder", node, opts);
}

function assertV8IntrinsicIdentifier(node, opts = {}) {
  assert("V8IntrinsicIdentifier", node, opts);
}

function assertArgumentPlaceholder(node, opts = {}) {
  assert("ArgumentPlaceholder", node, opts);
}

function assertBindExpression(node, opts = {}) {
  assert("BindExpression", node, opts);
}

function assertClassProperty(node, opts = {}) {
  assert("ClassProperty", node, opts);
}

function assertPipelineTopicExpression(node, opts = {}) {
  assert("PipelineTopicExpression", node, opts);
}

function assertPipelineBareFunction(node, opts = {}) {
  assert("PipelineBareFunction", node, opts);
}

function assertPipelinePrimaryTopicReference(node, opts = {}) {
  assert("PipelinePrimaryTopicReference", node, opts);
}

function assertClassPrivateProperty(node, opts = {}) {
  assert("ClassPrivateProperty", node, opts);
}

function assertClassPrivateMethod(node, opts = {}) {
  assert("ClassPrivateMethod", node, opts);
}

function assertImportAttribute(node, opts = {}) {
  assert("ImportAttribute", node, opts);
}

function assertDecorator(node, opts = {}) {
  assert("Decorator", node, opts);
}

function assertDoExpression(node, opts = {}) {
  assert("DoExpression", node, opts);
}

function assertExportDefaultSpecifier(node, opts = {}) {
  assert("ExportDefaultSpecifier", node, opts);
}

function assertPrivateName(node, opts = {}) {
  assert("PrivateName", node, opts);
}

function assertRecordExpression(node, opts = {}) {
  assert("RecordExpression", node, opts);
}

function assertTupleExpression(node, opts = {}) {
  assert("TupleExpression", node, opts);
}

function assertDecimalLiteral(node, opts = {}) {
  assert("DecimalLiteral", node, opts);
}

function assertTSParameterProperty(node, opts = {}) {
  assert("TSParameterProperty", node, opts);
}

function assertTSDeclareFunction(node, opts = {}) {
  assert("TSDeclareFunction", node, opts);
}

function assertTSDeclareMethod(node, opts = {}) {
  assert("TSDeclareMethod", node, opts);
}

function assertTSQualifiedName(node, opts = {}) {
  assert("TSQualifiedName", node, opts);
}

function assertTSCallSignatureDeclaration(node, opts = {}) {
  assert("TSCallSignatureDeclaration", node, opts);
}

function assertTSConstructSignatureDeclaration(node, opts = {}) {
  assert("TSConstructSignatureDeclaration", node, opts);
}

function assertTSPropertySignature(node, opts = {}) {
  assert("TSPropertySignature", node, opts);
}

function assertTSMethodSignature(node, opts = {}) {
  assert("TSMethodSignature", node, opts);
}

function assertTSIndexSignature(node, opts = {}) {
  assert("TSIndexSignature", node, opts);
}

function assertTSAnyKeyword(node, opts = {}) {
  assert("TSAnyKeyword", node, opts);
}

function assertTSBooleanKeyword(node, opts = {}) {
  assert("TSBooleanKeyword", node, opts);
}

function assertTSBigIntKeyword(node, opts = {}) {
  assert("TSBigIntKeyword", node, opts);
}

function assertTSNeverKeyword(node, opts = {}) {
  assert("TSNeverKeyword", node, opts);
}

function assertTSNullKeyword(node, opts = {}) {
  assert("TSNullKeyword", node, opts);
}

function assertTSNumberKeyword(node, opts = {}) {
  assert("TSNumberKeyword", node, opts);
}

function assertTSObjectKeyword(node, opts = {}) {
  assert("TSObjectKeyword", node, opts);
}

function assertTSStringKeyword(node, opts = {}) {
  assert("TSStringKeyword", node, opts);
}

function assertTSSymbolKeyword(node, opts = {}) {
  assert("TSSymbolKeyword", node, opts);
}

function assertTSUndefinedKeyword(node, opts = {}) {
  assert("TSUndefinedKeyword", node, opts);
}

function assertTSUnknownKeyword(node, opts = {}) {
  assert("TSUnknownKeyword", node, opts);
}

function assertTSVoidKeyword(node, opts = {}) {
  assert("TSVoidKeyword", node, opts);
}

function assertTSThisType(node, opts = {}) {
  assert("TSThisType", node, opts);
}

function assertTSFunctionType(node, opts = {}) {
  assert("TSFunctionType", node, opts);
}

function assertTSConstructorType(node, opts = {}) {
  assert("TSConstructorType", node, opts);
}

function assertTSTypeReference(node, opts = {}) {
  assert("TSTypeReference", node, opts);
}

function assertTSTypePredicate(node, opts = {}) {
  assert("TSTypePredicate", node, opts);
}

function assertTSTypeQuery(node, opts = {}) {
  assert("TSTypeQuery", node, opts);
}

function assertTSTypeLiteral(node, opts = {}) {
  assert("TSTypeLiteral", node, opts);
}

function assertTSArrayType(node, opts = {}) {
  assert("TSArrayType", node, opts);
}

function assertTSTupleType(node, opts = {}) {
  assert("TSTupleType", node, opts);
}

function assertTSOptionalType(node, opts = {}) {
  assert("TSOptionalType", node, opts);
}

function assertTSRestType(node, opts = {}) {
  assert("TSRestType", node, opts);
}

function assertTSNamedTupleMember(node, opts = {}) {
  assert("TSNamedTupleMember", node, opts);
}

function assertTSUnionType(node, opts = {}) {
  assert("TSUnionType", node, opts);
}

function assertTSIntersectionType(node, opts = {}) {
  assert("TSIntersectionType", node, opts);
}

function assertTSConditionalType(node, opts = {}) {
  assert("TSConditionalType", node, opts);
}

function assertTSInferType(node, opts = {}) {
  assert("TSInferType", node, opts);
}

function assertTSParenthesizedType(node, opts = {}) {
  assert("TSParenthesizedType", node, opts);
}

function assertTSTypeOperator(node, opts = {}) {
  assert("TSTypeOperator", node, opts);
}

function assertTSIndexedAccessType(node, opts = {}) {
  assert("TSIndexedAccessType", node, opts);
}

function assertTSMappedType(node, opts = {}) {
  assert("TSMappedType", node, opts);
}

function assertTSLiteralType(node, opts = {}) {
  assert("TSLiteralType", node, opts);
}

function assertTSExpressionWithTypeArguments(node, opts = {}) {
  assert("TSExpressionWithTypeArguments", node, opts);
}

function assertTSInterfaceDeclaration(node, opts = {}) {
  assert("TSInterfaceDeclaration", node, opts);
}

function assertTSInterfaceBody(node, opts = {}) {
  assert("TSInterfaceBody", node, opts);
}

function assertTSTypeAliasDeclaration(node, opts = {}) {
  assert("TSTypeAliasDeclaration", node, opts);
}

function assertTSAsExpression(node, opts = {}) {
  assert("TSAsExpression", node, opts);
}

function assertTSTypeAssertion(node, opts = {}) {
  assert("TSTypeAssertion", node, opts);
}

function assertTSEnumDeclaration(node, opts = {}) {
  assert("TSEnumDeclaration", node, opts);
}

function assertTSEnumMember(node, opts = {}) {
  assert("TSEnumMember", node, opts);
}

function assertTSModuleDeclaration(node, opts = {}) {
  assert("TSModuleDeclaration", node, opts);
}

function assertTSModuleBlock(node, opts = {}) {
  assert("TSModuleBlock", node, opts);
}

function assertTSImportType(node, opts = {}) {
  assert("TSImportType", node, opts);
}

function assertTSImportEqualsDeclaration(node, opts = {}) {
  assert("TSImportEqualsDeclaration", node, opts);
}

function assertTSExternalModuleReference(node, opts = {}) {
  assert("TSExternalModuleReference", node, opts);
}

function assertTSNonNullExpression(node, opts = {}) {
  assert("TSNonNullExpression", node, opts);
}

function assertTSExportAssignment(node, opts = {}) {
  assert("TSExportAssignment", node, opts);
}

function assertTSNamespaceExportDeclaration(node, opts = {}) {
  assert("TSNamespaceExportDeclaration", node, opts);
}

function assertTSTypeAnnotation(node, opts = {}) {
  assert("TSTypeAnnotation", node, opts);
}

function assertTSTypeParameterInstantiation(node, opts = {}) {
  assert("TSTypeParameterInstantiation", node, opts);
}

function assertTSTypeParameterDeclaration(node, opts = {}) {
  assert("TSTypeParameterDeclaration", node, opts);
}

function assertTSTypeParameter(node, opts = {}) {
  assert("TSTypeParameter", node, opts);
}

function assertExpression(node, opts = {}) {
  assert("Expression", node, opts);
}

function assertBinary(node, opts = {}) {
  assert("Binary", node, opts);
}

function assertScopable(node, opts = {}) {
  assert("Scopable", node, opts);
}

function assertBlockParent(node, opts = {}) {
  assert("BlockParent", node, opts);
}

function assertBlock(node, opts = {}) {
  assert("Block", node, opts);
}

function assertStatement(node, opts = {}) {
  assert("Statement", node, opts);
}

function assertTerminatorless(node, opts = {}) {
  assert("Terminatorless", node, opts);
}

function assertCompletionStatement(node, opts = {}) {
  assert("CompletionStatement", node, opts);
}

function assertConditional(node, opts = {}) {
  assert("Conditional", node, opts);
}

function assertLoop(node, opts = {}) {
  assert("Loop", node, opts);
}

function assertWhile(node, opts = {}) {
  assert("While", node, opts);
}

function assertExpressionWrapper(node, opts = {}) {
  assert("ExpressionWrapper", node, opts);
}

function assertFor(node, opts = {}) {
  assert("For", node, opts);
}

function assertForXStatement(node, opts = {}) {
  assert("ForXStatement", node, opts);
}

function assertFunction(node, opts = {}) {
  assert("Function", node, opts);
}

function assertFunctionParent(node, opts = {}) {
  assert("FunctionParent", node, opts);
}

function assertPureish(node, opts = {}) {
  assert("Pureish", node, opts);
}

function assertDeclaration(node, opts = {}) {
  assert("Declaration", node, opts);
}

function assertPatternLike(node, opts = {}) {
  assert("PatternLike", node, opts);
}

function assertLVal(node, opts = {}) {
  assert("LVal", node, opts);
}

function assertTSEntityName(node, opts = {}) {
  assert("TSEntityName", node, opts);
}

function assertLiteral(node, opts = {}) {
  assert("Literal", node, opts);
}

function assertImmutable(node, opts = {}) {
  assert("Immutable", node, opts);
}

function assertUserWhitespacable(node, opts = {}) {
  assert("UserWhitespacable", node, opts);
}

function assertMethod(node, opts = {}) {
  assert("Method", node, opts);
}

function assertObjectMember(node, opts = {}) {
  assert("ObjectMember", node, opts);
}

function assertProperty(node, opts = {}) {
  assert("Property", node, opts);
}

function assertUnaryLike(node, opts = {}) {
  assert("UnaryLike", node, opts);
}

function assertPattern(node, opts = {}) {
  assert("Pattern", node, opts);
}

function assertClass(node, opts = {}) {
  assert("Class", node, opts);
}

function assertModuleDeclaration(node, opts = {}) {
  assert("ModuleDeclaration", node, opts);
}

function assertExportDeclaration(node, opts = {}) {
  assert("ExportDeclaration", node, opts);
}

function assertModuleSpecifier(node, opts = {}) {
  assert("ModuleSpecifier", node, opts);
}

function assertFlow(node, opts = {}) {
  assert("Flow", node, opts);
}

function assertFlowType(node, opts = {}) {
  assert("FlowType", node, opts);
}

function assertFlowBaseAnnotation(node, opts = {}) {
  assert("FlowBaseAnnotation", node, opts);
}

function assertFlowDeclaration(node, opts = {}) {
  assert("FlowDeclaration", node, opts);
}

function assertFlowPredicate(node, opts = {}) {
  assert("FlowPredicate", node, opts);
}

function assertEnumBody(node, opts = {}) {
  assert("EnumBody", node, opts);
}

function assertEnumMember(node, opts = {}) {
  assert("EnumMember", node, opts);
}

function assertJSX(node, opts = {}) {
  assert("JSX", node, opts);
}

function assertPrivate(node, opts = {}) {
  assert("Private", node, opts);
}

function assertTSTypeElement(node, opts = {}) {
  assert("TSTypeElement", node, opts);
}

function assertTSType(node, opts = {}) {
  assert("TSType", node, opts);
}

function assertTSBaseType(node, opts = {}) {
  assert("TSBaseType", node, opts);
}

function assertNumberLiteral(node, opts) {
  console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
  assert("NumberLiteral", node, opts);
}

function assertRegexLiteral(node, opts) {
  console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
  assert("RegexLiteral", node, opts);
}

function assertRestProperty(node, opts) {
  console.trace("The node type RestProperty has been renamed to RestElement");
  assert("RestProperty", node, opts);
}

function assertSpreadProperty(node, opts) {
  console.trace("The node type SpreadProperty has been renamed to SpreadElement");
  assert("SpreadProperty", node, opts);
}
},{"../../validators/is":89}],32:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = builder;

var _clone = _interopRequireDefault(require("lodash/clone"));

var _definitions = require("../definitions");

var _validate = _interopRequireDefault(require("../validators/validate"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function builder(type, ...args) {
  const keys = _definitions.BUILDER_KEYS[type];
  const countArgs = args.length;

  if (countArgs > keys.length) {
    throw new Error(`${type}: Too many arguments passed. Received ${countArgs} but can receive no more than ${keys.length}`);
  }

  const node = {
    type
  };
  let i = 0;
  keys.forEach(key => {
    const field = _definitions.NODE_FIELDS[type][key];
    let arg;
    if (i < countArgs) arg = args[i];
    if (arg === undefined) arg = (0, _clone.default)(field.default);
    node[key] = arg;
    i++;
  });

  for (const key of Object.keys(node)) {
    (0, _validate.default)(node, key, node[key]);
  }

  return node;
}
},{"../definitions":66,"../validators/validate":107,"lodash/clone":205}],33:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createFlowUnionType;

var _generated = require("../generated");

var _removeTypeDuplicates = _interopRequireDefault(require("../../modifications/flow/removeTypeDuplicates"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createFlowUnionType(types) {
  const flattened = (0, _removeTypeDuplicates.default)(types);

  if (flattened.length === 1) {
    return flattened[0];
  } else {
    return (0, _generated.unionTypeAnnotation)(flattened);
  }
}
},{"../../modifications/flow/removeTypeDuplicates":74,"../generated":35}],34:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createTypeAnnotationBasedOnTypeof;

var _generated = require("../generated");

function createTypeAnnotationBasedOnTypeof(type) {
  if (type === "string") {
    return (0, _generated.stringTypeAnnotation)();
  } else if (type === "number") {
    return (0, _generated.numberTypeAnnotation)();
  } else if (type === "undefined") {
    return (0, _generated.voidTypeAnnotation)();
  } else if (type === "boolean") {
    return (0, _generated.booleanTypeAnnotation)();
  } else if (type === "function") {
    return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Function"));
  } else if (type === "object") {
    return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Object"));
  } else if (type === "symbol") {
    return (0, _generated.genericTypeAnnotation)((0, _generated.identifier)("Symbol"));
  } else {
    throw new Error("Invalid typeof value");
  }
}
},{"../generated":35}],35:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ArrayExpression = exports.arrayExpression = arrayExpression;
exports.AssignmentExpression = exports.assignmentExpression = assignmentExpression;
exports.BinaryExpression = exports.binaryExpression = binaryExpression;
exports.InterpreterDirective = exports.interpreterDirective = interpreterDirective;
exports.Directive = exports.directive = directive;
exports.DirectiveLiteral = exports.directiveLiteral = directiveLiteral;
exports.BlockStatement = exports.blockStatement = blockStatement;
exports.BreakStatement = exports.breakStatement = breakStatement;
exports.CallExpression = exports.callExpression = callExpression;
exports.CatchClause = exports.catchClause = catchClause;
exports.ConditionalExpression = exports.conditionalExpression = conditionalExpression;
exports.ContinueStatement = exports.continueStatement = continueStatement;
exports.DebuggerStatement = exports.debuggerStatement = debuggerStatement;
exports.DoWhileStatement = exports.doWhileStatement = doWhileStatement;
exports.EmptyStatement = exports.emptyStatement = emptyStatement;
exports.ExpressionStatement = exports.expressionStatement = expressionStatement;
exports.File = exports.file = file;
exports.ForInStatement = exports.forInStatement = forInStatement;
exports.ForStatement = exports.forStatement = forStatement;
exports.FunctionDeclaration = exports.functionDeclaration = functionDeclaration;
exports.FunctionExpression = exports.functionExpression = functionExpression;
exports.Identifier = exports.identifier = identifier;
exports.IfStatement = exports.ifStatement = ifStatement;
exports.LabeledStatement = exports.labeledStatement = labeledStatement;
exports.StringLiteral = exports.stringLiteral = stringLiteral;
exports.NumericLiteral = exports.numericLiteral = numericLiteral;
exports.NullLiteral = exports.nullLiteral = nullLiteral;
exports.BooleanLiteral = exports.booleanLiteral = booleanLiteral;
exports.RegExpLiteral = exports.regExpLiteral = regExpLiteral;
exports.LogicalExpression = exports.logicalExpression = logicalExpression;
exports.MemberExpression = exports.memberExpression = memberExpression;
exports.NewExpression = exports.newExpression = newExpression;
exports.Program = exports.program = program;
exports.ObjectExpression = exports.objectExpression = objectExpression;
exports.ObjectMethod = exports.objectMethod = objectMethod;
exports.ObjectProperty = exports.objectProperty = objectProperty;
exports.RestElement = exports.restElement = restElement;
exports.ReturnStatement = exports.returnStatement = returnStatement;
exports.SequenceExpression = exports.sequenceExpression = sequenceExpression;
exports.ParenthesizedExpression = exports.parenthesizedExpression = parenthesizedExpression;
exports.SwitchCase = exports.switchCase = switchCase;
exports.SwitchStatement = exports.switchStatement = switchStatement;
exports.ThisExpression = exports.thisExpression = thisExpression;
exports.ThrowStatement = exports.throwStatement = throwStatement;
exports.TryStatement = exports.tryStatement = tryStatement;
exports.UnaryExpression = exports.unaryExpression = unaryExpression;
exports.UpdateExpression = exports.updateExpression = updateExpression;
exports.VariableDeclaration = exports.variableDeclaration = variableDeclaration;
exports.VariableDeclarator = exports.variableDeclarator = variableDeclarator;
exports.WhileStatement = exports.whileStatement = whileStatement;
exports.WithStatement = exports.withStatement = withStatement;
exports.AssignmentPattern = exports.assignmentPattern = assignmentPattern;
exports.ArrayPattern = exports.arrayPattern = arrayPattern;
exports.ArrowFunctionExpression = exports.arrowFunctionExpression = arrowFunctionExpression;
exports.ClassBody = exports.classBody = classBody;
exports.ClassExpression = exports.classExpression = classExpression;
exports.ClassDeclaration = exports.classDeclaration = classDeclaration;
exports.ExportAllDeclaration = exports.exportAllDeclaration = exportAllDeclaration;
exports.ExportDefaultDeclaration = exports.exportDefaultDeclaration = exportDefaultDeclaration;
exports.ExportNamedDeclaration = exports.exportNamedDeclaration = exportNamedDeclaration;
exports.ExportSpecifier = exports.exportSpecifier = exportSpecifier;
exports.ForOfStatement = exports.forOfStatement = forOfStatement;
exports.ImportDeclaration = exports.importDeclaration = importDeclaration;
exports.ImportDefaultSpecifier = exports.importDefaultSpecifier = importDefaultSpecifier;
exports.ImportNamespaceSpecifier = exports.importNamespaceSpecifier = importNamespaceSpecifier;
exports.ImportSpecifier = exports.importSpecifier = importSpecifier;
exports.MetaProperty = exports.metaProperty = metaProperty;
exports.ClassMethod = exports.classMethod = classMethod;
exports.ObjectPattern = exports.objectPattern = objectPattern;
exports.SpreadElement = exports.spreadElement = spreadElement;
exports.super = exports.Super = _super;
exports.TaggedTemplateExpression = exports.taggedTemplateExpression = taggedTemplateExpression;
exports.TemplateElement = exports.templateElement = templateElement;
exports.TemplateLiteral = exports.templateLiteral = templateLiteral;
exports.YieldExpression = exports.yieldExpression = yieldExpression;
exports.AwaitExpression = exports.awaitExpression = awaitExpression;
exports.import = exports.Import = _import;
exports.BigIntLiteral = exports.bigIntLiteral = bigIntLiteral;
exports.ExportNamespaceSpecifier = exports.exportNamespaceSpecifier = exportNamespaceSpecifier;
exports.OptionalMemberExpression = exports.optionalMemberExpression = optionalMemberExpression;
exports.OptionalCallExpression = exports.optionalCallExpression = optionalCallExpression;
exports.AnyTypeAnnotation = exports.anyTypeAnnotation = anyTypeAnnotation;
exports.ArrayTypeAnnotation = exports.arrayTypeAnnotation = arrayTypeAnnotation;
exports.BooleanTypeAnnotation = exports.booleanTypeAnnotation = booleanTypeAnnotation;
exports.BooleanLiteralTypeAnnotation = exports.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
exports.NullLiteralTypeAnnotation = exports.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
exports.ClassImplements = exports.classImplements = classImplements;
exports.DeclareClass = exports.declareClass = declareClass;
exports.DeclareFunction = exports.declareFunction = declareFunction;
exports.DeclareInterface = exports.declareInterface = declareInterface;
exports.DeclareModule = exports.declareModule = declareModule;
exports.DeclareModuleExports = exports.declareModuleExports = declareModuleExports;
exports.DeclareTypeAlias = exports.declareTypeAlias = declareTypeAlias;
exports.DeclareOpaqueType = exports.declareOpaqueType = declareOpaqueType;
exports.DeclareVariable = exports.declareVariable = declareVariable;
exports.DeclareExportDeclaration = exports.declareExportDeclaration = declareExportDeclaration;
exports.DeclareExportAllDeclaration = exports.declareExportAllDeclaration = declareExportAllDeclaration;
exports.DeclaredPredicate = exports.declaredPredicate = declaredPredicate;
exports.ExistsTypeAnnotation = exports.existsTypeAnnotation = existsTypeAnnotation;
exports.FunctionTypeAnnotation = exports.functionTypeAnnotation = functionTypeAnnotation;
exports.FunctionTypeParam = exports.functionTypeParam = functionTypeParam;
exports.GenericTypeAnnotation = exports.genericTypeAnnotation = genericTypeAnnotation;
exports.InferredPredicate = exports.inferredPredicate = inferredPredicate;
exports.InterfaceExtends = exports.interfaceExtends = interfaceExtends;
exports.InterfaceDeclaration = exports.interfaceDeclaration = interfaceDeclaration;
exports.InterfaceTypeAnnotation = exports.interfaceTypeAnnotation = interfaceTypeAnnotation;
exports.IntersectionTypeAnnotation = exports.intersectionTypeAnnotation = intersectionTypeAnnotation;
exports.MixedTypeAnnotation = exports.mixedTypeAnnotation = mixedTypeAnnotation;
exports.EmptyTypeAnnotation = exports.emptyTypeAnnotation = emptyTypeAnnotation;
exports.NullableTypeAnnotation = exports.nullableTypeAnnotation = nullableTypeAnnotation;
exports.NumberLiteralTypeAnnotation = exports.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
exports.NumberTypeAnnotation = exports.numberTypeAnnotation = numberTypeAnnotation;
exports.ObjectTypeAnnotation = exports.objectTypeAnnotation = objectTypeAnnotation;
exports.ObjectTypeInternalSlot = exports.objectTypeInternalSlot = objectTypeInternalSlot;
exports.ObjectTypeCallProperty = exports.objectTypeCallProperty = objectTypeCallProperty;
exports.ObjectTypeIndexer = exports.objectTypeIndexer = objectTypeIndexer;
exports.ObjectTypeProperty = exports.objectTypeProperty = objectTypeProperty;
exports.ObjectTypeSpreadProperty = exports.objectTypeSpreadProperty = objectTypeSpreadProperty;
exports.OpaqueType = exports.opaqueType = opaqueType;
exports.QualifiedTypeIdentifier = exports.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
exports.StringLiteralTypeAnnotation = exports.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
exports.StringTypeAnnotation = exports.stringTypeAnnotation = stringTypeAnnotation;
exports.SymbolTypeAnnotation = exports.symbolTypeAnnotation = symbolTypeAnnotation;
exports.ThisTypeAnnotation = exports.thisTypeAnnotation = thisTypeAnnotation;
exports.TupleTypeAnnotation = exports.tupleTypeAnnotation = tupleTypeAnnotation;
exports.TypeofTypeAnnotation = exports.typeofTypeAnnotation = typeofTypeAnnotation;
exports.TypeAlias = exports.typeAlias = typeAlias;
exports.TypeAnnotation = exports.typeAnnotation = typeAnnotation;
exports.TypeCastExpression = exports.typeCastExpression = typeCastExpression;
exports.TypeParameter = exports.typeParameter = typeParameter;
exports.TypeParameterDeclaration = exports.typeParameterDeclaration = typeParameterDeclaration;
exports.TypeParameterInstantiation = exports.typeParameterInstantiation = typeParameterInstantiation;
exports.UnionTypeAnnotation = exports.unionTypeAnnotation = unionTypeAnnotation;
exports.Variance = exports.variance = variance;
exports.VoidTypeAnnotation = exports.voidTypeAnnotation = voidTypeAnnotation;
exports.EnumDeclaration = exports.enumDeclaration = enumDeclaration;
exports.EnumBooleanBody = exports.enumBooleanBody = enumBooleanBody;
exports.EnumNumberBody = exports.enumNumberBody = enumNumberBody;
exports.EnumStringBody = exports.enumStringBody = enumStringBody;
exports.EnumSymbolBody = exports.enumSymbolBody = enumSymbolBody;
exports.EnumBooleanMember = exports.enumBooleanMember = enumBooleanMember;
exports.EnumNumberMember = exports.enumNumberMember = enumNumberMember;
exports.EnumStringMember = exports.enumStringMember = enumStringMember;
exports.EnumDefaultedMember = exports.enumDefaultedMember = enumDefaultedMember;
exports.jSXAttribute = exports.JSXAttribute = exports.jsxAttribute = jsxAttribute;
exports.jSXClosingElement = exports.JSXClosingElement = exports.jsxClosingElement = jsxClosingElement;
exports.jSXElement = exports.JSXElement = exports.jsxElement = jsxElement;
exports.jSXEmptyExpression = exports.JSXEmptyExpression = exports.jsxEmptyExpression = jsxEmptyExpression;
exports.jSXExpressionContainer = exports.JSXExpressionContainer = exports.jsxExpressionContainer = jsxExpressionContainer;
exports.jSXSpreadChild = exports.JSXSpreadChild = exports.jsxSpreadChild = jsxSpreadChild;
exports.jSXIdentifier = exports.JSXIdentifier = exports.jsxIdentifier = jsxIdentifier;
exports.jSXMemberExpression = exports.JSXMemberExpression = exports.jsxMemberExpression = jsxMemberExpression;
exports.jSXNamespacedName = exports.JSXNamespacedName = exports.jsxNamespacedName = jsxNamespacedName;
exports.jSXOpeningElement = exports.JSXOpeningElement = exports.jsxOpeningElement = jsxOpeningElement;
exports.jSXSpreadAttribute = exports.JSXSpreadAttribute = exports.jsxSpreadAttribute = jsxSpreadAttribute;
exports.jSXText = exports.JSXText = exports.jsxText = jsxText;
exports.jSXFragment = exports.JSXFragment = exports.jsxFragment = jsxFragment;
exports.jSXOpeningFragment = exports.JSXOpeningFragment = exports.jsxOpeningFragment = jsxOpeningFragment;
exports.jSXClosingFragment = exports.JSXClosingFragment = exports.jsxClosingFragment = jsxClosingFragment;
exports.Noop = exports.noop = noop;
exports.Placeholder = exports.placeholder = placeholder;
exports.V8IntrinsicIdentifier = exports.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
exports.ArgumentPlaceholder = exports.argumentPlaceholder = argumentPlaceholder;
exports.BindExpression = exports.bindExpression = bindExpression;
exports.ClassProperty = exports.classProperty = classProperty;
exports.PipelineTopicExpression = exports.pipelineTopicExpression = pipelineTopicExpression;
exports.PipelineBareFunction = exports.pipelineBareFunction = pipelineBareFunction;
exports.PipelinePrimaryTopicReference = exports.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
exports.ClassPrivateProperty = exports.classPrivateProperty = classPrivateProperty;
exports.ClassPrivateMethod = exports.classPrivateMethod = classPrivateMethod;
exports.ImportAttribute = exports.importAttribute = importAttribute;
exports.Decorator = exports.decorator = decorator;
exports.DoExpression = exports.doExpression = doExpression;
exports.ExportDefaultSpecifier = exports.exportDefaultSpecifier = exportDefaultSpecifier;
exports.PrivateName = exports.privateName = privateName;
exports.RecordExpression = exports.recordExpression = recordExpression;
exports.TupleExpression = exports.tupleExpression = tupleExpression;
exports.DecimalLiteral = exports.decimalLiteral = decimalLiteral;
exports.tSParameterProperty = exports.TSParameterProperty = exports.tsParameterProperty = tsParameterProperty;
exports.tSDeclareFunction = exports.TSDeclareFunction = exports.tsDeclareFunction = tsDeclareFunction;
exports.tSDeclareMethod = exports.TSDeclareMethod = exports.tsDeclareMethod = tsDeclareMethod;
exports.tSQualifiedName = exports.TSQualifiedName = exports.tsQualifiedName = tsQualifiedName;
exports.tSCallSignatureDeclaration = exports.TSCallSignatureDeclaration = exports.tsCallSignatureDeclaration = tsCallSignatureDeclaration;
exports.tSConstructSignatureDeclaration = exports.TSConstructSignatureDeclaration = exports.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;
exports.tSPropertySignature = exports.TSPropertySignature = exports.tsPropertySignature = tsPropertySignature;
exports.tSMethodSignature = exports.TSMethodSignature = exports.tsMethodSignature = tsMethodSignature;
exports.tSIndexSignature = exports.TSIndexSignature = exports.tsIndexSignature = tsIndexSignature;
exports.tSAnyKeyword = exports.TSAnyKeyword = exports.tsAnyKeyword = tsAnyKeyword;
exports.tSBooleanKeyword = exports.TSBooleanKeyword = exports.tsBooleanKeyword = tsBooleanKeyword;
exports.tSBigIntKeyword = exports.TSBigIntKeyword = exports.tsBigIntKeyword = tsBigIntKeyword;
exports.tSNeverKeyword = exports.TSNeverKeyword = exports.tsNeverKeyword = tsNeverKeyword;
exports.tSNullKeyword = exports.TSNullKeyword = exports.tsNullKeyword = tsNullKeyword;
exports.tSNumberKeyword = exports.TSNumberKeyword = exports.tsNumberKeyword = tsNumberKeyword;
exports.tSObjectKeyword = exports.TSObjectKeyword = exports.tsObjectKeyword = tsObjectKeyword;
exports.tSStringKeyword = exports.TSStringKeyword = exports.tsStringKeyword = tsStringKeyword;
exports.tSSymbolKeyword = exports.TSSymbolKeyword = exports.tsSymbolKeyword = tsSymbolKeyword;
exports.tSUndefinedKeyword = exports.TSUndefinedKeyword = exports.tsUndefinedKeyword = tsUndefinedKeyword;
exports.tSUnknownKeyword = exports.TSUnknownKeyword = exports.tsUnknownKeyword = tsUnknownKeyword;
exports.tSVoidKeyword = exports.TSVoidKeyword = exports.tsVoidKeyword = tsVoidKeyword;
exports.tSThisType = exports.TSThisType = exports.tsThisType = tsThisType;
exports.tSFunctionType = exports.TSFunctionType = exports.tsFunctionType = tsFunctionType;
exports.tSConstructorType = exports.TSConstructorType = exports.tsConstructorType = tsConstructorType;
exports.tSTypeReference = exports.TSTypeReference = exports.tsTypeReference = tsTypeReference;
exports.tSTypePredicate = exports.TSTypePredicate = exports.tsTypePredicate = tsTypePredicate;
exports.tSTypeQuery = exports.TSTypeQuery = exports.tsTypeQuery = tsTypeQuery;
exports.tSTypeLiteral = exports.TSTypeLiteral = exports.tsTypeLiteral = tsTypeLiteral;
exports.tSArrayType = exports.TSArrayType = exports.tsArrayType = tsArrayType;
exports.tSTupleType = exports.TSTupleType = exports.tsTupleType = tsTupleType;
exports.tSOptionalType = exports.TSOptionalType = exports.tsOptionalType = tsOptionalType;
exports.tSRestType = exports.TSRestType = exports.tsRestType = tsRestType;
exports.tSNamedTupleMember = exports.TSNamedTupleMember = exports.tsNamedTupleMember = tsNamedTupleMember;
exports.tSUnionType = exports.TSUnionType = exports.tsUnionType = tsUnionType;
exports.tSIntersectionType = exports.TSIntersectionType = exports.tsIntersectionType = tsIntersectionType;
exports.tSConditionalType = exports.TSConditionalType = exports.tsConditionalType = tsConditionalType;
exports.tSInferType = exports.TSInferType = exports.tsInferType = tsInferType;
exports.tSParenthesizedType = exports.TSParenthesizedType = exports.tsParenthesizedType = tsParenthesizedType;
exports.tSTypeOperator = exports.TSTypeOperator = exports.tsTypeOperator = tsTypeOperator;
exports.tSIndexedAccessType = exports.TSIndexedAccessType = exports.tsIndexedAccessType = tsIndexedAccessType;
exports.tSMappedType = exports.TSMappedType = exports.tsMappedType = tsMappedType;
exports.tSLiteralType = exports.TSLiteralType = exports.tsLiteralType = tsLiteralType;
exports.tSExpressionWithTypeArguments = exports.TSExpressionWithTypeArguments = exports.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;
exports.tSInterfaceDeclaration = exports.TSInterfaceDeclaration = exports.tsInterfaceDeclaration = tsInterfaceDeclaration;
exports.tSInterfaceBody = exports.TSInterfaceBody = exports.tsInterfaceBody = tsInterfaceBody;
exports.tSTypeAliasDeclaration = exports.TSTypeAliasDeclaration = exports.tsTypeAliasDeclaration = tsTypeAliasDeclaration;
exports.tSAsExpression = exports.TSAsExpression = exports.tsAsExpression = tsAsExpression;
exports.tSTypeAssertion = exports.TSTypeAssertion = exports.tsTypeAssertion = tsTypeAssertion;
exports.tSEnumDeclaration = exports.TSEnumDeclaration = exports.tsEnumDeclaration = tsEnumDeclaration;
exports.tSEnumMember = exports.TSEnumMember = exports.tsEnumMember = tsEnumMember;
exports.tSModuleDeclaration = exports.TSModuleDeclaration = exports.tsModuleDeclaration = tsModuleDeclaration;
exports.tSModuleBlock = exports.TSModuleBlock = exports.tsModuleBlock = tsModuleBlock;
exports.tSImportType = exports.TSImportType = exports.tsImportType = tsImportType;
exports.tSImportEqualsDeclaration = exports.TSImportEqualsDeclaration = exports.tsImportEqualsDeclaration = tsImportEqualsDeclaration;
exports.tSExternalModuleReference = exports.TSExternalModuleReference = exports.tsExternalModuleReference = tsExternalModuleReference;
exports.tSNonNullExpression = exports.TSNonNullExpression = exports.tsNonNullExpression = tsNonNullExpression;
exports.tSExportAssignment = exports.TSExportAssignment = exports.tsExportAssignment = tsExportAssignment;
exports.tSNamespaceExportDeclaration = exports.TSNamespaceExportDeclaration = exports.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;
exports.tSTypeAnnotation = exports.TSTypeAnnotation = exports.tsTypeAnnotation = tsTypeAnnotation;
exports.tSTypeParameterInstantiation = exports.TSTypeParameterInstantiation = exports.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
exports.tSTypeParameterDeclaration = exports.TSTypeParameterDeclaration = exports.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
exports.tSTypeParameter = exports.TSTypeParameter = exports.tsTypeParameter = tsTypeParameter;
exports.numberLiteral = exports.NumberLiteral = NumberLiteral;
exports.regexLiteral = exports.RegexLiteral = RegexLiteral;
exports.restProperty = exports.RestProperty = RestProperty;
exports.spreadProperty = exports.SpreadProperty = SpreadProperty;

var _builder = _interopRequireDefault(require("../builder"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function arrayExpression(...args) {
  return (0, _builder.default)("ArrayExpression", ...args);
}

function assignmentExpression(...args) {
  return (0, _builder.default)("AssignmentExpression", ...args);
}

function binaryExpression(...args) {
  return (0, _builder.default)("BinaryExpression", ...args);
}

function interpreterDirective(...args) {
  return (0, _builder.default)("InterpreterDirective", ...args);
}

function directive(...args) {
  return (0, _builder.default)("Directive", ...args);
}

function directiveLiteral(...args) {
  return (0, _builder.default)("DirectiveLiteral", ...args);
}

function blockStatement(...args) {
  return (0, _builder.default)("BlockStatement", ...args);
}

function breakStatement(...args) {
  return (0, _builder.default)("BreakStatement", ...args);
}

function callExpression(...args) {
  return (0, _builder.default)("CallExpression", ...args);
}

function catchClause(...args) {
  return (0, _builder.default)("CatchClause", ...args);
}

function conditionalExpression(...args) {
  return (0, _builder.default)("ConditionalExpression", ...args);
}

function continueStatement(...args) {
  return (0, _builder.default)("ContinueStatement", ...args);
}

function debuggerStatement(...args) {
  return (0, _builder.default)("DebuggerStatement", ...args);
}

function doWhileStatement(...args) {
  return (0, _builder.default)("DoWhileStatement", ...args);
}

function emptyStatement(...args) {
  return (0, _builder.default)("EmptyStatement", ...args);
}

function expressionStatement(...args) {
  return (0, _builder.default)("ExpressionStatement", ...args);
}

function file(...args) {
  return (0, _builder.default)("File", ...args);
}

function forInStatement(...args) {
  return (0, _builder.default)("ForInStatement", ...args);
}

function forStatement(...args) {
  return (0, _builder.default)("ForStatement", ...args);
}

function functionDeclaration(...args) {
  return (0, _builder.default)("FunctionDeclaration", ...args);
}

function functionExpression(...args) {
  return (0, _builder.default)("FunctionExpression", ...args);
}

function identifier(...args) {
  return (0, _builder.default)("Identifier", ...args);
}

function ifStatement(...args) {
  return (0, _builder.default)("IfStatement", ...args);
}

function labeledStatement(...args) {
  return (0, _builder.default)("LabeledStatement", ...args);
}

function stringLiteral(...args) {
  return (0, _builder.default)("StringLiteral", ...args);
}

function numericLiteral(...args) {
  return (0, _builder.default)("NumericLiteral", ...args);
}

function nullLiteral(...args) {
  return (0, _builder.default)("NullLiteral", ...args);
}

function booleanLiteral(...args) {
  return (0, _builder.default)("BooleanLiteral", ...args);
}

function regExpLiteral(...args) {
  return (0, _builder.default)("RegExpLiteral", ...args);
}

function logicalExpression(...args) {
  return (0, _builder.default)("LogicalExpression", ...args);
}

function memberExpression(...args) {
  return (0, _builder.default)("MemberExpression", ...args);
}

function newExpression(...args) {
  return (0, _builder.default)("NewExpression", ...args);
}

function program(...args) {
  return (0, _builder.default)("Program", ...args);
}

function objectExpression(...args) {
  return (0, _builder.default)("ObjectExpression", ...args);
}

function objectMethod(...args) {
  return (0, _builder.default)("ObjectMethod", ...args);
}

function objectProperty(...args) {
  return (0, _builder.default)("ObjectProperty", ...args);
}

function restElement(...args) {
  return (0, _builder.default)("RestElement", ...args);
}

function returnStatement(...args) {
  return (0, _builder.default)("ReturnStatement", ...args);
}

function sequenceExpression(...args) {
  return (0, _builder.default)("SequenceExpression", ...args);
}

function parenthesizedExpression(...args) {
  return (0, _builder.default)("ParenthesizedExpression", ...args);
}

function switchCase(...args) {
  return (0, _builder.default)("SwitchCase", ...args);
}

function switchStatement(...args) {
  return (0, _builder.default)("SwitchStatement", ...args);
}

function thisExpression(...args) {
  return (0, _builder.default)("ThisExpression", ...args);
}

function throwStatement(...args) {
  return (0, _builder.default)("ThrowStatement", ...args);
}

function tryStatement(...args) {
  return (0, _builder.default)("TryStatement", ...args);
}

function unaryExpression(...args) {
  return (0, _builder.default)("UnaryExpression", ...args);
}

function updateExpression(...args) {
  return (0, _builder.default)("UpdateExpression", ...args);
}

function variableDeclaration(...args) {
  return (0, _builder.default)("VariableDeclaration", ...args);
}

function variableDeclarator(...args) {
  return (0, _builder.default)("VariableDeclarator", ...args);
}

function whileStatement(...args) {
  return (0, _builder.default)("WhileStatement", ...args);
}

function withStatement(...args) {
  return (0, _builder.default)("WithStatement", ...args);
}

function assignmentPattern(...args) {
  return (0, _builder.default)("AssignmentPattern", ...args);
}

function arrayPattern(...args) {
  return (0, _builder.default)("ArrayPattern", ...args);
}

function arrowFunctionExpression(...args) {
  return (0, _builder.default)("ArrowFunctionExpression", ...args);
}

function classBody(...args) {
  return (0, _builder.default)("ClassBody", ...args);
}

function classExpression(...args) {
  return (0, _builder.default)("ClassExpression", ...args);
}

function classDeclaration(...args) {
  return (0, _builder.default)("ClassDeclaration", ...args);
}

function exportAllDeclaration(...args) {
  return (0, _builder.default)("ExportAllDeclaration", ...args);
}

function exportDefaultDeclaration(...args) {
  return (0, _builder.default)("ExportDefaultDeclaration", ...args);
}

function exportNamedDeclaration(...args) {
  return (0, _builder.default)("ExportNamedDeclaration", ...args);
}

function exportSpecifier(...args) {
  return (0, _builder.default)("ExportSpecifier", ...args);
}

function forOfStatement(...args) {
  return (0, _builder.default)("ForOfStatement", ...args);
}

function importDeclaration(...args) {
  return (0, _builder.default)("ImportDeclaration", ...args);
}

function importDefaultSpecifier(...args) {
  return (0, _builder.default)("ImportDefaultSpecifier", ...args);
}

function importNamespaceSpecifier(...args) {
  return (0, _builder.default)("ImportNamespaceSpecifier", ...args);
}

function importSpecifier(...args) {
  return (0, _builder.default)("ImportSpecifier", ...args);
}

function metaProperty(...args) {
  return (0, _builder.default)("MetaProperty", ...args);
}

function classMethod(...args) {
  return (0, _builder.default)("ClassMethod", ...args);
}

function objectPattern(...args) {
  return (0, _builder.default)("ObjectPattern", ...args);
}

function spreadElement(...args) {
  return (0, _builder.default)("SpreadElement", ...args);
}

function _super(...args) {
  return (0, _builder.default)("Super", ...args);
}

function taggedTemplateExpression(...args) {
  return (0, _builder.default)("TaggedTemplateExpression", ...args);
}

function templateElement(...args) {
  return (0, _builder.default)("TemplateElement", ...args);
}

function templateLiteral(...args) {
  return (0, _builder.default)("TemplateLiteral", ...args);
}

function yieldExpression(...args) {
  return (0, _builder.default)("YieldExpression", ...args);
}

function awaitExpression(...args) {
  return (0, _builder.default)("AwaitExpression", ...args);
}

function _import(...args) {
  return (0, _builder.default)("Import", ...args);
}

function bigIntLiteral(...args) {
  return (0, _builder.default)("BigIntLiteral", ...args);
}

function exportNamespaceSpecifier(...args) {
  return (0, _builder.default)("ExportNamespaceSpecifier", ...args);
}

function optionalMemberExpression(...args) {
  return (0, _builder.default)("OptionalMemberExpression", ...args);
}

function optionalCallExpression(...args) {
  return (0, _builder.default)("OptionalCallExpression", ...args);
}

function anyTypeAnnotation(...args) {
  return (0, _builder.default)("AnyTypeAnnotation", ...args);
}

function arrayTypeAnnotation(...args) {
  return (0, _builder.default)("ArrayTypeAnnotation", ...args);
}

function booleanTypeAnnotation(...args) {
  return (0, _builder.default)("BooleanTypeAnnotation", ...args);
}

function booleanLiteralTypeAnnotation(...args) {
  return (0, _builder.default)("BooleanLiteralTypeAnnotation", ...args);
}

function nullLiteralTypeAnnotation(...args) {
  return (0, _builder.default)("NullLiteralTypeAnnotation", ...args);
}

function classImplements(...args) {
  return (0, _builder.default)("ClassImplements", ...args);
}

function declareClass(...args) {
  return (0, _builder.default)("DeclareClass", ...args);
}

function declareFunction(...args) {
  return (0, _builder.default)("DeclareFunction", ...args);
}

function declareInterface(...args) {
  return (0, _builder.default)("DeclareInterface", ...args);
}

function declareModule(...args) {
  return (0, _builder.default)("DeclareModule", ...args);
}

function declareModuleExports(...args) {
  return (0, _builder.default)("DeclareModuleExports", ...args);
}

function declareTypeAlias(...args) {
  return (0, _builder.default)("DeclareTypeAlias", ...args);
}

function declareOpaqueType(...args) {
  return (0, _builder.default)("DeclareOpaqueType", ...args);
}

function declareVariable(...args) {
  return (0, _builder.default)("DeclareVariable", ...args);
}

function declareExportDeclaration(...args) {
  return (0, _builder.default)("DeclareExportDeclaration", ...args);
}

function declareExportAllDeclaration(...args) {
  return (0, _builder.default)("DeclareExportAllDeclaration", ...args);
}

function declaredPredicate(...args) {
  return (0, _builder.default)("DeclaredPredicate", ...args);
}

function existsTypeAnnotation(...args) {
  return (0, _builder.default)("ExistsTypeAnnotation", ...args);
}

function functionTypeAnnotation(...args) {
  return (0, _builder.default)("FunctionTypeAnnotation", ...args);
}

function functionTypeParam(...args) {
  return (0, _builder.default)("FunctionTypeParam", ...args);
}

function genericTypeAnnotation(...args) {
  return (0, _builder.default)("GenericTypeAnnotation", ...args);
}

function inferredPredicate(...args) {
  return (0, _builder.default)("InferredPredicate", ...args);
}

function interfaceExtends(...args) {
  return (0, _builder.default)("InterfaceExtends", ...args);
}

function interfaceDeclaration(...args) {
  return (0, _builder.default)("InterfaceDeclaration", ...args);
}

function interfaceTypeAnnotation(...args) {
  return (0, _builder.default)("InterfaceTypeAnnotation", ...args);
}

function intersectionTypeAnnotation(...args) {
  return (0, _builder.default)("IntersectionTypeAnnotation", ...args);
}

function mixedTypeAnnotation(...args) {
  return (0, _builder.default)("MixedTypeAnnotation", ...args);
}

function emptyTypeAnnotation(...args) {
  return (0, _builder.default)("EmptyTypeAnnotation", ...args);
}

function nullableTypeAnnotation(...args) {
  return (0, _builder.default)("NullableTypeAnnotation", ...args);
}

function numberLiteralTypeAnnotation(...args) {
  return (0, _builder.default)("NumberLiteralTypeAnnotation", ...args);
}

function numberTypeAnnotation(...args) {
  return (0, _builder.default)("NumberTypeAnnotation", ...args);
}

function objectTypeAnnotation(...args) {
  return (0, _builder.default)("ObjectTypeAnnotation", ...args);
}

function objectTypeInternalSlot(...args) {
  return (0, _builder.default)("ObjectTypeInternalSlot", ...args);
}

function objectTypeCallProperty(...args) {
  return (0, _builder.default)("ObjectTypeCallProperty", ...args);
}

function objectTypeIndexer(...args) {
  return (0, _builder.default)("ObjectTypeIndexer", ...args);
}

function objectTypeProperty(...args) {
  return (0, _builder.default)("ObjectTypeProperty", ...args);
}

function objectTypeSpreadProperty(...args) {
  return (0, _builder.default)("ObjectTypeSpreadProperty", ...args);
}

function opaqueType(...args) {
  return (0, _builder.default)("OpaqueType", ...args);
}

function qualifiedTypeIdentifier(...args) {
  return (0, _builder.default)("QualifiedTypeIdentifier", ...args);
}

function stringLiteralTypeAnnotation(...args) {
  return (0, _builder.default)("StringLiteralTypeAnnotation", ...args);
}

function stringTypeAnnotation(...args) {
  return (0, _builder.default)("StringTypeAnnotation", ...args);
}

function symbolTypeAnnotation(...args) {
  return (0, _builder.default)("SymbolTypeAnnotation", ...args);
}

function thisTypeAnnotation(...args) {
  return (0, _builder.default)("ThisTypeAnnotation", ...args);
}

function tupleTypeAnnotation(...args) {
  return (0, _builder.default)("TupleTypeAnnotation", ...args);
}

function typeofTypeAnnotation(...args) {
  return (0, _builder.default)("TypeofTypeAnnotation", ...args);
}

function typeAlias(...args) {
  return (0, _builder.default)("TypeAlias", ...args);
}

function typeAnnotation(...args) {
  return (0, _builder.default)("TypeAnnotation", ...args);
}

function typeCastExpression(...args) {
  return (0, _builder.default)("TypeCastExpression", ...args);
}

function typeParameter(...args) {
  return (0, _builder.default)("TypeParameter", ...args);
}

function typeParameterDeclaration(...args) {
  return (0, _builder.default)("TypeParameterDeclaration", ...args);
}

function typeParameterInstantiation(...args) {
  return (0, _builder.default)("TypeParameterInstantiation", ...args);
}

function unionTypeAnnotation(...args) {
  return (0, _builder.default)("UnionTypeAnnotation", ...args);
}

function variance(...args) {
  return (0, _builder.default)("Variance", ...args);
}

function voidTypeAnnotation(...args) {
  return (0, _builder.default)("VoidTypeAnnotation", ...args);
}

function enumDeclaration(...args) {
  return (0, _builder.default)("EnumDeclaration", ...args);
}

function enumBooleanBody(...args) {
  return (0, _builder.default)("EnumBooleanBody", ...args);
}

function enumNumberBody(...args) {
  return (0, _builder.default)("EnumNumberBody", ...args);
}

function enumStringBody(...args) {
  return (0, _builder.default)("EnumStringBody", ...args);
}

function enumSymbolBody(...args) {
  return (0, _builder.default)("EnumSymbolBody", ...args);
}

function enumBooleanMember(...args) {
  return (0, _builder.default)("EnumBooleanMember", ...args);
}

function enumNumberMember(...args) {
  return (0, _builder.default)("EnumNumberMember", ...args);
}

function enumStringMember(...args) {
  return (0, _builder.default)("EnumStringMember", ...args);
}

function enumDefaultedMember(...args) {
  return (0, _builder.default)("EnumDefaultedMember", ...args);
}

function jsxAttribute(...args) {
  return (0, _builder.default)("JSXAttribute", ...args);
}

function jsxClosingElement(...args) {
  return (0, _builder.default)("JSXClosingElement", ...args);
}

function jsxElement(...args) {
  return (0, _builder.default)("JSXElement", ...args);
}

function jsxEmptyExpression(...args) {
  return (0, _builder.default)("JSXEmptyExpression", ...args);
}

function jsxExpressionContainer(...args) {
  return (0, _builder.default)("JSXExpressionContainer", ...args);
}

function jsxSpreadChild(...args) {
  return (0, _builder.default)("JSXSpreadChild", ...args);
}

function jsxIdentifier(...args) {
  return (0, _builder.default)("JSXIdentifier", ...args);
}

function jsxMemberExpression(...args) {
  return (0, _builder.default)("JSXMemberExpression", ...args);
}

function jsxNamespacedName(...args) {
  return (0, _builder.default)("JSXNamespacedName", ...args);
}

function jsxOpeningElement(...args) {
  return (0, _builder.default)("JSXOpeningElement", ...args);
}

function jsxSpreadAttribute(...args) {
  return (0, _builder.default)("JSXSpreadAttribute", ...args);
}

function jsxText(...args) {
  return (0, _builder.default)("JSXText", ...args);
}

function jsxFragment(...args) {
  return (0, _builder.default)("JSXFragment", ...args);
}

function jsxOpeningFragment(...args) {
  return (0, _builder.default)("JSXOpeningFragment", ...args);
}

function jsxClosingFragment(...args) {
  return (0, _builder.default)("JSXClosingFragment", ...args);
}

function noop(...args) {
  return (0, _builder.default)("Noop", ...args);
}

function placeholder(...args) {
  return (0, _builder.default)("Placeholder", ...args);
}

function v8IntrinsicIdentifier(...args) {
  return (0, _builder.default)("V8IntrinsicIdentifier", ...args);
}

function argumentPlaceholder(...args) {
  return (0, _builder.default)("ArgumentPlaceholder", ...args);
}

function bindExpression(...args) {
  return (0, _builder.default)("BindExpression", ...args);
}

function classProperty(...args) {
  return (0, _builder.default)("ClassProperty", ...args);
}

function pipelineTopicExpression(...args) {
  return (0, _builder.default)("PipelineTopicExpression", ...args);
}

function pipelineBareFunction(...args) {
  return (0, _builder.default)("PipelineBareFunction", ...args);
}

function pipelinePrimaryTopicReference(...args) {
  return (0, _builder.default)("PipelinePrimaryTopicReference", ...args);
}

function classPrivateProperty(...args) {
  return (0, _builder.default)("ClassPrivateProperty", ...args);
}

function classPrivateMethod(...args) {
  return (0, _builder.default)("ClassPrivateMethod", ...args);
}

function importAttribute(...args) {
  return (0, _builder.default)("ImportAttribute", ...args);
}

function decorator(...args) {
  return (0, _builder.default)("Decorator", ...args);
}

function doExpression(...args) {
  return (0, _builder.default)("DoExpression", ...args);
}

function exportDefaultSpecifier(...args) {
  return (0, _builder.default)("ExportDefaultSpecifier", ...args);
}

function privateName(...args) {
  return (0, _builder.default)("PrivateName", ...args);
}

function recordExpression(...args) {
  return (0, _builder.default)("RecordExpression", ...args);
}

function tupleExpression(...args) {
  return (0, _builder.default)("TupleExpression", ...args);
}

function decimalLiteral(...args) {
  return (0, _builder.default)("DecimalLiteral", ...args);
}

function tsParameterProperty(...args) {
  return (0, _builder.default)("TSParameterProperty", ...args);
}

function tsDeclareFunction(...args) {
  return (0, _builder.default)("TSDeclareFunction", ...args);
}

function tsDeclareMethod(...args) {
  return (0, _builder.default)("TSDeclareMethod", ...args);
}

function tsQualifiedName(...args) {
  return (0, _builder.default)("TSQualifiedName", ...args);
}

function tsCallSignatureDeclaration(...args) {
  return (0, _builder.default)("TSCallSignatureDeclaration", ...args);
}

function tsConstructSignatureDeclaration(...args) {
  return (0, _builder.default)("TSConstructSignatureDeclaration", ...args);
}

function tsPropertySignature(...args) {
  return (0, _builder.default)("TSPropertySignature", ...args);
}

function tsMethodSignature(...args) {
  return (0, _builder.default)("TSMethodSignature", ...args);
}

function tsIndexSignature(...args) {
  return (0, _builder.default)("TSIndexSignature", ...args);
}

function tsAnyKeyword(...args) {
  return (0, _builder.default)("TSAnyKeyword", ...args);
}

function tsBooleanKeyword(...args) {
  return (0, _builder.default)("TSBooleanKeyword", ...args);
}

function tsBigIntKeyword(...args) {
  return (0, _builder.default)("TSBigIntKeyword", ...args);
}

function tsNeverKeyword(...args) {
  return (0, _builder.default)("TSNeverKeyword", ...args);
}

function tsNullKeyword(...args) {
  return (0, _builder.default)("TSNullKeyword", ...args);
}

function tsNumberKeyword(...args) {
  return (0, _builder.default)("TSNumberKeyword", ...args);
}

function tsObjectKeyword(...args) {
  return (0, _builder.default)("TSObjectKeyword", ...args);
}

function tsStringKeyword(...args) {
  return (0, _builder.default)("TSStringKeyword", ...args);
}

function tsSymbolKeyword(...args) {
  return (0, _builder.default)("TSSymbolKeyword", ...args);
}

function tsUndefinedKeyword(...args) {
  return (0, _builder.default)("TSUndefinedKeyword", ...args);
}

function tsUnknownKeyword(...args) {
  return (0, _builder.default)("TSUnknownKeyword", ...args);
}

function tsVoidKeyword(...args) {
  return (0, _builder.default)("TSVoidKeyword", ...args);
}

function tsThisType(...args) {
  return (0, _builder.default)("TSThisType", ...args);
}

function tsFunctionType(...args) {
  return (0, _builder.default)("TSFunctionType", ...args);
}

function tsConstructorType(...args) {
  return (0, _builder.default)("TSConstructorType", ...args);
}

function tsTypeReference(...args) {
  return (0, _builder.default)("TSTypeReference", ...args);
}

function tsTypePredicate(...args) {
  return (0, _builder.default)("TSTypePredicate", ...args);
}

function tsTypeQuery(...args) {
  return (0, _builder.default)("TSTypeQuery", ...args);
}

function tsTypeLiteral(...args) {
  return (0, _builder.default)("TSTypeLiteral", ...args);
}

function tsArrayType(...args) {
  return (0, _builder.default)("TSArrayType", ...args);
}

function tsTupleType(...args) {
  return (0, _builder.default)("TSTupleType", ...args);
}

function tsOptionalType(...args) {
  return (0, _builder.default)("TSOptionalType", ...args);
}

function tsRestType(...args) {
  return (0, _builder.default)("TSRestType", ...args);
}

function tsNamedTupleMember(...args) {
  return (0, _builder.default)("TSNamedTupleMember", ...args);
}

function tsUnionType(...args) {
  return (0, _builder.default)("TSUnionType", ...args);
}

function tsIntersectionType(...args) {
  return (0, _builder.default)("TSIntersectionType", ...args);
}

function tsConditionalType(...args) {
  return (0, _builder.default)("TSConditionalType", ...args);
}

function tsInferType(...args) {
  return (0, _builder.default)("TSInferType", ...args);
}

function tsParenthesizedType(...args) {
  return (0, _builder.default)("TSParenthesizedType", ...args);
}

function tsTypeOperator(...args) {
  return (0, _builder.default)("TSTypeOperator", ...args);
}

function tsIndexedAccessType(...args) {
  return (0, _builder.default)("TSIndexedAccessType", ...args);
}

function tsMappedType(...args) {
  return (0, _builder.default)("TSMappedType", ...args);
}

function tsLiteralType(...args) {
  return (0, _builder.default)("TSLiteralType", ...args);
}

function tsExpressionWithTypeArguments(...args) {
  return (0, _builder.default)("TSExpressionWithTypeArguments", ...args);
}

function tsInterfaceDeclaration(...args) {
  return (0, _builder.default)("TSInterfaceDeclaration", ...args);
}

function tsInterfaceBody(...args) {
  return (0, _builder.default)("TSInterfaceBody", ...args);
}

function tsTypeAliasDeclaration(...args) {
  return (0, _builder.default)("TSTypeAliasDeclaration", ...args);
}

function tsAsExpression(...args) {
  return (0, _builder.default)("TSAsExpression", ...args);
}

function tsTypeAssertion(...args) {
  return (0, _builder.default)("TSTypeAssertion", ...args);
}

function tsEnumDeclaration(...args) {
  return (0, _builder.default)("TSEnumDeclaration", ...args);
}

function tsEnumMember(...args) {
  return (0, _builder.default)("TSEnumMember", ...args);
}

function tsModuleDeclaration(...args) {
  return (0, _builder.default)("TSModuleDeclaration", ...args);
}

function tsModuleBlock(...args) {
  return (0, _builder.default)("TSModuleBlock", ...args);
}

function tsImportType(...args) {
  return (0, _builder.default)("TSImportType", ...args);
}

function tsImportEqualsDeclaration(...args) {
  return (0, _builder.default)("TSImportEqualsDeclaration", ...args);
}

function tsExternalModuleReference(...args) {
  return (0, _builder.default)("TSExternalModuleReference", ...args);
}

function tsNonNullExpression(...args) {
  return (0, _builder.default)("TSNonNullExpression", ...args);
}

function tsExportAssignment(...args) {
  return (0, _builder.default)("TSExportAssignment", ...args);
}

function tsNamespaceExportDeclaration(...args) {
  return (0, _builder.default)("TSNamespaceExportDeclaration", ...args);
}

function tsTypeAnnotation(...args) {
  return (0, _builder.default)("TSTypeAnnotation", ...args);
}

function tsTypeParameterInstantiation(...args) {
  return (0, _builder.default)("TSTypeParameterInstantiation", ...args);
}

function tsTypeParameterDeclaration(...args) {
  return (0, _builder.default)("TSTypeParameterDeclaration", ...args);
}

function tsTypeParameter(...args) {
  return (0, _builder.default)("TSTypeParameter", ...args);
}

function NumberLiteral(...args) {
  console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
  return (0, _builder.default)("NumberLiteral", ...args);
}

function RegexLiteral(...args) {
  console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
  return (0, _builder.default)("RegexLiteral", ...args);
}

function RestProperty(...args) {
  console.trace("The node type RestProperty has been renamed to RestElement");
  return (0, _builder.default)("RestProperty", ...args);
}

function SpreadProperty(...args) {
  console.trace("The node type SpreadProperty has been renamed to SpreadElement");
  return (0, _builder.default)("SpreadProperty", ...args);
}
},{"../builder":32}],36:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = buildChildren;

var _generated = require("../../validators/generated");

var _cleanJSXElementLiteralChild = _interopRequireDefault(require("../../utils/react/cleanJSXElementLiteralChild"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function buildChildren(node) {
  const elements = [];

  for (let i = 0; i < node.children.length; i++) {
    let child = node.children[i];

    if ((0, _generated.isJSXText)(child)) {
      (0, _cleanJSXElementLiteralChild.default)(child, elements);
      continue;
    }

    if ((0, _generated.isJSXExpressionContainer)(child)) child = child.expression;
    if ((0, _generated.isJSXEmptyExpression)(child)) continue;
    elements.push(child);
  }

  return elements;
}
},{"../../utils/react/cleanJSXElementLiteralChild":85,"../../validators/generated":88}],37:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createTSUnionType;

var _generated = require("../generated");

var _removeTypeDuplicates = _interopRequireDefault(require("../../modifications/typescript/removeTypeDuplicates"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createTSUnionType(typeAnnotations) {
  const types = typeAnnotations.map(type => type.typeAnnotations);
  const flattened = (0, _removeTypeDuplicates.default)(types);

  if (flattened.length === 1) {
    return flattened[0];
  } else {
    return (0, _generated.tsUnionType)(flattened);
  }
}
},{"../../modifications/typescript/removeTypeDuplicates":79,"../generated":35}],38:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = clone;

var _cloneNode = _interopRequireDefault(require("./cloneNode"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function clone(node) {
  return (0, _cloneNode.default)(node, false);
}
},{"./cloneNode":41}],39:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cloneDeep;

var _cloneNode = _interopRequireDefault(require("./cloneNode"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function cloneDeep(node) {
  return (0, _cloneNode.default)(node);
}
},{"./cloneNode":41}],40:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cloneDeepWithoutLoc;

var _cloneNode = _interopRequireDefault(require("./cloneNode"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function cloneDeepWithoutLoc(node) {
  return (0, _cloneNode.default)(node, true, true);
}
},{"./cloneNode":41}],41:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cloneNode;

var _definitions = require("../definitions");

const has = Function.call.bind(Object.prototype.hasOwnProperty);

function cloneIfNode(obj, deep, withoutLoc) {
  if (obj && typeof obj.type === "string") {
    return cloneNode(obj, deep, withoutLoc);
  }

  return obj;
}

function cloneIfNodeOrArray(obj, deep, withoutLoc) {
  if (Array.isArray(obj)) {
    return obj.map(node => cloneIfNode(node, deep, withoutLoc));
  }

  return cloneIfNode(obj, deep, withoutLoc);
}

function cloneNode(node, deep = true, withoutLoc = false) {
  if (!node) return node;
  const {
    type
  } = node;
  const newNode = {
    type
  };

  if (type === "Identifier") {
    newNode.name = node.name;

    if (has(node, "optional") && typeof node.optional === "boolean") {
      newNode.optional = node.optional;
    }

    if (has(node, "typeAnnotation")) {
      newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc) : node.typeAnnotation;
    }
  } else if (!has(_definitions.NODE_FIELDS, type)) {
    throw new Error(`Unknown node type: "${type}"`);
  } else {
    for (const field of Object.keys(_definitions.NODE_FIELDS[type])) {
      if (has(node, field)) {
        if (deep) {
          newNode[field] = type === "File" && field === "comments" ? maybeCloneComments(node.comments, deep, withoutLoc) : cloneIfNodeOrArray(node[field], true, withoutLoc);
        } else {
          newNode[field] = node[field];
        }
      }
    }
  }

  if (has(node, "loc")) {
    if (withoutLoc) {
      newNode.loc = null;
    } else {
      newNode.loc = node.loc;
    }
  }

  if (has(node, "leadingComments")) {
    newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc);
  }

  if (has(node, "innerComments")) {
    newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc);
  }

  if (has(node, "trailingComments")) {
    newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc);
  }

  if (has(node, "extra")) {
    newNode.extra = Object.assign({}, node.extra);
  }

  return newNode;
}

function cloneCommentsWithoutLoc(comments) {
  return comments.map(({
    type,
    value
  }) => ({
    type,
    value,
    loc: null
  }));
}

function maybeCloneComments(comments, deep, withoutLoc) {
  return deep && withoutLoc ? cloneCommentsWithoutLoc(comments) : comments;
}
},{"../definitions":66}],42:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cloneWithoutLoc;

var _cloneNode = _interopRequireDefault(require("./cloneNode"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function cloneWithoutLoc(node) {
  return (0, _cloneNode.default)(node, false, true);
}
},{"./cloneNode":41}],43:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = addComment;

var _addComments = _interopRequireDefault(require("./addComments"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function addComment(node, type, content, line) {
  return (0, _addComments.default)(node, type, [{
    type: line ? "CommentLine" : "CommentBlock",
    value: content
  }]);
}
},{"./addComments":44}],44:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = addComments;

function addComments(node, type, comments) {
  if (!comments || !node) return node;
  const key = `${type}Comments`;

  if (node[key]) {
    if (type === "leading") {
      node[key] = comments.concat(node[key]);
    } else {
      node[key] = node[key].concat(comments);
    }
  } else {
    node[key] = comments;
  }

  return node;
}
},{}],45:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = inheritInnerComments;

var _inherit = _interopRequireDefault(require("../utils/inherit"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function inheritInnerComments(child, parent) {
  (0, _inherit.default)("innerComments", child, parent);
}
},{"../utils/inherit":84}],46:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = inheritLeadingComments;

var _inherit = _interopRequireDefault(require("../utils/inherit"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function inheritLeadingComments(child, parent) {
  (0, _inherit.default)("leadingComments", child, parent);
}
},{"../utils/inherit":84}],47:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = inheritTrailingComments;

var _inherit = _interopRequireDefault(require("../utils/inherit"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function inheritTrailingComments(child, parent) {
  (0, _inherit.default)("trailingComments", child, parent);
}
},{"../utils/inherit":84}],48:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = inheritsComments;

var _inheritTrailingComments = _interopRequireDefault(require("./inheritTrailingComments"));

var _inheritLeadingComments = _interopRequireDefault(require("./inheritLeadingComments"));

var _inheritInnerComments = _interopRequireDefault(require("./inheritInnerComments"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function inheritsComments(child, parent) {
  (0, _inheritTrailingComments.default)(child, parent);
  (0, _inheritLeadingComments.default)(child, parent);
  (0, _inheritInnerComments.default)(child, parent);
  return child;
}
},{"./inheritInnerComments":45,"./inheritLeadingComments":46,"./inheritTrailingComments":47}],49:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = removeComments;

var _constants = require("../constants");

function removeComments(node) {
  _constants.COMMENT_KEYS.forEach(key => {
    node[key] = null;
  });

  return node;
}
},{"../constants":51}],50:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TSBASETYPE_TYPES = exports.TSTYPE_TYPES = exports.TSTYPEELEMENT_TYPES = exports.PRIVATE_TYPES = exports.JSX_TYPES = exports.ENUMMEMBER_TYPES = exports.ENUMBODY_TYPES = exports.FLOWPREDICATE_TYPES = exports.FLOWDECLARATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = exports.FLOWTYPE_TYPES = exports.FLOW_TYPES = exports.MODULESPECIFIER_TYPES = exports.EXPORTDECLARATION_TYPES = exports.MODULEDECLARATION_TYPES = exports.CLASS_TYPES = exports.PATTERN_TYPES = exports.UNARYLIKE_TYPES = exports.PROPERTY_TYPES = exports.OBJECTMEMBER_TYPES = exports.METHOD_TYPES = exports.USERWHITESPACABLE_TYPES = exports.IMMUTABLE_TYPES = exports.LITERAL_TYPES = exports.TSENTITYNAME_TYPES = exports.LVAL_TYPES = exports.PATTERNLIKE_TYPES = exports.DECLARATION_TYPES = exports.PUREISH_TYPES = exports.FUNCTIONPARENT_TYPES = exports.FUNCTION_TYPES = exports.FORXSTATEMENT_TYPES = exports.FOR_TYPES = exports.EXPRESSIONWRAPPER_TYPES = exports.WHILE_TYPES = exports.LOOP_TYPES = exports.CONDITIONAL_TYPES = exports.COMPLETIONSTATEMENT_TYPES = exports.TERMINATORLESS_TYPES = exports.STATEMENT_TYPES = exports.BLOCK_TYPES = exports.BLOCKPARENT_TYPES = exports.SCOPABLE_TYPES = exports.BINARY_TYPES = exports.EXPRESSION_TYPES = void 0;

var _definitions = require("../../definitions");

const EXPRESSION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Expression"];
exports.EXPRESSION_TYPES = EXPRESSION_TYPES;
const BINARY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Binary"];
exports.BINARY_TYPES = BINARY_TYPES;
const SCOPABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Scopable"];
exports.SCOPABLE_TYPES = SCOPABLE_TYPES;
const BLOCKPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["BlockParent"];
exports.BLOCKPARENT_TYPES = BLOCKPARENT_TYPES;
const BLOCK_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Block"];
exports.BLOCK_TYPES = BLOCK_TYPES;
const STATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Statement"];
exports.STATEMENT_TYPES = STATEMENT_TYPES;
const TERMINATORLESS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Terminatorless"];
exports.TERMINATORLESS_TYPES = TERMINATORLESS_TYPES;
const COMPLETIONSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["CompletionStatement"];
exports.COMPLETIONSTATEMENT_TYPES = COMPLETIONSTATEMENT_TYPES;
const CONDITIONAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Conditional"];
exports.CONDITIONAL_TYPES = CONDITIONAL_TYPES;
const LOOP_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Loop"];
exports.LOOP_TYPES = LOOP_TYPES;
const WHILE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["While"];
exports.WHILE_TYPES = WHILE_TYPES;
const EXPRESSIONWRAPPER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
exports.EXPRESSIONWRAPPER_TYPES = EXPRESSIONWRAPPER_TYPES;
const FOR_TYPES = _definitions.FLIPPED_ALIAS_KEYS["For"];
exports.FOR_TYPES = FOR_TYPES;
const FORXSTATEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ForXStatement"];
exports.FORXSTATEMENT_TYPES = FORXSTATEMENT_TYPES;
const FUNCTION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Function"];
exports.FUNCTION_TYPES = FUNCTION_TYPES;
const FUNCTIONPARENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FunctionParent"];
exports.FUNCTIONPARENT_TYPES = FUNCTIONPARENT_TYPES;
const PUREISH_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Pureish"];
exports.PUREISH_TYPES = PUREISH_TYPES;
const DECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Declaration"];
exports.DECLARATION_TYPES = DECLARATION_TYPES;
const PATTERNLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["PatternLike"];
exports.PATTERNLIKE_TYPES = PATTERNLIKE_TYPES;
const LVAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["LVal"];
exports.LVAL_TYPES = LVAL_TYPES;
const TSENTITYNAME_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSEntityName"];
exports.TSENTITYNAME_TYPES = TSENTITYNAME_TYPES;
const LITERAL_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Literal"];
exports.LITERAL_TYPES = LITERAL_TYPES;
const IMMUTABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Immutable"];
exports.IMMUTABLE_TYPES = IMMUTABLE_TYPES;
const USERWHITESPACABLE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["UserWhitespacable"];
exports.USERWHITESPACABLE_TYPES = USERWHITESPACABLE_TYPES;
const METHOD_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Method"];
exports.METHOD_TYPES = METHOD_TYPES;
const OBJECTMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ObjectMember"];
exports.OBJECTMEMBER_TYPES = OBJECTMEMBER_TYPES;
const PROPERTY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Property"];
exports.PROPERTY_TYPES = PROPERTY_TYPES;
const UNARYLIKE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["UnaryLike"];
exports.UNARYLIKE_TYPES = UNARYLIKE_TYPES;
const PATTERN_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Pattern"];
exports.PATTERN_TYPES = PATTERN_TYPES;
const CLASS_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Class"];
exports.CLASS_TYPES = CLASS_TYPES;
const MODULEDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ModuleDeclaration"];
exports.MODULEDECLARATION_TYPES = MODULEDECLARATION_TYPES;
const EXPORTDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ExportDeclaration"];
exports.EXPORTDECLARATION_TYPES = EXPORTDECLARATION_TYPES;
const MODULESPECIFIER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
exports.MODULESPECIFIER_TYPES = MODULESPECIFIER_TYPES;
const FLOW_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Flow"];
exports.FLOW_TYPES = FLOW_TYPES;
const FLOWTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowType"];
exports.FLOWTYPE_TYPES = FLOWTYPE_TYPES;
const FLOWBASEANNOTATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
exports.FLOWBASEANNOTATION_TYPES = FLOWBASEANNOTATION_TYPES;
const FLOWDECLARATION_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowDeclaration"];
exports.FLOWDECLARATION_TYPES = FLOWDECLARATION_TYPES;
const FLOWPREDICATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["FlowPredicate"];
exports.FLOWPREDICATE_TYPES = FLOWPREDICATE_TYPES;
const ENUMBODY_TYPES = _definitions.FLIPPED_ALIAS_KEYS["EnumBody"];
exports.ENUMBODY_TYPES = ENUMBODY_TYPES;
const ENUMMEMBER_TYPES = _definitions.FLIPPED_ALIAS_KEYS["EnumMember"];
exports.ENUMMEMBER_TYPES = ENUMMEMBER_TYPES;
const JSX_TYPES = _definitions.FLIPPED_ALIAS_KEYS["JSX"];
exports.JSX_TYPES = JSX_TYPES;
const PRIVATE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["Private"];
exports.PRIVATE_TYPES = PRIVATE_TYPES;
const TSTYPEELEMENT_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSTypeElement"];
exports.TSTYPEELEMENT_TYPES = TSTYPEELEMENT_TYPES;
const TSTYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSType"];
exports.TSTYPE_TYPES = TSTYPE_TYPES;
const TSBASETYPE_TYPES = _definitions.FLIPPED_ALIAS_KEYS["TSBaseType"];
exports.TSBASETYPE_TYPES = TSBASETYPE_TYPES;
},{"../../definitions":66}],51:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NOT_LOCAL_BINDING = exports.BLOCK_SCOPED_SYMBOL = exports.INHERIT_KEYS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.NUMBER_UNARY_OPERATORS = exports.BOOLEAN_UNARY_OPERATORS = exports.ASSIGNMENT_OPERATORS = exports.BINARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.EQUALITY_BINARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.UPDATE_OPERATORS = exports.LOGICAL_OPERATORS = exports.COMMENT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.STATEMENT_OR_BLOCK_KEYS = void 0;
const STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
exports.STATEMENT_OR_BLOCK_KEYS = STATEMENT_OR_BLOCK_KEYS;
const FLATTENABLE_KEYS = ["body", "expressions"];
exports.FLATTENABLE_KEYS = FLATTENABLE_KEYS;
const FOR_INIT_KEYS = ["left", "init"];
exports.FOR_INIT_KEYS = FOR_INIT_KEYS;
const COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
exports.COMMENT_KEYS = COMMENT_KEYS;
const LOGICAL_OPERATORS = ["||", "&&", "??"];
exports.LOGICAL_OPERATORS = LOGICAL_OPERATORS;
const UPDATE_OPERATORS = ["++", "--"];
exports.UPDATE_OPERATORS = UPDATE_OPERATORS;
const BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];
exports.BOOLEAN_NUMBER_BINARY_OPERATORS = BOOLEAN_NUMBER_BINARY_OPERATORS;
const EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
exports.EQUALITY_BINARY_OPERATORS = EQUALITY_BINARY_OPERATORS;
const COMPARISON_BINARY_OPERATORS = [...EQUALITY_BINARY_OPERATORS, "in", "instanceof"];
exports.COMPARISON_BINARY_OPERATORS = COMPARISON_BINARY_OPERATORS;
const BOOLEAN_BINARY_OPERATORS = [...COMPARISON_BINARY_OPERATORS, ...BOOLEAN_NUMBER_BINARY_OPERATORS];
exports.BOOLEAN_BINARY_OPERATORS = BOOLEAN_BINARY_OPERATORS;
const NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
exports.NUMBER_BINARY_OPERATORS = NUMBER_BINARY_OPERATORS;
const BINARY_OPERATORS = ["+", ...NUMBER_BINARY_OPERATORS, ...BOOLEAN_BINARY_OPERATORS];
exports.BINARY_OPERATORS = BINARY_OPERATORS;
const ASSIGNMENT_OPERATORS = ["=", "+=", ...NUMBER_BINARY_OPERATORS.map(op => op + "="), ...LOGICAL_OPERATORS.map(op => op + "=")];
exports.ASSIGNMENT_OPERATORS = ASSIGNMENT_OPERATORS;
const BOOLEAN_UNARY_OPERATORS = ["delete", "!"];
exports.BOOLEAN_UNARY_OPERATORS = BOOLEAN_UNARY_OPERATORS;
const NUMBER_UNARY_OPERATORS = ["+", "-", "~"];
exports.NUMBER_UNARY_OPERATORS = NUMBER_UNARY_OPERATORS;
const STRING_UNARY_OPERATORS = ["typeof"];
exports.STRING_UNARY_OPERATORS = STRING_UNARY_OPERATORS;
const UNARY_OPERATORS = ["void", "throw", ...BOOLEAN_UNARY_OPERATORS, ...NUMBER_UNARY_OPERATORS, ...STRING_UNARY_OPERATORS];
exports.UNARY_OPERATORS = UNARY_OPERATORS;
const INHERIT_KEYS = {
  optional: ["typeAnnotation", "typeParameters", "returnType"],
  force: ["start", "loc", "end"]
};
exports.INHERIT_KEYS = INHERIT_KEYS;
const BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
exports.BLOCK_SCOPED_SYMBOL = BLOCK_SCOPED_SYMBOL;
const NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
exports.NOT_LOCAL_BINDING = NOT_LOCAL_BINDING;
},{}],52:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ensureBlock;

var _toBlock = _interopRequireDefault(require("./toBlock"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ensureBlock(node, key = "body") {
  return node[key] = (0, _toBlock.default)(node[key], node);
}
},{"./toBlock":55}],53:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = gatherSequenceExpressions;

var _getBindingIdentifiers = _interopRequireDefault(require("../retrievers/getBindingIdentifiers"));

var _generated = require("../validators/generated");

var _generated2 = require("../builders/generated");

var _cloneNode = _interopRequireDefault(require("../clone/cloneNode"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function gatherSequenceExpressions(nodes, scope, declars) {
  const exprs = [];
  let ensureLastUndefined = true;

  for (const node of nodes) {
    if (!(0, _generated.isEmptyStatement)(node)) {
      ensureLastUndefined = false;
    }

    if ((0, _generated.isExpression)(node)) {
      exprs.push(node);
    } else if ((0, _generated.isExpressionStatement)(node)) {
      exprs.push(node.expression);
    } else if ((0, _generated.isVariableDeclaration)(node)) {
      if (node.kind !== "var") return;

      for (const declar of node.declarations) {
        const bindings = (0, _getBindingIdentifiers.default)(declar);

        for (const key of Object.keys(bindings)) {
          declars.push({
            kind: node.kind,
            id: (0, _cloneNode.default)(bindings[key])
          });
        }

        if (declar.init) {
          exprs.push((0, _generated2.assignmentExpression)("=", declar.id, declar.init));
        }
      }

      ensureLastUndefined = true;
    } else if ((0, _generated.isIfStatement)(node)) {
      const consequent = node.consequent ? gatherSequenceExpressions([node.consequent], scope, declars) : scope.buildUndefinedNode();
      const alternate = node.alternate ? gatherSequenceExpressions([node.alternate], scope, declars) : scope.buildUndefinedNode();
      if (!consequent || !alternate) return;
      exprs.push((0, _generated2.conditionalExpression)(node.test, consequent, alternate));
    } else if ((0, _generated.isBlockStatement)(node)) {
      const body = gatherSequenceExpressions(node.body, scope, declars);
      if (!body) return;
      exprs.push(body);
    } else if ((0, _generated.isEmptyStatement)(node)) {
      if (nodes.indexOf(node) === 0) {
        ensureLastUndefined = true;
      }
    } else {
      return;
    }
  }

  if (ensureLastUndefined) {
    exprs.push(scope.buildUndefinedNode());
  }

  if (exprs.length === 1) {
    return exprs[0];
  } else {
    return (0, _generated2.sequenceExpression)(exprs);
  }
}
},{"../builders/generated":35,"../clone/cloneNode":41,"../retrievers/getBindingIdentifiers":80,"../validators/generated":88}],54:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toBindingIdentifierName;

var _toIdentifier = _interopRequireDefault(require("./toIdentifier"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function toBindingIdentifierName(name) {
  name = (0, _toIdentifier.default)(name);
  if (name === "eval" || name === "arguments") name = "_" + name;
  return name;
}
},{"./toIdentifier":58}],55:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toBlock;

var _generated = require("../validators/generated");

var _generated2 = require("../builders/generated");

function toBlock(node, parent) {
  if ((0, _generated.isBlockStatement)(node)) {
    return node;
  }

  let blockNodes = [];

  if ((0, _generated.isEmptyStatement)(node)) {
    blockNodes = [];
  } else {
    if (!(0, _generated.isStatement)(node)) {
      if ((0, _generated.isFunction)(parent)) {
        node = (0, _generated2.returnStatement)(node);
      } else {
        node = (0, _generated2.expressionStatement)(node);
      }
    }

    blockNodes = [node];
  }

  return (0, _generated2.blockStatement)(blockNodes);
}
},{"../builders/generated":35,"../validators/generated":88}],56:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toComputedKey;

var _generated = require("../validators/generated");

var _generated2 = require("../builders/generated");

function toComputedKey(node, key = node.key || node.property) {
  if (!node.computed && (0, _generated.isIdentifier)(key)) key = (0, _generated2.stringLiteral)(key.name);
  return key;
}
},{"../builders/generated":35,"../validators/generated":88}],57:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toExpression;

var _generated = require("../validators/generated");

function toExpression(node) {
  if ((0, _generated.isExpressionStatement)(node)) {
    node = node.expression;
  }

  if ((0, _generated.isExpression)(node)) {
    return node;
  }

  if ((0, _generated.isClass)(node)) {
    node.type = "ClassExpression";
  } else if ((0, _generated.isFunction)(node)) {
    node.type = "FunctionExpression";
  }

  if (!(0, _generated.isExpression)(node)) {
    throw new Error(`cannot turn ${node.type} to an expression`);
  }

  return node;
}
},{"../validators/generated":88}],58:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toIdentifier;

var _isValidIdentifier = _interopRequireDefault(require("../validators/isValidIdentifier"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function toIdentifier(name) {
  name = name + "";
  name = name.replace(/[^a-zA-Z0-9$_]/g, "-");
  name = name.replace(/^[-0-9]+/, "");
  name = name.replace(/[-\s]+(.)?/g, function (match, c) {
    return c ? c.toUpperCase() : "";
  });

  if (!(0, _isValidIdentifier.default)(name)) {
    name = `_${name}`;
  }

  return name || "_";
}
},{"../validators/isValidIdentifier":102}],59:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toKeyAlias;

var _generated = require("../validators/generated");

var _cloneNode = _interopRequireDefault(require("../clone/cloneNode"));

var _removePropertiesDeep = _interopRequireDefault(require("../modifications/removePropertiesDeep"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function toKeyAlias(node, key = node.key) {
  let alias;

  if (node.kind === "method") {
    return toKeyAlias.increment() + "";
  } else if ((0, _generated.isIdentifier)(key)) {
    alias = key.name;
  } else if ((0, _generated.isStringLiteral)(key)) {
    alias = JSON.stringify(key.value);
  } else {
    alias = JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode.default)(key)));
  }

  if (node.computed) {
    alias = `[${alias}]`;
  }

  if (node.static) {
    alias = `static:${alias}`;
  }

  return alias;
}

toKeyAlias.uid = 0;

toKeyAlias.increment = function () {
  if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {
    return toKeyAlias.uid = 0;
  } else {
    return toKeyAlias.uid++;
  }
};
},{"../clone/cloneNode":41,"../modifications/removePropertiesDeep":78,"../validators/generated":88}],60:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toSequenceExpression;

var _gatherSequenceExpressions = _interopRequireDefault(require("./gatherSequenceExpressions"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function toSequenceExpression(nodes, scope) {
  if (!(nodes == null ? void 0 : nodes.length)) return;
  const declars = [];
  const result = (0, _gatherSequenceExpressions.default)(nodes, scope, declars);
  if (!result) return;

  for (const declar of declars) {
    scope.push(declar);
  }

  return result;
}
},{"./gatherSequenceExpressions":53}],61:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toStatement;

var _generated = require("../validators/generated");

var _generated2 = require("../builders/generated");

function toStatement(node, ignore) {
  if ((0, _generated.isStatement)(node)) {
    return node;
  }

  let mustHaveId = false;
  let newType;

  if ((0, _generated.isClass)(node)) {
    mustHaveId = true;
    newType = "ClassDeclaration";
  } else if ((0, _generated.isFunction)(node)) {
    mustHaveId = true;
    newType = "FunctionDeclaration";
  } else if ((0, _generated.isAssignmentExpression)(node)) {
    return (0, _generated2.expressionStatement)(node);
  }

  if (mustHaveId && !node.id) {
    newType = false;
  }

  if (!newType) {
    if (ignore) {
      return false;
    } else {
      throw new Error(`cannot turn ${node.type} to a statement`);
    }
  }

  node.type = newType;
  return node;
}
},{"../builders/generated":35,"../validators/generated":88}],62:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = valueToNode;

var _isPlainObject = _interopRequireDefault(require("lodash/isPlainObject"));

var _isRegExp = _interopRequireDefault(require("lodash/isRegExp"));

var _isValidIdentifier = _interopRequireDefault(require("../validators/isValidIdentifier"));

var _generated = require("../builders/generated");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function valueToNode(value) {
  if (value === undefined) {
    return (0, _generated.identifier)("undefined");
  }

  if (value === true || value === false) {
    return (0, _generated.booleanLiteral)(value);
  }

  if (value === null) {
    return (0, _generated.nullLiteral)();
  }

  if (typeof value === "string") {
    return (0, _generated.stringLiteral)(value);
  }

  if (typeof value === "number") {
    let result;

    if (Number.isFinite(value)) {
      result = (0, _generated.numericLiteral)(Math.abs(value));
    } else {
      let numerator;

      if (Number.isNaN(value)) {
        numerator = (0, _generated.numericLiteral)(0);
      } else {
        numerator = (0, _generated.numericLiteral)(1);
      }

      result = (0, _generated.binaryExpression)("/", numerator, (0, _generated.numericLiteral)(0));
    }

    if (value < 0 || Object.is(value, -0)) {
      result = (0, _generated.unaryExpression)("-", result);
    }

    return result;
  }

  if ((0, _isRegExp.default)(value)) {
    const pattern = value.source;
    const flags = value.toString().match(/\/([a-z]+|)$/)[1];
    return (0, _generated.regExpLiteral)(pattern, flags);
  }

  if (Array.isArray(value)) {
    return (0, _generated.arrayExpression)(value.map(valueToNode));
  }

  if ((0, _isPlainObject.default)(value)) {
    const props = [];

    for (const key of Object.keys(value)) {
      let nodeKey;

      if ((0, _isValidIdentifier.default)(key)) {
        nodeKey = (0, _generated.identifier)(key);
      } else {
        nodeKey = (0, _generated.stringLiteral)(key);
      }

      props.push((0, _generated.objectProperty)(nodeKey, valueToNode(value[key])));
    }

    return (0, _generated.objectExpression)(props);
  }

  throw new Error("don't know how to turn this value into a node");
}
},{"../builders/generated":35,"../validators/isValidIdentifier":102,"lodash/isPlainObject":216,"lodash/isRegExp":217}],63:[function(require,module,exports){
(function (process){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.classMethodOrDeclareMethodCommon = exports.classMethodOrPropertyCommon = exports.patternLikeCommon = exports.functionDeclarationCommon = exports.functionTypeAnnotationCommon = exports.functionCommon = void 0;

var _is = _interopRequireDefault(require("../validators/is"));

var _isValidIdentifier = _interopRequireDefault(require("../validators/isValidIdentifier"));

var _helperValidatorIdentifier = require("@babel/helper-validator-identifier");

var _constants = require("../constants");

var _utils = _interopRequireWildcard(require("./utils"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _utils.default)("ArrayExpression", {
  fields: {
    elements: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "Expression", "SpreadElement"))),
      default: !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined
    }
  },
  visitor: ["elements"],
  aliases: ["Expression"]
});
(0, _utils.default)("AssignmentExpression", {
  fields: {
    operator: {
      validate: function () {
        if (!process.env.BABEL_TYPES_8_BREAKING) {
          return (0, _utils.assertValueType)("string");
        }

        const identifier = (0, _utils.assertOneOf)(..._constants.ASSIGNMENT_OPERATORS);
        const pattern = (0, _utils.assertOneOf)("=");
        return function (node, key, val) {
          const validator = (0, _is.default)("Pattern", node.left) ? pattern : identifier;
          validator(node, key, val);
        };
      }()
    },
    left: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal") : (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern")
    },
    right: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  },
  builder: ["operator", "left", "right"],
  visitor: ["left", "right"],
  aliases: ["Expression"]
});
(0, _utils.default)("BinaryExpression", {
  builder: ["operator", "left", "right"],
  fields: {
    operator: {
      validate: (0, _utils.assertOneOf)(..._constants.BINARY_OPERATORS)
    },
    left: {
      validate: function () {
        const expression = (0, _utils.assertNodeType)("Expression");
        const inOp = (0, _utils.assertNodeType)("Expression", "PrivateName");

        const validator = function (node, key, val) {
          const validator = node.operator === "in" ? inOp : expression;
          validator(node, key, val);
        };

        validator.oneOfNodeTypes = ["Expression", "PrivateName"];
        return validator;
      }()
    },
    right: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  },
  visitor: ["left", "right"],
  aliases: ["Binary", "Expression"]
});
(0, _utils.default)("InterpreterDirective", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("string")
    }
  }
});
(0, _utils.default)("Directive", {
  visitor: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertNodeType)("DirectiveLiteral")
    }
  }
});
(0, _utils.default)("DirectiveLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("string")
    }
  }
});
(0, _utils.default)("BlockStatement", {
  builder: ["body", "directives"],
  visitor: ["directives", "body"],
  fields: {
    directives: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
      default: []
    },
    body: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
    }
  },
  aliases: ["Scopable", "BlockParent", "Block", "Statement"]
});
(0, _utils.default)("BreakStatement", {
  visitor: ["label"],
  fields: {
    label: {
      validate: (0, _utils.assertNodeType)("Identifier"),
      optional: true
    }
  },
  aliases: ["Statement", "Terminatorless", "CompletionStatement"]
});
(0, _utils.default)("CallExpression", {
  visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
  builder: ["callee", "arguments"],
  aliases: ["Expression"],
  fields: Object.assign({
    callee: {
      validate: (0, _utils.assertNodeType)("Expression", "V8IntrinsicIdentifier")
    },
    arguments: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
    }
  }, !process.env.BABEL_TYPES_8_BREAKING ? {
    optional: {
      validate: (0, _utils.assertOneOf)(true, false),
      optional: true
    }
  } : {}, {
    typeArguments: {
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
      optional: true
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
      optional: true
    }
  })
});
(0, _utils.default)("CatchClause", {
  visitor: ["param", "body"],
  fields: {
    param: {
      validate: (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
      optional: true
    },
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  },
  aliases: ["Scopable", "BlockParent"]
});
(0, _utils.default)("ConditionalExpression", {
  visitor: ["test", "consequent", "alternate"],
  fields: {
    test: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    consequent: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    alternate: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  },
  aliases: ["Expression", "Conditional"]
});
(0, _utils.default)("ContinueStatement", {
  visitor: ["label"],
  fields: {
    label: {
      validate: (0, _utils.assertNodeType)("Identifier"),
      optional: true
    }
  },
  aliases: ["Statement", "Terminatorless", "CompletionStatement"]
});
(0, _utils.default)("DebuggerStatement", {
  aliases: ["Statement"]
});
(0, _utils.default)("DoWhileStatement", {
  visitor: ["test", "body"],
  fields: {
    test: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    }
  },
  aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
});
(0, _utils.default)("EmptyStatement", {
  aliases: ["Statement"]
});
(0, _utils.default)("ExpressionStatement", {
  visitor: ["expression"],
  fields: {
    expression: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  },
  aliases: ["Statement", "ExpressionWrapper"]
});
(0, _utils.default)("File", {
  builder: ["program", "comments", "tokens"],
  visitor: ["program"],
  fields: {
    program: {
      validate: (0, _utils.assertNodeType)("Program")
    },
    comments: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(() => {}, {
        each: {
          oneOfNodeTypes: ["CommentBlock", "CommentLine"]
        }
      }) : (0, _utils.assertEach)((0, _utils.assertNodeType)("CommentBlock", "CommentLine")),
      optional: true
    },
    tokens: {
      validate: (0, _utils.assertEach)(Object.assign(() => {}, {
        type: "any"
      })),
      optional: true
    }
  }
});
(0, _utils.default)("ForInStatement", {
  visitor: ["left", "right", "body"],
  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
  fields: {
    left: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("VariableDeclaration", "LVal") : (0, _utils.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern")
    },
    right: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    }
  }
});
(0, _utils.default)("ForStatement", {
  visitor: ["init", "test", "update", "body"],
  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
  fields: {
    init: {
      validate: (0, _utils.assertNodeType)("VariableDeclaration", "Expression"),
      optional: true
    },
    test: {
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
    },
    update: {
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    }
  }
});
const functionCommon = {
  params: {
    validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty")))
  },
  generator: {
    default: false
  },
  async: {
    default: false
  }
};
exports.functionCommon = functionCommon;
const functionTypeAnnotationCommon = {
  returnType: {
    validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
    optional: true
  },
  typeParameters: {
    validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
    optional: true
  }
};
exports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
const functionDeclarationCommon = Object.assign({}, functionCommon, {
  declare: {
    validate: (0, _utils.assertValueType)("boolean"),
    optional: true
  },
  id: {
    validate: (0, _utils.assertNodeType)("Identifier"),
    optional: true
  }
});
exports.functionDeclarationCommon = functionDeclarationCommon;
(0, _utils.default)("FunctionDeclaration", {
  builder: ["id", "params", "body", "generator", "async"],
  visitor: ["id", "params", "body", "returnType", "typeParameters"],
  fields: Object.assign({}, functionDeclarationCommon, functionTypeAnnotationCommon, {
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  }),
  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
  validate: function () {
    if (!process.env.BABEL_TYPES_8_BREAKING) return () => {};
    const identifier = (0, _utils.assertNodeType)("Identifier");
    return function (parent, key, node) {
      if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
        identifier(node, "id", node.id);
      }
    };
  }()
});
(0, _utils.default)("FunctionExpression", {
  inherits: "FunctionDeclaration",
  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
    id: {
      validate: (0, _utils.assertNodeType)("Identifier"),
      optional: true
    },
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  })
});
const patternLikeCommon = {
  typeAnnotation: {
    validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
    optional: true
  },
  decorators: {
    validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator")))
  }
};
exports.patternLikeCommon = patternLikeCommon;
(0, _utils.default)("Identifier", {
  builder: ["name"],
  visitor: ["typeAnnotation", "decorators"],
  aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
  fields: Object.assign({}, patternLikeCommon, {
    name: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function (node, key, val) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;

        if (!(0, _isValidIdentifier.default)(val, false)) {
          throw new TypeError(`"${val}" is not a valid identifier name`);
        }
      }, {
        type: "string"
      }))
    },
    optional: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    }
  }),

  validate(parent, key, node) {
    if (!process.env.BABEL_TYPES_8_BREAKING) return;
    const match = /\.(\w+)$/.exec(key);
    if (!match) return;
    const [, parentKey] = match;
    const nonComp = {
      computed: false
    };

    if (parentKey === "property") {
      if ((0, _is.default)("MemberExpression", parent, nonComp)) return;
      if ((0, _is.default)("OptionalMemberExpression", parent, nonComp)) return;
    } else if (parentKey === "key") {
      if ((0, _is.default)("Property", parent, nonComp)) return;
      if ((0, _is.default)("Method", parent, nonComp)) return;
    } else if (parentKey === "exported") {
      if ((0, _is.default)("ExportSpecifier", parent)) return;
    } else if (parentKey === "imported") {
      if ((0, _is.default)("ImportSpecifier", parent, {
        imported: node
      })) return;
    } else if (parentKey === "meta") {
      if ((0, _is.default)("MetaProperty", parent, {
        meta: node
      })) return;
    }

    if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name)) && node.name !== "this") {
      throw new TypeError(`"${node.name}" is not a valid identifier`);
    }
  }

});
(0, _utils.default)("IfStatement", {
  visitor: ["test", "consequent", "alternate"],
  aliases: ["Statement", "Conditional"],
  fields: {
    test: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    consequent: {
      validate: (0, _utils.assertNodeType)("Statement")
    },
    alternate: {
      optional: true,
      validate: (0, _utils.assertNodeType)("Statement")
    }
  }
});
(0, _utils.default)("LabeledStatement", {
  visitor: ["label", "body"],
  aliases: ["Statement"],
  fields: {
    label: {
      validate: (0, _utils.assertNodeType)("Identifier")
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    }
  }
});
(0, _utils.default)("StringLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("string")
    }
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});
(0, _utils.default)("NumericLiteral", {
  builder: ["value"],
  deprecatedAlias: "NumberLiteral",
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("number")
    }
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});
(0, _utils.default)("NullLiteral", {
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});
(0, _utils.default)("BooleanLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("boolean")
    }
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});
(0, _utils.default)("RegExpLiteral", {
  builder: ["pattern", "flags"],
  deprecatedAlias: "RegexLiteral",
  aliases: ["Expression", "Pureish", "Literal"],
  fields: {
    pattern: {
      validate: (0, _utils.assertValueType)("string")
    },
    flags: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function (node, key, val) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        const invalid = /[^gimsuy]/.exec(val);

        if (invalid) {
          throw new TypeError(`"${invalid[0]}" is not a valid RegExp flag`);
        }
      }, {
        type: "string"
      })),
      default: ""
    }
  }
});
(0, _utils.default)("LogicalExpression", {
  builder: ["operator", "left", "right"],
  visitor: ["left", "right"],
  aliases: ["Binary", "Expression"],
  fields: {
    operator: {
      validate: (0, _utils.assertOneOf)(..._constants.LOGICAL_OPERATORS)
    },
    left: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    right: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("MemberExpression", {
  builder: ["object", "property", "computed", "optional"],
  visitor: ["object", "property"],
  aliases: ["Expression", "LVal"],
  fields: Object.assign({
    object: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    property: {
      validate: function () {
        const normal = (0, _utils.assertNodeType)("Identifier", "PrivateName");
        const computed = (0, _utils.assertNodeType)("Expression");

        const validator = function (node, key, val) {
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
        };

        validator.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"];
        return validator;
      }()
    },
    computed: {
      default: false
    }
  }, !process.env.BABEL_TYPES_8_BREAKING ? {
    optional: {
      validate: (0, _utils.assertOneOf)(true, false),
      optional: true
    }
  } : {})
});
(0, _utils.default)("NewExpression", {
  inherits: "CallExpression"
});
(0, _utils.default)("Program", {
  visitor: ["directives", "body"],
  builder: ["body", "directives", "sourceType", "interpreter"],
  fields: {
    sourceFile: {
      validate: (0, _utils.assertValueType)("string")
    },
    sourceType: {
      validate: (0, _utils.assertOneOf)("script", "module"),
      default: "script"
    },
    interpreter: {
      validate: (0, _utils.assertNodeType)("InterpreterDirective"),
      default: null,
      optional: true
    },
    directives: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
      default: []
    },
    body: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
    }
  },
  aliases: ["Scopable", "BlockParent", "Block"]
});
(0, _utils.default)("ObjectExpression", {
  visitor: ["properties"],
  aliases: ["Expression"],
  fields: {
    properties: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement")))
    }
  }
});
(0, _utils.default)("ObjectMethod", {
  builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
    kind: Object.assign({
      validate: (0, _utils.assertOneOf)("method", "get", "set")
    }, !process.env.BABEL_TYPES_8_BREAKING ? {
      default: "method"
    } : {}),
    computed: {
      default: false
    },
    key: {
      validate: function () {
        const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
        const computed = (0, _utils.assertNodeType)("Expression");

        const validator = function (node, key, val) {
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
        };

        validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral"];
        return validator;
      }()
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
    },
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  }),
  visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
  aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
});
(0, _utils.default)("ObjectProperty", {
  builder: ["key", "value", "computed", "shorthand", ...(!process.env.BABEL_TYPES_8_BREAKING ? ["decorators"] : [])],
  fields: {
    computed: {
      default: false
    },
    key: {
      validate: function () {
        const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
        const computed = (0, _utils.assertNodeType)("Expression");

        const validator = function (node, key, val) {
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
        };

        validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral"];
        return validator;
      }()
    },
    value: {
      validate: (0, _utils.assertNodeType)("Expression", "PatternLike")
    },
    shorthand: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function (node, key, val) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;

        if (val && node.computed) {
          throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
        }
      }, {
        type: "boolean"
      }), function (node, key, val) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;

        if (val && !(0, _is.default)("Identifier", node.key)) {
          throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
        }
      }),
      default: false
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
    }
  },
  visitor: ["key", "value", "decorators"],
  aliases: ["UserWhitespacable", "Property", "ObjectMember"],
  validate: function () {
    const pattern = (0, _utils.assertNodeType)("Identifier", "Pattern");
    const expression = (0, _utils.assertNodeType)("Expression");
    return function (parent, key, node) {
      if (!process.env.BABEL_TYPES_8_BREAKING) return;
      const validator = (0, _is.default)("ObjectPattern", parent) ? pattern : expression;
      validator(node, "value", node.value);
    };
  }()
});
(0, _utils.default)("RestElement", {
  visitor: ["argument", "typeAnnotation"],
  builder: ["argument"],
  aliases: ["LVal", "PatternLike"],
  deprecatedAlias: "RestProperty",
  fields: Object.assign({}, patternLikeCommon, {
    argument: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal") : (0, _utils.assertNodeType)("Identifier", "Pattern", "MemberExpression")
    }
  }),

  validate(parent, key) {
    if (!process.env.BABEL_TYPES_8_BREAKING) return;
    const match = /(\w+)\[(\d+)\]/.exec(key);
    if (!match) throw new Error("Internal Babel error: malformed key.");
    const [, listKey, index] = match;

    if (parent[listKey].length > index + 1) {
      throw new TypeError(`RestElement must be last element of ${listKey}`);
    }
  }

});
(0, _utils.default)("ReturnStatement", {
  visitor: ["argument"],
  aliases: ["Statement", "Terminatorless", "CompletionStatement"],
  fields: {
    argument: {
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
    }
  }
});
(0, _utils.default)("SequenceExpression", {
  visitor: ["expressions"],
  fields: {
    expressions: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression")))
    }
  },
  aliases: ["Expression"]
});
(0, _utils.default)("ParenthesizedExpression", {
  visitor: ["expression"],
  aliases: ["Expression", "ExpressionWrapper"],
  fields: {
    expression: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("SwitchCase", {
  visitor: ["test", "consequent"],
  fields: {
    test: {
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
    },
    consequent: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
    }
  }
});
(0, _utils.default)("SwitchStatement", {
  visitor: ["discriminant", "cases"],
  aliases: ["Statement", "BlockParent", "Scopable"],
  fields: {
    discriminant: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    cases: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("SwitchCase")))
    }
  }
});
(0, _utils.default)("ThisExpression", {
  aliases: ["Expression"]
});
(0, _utils.default)("ThrowStatement", {
  visitor: ["argument"],
  aliases: ["Statement", "Terminatorless", "CompletionStatement"],
  fields: {
    argument: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("TryStatement", {
  visitor: ["block", "handler", "finalizer"],
  aliases: ["Statement"],
  fields: {
    block: {
      validate: (0, _utils.chain)((0, _utils.assertNodeType)("BlockStatement"), Object.assign(function (node) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;

        if (!node.handler && !node.finalizer) {
          throw new TypeError("TryStatement expects either a handler or finalizer, or both");
        }
      }, {
        oneOfNodeTypes: ["BlockStatement"]
      }))
    },
    handler: {
      optional: true,
      validate: (0, _utils.assertNodeType)("CatchClause")
    },
    finalizer: {
      optional: true,
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  }
});
(0, _utils.default)("UnaryExpression", {
  builder: ["operator", "argument", "prefix"],
  fields: {
    prefix: {
      default: true
    },
    argument: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    operator: {
      validate: (0, _utils.assertOneOf)(..._constants.UNARY_OPERATORS)
    }
  },
  visitor: ["argument"],
  aliases: ["UnaryLike", "Expression"]
});
(0, _utils.default)("UpdateExpression", {
  builder: ["operator", "argument", "prefix"],
  fields: {
    prefix: {
      default: false
    },
    argument: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Expression") : (0, _utils.assertNodeType)("Identifier", "MemberExpression")
    },
    operator: {
      validate: (0, _utils.assertOneOf)(..._constants.UPDATE_OPERATORS)
    }
  },
  visitor: ["argument"],
  aliases: ["Expression"]
});
(0, _utils.default)("VariableDeclaration", {
  builder: ["kind", "declarations"],
  visitor: ["declarations"],
  aliases: ["Statement", "Declaration"],
  fields: {
    declare: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    kind: {
      validate: (0, _utils.assertOneOf)("var", "let", "const")
    },
    declarations: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("VariableDeclarator")))
    }
  },

  validate(parent, key, node) {
    if (!process.env.BABEL_TYPES_8_BREAKING) return;
    if (!(0, _is.default)("ForXStatement", parent, {
      left: node
    })) return;

    if (node.declarations.length !== 1) {
      throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);
    }
  }

});
(0, _utils.default)("VariableDeclarator", {
  visitor: ["id", "init"],
  fields: {
    id: {
      validate: function () {
        if (!process.env.BABEL_TYPES_8_BREAKING) {
          return (0, _utils.assertNodeType)("LVal");
        }

        const normal = (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern");
        const without = (0, _utils.assertNodeType)("Identifier");
        return function (node, key, val) {
          const validator = node.init ? normal : without;
          validator(node, key, val);
        };
      }()
    },
    definite: {
      optional: true,
      validate: (0, _utils.assertValueType)("boolean")
    },
    init: {
      optional: true,
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("WhileStatement", {
  visitor: ["test", "body"],
  aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
  fields: {
    test: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    }
  }
});
(0, _utils.default)("WithStatement", {
  visitor: ["object", "body"],
  aliases: ["Statement"],
  fields: {
    object: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    }
  }
});
(0, _utils.default)("AssignmentPattern", {
  visitor: ["left", "right", "decorators"],
  builder: ["left", "right"],
  aliases: ["Pattern", "PatternLike", "LVal"],
  fields: Object.assign({}, patternLikeCommon, {
    left: {
      validate: (0, _utils.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression")
    },
    right: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
    }
  })
});
(0, _utils.default)("ArrayPattern", {
  visitor: ["elements", "typeAnnotation"],
  builder: ["elements"],
  aliases: ["Pattern", "PatternLike", "LVal"],
  fields: Object.assign({}, patternLikeCommon, {
    elements: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "PatternLike")))
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
    }
  })
});
(0, _utils.default)("ArrowFunctionExpression", {
  builder: ["params", "body", "async"],
  visitor: ["params", "body", "returnType", "typeParameters"],
  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
  fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
    expression: {
      validate: (0, _utils.assertValueType)("boolean")
    },
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement", "Expression")
    }
  })
});
(0, _utils.default)("ClassBody", {
  visitor: ["body"],
  fields: {
    body: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "TSDeclareMethod", "TSIndexSignature")))
    }
  }
});
(0, _utils.default)("ClassExpression", {
  builder: ["id", "superClass", "body", "decorators"],
  visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
  aliases: ["Scopable", "Class", "Expression"],
  fields: {
    id: {
      validate: (0, _utils.assertNodeType)("Identifier"),
      optional: true
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
      optional: true
    },
    body: {
      validate: (0, _utils.assertNodeType)("ClassBody")
    },
    superClass: {
      optional: true,
      validate: (0, _utils.assertNodeType)("Expression")
    },
    superTypeParameters: {
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
      optional: true
    },
    implements: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
      optional: true
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
    },
    mixins: {
      validate: (0, _utils.assertNodeType)("InterfaceExtends"),
      optional: true
    }
  }
});
(0, _utils.default)("ClassDeclaration", {
  inherits: "ClassExpression",
  aliases: ["Scopable", "Class", "Statement", "Declaration"],
  fields: {
    id: {
      validate: (0, _utils.assertNodeType)("Identifier")
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
      optional: true
    },
    body: {
      validate: (0, _utils.assertNodeType)("ClassBody")
    },
    superClass: {
      optional: true,
      validate: (0, _utils.assertNodeType)("Expression")
    },
    superTypeParameters: {
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
      optional: true
    },
    implements: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
      optional: true
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
    },
    mixins: {
      validate: (0, _utils.assertNodeType)("InterfaceExtends"),
      optional: true
    },
    declare: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    abstract: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    }
  },
  validate: function () {
    const identifier = (0, _utils.assertNodeType)("Identifier");
    return function (parent, key, node) {
      if (!process.env.BABEL_TYPES_8_BREAKING) return;

      if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
        identifier(node, "id", node.id);
      }
    };
  }()
});
(0, _utils.default)("ExportAllDeclaration", {
  visitor: ["source"],
  aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
  fields: {
    source: {
      validate: (0, _utils.assertNodeType)("StringLiteral")
    }
  }
});
(0, _utils.default)("ExportDefaultDeclaration", {
  visitor: ["declaration"],
  aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
  fields: {
    declaration: {
      validate: (0, _utils.assertNodeType)("FunctionDeclaration", "TSDeclareFunction", "ClassDeclaration", "Expression")
    }
  }
});
(0, _utils.default)("ExportNamedDeclaration", {
  visitor: ["declaration", "specifiers", "source"],
  aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
  fields: {
    declaration: {
      optional: true,
      validate: (0, _utils.chain)((0, _utils.assertNodeType)("Declaration"), Object.assign(function (node, key, val) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;

        if (val && node.specifiers.length) {
          throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
        }
      }, {
        oneOfNodeTypes: ["Declaration"]
      }), function (node, key, val) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;

        if (val && node.source) {
          throw new TypeError("Cannot export a declaration from a source");
        }
      })
    },
    specifiers: {
      default: [],
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)(function () {
        const sourced = (0, _utils.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");
        const sourceless = (0, _utils.assertNodeType)("ExportSpecifier");
        if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;
        return function (node, key, val) {
          const validator = node.source ? sourced : sourceless;
          validator(node, key, val);
        };
      }()))
    },
    source: {
      validate: (0, _utils.assertNodeType)("StringLiteral"),
      optional: true
    },
    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
  }
});
(0, _utils.default)("ExportSpecifier", {
  visitor: ["local", "exported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, _utils.assertNodeType)("Identifier")
    },
    exported: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
(0, _utils.default)("ForOfStatement", {
  visitor: ["left", "right", "body"],
  builder: ["left", "right", "body", "await"],
  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
  fields: {
    left: {
      validate: function () {
        if (!process.env.BABEL_TYPES_8_BREAKING) {
          return (0, _utils.assertNodeType)("VariableDeclaration", "LVal");
        }

        const declaration = (0, _utils.assertNodeType)("VariableDeclaration");
        const lval = (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern");
        return function (node, key, val) {
          if ((0, _is.default)("VariableDeclaration", val)) {
            declaration(node, key, val);
          } else {
            lval(node, key, val);
          }
        };
      }()
    },
    right: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    },
    await: {
      default: false
    }
  }
});
(0, _utils.default)("ImportDeclaration", {
  visitor: ["specifiers", "source"],
  aliases: ["Statement", "Declaration", "ModuleDeclaration"],
  fields: {
    specifiers: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
    },
    source: {
      validate: (0, _utils.assertNodeType)("StringLiteral")
    },
    importKind: {
      validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
      optional: true
    }
  }
});
(0, _utils.default)("ImportDefaultSpecifier", {
  visitor: ["local"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
(0, _utils.default)("ImportNamespaceSpecifier", {
  visitor: ["local"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
(0, _utils.default)("ImportSpecifier", {
  visitor: ["local", "imported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, _utils.assertNodeType)("Identifier")
    },
    imported: {
      validate: (0, _utils.assertNodeType)("Identifier")
    },
    importKind: {
      validate: (0, _utils.assertOneOf)("type", "typeof"),
      optional: true
    }
  }
});
(0, _utils.default)("MetaProperty", {
  visitor: ["meta", "property"],
  aliases: ["Expression"],
  fields: {
    meta: {
      validate: (0, _utils.chain)((0, _utils.assertNodeType)("Identifier"), Object.assign(function (node, key, val) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        let property;

        switch (val.name) {
          case "function":
            property = "sent";
            break;

          case "new":
            property = "target";
            break;

          case "import":
            property = "meta";
            break;
        }

        if (!(0, _is.default)("Identifier", node.property, {
          name: property
        })) {
          throw new TypeError("Unrecognised MetaProperty");
        }
      }, {
        oneOfNodeTypes: ["Identifier"]
      }))
    },
    property: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
const classMethodOrPropertyCommon = {
  abstract: {
    validate: (0, _utils.assertValueType)("boolean"),
    optional: true
  },
  accessibility: {
    validate: (0, _utils.assertOneOf)("public", "private", "protected"),
    optional: true
  },
  static: {
    default: false
  },
  computed: {
    default: false
  },
  optional: {
    validate: (0, _utils.assertValueType)("boolean"),
    optional: true
  },
  key: {
    validate: (0, _utils.chain)(function () {
      const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
      const computed = (0, _utils.assertNodeType)("Expression");
      return function (node, key, val) {
        const validator = node.computed ? computed : normal;
        validator(node, key, val);
      };
    }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "Expression"))
  }
};
exports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
const classMethodOrDeclareMethodCommon = Object.assign({}, functionCommon, classMethodOrPropertyCommon, {
  kind: {
    validate: (0, _utils.assertOneOf)("get", "set", "method", "constructor"),
    default: "method"
  },
  access: {
    validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),
    optional: true
  },
  decorators: {
    validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
    optional: true
  }
});
exports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
(0, _utils.default)("ClassMethod", {
  aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
  builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
  visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
  fields: Object.assign({}, classMethodOrDeclareMethodCommon, functionTypeAnnotationCommon, {
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  })
});
(0, _utils.default)("ObjectPattern", {
  visitor: ["properties", "typeAnnotation", "decorators"],
  builder: ["properties"],
  aliases: ["Pattern", "PatternLike", "LVal"],
  fields: Object.assign({}, patternLikeCommon, {
    properties: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("RestElement", "ObjectProperty")))
    }
  })
});
(0, _utils.default)("SpreadElement", {
  visitor: ["argument"],
  aliases: ["UnaryLike"],
  deprecatedAlias: "SpreadProperty",
  fields: {
    argument: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("Super", {
  aliases: ["Expression"]
});
(0, _utils.default)("TaggedTemplateExpression", {
  visitor: ["tag", "quasi"],
  aliases: ["Expression"],
  fields: {
    tag: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    quasi: {
      validate: (0, _utils.assertNodeType)("TemplateLiteral")
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
      optional: true
    }
  }
});
(0, _utils.default)("TemplateElement", {
  builder: ["value", "tail"],
  fields: {
    value: {
      validate: (0, _utils.assertShape)({
        raw: {
          validate: (0, _utils.assertValueType)("string")
        },
        cooked: {
          validate: (0, _utils.assertValueType)("string"),
          optional: true
        }
      })
    },
    tail: {
      default: false
    }
  }
});
(0, _utils.default)("TemplateLiteral", {
  visitor: ["quasis", "expressions"],
  aliases: ["Expression", "Literal"],
  fields: {
    quasis: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TemplateElement")))
    },
    expressions: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression")), function (node, key, val) {
        if (node.quasis.length !== val.length + 1) {
          throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.\nExpected ${val.length + 1} quasis but got ${node.quasis.length}`);
        }
      })
    }
  }
});
(0, _utils.default)("YieldExpression", {
  builder: ["argument", "delegate"],
  visitor: ["argument"],
  aliases: ["Expression", "Terminatorless"],
  fields: {
    delegate: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function (node, key, val) {
        if (!process.env.BABEL_TYPES_8_BREAKING) return;

        if (val && !node.argument) {
          throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
        }
      }, {
        type: "boolean"
      })),
      default: false
    },
    argument: {
      optional: true,
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("AwaitExpression", {
  builder: ["argument"],
  visitor: ["argument"],
  aliases: ["Expression", "Terminatorless"],
  fields: {
    argument: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("Import", {
  aliases: ["Expression"]
});
(0, _utils.default)("BigIntLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("string")
    }
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});
(0, _utils.default)("ExportNamespaceSpecifier", {
  visitor: ["exported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    exported: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
(0, _utils.default)("OptionalMemberExpression", {
  builder: ["object", "property", "computed", "optional"],
  visitor: ["object", "property"],
  aliases: ["Expression"],
  fields: {
    object: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    property: {
      validate: function () {
        const normal = (0, _utils.assertNodeType)("Identifier");
        const computed = (0, _utils.assertNodeType)("Expression");

        const validator = function (node, key, val) {
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
        };

        validator.oneOfNodeTypes = ["Expression", "Identifier"];
        return validator;
      }()
    },
    computed: {
      default: false
    },
    optional: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
    }
  }
});
(0, _utils.default)("OptionalCallExpression", {
  visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
  builder: ["callee", "arguments", "optional"],
  aliases: ["Expression"],
  fields: {
    callee: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    arguments: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName")))
    },
    optional: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
    },
    typeArguments: {
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
      optional: true
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
      optional: true
    }
  }
});
}).call(this,require('_process'))

},{"../constants":51,"../validators/is":89,"../validators/isValidIdentifier":102,"./utils":71,"@babel/helper-validator-identifier":28,"_process":224}],64:[function(require,module,exports){
(function (process){
"use strict";

var _utils = _interopRequireWildcard(require("./utils"));

var _core = require("./core");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

(0, _utils.default)("ArgumentPlaceholder", {});
(0, _utils.default)("BindExpression", {
  visitor: ["object", "callee"],
  aliases: ["Expression"],
  fields: !process.env.BABEL_TYPES_8_BREAKING ? {
    object: {
      validate: Object.assign(() => {}, {
        oneOfNodeTypes: ["Expression"]
      })
    },
    callee: {
      validate: Object.assign(() => {}, {
        oneOfNodeTypes: ["Expression"]
      })
    }
  } : {
    object: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    callee: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("ClassProperty", {
  visitor: ["key", "value", "typeAnnotation", "decorators"],
  builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
  aliases: ["Property"],
  fields: Object.assign({}, _core.classMethodOrPropertyCommon, {
    value: {
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
    },
    definite: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    typeAnnotation: {
      validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: true
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
    },
    readonly: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    declare: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    }
  })
});
(0, _utils.default)("PipelineTopicExpression", {
  builder: ["expression"],
  visitor: ["expression"],
  fields: {
    expression: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("PipelineBareFunction", {
  builder: ["callee"],
  visitor: ["callee"],
  fields: {
    callee: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("PipelinePrimaryTopicReference", {
  aliases: ["Expression"]
});
(0, _utils.default)("ClassPrivateProperty", {
  visitor: ["key", "value", "decorators"],
  builder: ["key", "value", "decorators"],
  aliases: ["Property", "Private"],
  fields: {
    key: {
      validate: (0, _utils.assertNodeType)("PrivateName")
    },
    value: {
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
    },
    decorators: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
    }
  }
});
(0, _utils.default)("ClassPrivateMethod", {
  builder: ["kind", "key", "params", "body", "static"],
  visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
  aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
  fields: Object.assign({}, _core.classMethodOrDeclareMethodCommon, _core.functionTypeAnnotationCommon, {
    key: {
      validate: (0, _utils.assertNodeType)("PrivateName")
    },
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  })
});
(0, _utils.default)("ImportAttribute", {
  visitor: ["key", "value"],
  fields: {
    key: {
      validate: (0, _utils.assertNodeType)("Identifier")
    },
    value: {
      validate: (0, _utils.assertNodeType)("StringLiteral")
    }
  }
});
(0, _utils.default)("Decorator", {
  visitor: ["expression"],
  fields: {
    expression: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("DoExpression", {
  visitor: ["body"],
  aliases: ["Expression"],
  fields: {
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  }
});
(0, _utils.default)("ExportDefaultSpecifier", {
  visitor: ["exported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    exported: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
(0, _utils.default)("PrivateName", {
  visitor: ["id"],
  aliases: ["Private"],
  fields: {
    id: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
(0, _utils.default)("RecordExpression", {
  visitor: ["properties"],
  aliases: ["Expression"],
  fields: {
    properties: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectProperty", "SpreadElement")))
    }
  }
});
(0, _utils.default)("TupleExpression", {
  fields: {
    elements: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement"))),
      default: []
    }
  },
  visitor: ["elements"],
  aliases: ["Expression"]
});
(0, _utils.default)("DecimalLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("string")
    }
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});
}).call(this,require('_process'))

},{"./core":63,"./utils":71,"_process":224}],65:[function(require,module,exports){
"use strict";

var _utils = _interopRequireWildcard(require("./utils"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const defineInterfaceishType = (name, typeParameterType = "TypeParameterDeclaration") => {
  (0, _utils.default)(name, {
    builder: ["id", "typeParameters", "extends", "body"],
    visitor: ["id", "typeParameters", "extends", "mixins", "implements", "body"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)(typeParameterType),
      extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
      mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
      implements: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ClassImplements")),
      body: (0, _utils.validateType)("ObjectTypeAnnotation")
    }
  });
};

(0, _utils.default)("AnyTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("ArrayTypeAnnotation", {
  visitor: ["elementType"],
  aliases: ["Flow", "FlowType"],
  fields: {
    elementType: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("BooleanTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("BooleanLiteralTypeAnnotation", {
  builder: ["value"],
  aliases: ["Flow", "FlowType"],
  fields: {
    value: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
  }
});
(0, _utils.default)("NullLiteralTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("ClassImplements", {
  visitor: ["id", "typeParameters"],
  aliases: ["Flow"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
  }
});
defineInterfaceishType("DeclareClass");
(0, _utils.default)("DeclareFunction", {
  visitor: ["id"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    predicate: (0, _utils.validateOptionalType)("DeclaredPredicate")
  }
});
defineInterfaceishType("DeclareInterface");
(0, _utils.default)("DeclareModule", {
  builder: ["id", "body", "kind"],
  visitor: ["id", "body"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
    body: (0, _utils.validateType)("BlockStatement"),
    kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("CommonJS", "ES"))
  }
});
(0, _utils.default)("DeclareModuleExports", {
  visitor: ["typeAnnotation"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
  }
});
(0, _utils.default)("DeclareTypeAlias", {
  visitor: ["id", "typeParameters", "right"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
    right: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("DeclareOpaqueType", {
  visitor: ["id", "typeParameters", "supertype"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
    supertype: (0, _utils.validateOptionalType)("FlowType")
  }
});
(0, _utils.default)("DeclareVariable", {
  visitor: ["id"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, _utils.validateType)("Identifier")
  }
});
(0, _utils.default)("DeclareExportDeclaration", {
  visitor: ["declaration", "specifiers", "source"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    declaration: (0, _utils.validateOptionalType)("Flow"),
    specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])),
    source: (0, _utils.validateOptionalType)("StringLiteral"),
    default: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
  }
});
(0, _utils.default)("DeclareExportAllDeclaration", {
  visitor: ["source"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    source: (0, _utils.validateType)("StringLiteral"),
    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
  }
});
(0, _utils.default)("DeclaredPredicate", {
  visitor: ["value"],
  aliases: ["Flow", "FlowPredicate"],
  fields: {
    value: (0, _utils.validateType)("Flow")
  }
});
(0, _utils.default)("ExistsTypeAnnotation", {
  aliases: ["Flow", "FlowType"]
});
(0, _utils.default)("FunctionTypeAnnotation", {
  visitor: ["typeParameters", "params", "rest", "returnType"],
  aliases: ["Flow", "FlowType"],
  fields: {
    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
    params: (0, _utils.validate)((0, _utils.arrayOfType)("FunctionTypeParam")),
    rest: (0, _utils.validateOptionalType)("FunctionTypeParam"),
    returnType: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("FunctionTypeParam", {
  visitor: ["name", "typeAnnotation"],
  aliases: ["Flow"],
  fields: {
    name: (0, _utils.validateOptionalType)("Identifier"),
    typeAnnotation: (0, _utils.validateType)("FlowType"),
    optional: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
  }
});
(0, _utils.default)("GenericTypeAnnotation", {
  visitor: ["id", "typeParameters"],
  aliases: ["Flow", "FlowType"],
  fields: {
    id: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
    typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
  }
});
(0, _utils.default)("InferredPredicate", {
  aliases: ["Flow", "FlowPredicate"]
});
(0, _utils.default)("InterfaceExtends", {
  visitor: ["id", "typeParameters"],
  aliases: ["Flow"],
  fields: {
    id: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
    typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
  }
});
defineInterfaceishType("InterfaceDeclaration");
(0, _utils.default)("InterfaceTypeAnnotation", {
  visitor: ["extends", "body"],
  aliases: ["Flow", "FlowType"],
  fields: {
    extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
    body: (0, _utils.validateType)("ObjectTypeAnnotation")
  }
});
(0, _utils.default)("IntersectionTypeAnnotation", {
  visitor: ["types"],
  aliases: ["Flow", "FlowType"],
  fields: {
    types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
  }
});
(0, _utils.default)("MixedTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("EmptyTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("NullableTypeAnnotation", {
  visitor: ["typeAnnotation"],
  aliases: ["Flow", "FlowType"],
  fields: {
    typeAnnotation: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("NumberLiteralTypeAnnotation", {
  builder: ["value"],
  aliases: ["Flow", "FlowType"],
  fields: {
    value: (0, _utils.validate)((0, _utils.assertValueType)("number"))
  }
});
(0, _utils.default)("NumberTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("ObjectTypeAnnotation", {
  visitor: ["properties", "indexers", "callProperties", "internalSlots"],
  aliases: ["Flow", "FlowType"],
  builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
  fields: {
    properties: (0, _utils.validate)((0, _utils.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])),
    indexers: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeIndexer")),
    callProperties: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeCallProperty")),
    internalSlots: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ObjectTypeInternalSlot")),
    exact: {
      validate: (0, _utils.assertValueType)("boolean"),
      default: false
    },
    inexact: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
  }
});
(0, _utils.default)("ObjectTypeInternalSlot", {
  visitor: ["id", "value", "optional", "static", "method"],
  aliases: ["Flow", "UserWhitespacable"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    value: (0, _utils.validateType)("FlowType"),
    optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
  }
});
(0, _utils.default)("ObjectTypeCallProperty", {
  visitor: ["value"],
  aliases: ["Flow", "UserWhitespacable"],
  fields: {
    value: (0, _utils.validateType)("FlowType"),
    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
  }
});
(0, _utils.default)("ObjectTypeIndexer", {
  visitor: ["id", "key", "value", "variance"],
  aliases: ["Flow", "UserWhitespacable"],
  fields: {
    id: (0, _utils.validateOptionalType)("Identifier"),
    key: (0, _utils.validateType)("FlowType"),
    value: (0, _utils.validateType)("FlowType"),
    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    variance: (0, _utils.validateOptionalType)("Variance")
  }
});
(0, _utils.default)("ObjectTypeProperty", {
  visitor: ["key", "value", "variance"],
  aliases: ["Flow", "UserWhitespacable"],
  fields: {
    key: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
    value: (0, _utils.validateType)("FlowType"),
    kind: (0, _utils.validate)((0, _utils.assertOneOf)("init", "get", "set")),
    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    proto: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    variance: (0, _utils.validateOptionalType)("Variance")
  }
});
(0, _utils.default)("ObjectTypeSpreadProperty", {
  visitor: ["argument"],
  aliases: ["Flow", "UserWhitespacable"],
  fields: {
    argument: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("OpaqueType", {
  visitor: ["id", "typeParameters", "supertype", "impltype"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
    supertype: (0, _utils.validateOptionalType)("FlowType"),
    impltype: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("QualifiedTypeIdentifier", {
  visitor: ["id", "qualification"],
  aliases: ["Flow"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    qualification: (0, _utils.validateType)(["Identifier", "QualifiedTypeIdentifier"])
  }
});
(0, _utils.default)("StringLiteralTypeAnnotation", {
  builder: ["value"],
  aliases: ["Flow", "FlowType"],
  fields: {
    value: (0, _utils.validate)((0, _utils.assertValueType)("string"))
  }
});
(0, _utils.default)("StringTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("SymbolTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("ThisTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("TupleTypeAnnotation", {
  visitor: ["types"],
  aliases: ["Flow", "FlowType"],
  fields: {
    types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
  }
});
(0, _utils.default)("TypeofTypeAnnotation", {
  visitor: ["argument"],
  aliases: ["Flow", "FlowType"],
  fields: {
    argument: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("TypeAlias", {
  visitor: ["id", "typeParameters", "right"],
  aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
    right: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("TypeAnnotation", {
  aliases: ["Flow"],
  visitor: ["typeAnnotation"],
  fields: {
    typeAnnotation: (0, _utils.validateType)("FlowType")
  }
});
(0, _utils.default)("TypeCastExpression", {
  visitor: ["expression", "typeAnnotation"],
  aliases: ["Flow", "ExpressionWrapper", "Expression"],
  fields: {
    expression: (0, _utils.validateType)("Expression"),
    typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
  }
});
(0, _utils.default)("TypeParameter", {
  aliases: ["Flow"],
  visitor: ["bound", "default", "variance"],
  fields: {
    name: (0, _utils.validate)((0, _utils.assertValueType)("string")),
    bound: (0, _utils.validateOptionalType)("TypeAnnotation"),
    default: (0, _utils.validateOptionalType)("FlowType"),
    variance: (0, _utils.validateOptionalType)("Variance")
  }
});
(0, _utils.default)("TypeParameterDeclaration", {
  aliases: ["Flow"],
  visitor: ["params"],
  fields: {
    params: (0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter"))
  }
});
(0, _utils.default)("TypeParameterInstantiation", {
  aliases: ["Flow"],
  visitor: ["params"],
  fields: {
    params: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
  }
});
(0, _utils.default)("UnionTypeAnnotation", {
  visitor: ["types"],
  aliases: ["Flow", "FlowType"],
  fields: {
    types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
  }
});
(0, _utils.default)("Variance", {
  aliases: ["Flow"],
  builder: ["kind"],
  fields: {
    kind: (0, _utils.validate)((0, _utils.assertOneOf)("minus", "plus"))
  }
});
(0, _utils.default)("VoidTypeAnnotation", {
  aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
});
(0, _utils.default)("EnumDeclaration", {
  aliases: ["Statement", "Declaration"],
  visitor: ["id", "body"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    body: (0, _utils.validateType)(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"])
  }
});
(0, _utils.default)("EnumBooleanBody", {
  aliases: ["EnumBody"],
  visitor: ["members"],
  fields: {
    explicit: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    members: (0, _utils.validateArrayOfType)("EnumBooleanMember")
  }
});
(0, _utils.default)("EnumNumberBody", {
  aliases: ["EnumBody"],
  visitor: ["members"],
  fields: {
    explicit: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    members: (0, _utils.validateArrayOfType)("EnumNumberMember")
  }
});
(0, _utils.default)("EnumStringBody", {
  aliases: ["EnumBody"],
  visitor: ["members"],
  fields: {
    explicit: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
    members: (0, _utils.validateArrayOfType)(["EnumStringMember", "EnumDefaultedMember"])
  }
});
(0, _utils.default)("EnumSymbolBody", {
  aliases: ["EnumBody"],
  visitor: ["members"],
  fields: {
    members: (0, _utils.validateArrayOfType)("EnumDefaultedMember")
  }
});
(0, _utils.default)("EnumBooleanMember", {
  aliases: ["EnumMember"],
  visitor: ["id"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    init: (0, _utils.validateType)("BooleanLiteral")
  }
});
(0, _utils.default)("EnumNumberMember", {
  aliases: ["EnumMember"],
  visitor: ["id", "init"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    init: (0, _utils.validateType)("NumericLiteral")
  }
});
(0, _utils.default)("EnumStringMember", {
  aliases: ["EnumMember"],
  visitor: ["id", "init"],
  fields: {
    id: (0, _utils.validateType)("Identifier"),
    init: (0, _utils.validateType)("StringLiteral")
  }
});
(0, _utils.default)("EnumDefaultedMember", {
  aliases: ["EnumMember"],
  visitor: ["id"],
  fields: {
    id: (0, _utils.validateType)("Identifier")
  }
});
},{"./utils":71}],66:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "VISITOR_KEYS", {
  enumerable: true,
  get: function () {
    return _utils.VISITOR_KEYS;
  }
});
Object.defineProperty(exports, "ALIAS_KEYS", {
  enumerable: true,
  get: function () {
    return _utils.ALIAS_KEYS;
  }
});
Object.defineProperty(exports, "FLIPPED_ALIAS_KEYS", {
  enumerable: true,
  get: function () {
    return _utils.FLIPPED_ALIAS_KEYS;
  }
});
Object.defineProperty(exports, "NODE_FIELDS", {
  enumerable: true,
  get: function () {
    return _utils.NODE_FIELDS;
  }
});
Object.defineProperty(exports, "BUILDER_KEYS", {
  enumerable: true,
  get: function () {
    return _utils.BUILDER_KEYS;
  }
});
Object.defineProperty(exports, "DEPRECATED_KEYS", {
  enumerable: true,
  get: function () {
    return _utils.DEPRECATED_KEYS;
  }
});
Object.defineProperty(exports, "NODE_PARENT_VALIDATIONS", {
  enumerable: true,
  get: function () {
    return _utils.NODE_PARENT_VALIDATIONS;
  }
});
Object.defineProperty(exports, "PLACEHOLDERS", {
  enumerable: true,
  get: function () {
    return _placeholders.PLACEHOLDERS;
  }
});
Object.defineProperty(exports, "PLACEHOLDERS_ALIAS", {
  enumerable: true,
  get: function () {
    return _placeholders.PLACEHOLDERS_ALIAS;
  }
});
Object.defineProperty(exports, "PLACEHOLDERS_FLIPPED_ALIAS", {
  enumerable: true,
  get: function () {
    return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;
  }
});
exports.TYPES = void 0;

var _toFastProperties = _interopRequireDefault(require("to-fast-properties"));

require("./core");

require("./flow");

require("./jsx");

require("./misc");

require("./experimental");

require("./typescript");

var _utils = require("./utils");

var _placeholders = require("./placeholders");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _toFastProperties.default)(_utils.VISITOR_KEYS);
(0, _toFastProperties.default)(_utils.ALIAS_KEYS);
(0, _toFastProperties.default)(_utils.FLIPPED_ALIAS_KEYS);
(0, _toFastProperties.default)(_utils.NODE_FIELDS);
(0, _toFastProperties.default)(_utils.BUILDER_KEYS);
(0, _toFastProperties.default)(_utils.DEPRECATED_KEYS);
(0, _toFastProperties.default)(_placeholders.PLACEHOLDERS_ALIAS);
(0, _toFastProperties.default)(_placeholders.PLACEHOLDERS_FLIPPED_ALIAS);
const TYPES = Object.keys(_utils.VISITOR_KEYS).concat(Object.keys(_utils.FLIPPED_ALIAS_KEYS)).concat(Object.keys(_utils.DEPRECATED_KEYS));
exports.TYPES = TYPES;
},{"./core":63,"./experimental":64,"./flow":65,"./jsx":67,"./misc":68,"./placeholders":69,"./typescript":70,"./utils":71,"to-fast-properties":228}],67:[function(require,module,exports){
"use strict";

var _utils = _interopRequireWildcard(require("./utils"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

(0, _utils.default)("JSXAttribute", {
  visitor: ["name", "value"],
  aliases: ["JSX", "Immutable"],
  fields: {
    name: {
      validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
    },
    value: {
      optional: true,
      validate: (0, _utils.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
    }
  }
});
(0, _utils.default)("JSXClosingElement", {
  visitor: ["name"],
  aliases: ["JSX", "Immutable"],
  fields: {
    name: {
      validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
    }
  }
});
(0, _utils.default)("JSXElement", {
  builder: ["openingElement", "closingElement", "children", "selfClosing"],
  visitor: ["openingElement", "children", "closingElement"],
  aliases: ["JSX", "Immutable", "Expression"],
  fields: {
    openingElement: {
      validate: (0, _utils.assertNodeType)("JSXOpeningElement")
    },
    closingElement: {
      optional: true,
      validate: (0, _utils.assertNodeType)("JSXClosingElement")
    },
    children: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
    },
    selfClosing: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    }
  }
});
(0, _utils.default)("JSXEmptyExpression", {
  aliases: ["JSX"]
});
(0, _utils.default)("JSXExpressionContainer", {
  visitor: ["expression"],
  aliases: ["JSX", "Immutable"],
  fields: {
    expression: {
      validate: (0, _utils.assertNodeType)("Expression", "JSXEmptyExpression")
    }
  }
});
(0, _utils.default)("JSXSpreadChild", {
  visitor: ["expression"],
  aliases: ["JSX", "Immutable"],
  fields: {
    expression: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("JSXIdentifier", {
  builder: ["name"],
  aliases: ["JSX"],
  fields: {
    name: {
      validate: (0, _utils.assertValueType)("string")
    }
  }
});
(0, _utils.default)("JSXMemberExpression", {
  visitor: ["object", "property"],
  aliases: ["JSX"],
  fields: {
    object: {
      validate: (0, _utils.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
    },
    property: {
      validate: (0, _utils.assertNodeType)("JSXIdentifier")
    }
  }
});
(0, _utils.default)("JSXNamespacedName", {
  visitor: ["namespace", "name"],
  aliases: ["JSX"],
  fields: {
    namespace: {
      validate: (0, _utils.assertNodeType)("JSXIdentifier")
    },
    name: {
      validate: (0, _utils.assertNodeType)("JSXIdentifier")
    }
  }
});
(0, _utils.default)("JSXOpeningElement", {
  builder: ["name", "attributes", "selfClosing"],
  visitor: ["name", "attributes"],
  aliases: ["JSX", "Immutable"],
  fields: {
    name: {
      validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
    },
    selfClosing: {
      default: false
    },
    attributes: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXAttribute", "JSXSpreadAttribute")))
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
      optional: true
    }
  }
});
(0, _utils.default)("JSXSpreadAttribute", {
  visitor: ["argument"],
  aliases: ["JSX"],
  fields: {
    argument: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
(0, _utils.default)("JSXText", {
  aliases: ["JSX", "Immutable"],
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("string")
    }
  }
});
(0, _utils.default)("JSXFragment", {
  builder: ["openingFragment", "closingFragment", "children"],
  visitor: ["openingFragment", "children", "closingFragment"],
  aliases: ["JSX", "Immutable", "Expression"],
  fields: {
    openingFragment: {
      validate: (0, _utils.assertNodeType)("JSXOpeningFragment")
    },
    closingFragment: {
      validate: (0, _utils.assertNodeType)("JSXClosingFragment")
    },
    children: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
    }
  }
});
(0, _utils.default)("JSXOpeningFragment", {
  aliases: ["JSX", "Immutable"]
});
(0, _utils.default)("JSXClosingFragment", {
  aliases: ["JSX", "Immutable"]
});
},{"./utils":71}],68:[function(require,module,exports){
"use strict";

var _utils = _interopRequireWildcard(require("./utils"));

var _placeholders = require("./placeholders");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

(0, _utils.default)("Noop", {
  visitor: []
});
(0, _utils.default)("Placeholder", {
  visitor: [],
  builder: ["expectedNode", "name"],
  fields: {
    name: {
      validate: (0, _utils.assertNodeType)("Identifier")
    },
    expectedNode: {
      validate: (0, _utils.assertOneOf)(..._placeholders.PLACEHOLDERS)
    }
  }
});
(0, _utils.default)("V8IntrinsicIdentifier", {
  builder: ["name"],
  fields: {
    name: {
      validate: (0, _utils.assertValueType)("string")
    }
  }
});
},{"./placeholders":69,"./utils":71}],69:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PLACEHOLDERS_FLIPPED_ALIAS = exports.PLACEHOLDERS_ALIAS = exports.PLACEHOLDERS = void 0;

var _utils = require("./utils");

const PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"];
exports.PLACEHOLDERS = PLACEHOLDERS;
const PLACEHOLDERS_ALIAS = {
  Declaration: ["Statement"],
  Pattern: ["PatternLike", "LVal"]
};
exports.PLACEHOLDERS_ALIAS = PLACEHOLDERS_ALIAS;

for (const type of PLACEHOLDERS) {
  const alias = _utils.ALIAS_KEYS[type];
  if (alias == null ? void 0 : alias.length) PLACEHOLDERS_ALIAS[type] = alias;
}

const PLACEHOLDERS_FLIPPED_ALIAS = {};
exports.PLACEHOLDERS_FLIPPED_ALIAS = PLACEHOLDERS_FLIPPED_ALIAS;
Object.keys(PLACEHOLDERS_ALIAS).forEach(type => {
  PLACEHOLDERS_ALIAS[type].forEach(alias => {
    if (!Object.hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {
      PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];
    }

    PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);
  });
});
},{"./utils":71}],70:[function(require,module,exports){
"use strict";

var _utils = _interopRequireWildcard(require("./utils"));

var _core = require("./core");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const bool = (0, _utils.assertValueType)("boolean");
const tSFunctionTypeAnnotationCommon = {
  returnType: {
    validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"),
    optional: true
  },
  typeParameters: {
    validate: (0, _utils.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
    optional: true
  }
};
(0, _utils.default)("TSParameterProperty", {
  aliases: ["LVal"],
  visitor: ["parameter"],
  fields: {
    accessibility: {
      validate: (0, _utils.assertOneOf)("public", "private", "protected"),
      optional: true
    },
    readonly: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    parameter: {
      validate: (0, _utils.assertNodeType)("Identifier", "AssignmentPattern")
    }
  }
});
(0, _utils.default)("TSDeclareFunction", {
  aliases: ["Statement", "Declaration"],
  visitor: ["id", "typeParameters", "params", "returnType"],
  fields: Object.assign({}, _core.functionDeclarationCommon, tSFunctionTypeAnnotationCommon)
});
(0, _utils.default)("TSDeclareMethod", {
  visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
  fields: Object.assign({}, _core.classMethodOrDeclareMethodCommon, tSFunctionTypeAnnotationCommon)
});
(0, _utils.default)("TSQualifiedName", {
  aliases: ["TSEntityName"],
  visitor: ["left", "right"],
  fields: {
    left: (0, _utils.validateType)("TSEntityName"),
    right: (0, _utils.validateType)("Identifier")
  }
});
const signatureDeclarationCommon = {
  typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
  parameters: (0, _utils.validateArrayOfType)(["Identifier", "RestElement"]),
  typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
};
const callConstructSignatureDeclaration = {
  aliases: ["TSTypeElement"],
  visitor: ["typeParameters", "parameters", "typeAnnotation"],
  fields: signatureDeclarationCommon
};
(0, _utils.default)("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
(0, _utils.default)("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
const namedTypeElementCommon = {
  key: (0, _utils.validateType)("Expression"),
  computed: (0, _utils.validate)(bool),
  optional: (0, _utils.validateOptional)(bool)
};
(0, _utils.default)("TSPropertySignature", {
  aliases: ["TSTypeElement"],
  visitor: ["key", "typeAnnotation", "initializer"],
  fields: Object.assign({}, namedTypeElementCommon, {
    readonly: (0, _utils.validateOptional)(bool),
    typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
    initializer: (0, _utils.validateOptionalType)("Expression")
  })
});
(0, _utils.default)("TSMethodSignature", {
  aliases: ["TSTypeElement"],
  visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
  fields: Object.assign({}, signatureDeclarationCommon, namedTypeElementCommon)
});
(0, _utils.default)("TSIndexSignature", {
  aliases: ["TSTypeElement"],
  visitor: ["parameters", "typeAnnotation"],
  fields: {
    readonly: (0, _utils.validateOptional)(bool),
    parameters: (0, _utils.validateArrayOfType)("Identifier"),
    typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
  }
});
const tsKeywordTypes = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];

for (const type of tsKeywordTypes) {
  (0, _utils.default)(type, {
    aliases: ["TSType", "TSBaseType"],
    visitor: [],
    fields: {}
  });
}

(0, _utils.default)("TSThisType", {
  aliases: ["TSType", "TSBaseType"],
  visitor: [],
  fields: {}
});
const fnOrCtr = {
  aliases: ["TSType"],
  visitor: ["typeParameters", "parameters", "typeAnnotation"],
  fields: signatureDeclarationCommon
};
(0, _utils.default)("TSFunctionType", fnOrCtr);
(0, _utils.default)("TSConstructorType", fnOrCtr);
(0, _utils.default)("TSTypeReference", {
  aliases: ["TSType"],
  visitor: ["typeName", "typeParameters"],
  fields: {
    typeName: (0, _utils.validateType)("TSEntityName"),
    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
  }
});
(0, _utils.default)("TSTypePredicate", {
  aliases: ["TSType"],
  visitor: ["parameterName", "typeAnnotation"],
  builder: ["parameterName", "typeAnnotation", "asserts"],
  fields: {
    parameterName: (0, _utils.validateType)(["Identifier", "TSThisType"]),
    typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
    asserts: (0, _utils.validateOptional)(bool)
  }
});
(0, _utils.default)("TSTypeQuery", {
  aliases: ["TSType"],
  visitor: ["exprName"],
  fields: {
    exprName: (0, _utils.validateType)(["TSEntityName", "TSImportType"])
  }
});
(0, _utils.default)("TSTypeLiteral", {
  aliases: ["TSType"],
  visitor: ["members"],
  fields: {
    members: (0, _utils.validateArrayOfType)("TSTypeElement")
  }
});
(0, _utils.default)("TSArrayType", {
  aliases: ["TSType"],
  visitor: ["elementType"],
  fields: {
    elementType: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSTupleType", {
  aliases: ["TSType"],
  visitor: ["elementTypes"],
  fields: {
    elementTypes: (0, _utils.validateArrayOfType)(["TSType", "TSNamedTupleMember"])
  }
});
(0, _utils.default)("TSOptionalType", {
  aliases: ["TSType"],
  visitor: ["typeAnnotation"],
  fields: {
    typeAnnotation: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSRestType", {
  aliases: ["TSType"],
  visitor: ["typeAnnotation"],
  fields: {
    typeAnnotation: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSNamedTupleMember", {
  visitor: ["label", "elementType"],
  builder: ["label", "elementType", "optional"],
  fields: {
    label: (0, _utils.validateType)("Identifier"),
    optional: {
      validate: bool,
      default: false
    },
    elementType: (0, _utils.validateType)("TSType")
  }
});
const unionOrIntersection = {
  aliases: ["TSType"],
  visitor: ["types"],
  fields: {
    types: (0, _utils.validateArrayOfType)("TSType")
  }
};
(0, _utils.default)("TSUnionType", unionOrIntersection);
(0, _utils.default)("TSIntersectionType", unionOrIntersection);
(0, _utils.default)("TSConditionalType", {
  aliases: ["TSType"],
  visitor: ["checkType", "extendsType", "trueType", "falseType"],
  fields: {
    checkType: (0, _utils.validateType)("TSType"),
    extendsType: (0, _utils.validateType)("TSType"),
    trueType: (0, _utils.validateType)("TSType"),
    falseType: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSInferType", {
  aliases: ["TSType"],
  visitor: ["typeParameter"],
  fields: {
    typeParameter: (0, _utils.validateType)("TSTypeParameter")
  }
});
(0, _utils.default)("TSParenthesizedType", {
  aliases: ["TSType"],
  visitor: ["typeAnnotation"],
  fields: {
    typeAnnotation: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSTypeOperator", {
  aliases: ["TSType"],
  visitor: ["typeAnnotation"],
  fields: {
    operator: (0, _utils.validate)((0, _utils.assertValueType)("string")),
    typeAnnotation: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSIndexedAccessType", {
  aliases: ["TSType"],
  visitor: ["objectType", "indexType"],
  fields: {
    objectType: (0, _utils.validateType)("TSType"),
    indexType: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSMappedType", {
  aliases: ["TSType"],
  visitor: ["typeParameter", "typeAnnotation"],
  fields: {
    readonly: (0, _utils.validateOptional)(bool),
    typeParameter: (0, _utils.validateType)("TSTypeParameter"),
    optional: (0, _utils.validateOptional)(bool),
    typeAnnotation: (0, _utils.validateOptionalType)("TSType")
  }
});
(0, _utils.default)("TSLiteralType", {
  aliases: ["TSType", "TSBaseType"],
  visitor: ["literal"],
  fields: {
    literal: (0, _utils.validateType)(["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral"])
  }
});
(0, _utils.default)("TSExpressionWithTypeArguments", {
  aliases: ["TSType"],
  visitor: ["expression", "typeParameters"],
  fields: {
    expression: (0, _utils.validateType)("TSEntityName"),
    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
  }
});
(0, _utils.default)("TSInterfaceDeclaration", {
  aliases: ["Statement", "Declaration"],
  visitor: ["id", "typeParameters", "extends", "body"],
  fields: {
    declare: (0, _utils.validateOptional)(bool),
    id: (0, _utils.validateType)("Identifier"),
    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
    extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("TSExpressionWithTypeArguments")),
    body: (0, _utils.validateType)("TSInterfaceBody")
  }
});
(0, _utils.default)("TSInterfaceBody", {
  visitor: ["body"],
  fields: {
    body: (0, _utils.validateArrayOfType)("TSTypeElement")
  }
});
(0, _utils.default)("TSTypeAliasDeclaration", {
  aliases: ["Statement", "Declaration"],
  visitor: ["id", "typeParameters", "typeAnnotation"],
  fields: {
    declare: (0, _utils.validateOptional)(bool),
    id: (0, _utils.validateType)("Identifier"),
    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
    typeAnnotation: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSAsExpression", {
  aliases: ["Expression"],
  visitor: ["expression", "typeAnnotation"],
  fields: {
    expression: (0, _utils.validateType)("Expression"),
    typeAnnotation: (0, _utils.validateType)("TSType")
  }
});
(0, _utils.default)("TSTypeAssertion", {
  aliases: ["Expression"],
  visitor: ["typeAnnotation", "expression"],
  fields: {
    typeAnnotation: (0, _utils.validateType)("TSType"),
    expression: (0, _utils.validateType)("Expression")
  }
});
(0, _utils.default)("TSEnumDeclaration", {
  aliases: ["Statement", "Declaration"],
  visitor: ["id", "members"],
  fields: {
    declare: (0, _utils.validateOptional)(bool),
    const: (0, _utils.validateOptional)(bool),
    id: (0, _utils.validateType)("Identifier"),
    members: (0, _utils.validateArrayOfType)("TSEnumMember"),
    initializer: (0, _utils.validateOptionalType)("Expression")
  }
});
(0, _utils.default)("TSEnumMember", {
  visitor: ["id", "initializer"],
  fields: {
    id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
    initializer: (0, _utils.validateOptionalType)("Expression")
  }
});
(0, _utils.default)("TSModuleDeclaration", {
  aliases: ["Statement", "Declaration"],
  visitor: ["id", "body"],
  fields: {
    declare: (0, _utils.validateOptional)(bool),
    global: (0, _utils.validateOptional)(bool),
    id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
    body: (0, _utils.validateType)(["TSModuleBlock", "TSModuleDeclaration"])
  }
});
(0, _utils.default)("TSModuleBlock", {
  aliases: ["Scopable", "Block", "BlockParent"],
  visitor: ["body"],
  fields: {
    body: (0, _utils.validateArrayOfType)("Statement")
  }
});
(0, _utils.default)("TSImportType", {
  aliases: ["TSType"],
  visitor: ["argument", "qualifier", "typeParameters"],
  fields: {
    argument: (0, _utils.validateType)("StringLiteral"),
    qualifier: (0, _utils.validateOptionalType)("TSEntityName"),
    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
  }
});
(0, _utils.default)("TSImportEqualsDeclaration", {
  aliases: ["Statement"],
  visitor: ["id", "moduleReference"],
  fields: {
    isExport: (0, _utils.validate)(bool),
    id: (0, _utils.validateType)("Identifier"),
    moduleReference: (0, _utils.validateType)(["TSEntityName", "TSExternalModuleReference"])
  }
});
(0, _utils.default)("TSExternalModuleReference", {
  visitor: ["expression"],
  fields: {
    expression: (0, _utils.validateType)("StringLiteral")
  }
});
(0, _utils.default)("TSNonNullExpression", {
  aliases: ["Expression"],
  visitor: ["expression"],
  fields: {
    expression: (0, _utils.validateType)("Expression")
  }
});
(0, _utils.default)("TSExportAssignment", {
  aliases: ["Statement"],
  visitor: ["expression"],
  fields: {
    expression: (0, _utils.validateType)("Expression")
  }
});
(0, _utils.default)("TSNamespaceExportDeclaration", {
  aliases: ["Statement"],
  visitor: ["id"],
  fields: {
    id: (0, _utils.validateType)("Identifier")
  }
});
(0, _utils.default)("TSTypeAnnotation", {
  visitor: ["typeAnnotation"],
  fields: {
    typeAnnotation: {
      validate: (0, _utils.assertNodeType)("TSType")
    }
  }
});
(0, _utils.default)("TSTypeParameterInstantiation", {
  visitor: ["params"],
  fields: {
    params: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSType")))
    }
  }
});
(0, _utils.default)("TSTypeParameterDeclaration", {
  visitor: ["params"],
  fields: {
    params: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSTypeParameter")))
    }
  }
});
(0, _utils.default)("TSTypeParameter", {
  builder: ["constraint", "default", "name"],
  visitor: ["constraint", "default"],
  fields: {
    name: {
      validate: (0, _utils.assertValueType)("string")
    },
    constraint: {
      validate: (0, _utils.assertNodeType)("TSType"),
      optional: true
    },
    default: {
      validate: (0, _utils.assertNodeType)("TSType"),
      optional: true
    }
  }
});
},{"./core":63,"./utils":71}],71:[function(require,module,exports){
(function (process){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validate = validate;
exports.typeIs = typeIs;
exports.validateType = validateType;
exports.validateOptional = validateOptional;
exports.validateOptionalType = validateOptionalType;
exports.arrayOf = arrayOf;
exports.arrayOfType = arrayOfType;
exports.validateArrayOfType = validateArrayOfType;
exports.assertEach = assertEach;
exports.assertOneOf = assertOneOf;
exports.assertNodeType = assertNodeType;
exports.assertNodeOrValueType = assertNodeOrValueType;
exports.assertValueType = assertValueType;
exports.assertShape = assertShape;
exports.assertOptionalChainStart = assertOptionalChainStart;
exports.chain = chain;
exports.default = defineType;
exports.NODE_PARENT_VALIDATIONS = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.NODE_FIELDS = exports.FLIPPED_ALIAS_KEYS = exports.ALIAS_KEYS = exports.VISITOR_KEYS = void 0;

var _is = _interopRequireDefault(require("../validators/is"));

var _validate = require("../validators/validate");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const VISITOR_KEYS = {};
exports.VISITOR_KEYS = VISITOR_KEYS;
const ALIAS_KEYS = {};
exports.ALIAS_KEYS = ALIAS_KEYS;
const FLIPPED_ALIAS_KEYS = {};
exports.FLIPPED_ALIAS_KEYS = FLIPPED_ALIAS_KEYS;
const NODE_FIELDS = {};
exports.NODE_FIELDS = NODE_FIELDS;
const BUILDER_KEYS = {};
exports.BUILDER_KEYS = BUILDER_KEYS;
const DEPRECATED_KEYS = {};
exports.DEPRECATED_KEYS = DEPRECATED_KEYS;
const NODE_PARENT_VALIDATIONS = {};
exports.NODE_PARENT_VALIDATIONS = NODE_PARENT_VALIDATIONS;

function getType(val) {
  if (Array.isArray(val)) {
    return "array";
  } else if (val === null) {
    return "null";
  } else {
    return typeof val;
  }
}

function validate(validate) {
  return {
    validate
  };
}

function typeIs(typeName) {
  return typeof typeName === "string" ? assertNodeType(typeName) : assertNodeType(...typeName);
}

function validateType(typeName) {
  return validate(typeIs(typeName));
}

function validateOptional(validate) {
  return {
    validate,
    optional: true
  };
}

function validateOptionalType(typeName) {
  return {
    validate: typeIs(typeName),
    optional: true
  };
}

function arrayOf(elementType) {
  return chain(assertValueType("array"), assertEach(elementType));
}

function arrayOfType(typeName) {
  return arrayOf(typeIs(typeName));
}

function validateArrayOfType(typeName) {
  return validate(arrayOfType(typeName));
}

function assertEach(callback) {
  function validator(node, key, val) {
    if (!Array.isArray(val)) return;

    for (let i = 0; i < val.length; i++) {
      const subkey = `${key}[${i}]`;
      const v = val[i];
      callback(node, subkey, v);
      if (process.env.BABEL_TYPES_8_BREAKING) (0, _validate.validateChild)(node, subkey, v);
    }
  }

  validator.each = callback;
  return validator;
}

function assertOneOf(...values) {
  function validate(node, key, val) {
    if (values.indexOf(val) < 0) {
      throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
    }
  }

  validate.oneOf = values;
  return validate;
}

function assertNodeType(...types) {
  function validate(node, key, val) {
    for (const type of types) {
      if ((0, _is.default)(type, val)) {
        (0, _validate.validateChild)(node, key, val);
        return;
      }
    }

    throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
  }

  validate.oneOfNodeTypes = types;
  return validate;
}

function assertNodeOrValueType(...types) {
  function validate(node, key, val) {
    for (const type of types) {
      if (getType(val) === type || (0, _is.default)(type, val)) {
        (0, _validate.validateChild)(node, key, val);
        return;
      }
    }

    throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
  }

  validate.oneOfNodeOrValueTypes = types;
  return validate;
}

function assertValueType(type) {
  function validate(node, key, val) {
    const valid = getType(val) === type;

    if (!valid) {
      throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
    }
  }

  validate.type = type;
  return validate;
}

function assertShape(shape) {
  function validate(node, key, val) {
    const errors = [];

    for (const property of Object.keys(shape)) {
      try {
        (0, _validate.validateField)(node, property, val[property], shape[property]);
      } catch (error) {
        if (error instanceof TypeError) {
          errors.push(error.message);
          continue;
        }

        throw error;
      }
    }

    if (errors.length) {
      throw new TypeError(`Property ${key} of ${node.type} expected to have the following:\n${errors.join("\n")}`);
    }
  }

  validate.shapeOf = shape;
  return validate;
}

function assertOptionalChainStart() {
  function validate(node) {
    var _current;

    let current = node;

    while (node) {
      const {
        type
      } = current;

      if (type === "OptionalCallExpression") {
        if (current.optional) return;
        current = current.callee;
        continue;
      }

      if (type === "OptionalMemberExpression") {
        if (current.optional) return;
        current = current.object;
        continue;
      }

      break;
    }

    throw new TypeError(`Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(_current = current) == null ? void 0 : _current.type}`);
  }

  return validate;
}

function chain(...fns) {
  function validate(...args) {
    for (const fn of fns) {
      fn(...args);
    }
  }

  validate.chainOf = fns;
  return validate;
}

const validTypeOpts = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"];
const validFieldKeys = ["default", "optional", "validate"];

function defineType(type, opts = {}) {
  const inherits = opts.inherits && store[opts.inherits] || {};
  let fields = opts.fields;

  if (!fields) {
    fields = {};

    if (inherits.fields) {
      const keys = Object.getOwnPropertyNames(inherits.fields);

      for (const key of keys) {
        const field = inherits.fields[key];
        fields[key] = {
          default: field.default,
          optional: field.optional,
          validate: field.validate
        };
      }
    }
  }

  const visitor = opts.visitor || inherits.visitor || [];
  const aliases = opts.aliases || inherits.aliases || [];
  const builder = opts.builder || inherits.builder || opts.visitor || [];

  for (const k of Object.keys(opts)) {
    if (validTypeOpts.indexOf(k) === -1) {
      throw new Error(`Unknown type option "${k}" on ${type}`);
    }
  }

  if (opts.deprecatedAlias) {
    DEPRECATED_KEYS[opts.deprecatedAlias] = type;
  }

  for (const key of visitor.concat(builder)) {
    fields[key] = fields[key] || {};
  }

  for (const key of Object.keys(fields)) {
    const field = fields[key];

    if (field.default !== undefined && builder.indexOf(key) === -1) {
      field.optional = true;
    }

    if (field.default === undefined) {
      field.default = null;
    } else if (!field.validate && field.default != null) {
      field.validate = assertValueType(getType(field.default));
    }

    for (const k of Object.keys(field)) {
      if (validFieldKeys.indexOf(k) === -1) {
        throw new Error(`Unknown field key "${k}" on ${type}.${key}`);
      }
    }
  }

  VISITOR_KEYS[type] = opts.visitor = visitor;
  BUILDER_KEYS[type] = opts.builder = builder;
  NODE_FIELDS[type] = opts.fields = fields;
  ALIAS_KEYS[type] = opts.aliases = aliases;
  aliases.forEach(alias => {
    FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
    FLIPPED_ALIAS_KEYS[alias].push(type);
  });

  if (opts.validate) {
    NODE_PARENT_VALIDATIONS[type] = opts.validate;
  }

  store[type] = opts;
}

const store = {};
}).call(this,require('_process'))

},{"../validators/is":89,"../validators/validate":107,"_process":224}],72:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  react: true,
  assertNode: true,
  createTypeAnnotationBasedOnTypeof: true,
  createUnionTypeAnnotation: true,
  createFlowUnionType: true,
  createTSUnionType: true,
  cloneNode: true,
  clone: true,
  cloneDeep: true,
  cloneDeepWithoutLoc: true,
  cloneWithoutLoc: true,
  addComment: true,
  addComments: true,
  inheritInnerComments: true,
  inheritLeadingComments: true,
  inheritsComments: true,
  inheritTrailingComments: true,
  removeComments: true,
  ensureBlock: true,
  toBindingIdentifierName: true,
  toBlock: true,
  toComputedKey: true,
  toExpression: true,
  toIdentifier: true,
  toKeyAlias: true,
  toSequenceExpression: true,
  toStatement: true,
  valueToNode: true,
  appendToMemberExpression: true,
  inherits: true,
  prependToMemberExpression: true,
  removeProperties: true,
  removePropertiesDeep: true,
  removeTypeDuplicates: true,
  getBindingIdentifiers: true,
  getOuterBindingIdentifiers: true,
  traverse: true,
  traverseFast: true,
  shallowEqual: true,
  is: true,
  isBinding: true,
  isBlockScoped: true,
  isImmutable: true,
  isLet: true,
  isNode: true,
  isNodesEquivalent: true,
  isPlaceholderType: true,
  isReferenced: true,
  isScope: true,
  isSpecifierDefault: true,
  isType: true,
  isValidES3Identifier: true,
  isValidIdentifier: true,
  isVar: true,
  matchesPattern: true,
  validate: true,
  buildMatchMemberExpression: true
};
Object.defineProperty(exports, "assertNode", {
  enumerable: true,
  get: function () {
    return _assertNode.default;
  }
});
Object.defineProperty(exports, "createTypeAnnotationBasedOnTypeof", {
  enumerable: true,
  get: function () {
    return _createTypeAnnotationBasedOnTypeof.default;
  }
});
Object.defineProperty(exports, "createUnionTypeAnnotation", {
  enumerable: true,
  get: function () {
    return _createFlowUnionType.default;
  }
});
Object.defineProperty(exports, "createFlowUnionType", {
  enumerable: true,
  get: function () {
    return _createFlowUnionType.default;
  }
});
Object.defineProperty(exports, "createTSUnionType", {
  enumerable: true,
  get: function () {
    return _createTSUnionType.default;
  }
});
Object.defineProperty(exports, "cloneNode", {
  enumerable: true,
  get: function () {
    return _cloneNode.default;
  }
});
Object.defineProperty(exports, "clone", {
  enumerable: true,
  get: function () {
    return _clone.default;
  }
});
Object.defineProperty(exports, "cloneDeep", {
  enumerable: true,
  get: function () {
    return _cloneDeep.default;
  }
});
Object.defineProperty(exports, "cloneDeepWithoutLoc", {
  enumerable: true,
  get: function () {
    return _cloneDeepWithoutLoc.default;
  }
});
Object.defineProperty(exports, "cloneWithoutLoc", {
  enumerable: true,
  get: function () {
    return _cloneWithoutLoc.default;
  }
});
Object.defineProperty(exports, "addComment", {
  enumerable: true,
  get: function () {
    return _addComment.default;
  }
});
Object.defineProperty(exports, "addComments", {
  enumerable: true,
  get: function () {
    return _addComments.default;
  }
});
Object.defineProperty(exports, "inheritInnerComments", {
  enumerable: true,
  get: function () {
    return _inheritInnerComments.default;
  }
});
Object.defineProperty(exports, "inheritLeadingComments", {
  enumerable: true,
  get: function () {
    return _inheritLeadingComments.default;
  }
});
Object.defineProperty(exports, "inheritsComments", {
  enumerable: true,
  get: function () {
    return _inheritsComments.default;
  }
});
Object.defineProperty(exports, "inheritTrailingComments", {
  enumerable: true,
  get: function () {
    return _inheritTrailingComments.default;
  }
});
Object.defineProperty(exports, "removeComments", {
  enumerable: true,
  get: function () {
    return _removeComments.default;
  }
});
Object.defineProperty(exports, "ensureBlock", {
  enumerable: true,
  get: function () {
    return _ensureBlock.default;
  }
});
Object.defineProperty(exports, "toBindingIdentifierName", {
  enumerable: true,
  get: function () {
    return _toBindingIdentifierName.default;
  }
});
Object.defineProperty(exports, "toBlock", {
  enumerable: true,
  get: function () {
    return _toBlock.default;
  }
});
Object.defineProperty(exports, "toComputedKey", {
  enumerable: true,
  get: function () {
    return _toComputedKey.default;
  }
});
Object.defineProperty(exports, "toExpression", {
  enumerable: true,
  get: function () {
    return _toExpression.default;
  }
});
Object.defineProperty(exports, "toIdentifier", {
  enumerable: true,
  get: function () {
    return _toIdentifier.default;
  }
});
Object.defineProperty(exports, "toKeyAlias", {
  enumerable: true,
  get: function () {
    return _toKeyAlias.default;
  }
});
Object.defineProperty(exports, "toSequenceExpression", {
  enumerable: true,
  get: function () {
    return _toSequenceExpression.default;
  }
});
Object.defineProperty(exports, "toStatement", {
  enumerable: true,
  get: function () {
    return _toStatement.default;
  }
});
Object.defineProperty(exports, "valueToNode", {
  enumerable: true,
  get: function () {
    return _valueToNode.default;
  }
});
Object.defineProperty(exports, "appendToMemberExpression", {
  enumerable: true,
  get: function () {
    return _appendToMemberExpression.default;
  }
});
Object.defineProperty(exports, "inherits", {
  enumerable: true,
  get: function () {
    return _inherits.default;
  }
});
Object.defineProperty(exports, "prependToMemberExpression", {
  enumerable: true,
  get: function () {
    return _prependToMemberExpression.default;
  }
});
Object.defineProperty(exports, "removeProperties", {
  enumerable: true,
  get: function () {
    return _removeProperties.default;
  }
});
Object.defineProperty(exports, "removePropertiesDeep", {
  enumerable: true,
  get: function () {
    return _removePropertiesDeep.default;
  }
});
Object.defineProperty(exports, "removeTypeDuplicates", {
  enumerable: true,
  get: function () {
    return _removeTypeDuplicates.default;
  }
});
Object.defineProperty(exports, "getBindingIdentifiers", {
  enumerable: true,
  get: function () {
    return _getBindingIdentifiers.default;
  }
});
Object.defineProperty(exports, "getOuterBindingIdentifiers", {
  enumerable: true,
  get: function () {
    return _getOuterBindingIdentifiers.default;
  }
});
Object.defineProperty(exports, "traverse", {
  enumerable: true,
  get: function () {
    return _traverse.default;
  }
});
Object.defineProperty(exports, "traverseFast", {
  enumerable: true,
  get: function () {
    return _traverseFast.default;
  }
});
Object.defineProperty(exports, "shallowEqual", {
  enumerable: true,
  get: function () {
    return _shallowEqual.default;
  }
});
Object.defineProperty(exports, "is", {
  enumerable: true,
  get: function () {
    return _is.default;
  }
});
Object.defineProperty(exports, "isBinding", {
  enumerable: true,
  get: function () {
    return _isBinding.default;
  }
});
Object.defineProperty(exports, "isBlockScoped", {
  enumerable: true,
  get: function () {
    return _isBlockScoped.default;
  }
});
Object.defineProperty(exports, "isImmutable", {
  enumerable: true,
  get: function () {
    return _isImmutable.default;
  }
});
Object.defineProperty(exports, "isLet", {
  enumerable: true,
  get: function () {
    return _isLet.default;
  }
});
Object.defineProperty(exports, "isNode", {
  enumerable: true,
  get: function () {
    return _isNode.default;
  }
});
Object.defineProperty(exports, "isNodesEquivalent", {
  enumerable: true,
  get: function () {
    return _isNodesEquivalent.default;
  }
});
Object.defineProperty(exports, "isPlaceholderType", {
  enumerable: true,
  get: function () {
    return _isPlaceholderType.default;
  }
});
Object.defineProperty(exports, "isReferenced", {
  enumerable: true,
  get: function () {
    return _isReferenced.default;
  }
});
Object.defineProperty(exports, "isScope", {
  enumerable: true,
  get: function () {
    return _isScope.default;
  }
});
Object.defineProperty(exports, "isSpecifierDefault", {
  enumerable: true,
  get: function () {
    return _isSpecifierDefault.default;
  }
});
Object.defineProperty(exports, "isType", {
  enumerable: true,
  get: function () {
    return _isType.default;
  }
});
Object.defineProperty(exports, "isValidES3Identifier", {
  enumerable: true,
  get: function () {
    return _isValidES3Identifier.default;
  }
});
Object.defineProperty(exports, "isValidIdentifier", {
  enumerable: true,
  get: function () {
    return _isValidIdentifier.default;
  }
});
Object.defineProperty(exports, "isVar", {
  enumerable: true,
  get: function () {
    return _isVar.default;
  }
});
Object.defineProperty(exports, "matchesPattern", {
  enumerable: true,
  get: function () {
    return _matchesPattern.default;
  }
});
Object.defineProperty(exports, "validate", {
  enumerable: true,
  get: function () {
    return _validate.default;
  }
});
Object.defineProperty(exports, "buildMatchMemberExpression", {
  enumerable: true,
  get: function () {
    return _buildMatchMemberExpression.default;
  }
});
exports.react = void 0;

var _isReactComponent = _interopRequireDefault(require("./validators/react/isReactComponent"));

var _isCompatTag = _interopRequireDefault(require("./validators/react/isCompatTag"));

var _buildChildren = _interopRequireDefault(require("./builders/react/buildChildren"));

var _assertNode = _interopRequireDefault(require("./asserts/assertNode"));

var _generated = require("./asserts/generated");

Object.keys(_generated).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _generated[key];
    }
  });
});

var _createTypeAnnotationBasedOnTypeof = _interopRequireDefault(require("./builders/flow/createTypeAnnotationBasedOnTypeof"));

var _createFlowUnionType = _interopRequireDefault(require("./builders/flow/createFlowUnionType"));

var _createTSUnionType = _interopRequireDefault(require("./builders/typescript/createTSUnionType"));

var _generated2 = require("./builders/generated");

Object.keys(_generated2).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _generated2[key];
    }
  });
});

var _cloneNode = _interopRequireDefault(require("./clone/cloneNode"));

var _clone = _interopRequireDefault(require("./clone/clone"));

var _cloneDeep = _interopRequireDefault(require("./clone/cloneDeep"));

var _cloneDeepWithoutLoc = _interopRequireDefault(require("./clone/cloneDeepWithoutLoc"));

var _cloneWithoutLoc = _interopRequireDefault(require("./clone/cloneWithoutLoc"));

var _addComment = _interopRequireDefault(require("./comments/addComment"));

var _addComments = _interopRequireDefault(require("./comments/addComments"));

var _inheritInnerComments = _interopRequireDefault(require("./comments/inheritInnerComments"));

var _inheritLeadingComments = _interopRequireDefault(require("./comments/inheritLeadingComments"));

var _inheritsComments = _interopRequireDefault(require("./comments/inheritsComments"));

var _inheritTrailingComments = _interopRequireDefault(require("./comments/inheritTrailingComments"));

var _removeComments = _interopRequireDefault(require("./comments/removeComments"));

var _generated3 = require("./constants/generated");

Object.keys(_generated3).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _generated3[key];
    }
  });
});

var _constants = require("./constants");

Object.keys(_constants).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _constants[key];
    }
  });
});

var _ensureBlock = _interopRequireDefault(require("./converters/ensureBlock"));

var _toBindingIdentifierName = _interopRequireDefault(require("./converters/toBindingIdentifierName"));

var _toBlock = _interopRequireDefault(require("./converters/toBlock"));

var _toComputedKey = _interopRequireDefault(require("./converters/toComputedKey"));

var _toExpression = _interopRequireDefault(require("./converters/toExpression"));

var _toIdentifier = _interopRequireDefault(require("./converters/toIdentifier"));

var _toKeyAlias = _interopRequireDefault(require("./converters/toKeyAlias"));

var _toSequenceExpression = _interopRequireDefault(require("./converters/toSequenceExpression"));

var _toStatement = _interopRequireDefault(require("./converters/toStatement"));

var _valueToNode = _interopRequireDefault(require("./converters/valueToNode"));

var _definitions = require("./definitions");

Object.keys(_definitions).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _definitions[key];
    }
  });
});

var _appendToMemberExpression = _interopRequireDefault(require("./modifications/appendToMemberExpression"));

var _inherits = _interopRequireDefault(require("./modifications/inherits"));

var _prependToMemberExpression = _interopRequireDefault(require("./modifications/prependToMemberExpression"));

var _removeProperties = _interopRequireDefault(require("./modifications/removeProperties"));

var _removePropertiesDeep = _interopRequireDefault(require("./modifications/removePropertiesDeep"));

var _removeTypeDuplicates = _interopRequireDefault(require("./modifications/flow/removeTypeDuplicates"));

var _getBindingIdentifiers = _interopRequireDefault(require("./retrievers/getBindingIdentifiers"));

var _getOuterBindingIdentifiers = _interopRequireDefault(require("./retrievers/getOuterBindingIdentifiers"));

var _traverse = _interopRequireDefault(require("./traverse/traverse"));

var _traverseFast = _interopRequireDefault(require("./traverse/traverseFast"));

var _shallowEqual = _interopRequireDefault(require("./utils/shallowEqual"));

var _is = _interopRequireDefault(require("./validators/is"));

var _isBinding = _interopRequireDefault(require("./validators/isBinding"));

var _isBlockScoped = _interopRequireDefault(require("./validators/isBlockScoped"));

var _isImmutable = _interopRequireDefault(require("./validators/isImmutable"));

var _isLet = _interopRequireDefault(require("./validators/isLet"));

var _isNode = _interopRequireDefault(require("./validators/isNode"));

var _isNodesEquivalent = _interopRequireDefault(require("./validators/isNodesEquivalent"));

var _isPlaceholderType = _interopRequireDefault(require("./validators/isPlaceholderType"));

var _isReferenced = _interopRequireDefault(require("./validators/isReferenced"));

var _isScope = _interopRequireDefault(require("./validators/isScope"));

var _isSpecifierDefault = _interopRequireDefault(require("./validators/isSpecifierDefault"));

var _isType = _interopRequireDefault(require("./validators/isType"));

var _isValidES3Identifier = _interopRequireDefault(require("./validators/isValidES3Identifier"));

var _isValidIdentifier = _interopRequireDefault(require("./validators/isValidIdentifier"));

var _isVar = _interopRequireDefault(require("./validators/isVar"));

var _matchesPattern = _interopRequireDefault(require("./validators/matchesPattern"));

var _validate = _interopRequireDefault(require("./validators/validate"));

var _buildMatchMemberExpression = _interopRequireDefault(require("./validators/buildMatchMemberExpression"));

var _generated4 = require("./validators/generated");

Object.keys(_generated4).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _generated4[key];
    }
  });
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const react = {
  isReactComponent: _isReactComponent.default,
  isCompatTag: _isCompatTag.default,
  buildChildren: _buildChildren.default
};
exports.react = react;
},{"./asserts/assertNode":30,"./asserts/generated":31,"./builders/flow/createFlowUnionType":33,"./builders/flow/createTypeAnnotationBasedOnTypeof":34,"./builders/generated":35,"./builders/react/buildChildren":36,"./builders/typescript/createTSUnionType":37,"./clone/clone":38,"./clone/cloneDeep":39,"./clone/cloneDeepWithoutLoc":40,"./clone/cloneNode":41,"./clone/cloneWithoutLoc":42,"./comments/addComment":43,"./comments/addComments":44,"./comments/inheritInnerComments":45,"./comments/inheritLeadingComments":46,"./comments/inheritTrailingComments":47,"./comments/inheritsComments":48,"./comments/removeComments":49,"./constants":51,"./constants/generated":50,"./converters/ensureBlock":52,"./converters/toBindingIdentifierName":54,"./converters/toBlock":55,"./converters/toComputedKey":56,"./converters/toExpression":57,"./converters/toIdentifier":58,"./converters/toKeyAlias":59,"./converters/toSequenceExpression":60,"./converters/toStatement":61,"./converters/valueToNode":62,"./definitions":66,"./modifications/appendToMemberExpression":73,"./modifications/flow/removeTypeDuplicates":74,"./modifications/inherits":75,"./modifications/prependToMemberExpression":76,"./modifications/removeProperties":77,"./modifications/removePropertiesDeep":78,"./retrievers/getBindingIdentifiers":80,"./retrievers/getOuterBindingIdentifiers":81,"./traverse/traverse":82,"./traverse/traverseFast":83,"./utils/shallowEqual":86,"./validators/buildMatchMemberExpression":87,"./validators/generated":88,"./validators/is":89,"./validators/isBinding":90,"./validators/isBlockScoped":91,"./validators/isImmutable":92,"./validators/isLet":93,"./validators/isNode":94,"./validators/isNodesEquivalent":95,"./validators/isPlaceholderType":96,"./validators/isReferenced":97,"./validators/isScope":98,"./validators/isSpecifierDefault":99,"./validators/isType":100,"./validators/isValidES3Identifier":101,"./validators/isValidIdentifier":102,"./validators/isVar":103,"./validators/matchesPattern":104,"./validators/react/isCompatTag":105,"./validators/react/isReactComponent":106,"./validators/validate":107}],73:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = appendToMemberExpression;

var _generated = require("../builders/generated");

function appendToMemberExpression(member, append, computed = false) {
  member.object = (0, _generated.memberExpression)(member.object, member.property, member.computed);
  member.property = append;
  member.computed = !!computed;
  return member;
}
},{"../builders/generated":35}],74:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = removeTypeDuplicates;

var _generated = require("../../validators/generated");

function removeTypeDuplicates(nodes) {
  const generics = {};
  const bases = {};
  const typeGroups = [];
  const types = [];

  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (!node) continue;

    if (types.indexOf(node) >= 0) {
      continue;
    }

    if ((0, _generated.isAnyTypeAnnotation)(node)) {
      return [node];
    }

    if ((0, _generated.isFlowBaseAnnotation)(node)) {
      bases[node.type] = node;
      continue;
    }

    if ((0, _generated.isUnionTypeAnnotation)(node)) {
      if (typeGroups.indexOf(node.types) < 0) {
        nodes = nodes.concat(node.types);
        typeGroups.push(node.types);
      }

      continue;
    }

    if ((0, _generated.isGenericTypeAnnotation)(node)) {
      const name = node.id.name;

      if (generics[name]) {
        let existing = generics[name];

        if (existing.typeParameters) {
          if (node.typeParameters) {
            existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));
          }
        } else {
          existing = node.typeParameters;
        }
      } else {
        generics[name] = node;
      }

      continue;
    }

    types.push(node);
  }

  for (const type of Object.keys(bases)) {
    types.push(bases[type]);
  }

  for (const name of Object.keys(generics)) {
    types.push(generics[name]);
  }

  return types;
}
},{"../../validators/generated":88}],75:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = inherits;

var _constants = require("../constants");

var _inheritsComments = _interopRequireDefault(require("../comments/inheritsComments"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function inherits(child, parent) {
  if (!child || !parent) return child;

  for (const key of _constants.INHERIT_KEYS.optional) {
    if (child[key] == null) {
      child[key] = parent[key];
    }
  }

  for (const key of Object.keys(parent)) {
    if (key[0] === "_" && key !== "__clone") child[key] = parent[key];
  }

  for (const key of _constants.INHERIT_KEYS.force) {
    child[key] = parent[key];
  }

  (0, _inheritsComments.default)(child, parent);
  return child;
}
},{"../comments/inheritsComments":48,"../constants":51}],76:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = prependToMemberExpression;

var _generated = require("../builders/generated");

function prependToMemberExpression(member, prepend) {
  member.object = (0, _generated.memberExpression)(prepend, member.object);
  return member;
}
},{"../builders/generated":35}],77:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = removeProperties;

var _constants = require("../constants");

const CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"];

const CLEAR_KEYS_PLUS_COMMENTS = _constants.COMMENT_KEYS.concat(["comments"]).concat(CLEAR_KEYS);

function removeProperties(node, opts = {}) {
  const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;

  for (const key of map) {
    if (node[key] != null) node[key] = undefined;
  }

  for (const key of Object.keys(node)) {
    if (key[0] === "_" && node[key] != null) node[key] = undefined;
  }

  const symbols = Object.getOwnPropertySymbols(node);

  for (const sym of symbols) {
    node[sym] = null;
  }
}
},{"../constants":51}],78:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = removePropertiesDeep;

var _traverseFast = _interopRequireDefault(require("../traverse/traverseFast"));

var _removeProperties = _interopRequireDefault(require("./removeProperties"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function removePropertiesDeep(tree, opts) {
  (0, _traverseFast.default)(tree, _removeProperties.default, opts);
  return tree;
}
},{"../traverse/traverseFast":83,"./removeProperties":77}],79:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = removeTypeDuplicates;

var _generated = require("../../validators/generated");

function removeTypeDuplicates(nodes) {
  const generics = {};
  const bases = {};
  const typeGroups = [];
  const types = [];

  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    if (!node) continue;

    if (types.indexOf(node) >= 0) {
      continue;
    }

    if ((0, _generated.isTSAnyKeyword)(node.type)) {
      return [node];
    }

    if ((0, _generated.isTSBaseType)(node)) {
      bases[node.type] = node;
      continue;
    }

    if ((0, _generated.isTSUnionType)(node)) {
      if (typeGroups.indexOf(node.types) < 0) {
        nodes = nodes.concat(node.types);
        typeGroups.push(node.types);
      }

      continue;
    }

    types.push(node);
  }

  for (const type of Object.keys(bases)) {
    types.push(bases[type]);
  }

  for (const name of Object.keys(generics)) {
    types.push(generics[name]);
  }

  return types;
}
},{"../../validators/generated":88}],80:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getBindingIdentifiers;

var _generated = require("../validators/generated");

function getBindingIdentifiers(node, duplicates, outerOnly) {
  let search = [].concat(node);
  const ids = Object.create(null);

  while (search.length) {
    const id = search.shift();
    if (!id) continue;
    const keys = getBindingIdentifiers.keys[id.type];

    if ((0, _generated.isIdentifier)(id)) {
      if (duplicates) {
        const _ids = ids[id.name] = ids[id.name] || [];

        _ids.push(id);
      } else {
        ids[id.name] = id;
      }

      continue;
    }

    if ((0, _generated.isExportDeclaration)(id)) {
      if ((0, _generated.isDeclaration)(id.declaration)) {
        search.push(id.declaration);
      }

      continue;
    }

    if (outerOnly) {
      if ((0, _generated.isFunctionDeclaration)(id)) {
        search.push(id.id);
        continue;
      }

      if ((0, _generated.isFunctionExpression)(id)) {
        continue;
      }
    }

    if (keys) {
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];

        if (id[key]) {
          search = search.concat(id[key]);
        }
      }
    }
  }

  return ids;
}

getBindingIdentifiers.keys = {
  DeclareClass: ["id"],
  DeclareFunction: ["id"],
  DeclareModule: ["id"],
  DeclareVariable: ["id"],
  DeclareInterface: ["id"],
  DeclareTypeAlias: ["id"],
  DeclareOpaqueType: ["id"],
  InterfaceDeclaration: ["id"],
  TypeAlias: ["id"],
  OpaqueType: ["id"],
  CatchClause: ["param"],
  LabeledStatement: ["label"],
  UnaryExpression: ["argument"],
  AssignmentExpression: ["left"],
  ImportSpecifier: ["local"],
  ImportNamespaceSpecifier: ["local"],
  ImportDefaultSpecifier: ["local"],
  ImportDeclaration: ["specifiers"],
  ExportSpecifier: ["exported"],
  ExportNamespaceSpecifier: ["exported"],
  ExportDefaultSpecifier: ["exported"],
  FunctionDeclaration: ["id", "params"],
  FunctionExpression: ["id", "params"],
  ArrowFunctionExpression: ["params"],
  ObjectMethod: ["params"],
  ClassMethod: ["params"],
  ForInStatement: ["left"],
  ForOfStatement: ["left"],
  ClassDeclaration: ["id"],
  ClassExpression: ["id"],
  RestElement: ["argument"],
  UpdateExpression: ["argument"],
  ObjectProperty: ["value"],
  AssignmentPattern: ["left"],
  ArrayPattern: ["elements"],
  ObjectPattern: ["properties"],
  VariableDeclaration: ["declarations"],
  VariableDeclarator: ["id"]
};
},{"../validators/generated":88}],81:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getOuterBindingIdentifiers;

var _getBindingIdentifiers = _interopRequireDefault(require("./getBindingIdentifiers"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getOuterBindingIdentifiers(node, duplicates) {
  return (0, _getBindingIdentifiers.default)(node, duplicates, true);
}
},{"./getBindingIdentifiers":80}],82:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = traverse;

var _definitions = require("../definitions");

function traverse(node, handlers, state) {
  if (typeof handlers === "function") {
    handlers = {
      enter: handlers
    };
  }

  const {
    enter,
    exit
  } = handlers;
  traverseSimpleImpl(node, enter, exit, state, []);
}

function traverseSimpleImpl(node, enter, exit, state, ancestors) {
  const keys = _definitions.VISITOR_KEYS[node.type];
  if (!keys) return;
  if (enter) enter(node, ancestors, state);

  for (const key of keys) {
    const subNode = node[key];

    if (Array.isArray(subNode)) {
      for (let i = 0; i < subNode.length; i++) {
        const child = subNode[i];
        if (!child) continue;
        ancestors.push({
          node,
          key,
          index: i
        });
        traverseSimpleImpl(child, enter, exit, state, ancestors);
        ancestors.pop();
      }
    } else if (subNode) {
      ancestors.push({
        node,
        key
      });
      traverseSimpleImpl(subNode, enter, exit, state, ancestors);
      ancestors.pop();
    }
  }

  if (exit) exit(node, ancestors, state);
}
},{"../definitions":66}],83:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = traverseFast;

var _definitions = require("../definitions");

function traverseFast(node, enter, opts) {
  if (!node) return;
  const keys = _definitions.VISITOR_KEYS[node.type];
  if (!keys) return;
  opts = opts || {};
  enter(node, opts);

  for (const key of keys) {
    const subNode = node[key];

    if (Array.isArray(subNode)) {
      for (const node of subNode) {
        traverseFast(node, enter, opts);
      }
    } else {
      traverseFast(subNode, enter, opts);
    }
  }
}
},{"../definitions":66}],84:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = inherit;

function inherit(key, child, parent) {
  if (child && parent) {
    child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean)));
  }
}
},{}],85:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cleanJSXElementLiteralChild;

var _generated = require("../../builders/generated");

function cleanJSXElementLiteralChild(child, args) {
  const lines = child.value.split(/\r\n|\n|\r/);
  let lastNonEmptyLine = 0;

  for (let i = 0; i < lines.length; i++) {
    if (lines[i].match(/[^ \t]/)) {
      lastNonEmptyLine = i;
    }
  }

  let str = "";

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const isFirstLine = i === 0;
    const isLastLine = i === lines.length - 1;
    const isLastNonEmptyLine = i === lastNonEmptyLine;
    let trimmedLine = line.replace(/\t/g, " ");

    if (!isFirstLine) {
      trimmedLine = trimmedLine.replace(/^[ ]+/, "");
    }

    if (!isLastLine) {
      trimmedLine = trimmedLine.replace(/[ ]+$/, "");
    }

    if (trimmedLine) {
      if (!isLastNonEmptyLine) {
        trimmedLine += " ";
      }

      str += trimmedLine;
    }
  }

  if (str) args.push((0, _generated.stringLiteral)(str));
}
},{"../../builders/generated":35}],86:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = shallowEqual;

function shallowEqual(actual, expected) {
  const keys = Object.keys(expected);

  for (const key of keys) {
    if (actual[key] !== expected[key]) {
      return false;
    }
  }

  return true;
}
},{}],87:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = buildMatchMemberExpression;

var _matchesPattern = _interopRequireDefault(require("./matchesPattern"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function buildMatchMemberExpression(match, allowPartial) {
  const parts = match.split(".");
  return member => (0, _matchesPattern.default)(member, parts, allowPartial);
}
},{"./matchesPattern":104}],88:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isArrayExpression = isArrayExpression;
exports.isAssignmentExpression = isAssignmentExpression;
exports.isBinaryExpression = isBinaryExpression;
exports.isInterpreterDirective = isInterpreterDirective;
exports.isDirective = isDirective;
exports.isDirectiveLiteral = isDirectiveLiteral;
exports.isBlockStatement = isBlockStatement;
exports.isBreakStatement = isBreakStatement;
exports.isCallExpression = isCallExpression;
exports.isCatchClause = isCatchClause;
exports.isConditionalExpression = isConditionalExpression;
exports.isContinueStatement = isContinueStatement;
exports.isDebuggerStatement = isDebuggerStatement;
exports.isDoWhileStatement = isDoWhileStatement;
exports.isEmptyStatement = isEmptyStatement;
exports.isExpressionStatement = isExpressionStatement;
exports.isFile = isFile;
exports.isForInStatement = isForInStatement;
exports.isForStatement = isForStatement;
exports.isFunctionDeclaration = isFunctionDeclaration;
exports.isFunctionExpression = isFunctionExpression;
exports.isIdentifier = isIdentifier;
exports.isIfStatement = isIfStatement;
exports.isLabeledStatement = isLabeledStatement;
exports.isStringLiteral = isStringLiteral;
exports.isNumericLiteral = isNumericLiteral;
exports.isNullLiteral = isNullLiteral;
exports.isBooleanLiteral = isBooleanLiteral;
exports.isRegExpLiteral = isRegExpLiteral;
exports.isLogicalExpression = isLogicalExpression;
exports.isMemberExpression = isMemberExpression;
exports.isNewExpression = isNewExpression;
exports.isProgram = isProgram;
exports.isObjectExpression = isObjectExpression;
exports.isObjectMethod = isObjectMethod;
exports.isObjectProperty = isObjectProperty;
exports.isRestElement = isRestElement;
exports.isReturnStatement = isReturnStatement;
exports.isSequenceExpression = isSequenceExpression;
exports.isParenthesizedExpression = isParenthesizedExpression;
exports.isSwitchCase = isSwitchCase;
exports.isSwitchStatement = isSwitchStatement;
exports.isThisExpression = isThisExpression;
exports.isThrowStatement = isThrowStatement;
exports.isTryStatement = isTryStatement;
exports.isUnaryExpression = isUnaryExpression;
exports.isUpdateExpression = isUpdateExpression;
exports.isVariableDeclaration = isVariableDeclaration;
exports.isVariableDeclarator = isVariableDeclarator;
exports.isWhileStatement = isWhileStatement;
exports.isWithStatement = isWithStatement;
exports.isAssignmentPattern = isAssignmentPattern;
exports.isArrayPattern = isArrayPattern;
exports.isArrowFunctionExpression = isArrowFunctionExpression;
exports.isClassBody = isClassBody;
exports.isClassExpression = isClassExpression;
exports.isClassDeclaration = isClassDeclaration;
exports.isExportAllDeclaration = isExportAllDeclaration;
exports.isExportDefaultDeclaration = isExportDefaultDeclaration;
exports.isExportNamedDeclaration = isExportNamedDeclaration;
exports.isExportSpecifier = isExportSpecifier;
exports.isForOfStatement = isForOfStatement;
exports.isImportDeclaration = isImportDeclaration;
exports.isImportDefaultSpecifier = isImportDefaultSpecifier;
exports.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
exports.isImportSpecifier = isImportSpecifier;
exports.isMetaProperty = isMetaProperty;
exports.isClassMethod = isClassMethod;
exports.isObjectPattern = isObjectPattern;
exports.isSpreadElement = isSpreadElement;
exports.isSuper = isSuper;
exports.isTaggedTemplateExpression = isTaggedTemplateExpression;
exports.isTemplateElement = isTemplateElement;
exports.isTemplateLiteral = isTemplateLiteral;
exports.isYieldExpression = isYieldExpression;
exports.isAwaitExpression = isAwaitExpression;
exports.isImport = isImport;
exports.isBigIntLiteral = isBigIntLiteral;
exports.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
exports.isOptionalMemberExpression = isOptionalMemberExpression;
exports.isOptionalCallExpression = isOptionalCallExpression;
exports.isAnyTypeAnnotation = isAnyTypeAnnotation;
exports.isArrayTypeAnnotation = isArrayTypeAnnotation;
exports.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
exports.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
exports.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
exports.isClassImplements = isClassImplements;
exports.isDeclareClass = isDeclareClass;
exports.isDeclareFunction = isDeclareFunction;
exports.isDeclareInterface = isDeclareInterface;
exports.isDeclareModule = isDeclareModule;
exports.isDeclareModuleExports = isDeclareModuleExports;
exports.isDeclareTypeAlias = isDeclareTypeAlias;
exports.isDeclareOpaqueType = isDeclareOpaqueType;
exports.isDeclareVariable = isDeclareVariable;
exports.isDeclareExportDeclaration = isDeclareExportDeclaration;
exports.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
exports.isDeclaredPredicate = isDeclaredPredicate;
exports.isExistsTypeAnnotation = isExistsTypeAnnotation;
exports.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
exports.isFunctionTypeParam = isFunctionTypeParam;
exports.isGenericTypeAnnotation = isGenericTypeAnnotation;
exports.isInferredPredicate = isInferredPredicate;
exports.isInterfaceExtends = isInterfaceExtends;
exports.isInterfaceDeclaration = isInterfaceDeclaration;
exports.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
exports.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
exports.isMixedTypeAnnotation = isMixedTypeAnnotation;
exports.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
exports.isNullableTypeAnnotation = isNullableTypeAnnotation;
exports.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
exports.isNumberTypeAnnotation = isNumberTypeAnnotation;
exports.isObjectTypeAnnotation = isObjectTypeAnnotation;
exports.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
exports.isObjectTypeCallProperty = isObjectTypeCallProperty;
exports.isObjectTypeIndexer = isObjectTypeIndexer;
exports.isObjectTypeProperty = isObjectTypeProperty;
exports.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
exports.isOpaqueType = isOpaqueType;
exports.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
exports.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
exports.isStringTypeAnnotation = isStringTypeAnnotation;
exports.isSymbolTypeAnnotation = isSymbolTypeAnnotation;
exports.isThisTypeAnnotation = isThisTypeAnnotation;
exports.isTupleTypeAnnotation = isTupleTypeAnnotation;
exports.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
exports.isTypeAlias = isTypeAlias;
exports.isTypeAnnotation = isTypeAnnotation;
exports.isTypeCastExpression = isTypeCastExpression;
exports.isTypeParameter = isTypeParameter;
exports.isTypeParameterDeclaration = isTypeParameterDeclaration;
exports.isTypeParameterInstantiation = isTypeParameterInstantiation;
exports.isUnionTypeAnnotation = isUnionTypeAnnotation;
exports.isVariance = isVariance;
exports.isVoidTypeAnnotation = isVoidTypeAnnotation;
exports.isEnumDeclaration = isEnumDeclaration;
exports.isEnumBooleanBody = isEnumBooleanBody;
exports.isEnumNumberBody = isEnumNumberBody;
exports.isEnumStringBody = isEnumStringBody;
exports.isEnumSymbolBody = isEnumSymbolBody;
exports.isEnumBooleanMember = isEnumBooleanMember;
exports.isEnumNumberMember = isEnumNumberMember;
exports.isEnumStringMember = isEnumStringMember;
exports.isEnumDefaultedMember = isEnumDefaultedMember;
exports.isJSXAttribute = isJSXAttribute;
exports.isJSXClosingElement = isJSXClosingElement;
exports.isJSXElement = isJSXElement;
exports.isJSXEmptyExpression = isJSXEmptyExpression;
exports.isJSXExpressionContainer = isJSXExpressionContainer;
exports.isJSXSpreadChild = isJSXSpreadChild;
exports.isJSXIdentifier = isJSXIdentifier;
exports.isJSXMemberExpression = isJSXMemberExpression;
exports.isJSXNamespacedName = isJSXNamespacedName;
exports.isJSXOpeningElement = isJSXOpeningElement;
exports.isJSXSpreadAttribute = isJSXSpreadAttribute;
exports.isJSXText = isJSXText;
exports.isJSXFragment = isJSXFragment;
exports.isJSXOpeningFragment = isJSXOpeningFragment;
exports.isJSXClosingFragment = isJSXClosingFragment;
exports.isNoop = isNoop;
exports.isPlaceholder = isPlaceholder;
exports.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;
exports.isArgumentPlaceholder = isArgumentPlaceholder;
exports.isBindExpression = isBindExpression;
exports.isClassProperty = isClassProperty;
exports.isPipelineTopicExpression = isPipelineTopicExpression;
exports.isPipelineBareFunction = isPipelineBareFunction;
exports.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;
exports.isClassPrivateProperty = isClassPrivateProperty;
exports.isClassPrivateMethod = isClassPrivateMethod;
exports.isImportAttribute = isImportAttribute;
exports.isDecorator = isDecorator;
exports.isDoExpression = isDoExpression;
exports.isExportDefaultSpecifier = isExportDefaultSpecifier;
exports.isPrivateName = isPrivateName;
exports.isRecordExpression = isRecordExpression;
exports.isTupleExpression = isTupleExpression;
exports.isDecimalLiteral = isDecimalLiteral;
exports.isTSParameterProperty = isTSParameterProperty;
exports.isTSDeclareFunction = isTSDeclareFunction;
exports.isTSDeclareMethod = isTSDeclareMethod;
exports.isTSQualifiedName = isTSQualifiedName;
exports.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
exports.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
exports.isTSPropertySignature = isTSPropertySignature;
exports.isTSMethodSignature = isTSMethodSignature;
exports.isTSIndexSignature = isTSIndexSignature;
exports.isTSAnyKeyword = isTSAnyKeyword;
exports.isTSBooleanKeyword = isTSBooleanKeyword;
exports.isTSBigIntKeyword = isTSBigIntKeyword;
exports.isTSNeverKeyword = isTSNeverKeyword;
exports.isTSNullKeyword = isTSNullKeyword;
exports.isTSNumberKeyword = isTSNumberKeyword;
exports.isTSObjectKeyword = isTSObjectKeyword;
exports.isTSStringKeyword = isTSStringKeyword;
exports.isTSSymbolKeyword = isTSSymbolKeyword;
exports.isTSUndefinedKeyword = isTSUndefinedKeyword;
exports.isTSUnknownKeyword = isTSUnknownKeyword;
exports.isTSVoidKeyword = isTSVoidKeyword;
exports.isTSThisType = isTSThisType;
exports.isTSFunctionType = isTSFunctionType;
exports.isTSConstructorType = isTSConstructorType;
exports.isTSTypeReference = isTSTypeReference;
exports.isTSTypePredicate = isTSTypePredicate;
exports.isTSTypeQuery = isTSTypeQuery;
exports.isTSTypeLiteral = isTSTypeLiteral;
exports.isTSArrayType = isTSArrayType;
exports.isTSTupleType = isTSTupleType;
exports.isTSOptionalType = isTSOptionalType;
exports.isTSRestType = isTSRestType;
exports.isTSNamedTupleMember = isTSNamedTupleMember;
exports.isTSUnionType = isTSUnionType;
exports.isTSIntersectionType = isTSIntersectionType;
exports.isTSConditionalType = isTSConditionalType;
exports.isTSInferType = isTSInferType;
exports.isTSParenthesizedType = isTSParenthesizedType;
exports.isTSTypeOperator = isTSTypeOperator;
exports.isTSIndexedAccessType = isTSIndexedAccessType;
exports.isTSMappedType = isTSMappedType;
exports.isTSLiteralType = isTSLiteralType;
exports.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
exports.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
exports.isTSInterfaceBody = isTSInterfaceBody;
exports.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
exports.isTSAsExpression = isTSAsExpression;
exports.isTSTypeAssertion = isTSTypeAssertion;
exports.isTSEnumDeclaration = isTSEnumDeclaration;
exports.isTSEnumMember = isTSEnumMember;
exports.isTSModuleDeclaration = isTSModuleDeclaration;
exports.isTSModuleBlock = isTSModuleBlock;
exports.isTSImportType = isTSImportType;
exports.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
exports.isTSExternalModuleReference = isTSExternalModuleReference;
exports.isTSNonNullExpression = isTSNonNullExpression;
exports.isTSExportAssignment = isTSExportAssignment;
exports.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
exports.isTSTypeAnnotation = isTSTypeAnnotation;
exports.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
exports.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
exports.isTSTypeParameter = isTSTypeParameter;
exports.isExpression = isExpression;
exports.isBinary = isBinary;
exports.isScopable = isScopable;
exports.isBlockParent = isBlockParent;
exports.isBlock = isBlock;
exports.isStatement = isStatement;
exports.isTerminatorless = isTerminatorless;
exports.isCompletionStatement = isCompletionStatement;
exports.isConditional = isConditional;
exports.isLoop = isLoop;
exports.isWhile = isWhile;
exports.isExpressionWrapper = isExpressionWrapper;
exports.isFor = isFor;
exports.isForXStatement = isForXStatement;
exports.isFunction = isFunction;
exports.isFunctionParent = isFunctionParent;
exports.isPureish = isPureish;
exports.isDeclaration = isDeclaration;
exports.isPatternLike = isPatternLike;
exports.isLVal = isLVal;
exports.isTSEntityName = isTSEntityName;
exports.isLiteral = isLiteral;
exports.isImmutable = isImmutable;
exports.isUserWhitespacable = isUserWhitespacable;
exports.isMethod = isMethod;
exports.isObjectMember = isObjectMember;
exports.isProperty = isProperty;
exports.isUnaryLike = isUnaryLike;
exports.isPattern = isPattern;
exports.isClass = isClass;
exports.isModuleDeclaration = isModuleDeclaration;
exports.isExportDeclaration = isExportDeclaration;
exports.isModuleSpecifier = isModuleSpecifier;
exports.isFlow = isFlow;
exports.isFlowType = isFlowType;
exports.isFlowBaseAnnotation = isFlowBaseAnnotation;
exports.isFlowDeclaration = isFlowDeclaration;
exports.isFlowPredicate = isFlowPredicate;
exports.isEnumBody = isEnumBody;
exports.isEnumMember = isEnumMember;
exports.isJSX = isJSX;
exports.isPrivate = isPrivate;
exports.isTSTypeElement = isTSTypeElement;
exports.isTSType = isTSType;
exports.isTSBaseType = isTSBaseType;
exports.isNumberLiteral = isNumberLiteral;
exports.isRegexLiteral = isRegexLiteral;
exports.isRestProperty = isRestProperty;
exports.isSpreadProperty = isSpreadProperty;

var _shallowEqual = _interopRequireDefault(require("../../utils/shallowEqual"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isArrayExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ArrayExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isAssignmentExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "AssignmentExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBinaryExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "BinaryExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isInterpreterDirective(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "InterpreterDirective") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDirective(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Directive") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDirectiveLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DirectiveLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBlockStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "BlockStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBreakStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "BreakStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isCallExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "CallExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isCatchClause(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "CatchClause") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isConditionalExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ConditionalExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isContinueStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ContinueStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDebuggerStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DebuggerStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDoWhileStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DoWhileStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEmptyStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "EmptyStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExpressionStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ExpressionStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFile(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "File") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isForInStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ForInStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isForStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ForStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFunctionDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "FunctionDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFunctionExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "FunctionExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isIdentifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Identifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isIfStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "IfStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isLabeledStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "LabeledStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isStringLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "StringLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNumericLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "NumericLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNullLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "NullLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBooleanLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "BooleanLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isRegExpLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "RegExpLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isLogicalExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "LogicalExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isMemberExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "MemberExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNewExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "NewExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isProgram(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Program") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectMethod(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectMethod") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isRestElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "RestElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isReturnStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ReturnStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isSequenceExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "SequenceExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isParenthesizedExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ParenthesizedExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isSwitchCase(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "SwitchCase") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isSwitchStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "SwitchStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isThisExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ThisExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isThrowStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ThrowStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTryStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TryStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isUnaryExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "UnaryExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isUpdateExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "UpdateExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isVariableDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "VariableDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isVariableDeclarator(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "VariableDeclarator") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isWhileStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "WhileStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isWithStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "WithStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isAssignmentPattern(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "AssignmentPattern") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isArrayPattern(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ArrayPattern") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isArrowFunctionExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ArrowFunctionExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClassBody(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ClassBody") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClassExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ClassExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClassDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ClassDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExportAllDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ExportAllDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExportDefaultDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ExportDefaultDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExportNamedDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ExportNamedDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExportSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ExportSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isForOfStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ForOfStatement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isImportDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ImportDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isImportDefaultSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ImportDefaultSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isImportNamespaceSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ImportNamespaceSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isImportSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ImportSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isMetaProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "MetaProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClassMethod(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ClassMethod") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectPattern(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectPattern") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isSpreadElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "SpreadElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isSuper(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Super") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTaggedTemplateExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TaggedTemplateExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTemplateElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TemplateElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTemplateLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TemplateLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isYieldExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "YieldExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isAwaitExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "AwaitExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isImport(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Import") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBigIntLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "BigIntLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExportNamespaceSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ExportNamespaceSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isOptionalMemberExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "OptionalMemberExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isOptionalCallExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "OptionalCallExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isAnyTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "AnyTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isArrayTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ArrayTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBooleanTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "BooleanTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBooleanLiteralTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "BooleanLiteralTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNullLiteralTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "NullLiteralTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClassImplements(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ClassImplements") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareClass(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclareClass") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareFunction(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclareFunction") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareInterface(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclareInterface") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareModule(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclareModule") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareModuleExports(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclareModuleExports") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareTypeAlias(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclareTypeAlias") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareOpaqueType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclareOpaqueType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareVariable(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclareVariable") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareExportDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclareExportDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclareExportAllDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclareExportAllDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclaredPredicate(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DeclaredPredicate") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExistsTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ExistsTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFunctionTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "FunctionTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFunctionTypeParam(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "FunctionTypeParam") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isGenericTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "GenericTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isInferredPredicate(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "InferredPredicate") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isInterfaceExtends(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "InterfaceExtends") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isInterfaceDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "InterfaceDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isInterfaceTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "InterfaceTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isIntersectionTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "IntersectionTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isMixedTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "MixedTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEmptyTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "EmptyTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNullableTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "NullableTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNumberLiteralTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "NumberLiteralTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNumberTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "NumberTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectTypeInternalSlot(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectTypeInternalSlot") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectTypeCallProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectTypeCallProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectTypeIndexer(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectTypeIndexer") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectTypeProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectTypeProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectTypeSpreadProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectTypeSpreadProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isOpaqueType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "OpaqueType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isQualifiedTypeIdentifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "QualifiedTypeIdentifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isStringLiteralTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "StringLiteralTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isStringTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "StringTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isSymbolTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "SymbolTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isThisTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ThisTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTupleTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TupleTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTypeofTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TypeofTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTypeAlias(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TypeAlias") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTypeCastExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TypeCastExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTypeParameter(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TypeParameter") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTypeParameterDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TypeParameterDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTypeParameterInstantiation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TypeParameterInstantiation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isUnionTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "UnionTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isVariance(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Variance") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isVoidTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "VoidTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "EnumDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumBooleanBody(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "EnumBooleanBody") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumNumberBody(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "EnumNumberBody") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumStringBody(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "EnumStringBody") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumSymbolBody(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "EnumSymbolBody") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumBooleanMember(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "EnumBooleanMember") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumNumberMember(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "EnumNumberMember") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumStringMember(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "EnumStringMember") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumDefaultedMember(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "EnumDefaultedMember") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXAttribute(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXAttribute") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXClosingElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXClosingElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXEmptyExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXEmptyExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXExpressionContainer(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXExpressionContainer") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXSpreadChild(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXSpreadChild") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXIdentifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXIdentifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXMemberExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXMemberExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXNamespacedName(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXNamespacedName") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXOpeningElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXOpeningElement") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXSpreadAttribute(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXSpreadAttribute") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXText(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXText") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXFragment(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXFragment") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXOpeningFragment(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXOpeningFragment") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSXClosingFragment(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSXClosingFragment") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNoop(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Noop") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPlaceholder(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Placeholder") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isV8IntrinsicIdentifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "V8IntrinsicIdentifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isArgumentPlaceholder(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ArgumentPlaceholder") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBindExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "BindExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClassProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ClassProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPipelineTopicExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "PipelineTopicExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPipelineBareFunction(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "PipelineBareFunction") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPipelinePrimaryTopicReference(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "PipelinePrimaryTopicReference") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClassPrivateProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ClassPrivateProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClassPrivateMethod(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ClassPrivateMethod") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isImportAttribute(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ImportAttribute") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDecorator(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Decorator") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDoExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DoExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExportDefaultSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ExportDefaultSpecifier") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPrivateName(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "PrivateName") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isRecordExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "RecordExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTupleExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TupleExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDecimalLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "DecimalLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSParameterProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSParameterProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSDeclareFunction(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSDeclareFunction") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSDeclareMethod(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSDeclareMethod") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSQualifiedName(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSQualifiedName") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSCallSignatureDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSCallSignatureDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSConstructSignatureDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSConstructSignatureDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSPropertySignature(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSPropertySignature") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSMethodSignature(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSMethodSignature") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSIndexSignature(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSIndexSignature") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSAnyKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSAnyKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSBooleanKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSBooleanKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSBigIntKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSBigIntKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSNeverKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSNeverKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSNullKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSNullKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSNumberKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSNumberKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSObjectKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSObjectKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSStringKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSStringKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSSymbolKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSSymbolKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSUndefinedKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSUndefinedKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSUnknownKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSUnknownKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSVoidKeyword(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSVoidKeyword") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSThisType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSThisType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSFunctionType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSFunctionType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSConstructorType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSConstructorType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeReference(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeReference") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypePredicate(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypePredicate") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeQuery(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeQuery") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSArrayType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSArrayType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTupleType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTupleType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSOptionalType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSOptionalType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSRestType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSRestType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSNamedTupleMember(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSNamedTupleMember") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSUnionType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSUnionType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSIntersectionType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSIntersectionType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSConditionalType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSConditionalType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSInferType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSInferType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSParenthesizedType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSParenthesizedType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeOperator(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeOperator") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSIndexedAccessType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSIndexedAccessType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSMappedType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSMappedType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSLiteralType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSLiteralType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSExpressionWithTypeArguments(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSExpressionWithTypeArguments") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSInterfaceDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSInterfaceDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSInterfaceBody(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSInterfaceBody") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeAliasDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeAliasDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSAsExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSAsExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeAssertion(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeAssertion") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSEnumDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSEnumDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSEnumMember(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSEnumMember") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSModuleDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSModuleDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSModuleBlock(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSModuleBlock") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSImportType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSImportType") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSImportEqualsDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSImportEqualsDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSExternalModuleReference(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSExternalModuleReference") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSNonNullExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSNonNullExpression") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSExportAssignment(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSExportAssignment") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSNamespaceExportDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSNamespaceExportDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeAnnotation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeParameterInstantiation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeParameterInstantiation") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeParameterDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeParameterDeclaration") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeParameter(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeParameter") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExpression(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Expression" || "ArrayExpression" === nodeType || "AssignmentExpression" === nodeType || "BinaryExpression" === nodeType || "CallExpression" === nodeType || "ConditionalExpression" === nodeType || "FunctionExpression" === nodeType || "Identifier" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "LogicalExpression" === nodeType || "MemberExpression" === nodeType || "NewExpression" === nodeType || "ObjectExpression" === nodeType || "SequenceExpression" === nodeType || "ParenthesizedExpression" === nodeType || "ThisExpression" === nodeType || "UnaryExpression" === nodeType || "UpdateExpression" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassExpression" === nodeType || "MetaProperty" === nodeType || "Super" === nodeType || "TaggedTemplateExpression" === nodeType || "TemplateLiteral" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType || "Import" === nodeType || "BigIntLiteral" === nodeType || "OptionalMemberExpression" === nodeType || "OptionalCallExpression" === nodeType || "TypeCastExpression" === nodeType || "JSXElement" === nodeType || "JSXFragment" === nodeType || "BindExpression" === nodeType || "PipelinePrimaryTopicReference" === nodeType || "DoExpression" === nodeType || "RecordExpression" === nodeType || "TupleExpression" === nodeType || "DecimalLiteral" === nodeType || "TSAsExpression" === nodeType || "TSTypeAssertion" === nodeType || "TSNonNullExpression" === nodeType || nodeType === "Placeholder" && ("Expression" === node.expectedNode || "Identifier" === node.expectedNode || "StringLiteral" === node.expectedNode)) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBinary(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Binary" || "BinaryExpression" === nodeType || "LogicalExpression" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isScopable(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Scopable" || "BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassExpression" === nodeType || "ClassDeclaration" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBlockParent(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "BlockParent" || "BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isBlock(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Block" || "BlockStatement" === nodeType || "Program" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Statement" || "BlockStatement" === nodeType || "BreakStatement" === nodeType || "ContinueStatement" === nodeType || "DebuggerStatement" === nodeType || "DoWhileStatement" === nodeType || "EmptyStatement" === nodeType || "ExpressionStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "IfStatement" === nodeType || "LabeledStatement" === nodeType || "ReturnStatement" === nodeType || "SwitchStatement" === nodeType || "ThrowStatement" === nodeType || "TryStatement" === nodeType || "VariableDeclaration" === nodeType || "WhileStatement" === nodeType || "WithStatement" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ForOfStatement" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "EnumDeclaration" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || "TSImportEqualsDeclaration" === nodeType || "TSExportAssignment" === nodeType || "TSNamespaceExportDeclaration" === nodeType || nodeType === "Placeholder" && ("Statement" === node.expectedNode || "Declaration" === node.expectedNode || "BlockStatement" === node.expectedNode)) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTerminatorless(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Terminatorless" || "BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isCompletionStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "CompletionStatement" || "BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isConditional(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Conditional" || "ConditionalExpression" === nodeType || "IfStatement" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isLoop(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Loop" || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "WhileStatement" === nodeType || "ForOfStatement" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isWhile(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "While" || "DoWhileStatement" === nodeType || "WhileStatement" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExpressionWrapper(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ExpressionWrapper" || "ExpressionStatement" === nodeType || "ParenthesizedExpression" === nodeType || "TypeCastExpression" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFor(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "For" || "ForInStatement" === nodeType || "ForStatement" === nodeType || "ForOfStatement" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isForXStatement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ForXStatement" || "ForInStatement" === nodeType || "ForOfStatement" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFunction(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Function" || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFunctionParent(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "FunctionParent" || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPureish(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Pureish" || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "ArrowFunctionExpression" === nodeType || "BigIntLiteral" === nodeType || "DecimalLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Declaration" || "FunctionDeclaration" === nodeType || "VariableDeclaration" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "EnumDeclaration" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || nodeType === "Placeholder" && "Declaration" === node.expectedNode) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPatternLike(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "PatternLike" || "Identifier" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || nodeType === "Placeholder" && ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode)) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isLVal(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "LVal" || "Identifier" === nodeType || "MemberExpression" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || "TSParameterProperty" === nodeType || nodeType === "Placeholder" && ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode)) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSEntityName(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSEntityName" || "Identifier" === nodeType || "TSQualifiedName" === nodeType || nodeType === "Placeholder" && "Identifier" === node.expectedNode) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isLiteral(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Literal" || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "TemplateLiteral" === nodeType || "BigIntLiteral" === nodeType || "DecimalLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isImmutable(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Immutable" || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "BigIntLiteral" === nodeType || "JSXAttribute" === nodeType || "JSXClosingElement" === nodeType || "JSXElement" === nodeType || "JSXExpressionContainer" === nodeType || "JSXSpreadChild" === nodeType || "JSXOpeningElement" === nodeType || "JSXText" === nodeType || "JSXFragment" === nodeType || "JSXOpeningFragment" === nodeType || "JSXClosingFragment" === nodeType || "DecimalLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isUserWhitespacable(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "UserWhitespacable" || "ObjectMethod" === nodeType || "ObjectProperty" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isMethod(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Method" || "ObjectMethod" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isObjectMember(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ObjectMember" || "ObjectMethod" === nodeType || "ObjectProperty" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isProperty(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Property" || "ObjectProperty" === nodeType || "ClassProperty" === nodeType || "ClassPrivateProperty" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isUnaryLike(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "UnaryLike" || "UnaryExpression" === nodeType || "SpreadElement" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPattern(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Pattern" || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || nodeType === "Placeholder" && "Pattern" === node.expectedNode) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isClass(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Class" || "ClassExpression" === nodeType || "ClassDeclaration" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isModuleDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ModuleDeclaration" || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isExportDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ExportDeclaration" || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isModuleSpecifier(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "ModuleSpecifier" || "ExportSpecifier" === nodeType || "ImportDefaultSpecifier" === nodeType || "ImportNamespaceSpecifier" === nodeType || "ImportSpecifier" === nodeType || "ExportNamespaceSpecifier" === nodeType || "ExportDefaultSpecifier" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFlow(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Flow" || "AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ClassImplements" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "DeclaredPredicate" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "FunctionTypeParam" === nodeType || "GenericTypeAnnotation" === nodeType || "InferredPredicate" === nodeType || "InterfaceExtends" === nodeType || "InterfaceDeclaration" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType || "OpaqueType" === nodeType || "QualifiedTypeIdentifier" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "TypeAlias" === nodeType || "TypeAnnotation" === nodeType || "TypeCastExpression" === nodeType || "TypeParameter" === nodeType || "TypeParameterDeclaration" === nodeType || "TypeParameterInstantiation" === nodeType || "UnionTypeAnnotation" === nodeType || "Variance" === nodeType || "VoidTypeAnnotation" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFlowType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "FlowType" || "AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "GenericTypeAnnotation" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "UnionTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFlowBaseAnnotation(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "FlowBaseAnnotation" || "AnyTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFlowDeclaration(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "FlowDeclaration" || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isFlowPredicate(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "FlowPredicate" || "DeclaredPredicate" === nodeType || "InferredPredicate" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumBody(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "EnumBody" || "EnumBooleanBody" === nodeType || "EnumNumberBody" === nodeType || "EnumStringBody" === nodeType || "EnumSymbolBody" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isEnumMember(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "EnumMember" || "EnumBooleanMember" === nodeType || "EnumNumberMember" === nodeType || "EnumStringMember" === nodeType || "EnumDefaultedMember" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isJSX(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "JSX" || "JSXAttribute" === nodeType || "JSXClosingElement" === nodeType || "JSXElement" === nodeType || "JSXEmptyExpression" === nodeType || "JSXExpressionContainer" === nodeType || "JSXSpreadChild" === nodeType || "JSXIdentifier" === nodeType || "JSXMemberExpression" === nodeType || "JSXNamespacedName" === nodeType || "JSXOpeningElement" === nodeType || "JSXSpreadAttribute" === nodeType || "JSXText" === nodeType || "JSXFragment" === nodeType || "JSXOpeningFragment" === nodeType || "JSXClosingFragment" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isPrivate(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "Private" || "ClassPrivateProperty" === nodeType || "ClassPrivateMethod" === nodeType || "PrivateName" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSTypeElement(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSTypeElement" || "TSCallSignatureDeclaration" === nodeType || "TSConstructSignatureDeclaration" === nodeType || "TSPropertySignature" === nodeType || "TSMethodSignature" === nodeType || "TSIndexSignature" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSType" || "TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSFunctionType" === nodeType || "TSConstructorType" === nodeType || "TSTypeReference" === nodeType || "TSTypePredicate" === nodeType || "TSTypeQuery" === nodeType || "TSTypeLiteral" === nodeType || "TSArrayType" === nodeType || "TSTupleType" === nodeType || "TSOptionalType" === nodeType || "TSRestType" === nodeType || "TSUnionType" === nodeType || "TSIntersectionType" === nodeType || "TSConditionalType" === nodeType || "TSInferType" === nodeType || "TSParenthesizedType" === nodeType || "TSTypeOperator" === nodeType || "TSIndexedAccessType" === nodeType || "TSMappedType" === nodeType || "TSLiteralType" === nodeType || "TSExpressionWithTypeArguments" === nodeType || "TSImportType" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isTSBaseType(node, opts) {
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "TSBaseType" || "TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSLiteralType" === nodeType) {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isNumberLiteral(node, opts) {
  console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "NumberLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isRegexLiteral(node, opts) {
  console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "RegexLiteral") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isRestProperty(node, opts) {
  console.trace("The node type RestProperty has been renamed to RestElement");
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "RestProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}

function isSpreadProperty(node, opts) {
  console.trace("The node type SpreadProperty has been renamed to SpreadElement");
  if (!node) return false;
  const nodeType = node.type;

  if (nodeType === "SpreadProperty") {
    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  return false;
}
},{"../../utils/shallowEqual":86}],89:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = is;

var _shallowEqual = _interopRequireDefault(require("../utils/shallowEqual"));

var _isType = _interopRequireDefault(require("./isType"));

var _isPlaceholderType = _interopRequireDefault(require("./isPlaceholderType"));

var _definitions = require("../definitions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function is(type, node, opts) {
  if (!node) return false;
  const matches = (0, _isType.default)(node.type, type);

  if (!matches) {
    if (!opts && node.type === "Placeholder" && type in _definitions.FLIPPED_ALIAS_KEYS) {
      return (0, _isPlaceholderType.default)(node.expectedNode, type);
    }

    return false;
  }

  if (typeof opts === "undefined") {
    return true;
  } else {
    return (0, _shallowEqual.default)(node, opts);
  }
}
},{"../definitions":66,"../utils/shallowEqual":86,"./isPlaceholderType":96,"./isType":100}],90:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isBinding;

var _getBindingIdentifiers = _interopRequireDefault(require("../retrievers/getBindingIdentifiers"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isBinding(node, parent, grandparent) {
  if (grandparent && node.type === "Identifier" && parent.type === "ObjectProperty" && grandparent.type === "ObjectExpression") {
    return false;
  }

  const keys = _getBindingIdentifiers.default.keys[parent.type];

  if (keys) {
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const val = parent[key];

      if (Array.isArray(val)) {
        if (val.indexOf(node) >= 0) return true;
      } else {
        if (val === node) return true;
      }
    }
  }

  return false;
}
},{"../retrievers/getBindingIdentifiers":80}],91:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isBlockScoped;

var _generated = require("./generated");

var _isLet = _interopRequireDefault(require("./isLet"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isBlockScoped(node) {
  return (0, _generated.isFunctionDeclaration)(node) || (0, _generated.isClassDeclaration)(node) || (0, _isLet.default)(node);
}
},{"./generated":88,"./isLet":93}],92:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isImmutable;

var _isType = _interopRequireDefault(require("./isType"));

var _generated = require("./generated");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isImmutable(node) {
  if ((0, _isType.default)(node.type, "Immutable")) return true;

  if ((0, _generated.isIdentifier)(node)) {
    if (node.name === "undefined") {
      return true;
    } else {
      return false;
    }
  }

  return false;
}
},{"./generated":88,"./isType":100}],93:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isLet;

var _generated = require("./generated");

var _constants = require("../constants");

function isLet(node) {
  return (0, _generated.isVariableDeclaration)(node) && (node.kind !== "var" || node[_constants.BLOCK_SCOPED_SYMBOL]);
}
},{"../constants":51,"./generated":88}],94:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isNode;

var _definitions = require("../definitions");

function isNode(node) {
  return !!(node && _definitions.VISITOR_KEYS[node.type]);
}
},{"../definitions":66}],95:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isNodesEquivalent;

var _definitions = require("../definitions");

function isNodesEquivalent(a, b) {
  if (typeof a !== "object" || typeof b !== "object" || a == null || b == null) {
    return a === b;
  }

  if (a.type !== b.type) {
    return false;
  }

  const fields = Object.keys(_definitions.NODE_FIELDS[a.type] || a.type);
  const visitorKeys = _definitions.VISITOR_KEYS[a.type];

  for (const field of fields) {
    if (typeof a[field] !== typeof b[field]) {
      return false;
    }

    if (a[field] == null && b[field] == null) {
      continue;
    } else if (a[field] == null || b[field] == null) {
      return false;
    }

    if (Array.isArray(a[field])) {
      if (!Array.isArray(b[field])) {
        return false;
      }

      if (a[field].length !== b[field].length) {
        return false;
      }

      for (let i = 0; i < a[field].length; i++) {
        if (!isNodesEquivalent(a[field][i], b[field][i])) {
          return false;
        }
      }

      continue;
    }

    if (typeof a[field] === "object" && !(visitorKeys == null ? void 0 : visitorKeys.includes(field))) {
      for (const key of Object.keys(a[field])) {
        if (a[field][key] !== b[field][key]) {
          return false;
        }
      }

      continue;
    }

    if (!isNodesEquivalent(a[field], b[field])) {
      return false;
    }
  }

  return true;
}
},{"../definitions":66}],96:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isPlaceholderType;

var _definitions = require("../definitions");

function isPlaceholderType(placeholderType, targetType) {
  if (placeholderType === targetType) return true;
  const aliases = _definitions.PLACEHOLDERS_ALIAS[placeholderType];

  if (aliases) {
    for (const alias of aliases) {
      if (targetType === alias) return true;
    }
  }

  return false;
}
},{"../definitions":66}],97:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isReferenced;

function isReferenced(node, parent, grandparent) {
  switch (parent.type) {
    case "MemberExpression":
    case "JSXMemberExpression":
    case "OptionalMemberExpression":
      if (parent.property === node) {
        return !!parent.computed;
      }

      return parent.object === node;

    case "VariableDeclarator":
      return parent.init === node;

    case "ArrowFunctionExpression":
      return parent.body === node;

    case "ExportSpecifier":
      if (parent.source) {
        return false;
      }

      return parent.local === node;

    case "PrivateName":
      return false;

    case "ClassMethod":
    case "ClassPrivateMethod":
    case "ObjectMethod":
      if (parent.params.includes(node)) {
        return false;
      }

    case "ObjectProperty":
    case "ClassProperty":
    case "ClassPrivateProperty":
      if (parent.key === node) {
        return !!parent.computed;
      }

      if (parent.value === node) {
        return !grandparent || grandparent.type !== "ObjectPattern";
      }

      return true;

    case "ClassDeclaration":
    case "ClassExpression":
      return parent.superClass === node;

    case "AssignmentExpression":
      return parent.right === node;

    case "AssignmentPattern":
      return parent.right === node;

    case "LabeledStatement":
      return false;

    case "CatchClause":
      return false;

    case "RestElement":
      return false;

    case "BreakStatement":
    case "ContinueStatement":
      return false;

    case "FunctionDeclaration":
    case "FunctionExpression":
      return false;

    case "ExportNamespaceSpecifier":
    case "ExportDefaultSpecifier":
      return false;

    case "ImportDefaultSpecifier":
    case "ImportNamespaceSpecifier":
    case "ImportSpecifier":
      return false;

    case "JSXAttribute":
      return false;

    case "ObjectPattern":
    case "ArrayPattern":
      return false;

    case "MetaProperty":
      return false;

    case "ObjectTypeProperty":
      return parent.key !== node;

    case "TSEnumMember":
      return parent.id !== node;

    case "TSPropertySignature":
      if (parent.key === node) {
        return !!parent.computed;
      }

      return true;
  }

  return true;
}
},{}],98:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isScope;

var _generated = require("./generated");

function isScope(node, parent) {
  if ((0, _generated.isBlockStatement)(node) && (0, _generated.isFunction)(parent, {
    body: node
  })) {
    return false;
  }

  if ((0, _generated.isBlockStatement)(node) && (0, _generated.isCatchClause)(parent, {
    body: node
  })) {
    return false;
  }

  if ((0, _generated.isPattern)(node) && (0, _generated.isFunction)(parent)) {
    return true;
  }

  return (0, _generated.isScopable)(node);
}
},{"./generated":88}],99:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isSpecifierDefault;

var _generated = require("./generated");

function isSpecifierDefault(specifier) {
  return (0, _generated.isImportDefaultSpecifier)(specifier) || (0, _generated.isIdentifier)(specifier.imported || specifier.exported, {
    name: "default"
  });
}
},{"./generated":88}],100:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isType;

var _definitions = require("../definitions");

function isType(nodeType, targetType) {
  if (nodeType === targetType) return true;
  if (_definitions.ALIAS_KEYS[targetType]) return false;
  const aliases = _definitions.FLIPPED_ALIAS_KEYS[targetType];

  if (aliases) {
    if (aliases[0] === nodeType) return true;

    for (const alias of aliases) {
      if (nodeType === alias) return true;
    }
  }

  return false;
}
},{"../definitions":66}],101:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isValidES3Identifier;

var _isValidIdentifier = _interopRequireDefault(require("./isValidIdentifier"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const RESERVED_WORDS_ES3_ONLY = new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);

function isValidES3Identifier(name) {
  return (0, _isValidIdentifier.default)(name) && !RESERVED_WORDS_ES3_ONLY.has(name);
}
},{"./isValidIdentifier":102}],102:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isValidIdentifier;

var _helperValidatorIdentifier = require("@babel/helper-validator-identifier");

function isValidIdentifier(name, reserved = true) {
  if (typeof name !== "string") return false;

  if (reserved) {
    if ((0, _helperValidatorIdentifier.isKeyword)(name) || (0, _helperValidatorIdentifier.isStrictReservedWord)(name)) {
      return false;
    } else if (name === "await") {
      return false;
    }
  }

  return (0, _helperValidatorIdentifier.isIdentifierName)(name);
}
},{"@babel/helper-validator-identifier":28}],103:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isVar;

var _generated = require("./generated");

var _constants = require("../constants");

function isVar(node) {
  return (0, _generated.isVariableDeclaration)(node, {
    kind: "var"
  }) && !node[_constants.BLOCK_SCOPED_SYMBOL];
}
},{"../constants":51,"./generated":88}],104:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = matchesPattern;

var _generated = require("./generated");

function matchesPattern(member, match, allowPartial) {
  if (!(0, _generated.isMemberExpression)(member)) return false;
  const parts = Array.isArray(match) ? match : match.split(".");
  const nodes = [];
  let node;

  for (node = member; (0, _generated.isMemberExpression)(node); node = node.object) {
    nodes.push(node.property);
  }

  nodes.push(node);
  if (nodes.length < parts.length) return false;
  if (!allowPartial && nodes.length > parts.length) return false;

  for (let i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {
    const node = nodes[j];
    let value;

    if ((0, _generated.isIdentifier)(node)) {
      value = node.name;
    } else if ((0, _generated.isStringLiteral)(node)) {
      value = node.value;
    } else {
      return false;
    }

    if (parts[i] !== value) return false;
  }

  return true;
}
},{"./generated":88}],105:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isCompatTag;

function isCompatTag(tagName) {
  return !!tagName && /^[a-z]/.test(tagName);
}
},{}],106:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _buildMatchMemberExpression = _interopRequireDefault(require("../buildMatchMemberExpression"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const isReactComponent = (0, _buildMatchMemberExpression.default)("React.Component");
var _default = isReactComponent;
exports.default = _default;
},{"../buildMatchMemberExpression":87}],107:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = validate;
exports.validateField = validateField;
exports.validateChild = validateChild;

var _definitions = require("../definitions");

function validate(node, key, val) {
  if (!node) return;
  const fields = _definitions.NODE_FIELDS[node.type];
  if (!fields) return;
  const field = fields[key];
  validateField(node, key, val, field);
  validateChild(node, key, val);
}

function validateField(node, key, val, field) {
  if (!(field == null ? void 0 : field.validate)) return;
  if (field.optional && val == null) return;
  field.validate(node, key, val);
}

function validateChild(node, key, val) {
  if (val == null) return;
  const validate = _definitions.NODE_PARENT_VALIDATIONS[val.type];
  if (!validate) return;
  validate(node, key, val);
}
},{"../definitions":66}],108:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],109:[function(require,module,exports){
(function (Buffer){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this,require("buffer").Buffer)

},{"base64-js":108,"buffer":109,"ieee754":112}],110:[function(require,module,exports){
var charenc = {
  // UTF-8 encoding
  utf8: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
    }
  },

  // Binary encoding
  bin: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      for (var bytes = [], i = 0; i < str.length; i++)
        bytes.push(str.charCodeAt(i) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      for (var str = [], i = 0; i < bytes.length; i++)
        str.push(String.fromCharCode(bytes[i]));
      return str.join('');
    }
  }
};

module.exports = charenc;

},{}],111:[function(require,module,exports){
(function() {
  var base64map
      = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',

  crypt = {
    // Bit-wise rotation left
    rotl: function(n, b) {
      return (n << b) | (n >>> (32 - b));
    },

    // Bit-wise rotation right
    rotr: function(n, b) {
      return (n << (32 - b)) | (n >>> b);
    },

    // Swap big-endian to little-endian and vice versa
    endian: function(n) {
      // If number given, swap endian
      if (n.constructor == Number) {
        return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;
      }

      // Else, assume array and swap all items
      for (var i = 0; i < n.length; i++)
        n[i] = crypt.endian(n[i]);
      return n;
    },

    // Generate an array of any length of random bytes
    randomBytes: function(n) {
      for (var bytes = []; n > 0; n--)
        bytes.push(Math.floor(Math.random() * 256));
      return bytes;
    },

    // Convert a byte array to big-endian 32-bit words
    bytesToWords: function(bytes) {
      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
        words[b >>> 5] |= bytes[i] << (24 - b % 32);
      return words;
    },

    // Convert big-endian 32-bit words to a byte array
    wordsToBytes: function(words) {
      for (var bytes = [], b = 0; b < words.length * 32; b += 8)
        bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a hex string
    bytesToHex: function(bytes) {
      for (var hex = [], i = 0; i < bytes.length; i++) {
        hex.push((bytes[i] >>> 4).toString(16));
        hex.push((bytes[i] & 0xF).toString(16));
      }
      return hex.join('');
    },

    // Convert a hex string to a byte array
    hexToBytes: function(hex) {
      for (var bytes = [], c = 0; c < hex.length; c += 2)
        bytes.push(parseInt(hex.substr(c, 2), 16));
      return bytes;
    },

    // Convert a byte array to a base-64 string
    bytesToBase64: function(bytes) {
      for (var base64 = [], i = 0; i < bytes.length; i += 3) {
        var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
        for (var j = 0; j < 4; j++)
          if (i * 8 + j * 6 <= bytes.length * 8)
            base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));
          else
            base64.push('=');
      }
      return base64.join('');
    },

    // Convert a base-64 string to a byte array
    base64ToBytes: function(base64) {
      // Remove non-base-64 characters
      base64 = base64.replace(/[^A-Z0-9+\/]/ig, '');

      for (var bytes = [], i = 0, imod4 = 0; i < base64.length;
          imod4 = ++i % 4) {
        if (imod4 == 0) continue;
        bytes.push(((base64map.indexOf(base64.charAt(i - 1))
            & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2))
            | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));
      }
      return bytes;
    }
  };

  module.exports = crypt;
})();

},{}],112:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],113:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;

},{"./_getNative":163,"./_root":198}],114:[function(require,module,exports){
var hashClear = require('./_hashClear'),
    hashDelete = require('./_hashDelete'),
    hashGet = require('./_hashGet'),
    hashHas = require('./_hashHas'),
    hashSet = require('./_hashSet');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;

},{"./_hashClear":170,"./_hashDelete":171,"./_hashGet":172,"./_hashHas":173,"./_hashSet":174}],115:[function(require,module,exports){
var listCacheClear = require('./_listCacheClear'),
    listCacheDelete = require('./_listCacheDelete'),
    listCacheGet = require('./_listCacheGet'),
    listCacheHas = require('./_listCacheHas'),
    listCacheSet = require('./_listCacheSet');

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;

},{"./_listCacheClear":182,"./_listCacheDelete":183,"./_listCacheGet":184,"./_listCacheHas":185,"./_listCacheSet":186}],116:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;

},{"./_getNative":163,"./_root":198}],117:[function(require,module,exports){
var mapCacheClear = require('./_mapCacheClear'),
    mapCacheDelete = require('./_mapCacheDelete'),
    mapCacheGet = require('./_mapCacheGet'),
    mapCacheHas = require('./_mapCacheHas'),
    mapCacheSet = require('./_mapCacheSet');

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;

},{"./_mapCacheClear":187,"./_mapCacheDelete":188,"./_mapCacheGet":189,"./_mapCacheHas":190,"./_mapCacheSet":191}],118:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;

},{"./_getNative":163,"./_root":198}],119:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;

},{"./_getNative":163,"./_root":198}],120:[function(require,module,exports){
var ListCache = require('./_ListCache'),
    stackClear = require('./_stackClear'),
    stackDelete = require('./_stackDelete'),
    stackGet = require('./_stackGet'),
    stackHas = require('./_stackHas'),
    stackSet = require('./_stackSet');

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;

},{"./_ListCache":115,"./_stackClear":199,"./_stackDelete":200,"./_stackGet":201,"./_stackHas":202,"./_stackSet":203}],121:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;

},{"./_root":198}],122:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;

},{"./_root":198}],123:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;

},{"./_getNative":163,"./_root":198}],124:[function(require,module,exports){
/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;

},{}],125:[function(require,module,exports){
/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;

},{}],126:[function(require,module,exports){
var baseTimes = require('./_baseTimes'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isIndex = require('./_isIndex'),
    isTypedArray = require('./isTypedArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;

},{"./_baseTimes":145,"./_isIndex":178,"./isArguments":207,"./isArray":208,"./isBuffer":210,"./isTypedArray":219}],127:[function(require,module,exports){
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;

},{}],128:[function(require,module,exports){
var baseAssignValue = require('./_baseAssignValue'),
    eq = require('./eq');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;

},{"./_baseAssignValue":132,"./eq":206}],129:[function(require,module,exports){
var eq = require('./eq');

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;

},{"./eq":206}],130:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    keys = require('./keys');

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;

},{"./_copyObject":154,"./keys":220}],131:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    keysIn = require('./keysIn');

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;

},{"./_copyObject":154,"./keysIn":221}],132:[function(require,module,exports){
var defineProperty = require('./_defineProperty');

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;

},{"./_defineProperty":158}],133:[function(require,module,exports){
var Stack = require('./_Stack'),
    arrayEach = require('./_arrayEach'),
    assignValue = require('./_assignValue'),
    baseAssign = require('./_baseAssign'),
    baseAssignIn = require('./_baseAssignIn'),
    cloneBuffer = require('./_cloneBuffer'),
    copyArray = require('./_copyArray'),
    copySymbols = require('./_copySymbols'),
    copySymbolsIn = require('./_copySymbolsIn'),
    getAllKeys = require('./_getAllKeys'),
    getAllKeysIn = require('./_getAllKeysIn'),
    getTag = require('./_getTag'),
    initCloneArray = require('./_initCloneArray'),
    initCloneByTag = require('./_initCloneByTag'),
    initCloneObject = require('./_initCloneObject'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isMap = require('./isMap'),
    isObject = require('./isObject'),
    isSet = require('./isSet'),
    keys = require('./keys'),
    keysIn = require('./keysIn');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;

},{"./_Stack":120,"./_arrayEach":124,"./_assignValue":128,"./_baseAssign":130,"./_baseAssignIn":131,"./_cloneBuffer":148,"./_copyArray":153,"./_copySymbols":155,"./_copySymbolsIn":156,"./_getAllKeys":160,"./_getAllKeysIn":161,"./_getTag":168,"./_initCloneArray":175,"./_initCloneByTag":176,"./_initCloneObject":177,"./isArray":208,"./isBuffer":210,"./isMap":213,"./isObject":214,"./isSet":218,"./keys":220,"./keysIn":221}],134:[function(require,module,exports){
var isObject = require('./isObject');

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;

},{"./isObject":214}],135:[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    isArray = require('./isArray');

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;

},{"./_arrayPush":127,"./isArray":208}],136:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    getRawTag = require('./_getRawTag'),
    objectToString = require('./_objectToString');

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;

},{"./_Symbol":121,"./_getRawTag":165,"./_objectToString":196}],137:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

},{"./_baseGetTag":136,"./isObjectLike":215}],138:[function(require,module,exports){
var getTag = require('./_getTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var mapTag = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;

},{"./_getTag":168,"./isObjectLike":215}],139:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isMasked = require('./_isMasked'),
    isObject = require('./isObject'),
    toSource = require('./_toSource');

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

},{"./_isMasked":180,"./_toSource":204,"./isFunction":211,"./isObject":214}],140:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var regexpTag = '[object RegExp]';

/**
 * The base implementation of `_.isRegExp` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
 */
function baseIsRegExp(value) {
  return isObjectLike(value) && baseGetTag(value) == regexpTag;
}

module.exports = baseIsRegExp;

},{"./_baseGetTag":136,"./isObjectLike":215}],141:[function(require,module,exports){
var getTag = require('./_getTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var setTag = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;

},{"./_getTag":168,"./isObjectLike":215}],142:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isLength = require('./isLength'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

},{"./_baseGetTag":136,"./isLength":212,"./isObjectLike":215}],143:[function(require,module,exports){
var isPrototype = require('./_isPrototype'),
    nativeKeys = require('./_nativeKeys');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;

},{"./_isPrototype":181,"./_nativeKeys":193}],144:[function(require,module,exports){
var isObject = require('./isObject'),
    isPrototype = require('./_isPrototype'),
    nativeKeysIn = require('./_nativeKeysIn');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;

},{"./_isPrototype":181,"./_nativeKeysIn":194,"./isObject":214}],145:[function(require,module,exports){
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;

},{}],146:[function(require,module,exports){
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;

},{}],147:[function(require,module,exports){
var Uint8Array = require('./_Uint8Array');

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;

},{"./_Uint8Array":122}],148:[function(require,module,exports){
var root = require('./_root');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

},{"./_root":198}],149:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer');

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;

},{"./_cloneArrayBuffer":147}],150:[function(require,module,exports){
/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;

},{}],151:[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;

},{"./_Symbol":121}],152:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer');

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;

},{"./_cloneArrayBuffer":147}],153:[function(require,module,exports){
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;

},{}],154:[function(require,module,exports){
var assignValue = require('./_assignValue'),
    baseAssignValue = require('./_baseAssignValue');

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;

},{"./_assignValue":128,"./_baseAssignValue":132}],155:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    getSymbols = require('./_getSymbols');

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;

},{"./_copyObject":154,"./_getSymbols":166}],156:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    getSymbolsIn = require('./_getSymbolsIn');

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;

},{"./_copyObject":154,"./_getSymbolsIn":167}],157:[function(require,module,exports){
var root = require('./_root');

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;

},{"./_root":198}],158:[function(require,module,exports){
var getNative = require('./_getNative');

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;

},{"./_getNative":163}],159:[function(require,module,exports){
(function (global){
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],160:[function(require,module,exports){
var baseGetAllKeys = require('./_baseGetAllKeys'),
    getSymbols = require('./_getSymbols'),
    keys = require('./keys');

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;

},{"./_baseGetAllKeys":135,"./_getSymbols":166,"./keys":220}],161:[function(require,module,exports){
var baseGetAllKeys = require('./_baseGetAllKeys'),
    getSymbolsIn = require('./_getSymbolsIn'),
    keysIn = require('./keysIn');

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;

},{"./_baseGetAllKeys":135,"./_getSymbolsIn":167,"./keysIn":221}],162:[function(require,module,exports){
var isKeyable = require('./_isKeyable');

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;

},{"./_isKeyable":179}],163:[function(require,module,exports){
var baseIsNative = require('./_baseIsNative'),
    getValue = require('./_getValue');

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

},{"./_baseIsNative":139,"./_getValue":169}],164:[function(require,module,exports){
var overArg = require('./_overArg');

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;

},{"./_overArg":197}],165:[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;

},{"./_Symbol":121}],166:[function(require,module,exports){
var arrayFilter = require('./_arrayFilter'),
    stubArray = require('./stubArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;

},{"./_arrayFilter":125,"./stubArray":222}],167:[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    getPrototype = require('./_getPrototype'),
    getSymbols = require('./_getSymbols'),
    stubArray = require('./stubArray');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;

},{"./_arrayPush":127,"./_getPrototype":164,"./_getSymbols":166,"./stubArray":222}],168:[function(require,module,exports){
var DataView = require('./_DataView'),
    Map = require('./_Map'),
    Promise = require('./_Promise'),
    Set = require('./_Set'),
    WeakMap = require('./_WeakMap'),
    baseGetTag = require('./_baseGetTag'),
    toSource = require('./_toSource');

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;

},{"./_DataView":113,"./_Map":116,"./_Promise":118,"./_Set":119,"./_WeakMap":123,"./_baseGetTag":136,"./_toSource":204}],169:[function(require,module,exports){
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

},{}],170:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;

},{"./_nativeCreate":192}],171:[function(require,module,exports){
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;

},{}],172:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

},{"./_nativeCreate":192}],173:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

},{"./_nativeCreate":192}],174:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

},{"./_nativeCreate":192}],175:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;

},{}],176:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer'),
    cloneDataView = require('./_cloneDataView'),
    cloneRegExp = require('./_cloneRegExp'),
    cloneSymbol = require('./_cloneSymbol'),
    cloneTypedArray = require('./_cloneTypedArray');

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor;

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor;

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;

},{"./_cloneArrayBuffer":147,"./_cloneDataView":149,"./_cloneRegExp":150,"./_cloneSymbol":151,"./_cloneTypedArray":152}],177:[function(require,module,exports){
var baseCreate = require('./_baseCreate'),
    getPrototype = require('./_getPrototype'),
    isPrototype = require('./_isPrototype');

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;

},{"./_baseCreate":134,"./_getPrototype":164,"./_isPrototype":181}],178:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;

},{}],179:[function(require,module,exports){
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;

},{}],180:[function(require,module,exports){
var coreJsData = require('./_coreJsData');

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;

},{"./_coreJsData":157}],181:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;

},{}],182:[function(require,module,exports){
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;

},{}],183:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;

},{"./_assocIndexOf":129}],184:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

},{"./_assocIndexOf":129}],185:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

},{"./_assocIndexOf":129}],186:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;

},{"./_assocIndexOf":129}],187:[function(require,module,exports){
var Hash = require('./_Hash'),
    ListCache = require('./_ListCache'),
    Map = require('./_Map');

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;

},{"./_Hash":114,"./_ListCache":115,"./_Map":116}],188:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;

},{"./_getMapData":162}],189:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

},{"./_getMapData":162}],190:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

},{"./_getMapData":162}],191:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;

},{"./_getMapData":162}],192:[function(require,module,exports){
var getNative = require('./_getNative');

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;

},{"./_getNative":163}],193:[function(require,module,exports){
var overArg = require('./_overArg');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;

},{"./_overArg":197}],194:[function(require,module,exports){
/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;

},{}],195:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

},{"./_freeGlobal":159}],196:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

},{}],197:[function(require,module,exports){
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

},{}],198:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;

},{"./_freeGlobal":159}],199:[function(require,module,exports){
var ListCache = require('./_ListCache');

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;

},{"./_ListCache":115}],200:[function(require,module,exports){
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;

},{}],201:[function(require,module,exports){
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

},{}],202:[function(require,module,exports){
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

},{}],203:[function(require,module,exports){
var ListCache = require('./_ListCache'),
    Map = require('./_Map'),
    MapCache = require('./_MapCache');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;

},{"./_ListCache":115,"./_Map":116,"./_MapCache":117}],204:[function(require,module,exports){
/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;

},{}],205:[function(require,module,exports){
var baseClone = require('./_baseClone');

/** Used to compose bitmasks for cloning. */
var CLONE_SYMBOLS_FLAG = 4;

/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */
function clone(value) {
  return baseClone(value, CLONE_SYMBOLS_FLAG);
}

module.exports = clone;

},{"./_baseClone":133}],206:[function(require,module,exports){
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;

},{}],207:[function(require,module,exports){
var baseIsArguments = require('./_baseIsArguments'),
    isObjectLike = require('./isObjectLike');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;

},{"./_baseIsArguments":137,"./isObjectLike":215}],208:[function(require,module,exports){
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;

},{}],209:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isLength = require('./isLength');

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

},{"./isFunction":211,"./isLength":212}],210:[function(require,module,exports){
var root = require('./_root'),
    stubFalse = require('./stubFalse');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

},{"./_root":198,"./stubFalse":223}],211:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObject = require('./isObject');

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

},{"./_baseGetTag":136,"./isObject":214}],212:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

},{}],213:[function(require,module,exports){
var baseIsMap = require('./_baseIsMap'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');

/* Node.js helper references. */
var nodeIsMap = nodeUtil && nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

module.exports = isMap;

},{"./_baseIsMap":138,"./_baseUnary":146,"./_nodeUtil":195}],214:[function(require,module,exports){
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

},{}],215:[function(require,module,exports){
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;

},{}],216:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    getPrototype = require('./_getPrototype'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;

},{"./_baseGetTag":136,"./_getPrototype":164,"./isObjectLike":215}],217:[function(require,module,exports){
var baseIsRegExp = require('./_baseIsRegExp'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');

/* Node.js helper references. */
var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;

/**
 * Checks if `value` is classified as a `RegExp` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
 * @example
 *
 * _.isRegExp(/abc/);
 * // => true
 *
 * _.isRegExp('/abc/');
 * // => false
 */
var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

module.exports = isRegExp;

},{"./_baseIsRegExp":140,"./_baseUnary":146,"./_nodeUtil":195}],218:[function(require,module,exports){
var baseIsSet = require('./_baseIsSet'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');

/* Node.js helper references. */
var nodeIsSet = nodeUtil && nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

module.exports = isSet;

},{"./_baseIsSet":141,"./_baseUnary":146,"./_nodeUtil":195}],219:[function(require,module,exports){
var baseIsTypedArray = require('./_baseIsTypedArray'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;

},{"./_baseIsTypedArray":142,"./_baseUnary":146,"./_nodeUtil":195}],220:[function(require,module,exports){
var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeys = require('./_baseKeys'),
    isArrayLike = require('./isArrayLike');

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;

},{"./_arrayLikeKeys":126,"./_baseKeys":143,"./isArrayLike":209}],221:[function(require,module,exports){
var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeysIn = require('./_baseKeysIn'),
    isArrayLike = require('./isArrayLike');

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;

},{"./_arrayLikeKeys":126,"./_baseKeysIn":144,"./isArrayLike":209}],222:[function(require,module,exports){
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;

},{}],223:[function(require,module,exports){
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

},{}],224:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],225:[function(require,module,exports){
/*
 * qTip2 - Pretty powerful tooltips - v3.0.3
 * http://qtip2.com
 *
 * Copyright (c) 2016 
 * Released under the MIT licenses
 * http://jquery.org/license
 *
 * Date: Wed May 11 2016 10:31 GMT+0100+0100
 * Plugins: tips modal viewport svg imagemap ie6
 * Styles: core basic css3
 */
/*global window: false, jQuery: false, console: false, define: false */

/* Cache window, document, undefined */
(function( window, document, undefined ) {

// Uses AMD or browser globals to create a jQuery plugin.
(function( factory ) {
	"use strict";
	if(typeof define === 'function' && define.amd) {
		define(['jquery'], factory);
	}
	else if(jQuery && !jQuery.fn.qtip) {
		factory(jQuery);
	}
}
(function($) {
	"use strict"; // Enable ECMAScript "strict" operation for this function. See more: http://ejohn.org/blog/ecmascript-5-strict-mode-json-and-more/
;// Munge the primitives - Paul Irish tip
var TRUE = true,
FALSE = false,
NULL = null,

// Common variables
X = 'x', Y = 'y',
WIDTH = 'width',
HEIGHT = 'height',

// Positioning sides
TOP = 'top',
LEFT = 'left',
BOTTOM = 'bottom',
RIGHT = 'right',
CENTER = 'center',

// Position adjustment types
FLIP = 'flip',
FLIPINVERT = 'flipinvert',
SHIFT = 'shift',

// Shortcut vars
QTIP, PROTOTYPE, CORNER, CHECKS,
PLUGINS = {},
NAMESPACE = 'qtip',
ATTR_HAS = 'data-hasqtip',
ATTR_ID = 'data-qtip-id',
WIDGET = ['ui-widget', 'ui-tooltip'],
SELECTOR = '.'+NAMESPACE,
INACTIVE_EVENTS = 'click dblclick mousedown mouseup mousemove mouseleave mouseenter'.split(' '),

CLASS_FIXED = NAMESPACE+'-fixed',
CLASS_DEFAULT = NAMESPACE + '-default',
CLASS_FOCUS = NAMESPACE + '-focus',
CLASS_HOVER = NAMESPACE + '-hover',
CLASS_DISABLED = NAMESPACE+'-disabled',

replaceSuffix = '_replacedByqTip',
oldtitle = 'oldtitle',
trackingBound,

// Browser detection
BROWSER = {
	/*
	 * IE version detection
	 *
	 * Adapted from: http://ajaxian.com/archives/attack-of-the-ie-conditional-comment
	 * Credit to James Padolsey for the original implemntation!
	 */
	ie: (function() {
		/* eslint-disable no-empty */
		var v, i;
		for (
			v = 4, i = document.createElement('div');
			(i.innerHTML = '<!--[if gt IE ' + v + ']><i></i><![endif]-->') && i.getElementsByTagName('i')[0];
			v+=1
		) {}
		return v > 4 ? v : NaN;
		/* eslint-enable no-empty */
	})(),

	/*
	 * iOS version detection
	 */
	iOS: parseFloat(
		('' + (/CPU.*OS ([0-9_]{1,5})|(CPU like).*AppleWebKit.*Mobile/i.exec(navigator.userAgent) || [0,''])[1])
		.replace('undefined', '3_2').replace('_', '.').replace('_', '')
	) || FALSE
};
;function QTip(target, options, id, attr) {
	// Elements and ID
	this.id = id;
	this.target = target;
	this.tooltip = NULL;
	this.elements = { target: target };

	// Internal constructs
	this._id = NAMESPACE + '-' + id;
	this.timers = { img: {} };
	this.options = options;
	this.plugins = {};

	// Cache object
	this.cache = {
		event: {},
		target: $(),
		disabled: FALSE,
		attr: attr,
		onTooltip: FALSE,
		lastClass: ''
	};

	// Set the initial flags
	this.rendered = this.destroyed = this.disabled = this.waiting =
		this.hiddenDuringWait = this.positioning = this.triggering = FALSE;
}
PROTOTYPE = QTip.prototype;

PROTOTYPE._when = function(deferreds) {
	return $.when.apply($, deferreds);
};

PROTOTYPE.render = function(show) {
	if(this.rendered || this.destroyed) { return this; } // If tooltip has already been rendered, exit

	var self = this,
		options = this.options,
		cache = this.cache,
		elements = this.elements,
		text = options.content.text,
		title = options.content.title,
		button = options.content.button,
		posOptions = options.position,
		deferreds = [];

	// Add ARIA attributes to target
	$.attr(this.target[0], 'aria-describedby', this._id);

	// Create public position object that tracks current position corners
	cache.posClass = this._createPosClass(
		(this.position = { my: posOptions.my, at: posOptions.at }).my
	);

	// Create tooltip element
	this.tooltip = elements.tooltip = $('<div/>', {
		'id': this._id,
		'class': [ NAMESPACE, CLASS_DEFAULT, options.style.classes, cache.posClass ].join(' '),
		'width': options.style.width || '',
		'height': options.style.height || '',
		'tracking': posOptions.target === 'mouse' && posOptions.adjust.mouse,

		/* ARIA specific attributes */
		'role': 'alert',
		'aria-live': 'polite',
		'aria-atomic': FALSE,
		'aria-describedby': this._id + '-content',
		'aria-hidden': TRUE
	})
	.toggleClass(CLASS_DISABLED, this.disabled)
	.attr(ATTR_ID, this.id)
	.data(NAMESPACE, this)
	.appendTo(posOptions.container)
	.append(
		// Create content element
		elements.content = $('<div />', {
			'class': NAMESPACE + '-content',
			'id': this._id + '-content',
			'aria-atomic': TRUE
		})
	);

	// Set rendered flag and prevent redundant reposition calls for now
	this.rendered = -1;
	this.positioning = TRUE;

	// Create title...
	if(title) {
		this._createTitle();

		// Update title only if its not a callback (called in toggle if so)
		if(!$.isFunction(title)) {
			deferreds.push( this._updateTitle(title, FALSE) );
		}
	}

	// Create button
	if(button) { this._createButton(); }

	// Set proper rendered flag and update content if not a callback function (called in toggle)
	if(!$.isFunction(text)) {
		deferreds.push( this._updateContent(text, FALSE) );
	}
	this.rendered = TRUE;

	// Setup widget classes
	this._setWidget();

	// Initialize 'render' plugins
	$.each(PLUGINS, function(name) {
		var instance;
		if(this.initialize === 'render' && (instance = this(self))) {
			self.plugins[name] = instance;
		}
	});

	// Unassign initial events and assign proper events
	this._unassignEvents();
	this._assignEvents();

	// When deferreds have completed
	this._when(deferreds).then(function() {
		// tooltiprender event
		self._trigger('render');

		// Reset flags
		self.positioning = FALSE;

		// Show tooltip if not hidden during wait period
		if(!self.hiddenDuringWait && (options.show.ready || show)) {
			self.toggle(TRUE, cache.event, FALSE);
		}
		self.hiddenDuringWait = FALSE;
	});

	// Expose API
	QTIP.api[this.id] = this;

	return this;
};

PROTOTYPE.destroy = function(immediate) {
	// Set flag the signify destroy is taking place to plugins
	// and ensure it only gets destroyed once!
	if(this.destroyed) { return this.target; }

	function process() {
		if(this.destroyed) { return; }
		this.destroyed = TRUE;

		var target = this.target,
			title = target.attr(oldtitle),
			timer;

		// Destroy tooltip if rendered
		if(this.rendered) {
			this.tooltip.stop(1,0).find('*').remove().end().remove();
		}

		// Destroy all plugins
		$.each(this.plugins, function() {
			this.destroy && this.destroy();
		});

		// Clear timers
		for (timer in this.timers) {
			if (this.timers.hasOwnProperty(timer)) {
				clearTimeout(this.timers[timer]);
			}
		}

		// Remove api object and ARIA attributes
		target.removeData(NAMESPACE)
			.removeAttr(ATTR_ID)
			.removeAttr(ATTR_HAS)
			.removeAttr('aria-describedby');

		// Reset old title attribute if removed
		if(this.options.suppress && title) {
			target.attr('title', title).removeAttr(oldtitle);
		}

		// Remove qTip events associated with this API
		this._unassignEvents();

		// Remove ID from used id objects, and delete object references
		// for better garbage collection and leak protection
		this.options = this.elements = this.cache = this.timers =
			this.plugins = this.mouse = NULL;

		// Delete epoxsed API object
		delete QTIP.api[this.id];
	}

	// If an immediate destroy is needed
	if((immediate !== TRUE || this.triggering === 'hide') && this.rendered) {
		this.tooltip.one('tooltiphidden', $.proxy(process, this));
		!this.triggering && this.hide();
	}

	// If we're not in the process of hiding... process
	else { process.call(this); }

	return this.target;
};
;function invalidOpt(a) {
	return a === NULL || $.type(a) !== 'object';
}

function invalidContent(c) {
	return !($.isFunction(c) || 
            c && c.attr || 
            c.length || 
            $.type(c) === 'object' && (c.jquery || c.then));
}

// Option object sanitizer
function sanitizeOptions(opts) {
	var content, text, ajax, once;

	if(invalidOpt(opts)) { return FALSE; }

	if(invalidOpt(opts.metadata)) {
		opts.metadata = { type: opts.metadata };
	}

	if('content' in opts) {
		content = opts.content;

		if(invalidOpt(content) || content.jquery || content.done) {
			text = invalidContent(content) ? FALSE : content;
			content = opts.content = {
				text: text
			};
		}
		else { text = content.text; }

		// DEPRECATED - Old content.ajax plugin functionality
		// Converts it into the proper Deferred syntax
		if('ajax' in content) {
			ajax = content.ajax;
			once = ajax && ajax.once !== FALSE;
			delete content.ajax;

			content.text = function(event, api) {
				var loading = text || $(this).attr(api.options.content.attr) || 'Loading...',

				deferred = $.ajax(
					$.extend({}, ajax, { context: api })
				)
				.then(ajax.success, NULL, ajax.error)
				.then(function(newContent) {
					if(newContent && once) { api.set('content.text', newContent); }
					return newContent;
				},
				function(xhr, status, error) {
					if(api.destroyed || xhr.status === 0) { return; }
					api.set('content.text', status + ': ' + error);
				});

				return !once ? (api.set('content.text', loading), deferred) : loading;
			};
		}

		if('title' in content) {
			if($.isPlainObject(content.title)) {
				content.button = content.title.button;
				content.title = content.title.text;
			}

			if(invalidContent(content.title || FALSE)) {
				content.title = FALSE;
			}
		}
	}

	if('position' in opts && invalidOpt(opts.position)) {
		opts.position = { my: opts.position, at: opts.position };
	}

	if('show' in opts && invalidOpt(opts.show)) {
		opts.show = opts.show.jquery ? { target: opts.show } :
			opts.show === TRUE ? { ready: TRUE } : { event: opts.show };
	}

	if('hide' in opts && invalidOpt(opts.hide)) {
		opts.hide = opts.hide.jquery ? { target: opts.hide } : { event: opts.hide };
	}

	if('style' in opts && invalidOpt(opts.style)) {
		opts.style = { classes: opts.style };
	}

	// Sanitize plugin options
	$.each(PLUGINS, function() {
		this.sanitize && this.sanitize(opts);
	});

	return opts;
}

// Setup builtin .set() option checks
CHECKS = PROTOTYPE.checks = {
	builtin: {
		// Core checks
		'^id$': function(obj, o, v, prev) {
			var id = v === TRUE ? QTIP.nextid : v,
				newId = NAMESPACE + '-' + id;

			if(id !== FALSE && id.length > 0 && !$('#'+newId).length) {
				this._id = newId;

				if(this.rendered) {
					this.tooltip[0].id = this._id;
					this.elements.content[0].id = this._id + '-content';
					this.elements.title[0].id = this._id + '-title';
				}
			}
			else { obj[o] = prev; }
		},
		'^prerender': function(obj, o, v) {
			v && !this.rendered && this.render(this.options.show.ready);
		},

		// Content checks
		'^content.text$': function(obj, o, v) {
			this._updateContent(v);
		},
		'^content.attr$': function(obj, o, v, prev) {
			if(this.options.content.text === this.target.attr(prev)) {
				this._updateContent( this.target.attr(v) );
			}
		},
		'^content.title$': function(obj, o, v) {
			// Remove title if content is null
			if(!v) { return this._removeTitle(); }

			// If title isn't already created, create it now and update
			v && !this.elements.title && this._createTitle();
			this._updateTitle(v);
		},
		'^content.button$': function(obj, o, v) {
			this._updateButton(v);
		},
		'^content.title.(text|button)$': function(obj, o, v) {
			this.set('content.'+o, v); // Backwards title.text/button compat
		},

		// Position checks
		'^position.(my|at)$': function(obj, o, v){
			if('string' === typeof v) {
				this.position[o] = obj[o] = new CORNER(v, o === 'at');
			}
		},
		'^position.container$': function(obj, o, v){
			this.rendered && this.tooltip.appendTo(v);
		},

		// Show checks
		'^show.ready$': function(obj, o, v) {
			v && (!this.rendered && this.render(TRUE) || this.toggle(TRUE));
		},

		// Style checks
		'^style.classes$': function(obj, o, v, p) {
			this.rendered && this.tooltip.removeClass(p).addClass(v);
		},
		'^style.(width|height)': function(obj, o, v) {
			this.rendered && this.tooltip.css(o, v);
		},
		'^style.widget|content.title': function() {
			this.rendered && this._setWidget();
		},
		'^style.def': function(obj, o, v) {
			this.rendered && this.tooltip.toggleClass(CLASS_DEFAULT, !!v);
		},

		// Events check
		'^events.(render|show|move|hide|focus|blur)$': function(obj, o, v) {
			this.rendered && this.tooltip[($.isFunction(v) ? '' : 'un') + 'bind']('tooltip'+o, v);
		},

		// Properties which require event reassignment
		'^(show|hide|position).(event|target|fixed|inactive|leave|distance|viewport|adjust)': function() {
			if(!this.rendered) { return; }

			// Set tracking flag
			var posOptions = this.options.position;
			this.tooltip.attr('tracking', posOptions.target === 'mouse' && posOptions.adjust.mouse);

			// Reassign events
			this._unassignEvents();
			this._assignEvents();
		}
	}
};

// Dot notation converter
function convertNotation(options, notation) {
	var i = 0, obj, option = options,

	// Split notation into array
	levels = notation.split('.');

	// Loop through
	while(option = option[ levels[i++] ]) {
		if(i < levels.length) { obj = option; }
	}

	return [obj || options, levels.pop()];
}

PROTOTYPE.get = function(notation) {
	if(this.destroyed) { return this; }

	var o = convertNotation(this.options, notation.toLowerCase()),
		result = o[0][ o[1] ];

	return result.precedance ? result.string() : result;
};

function setCallback(notation, args) {
	var category, rule, match;

	for(category in this.checks) {
		if (!this.checks.hasOwnProperty(category)) { continue; }

		for(rule in this.checks[category]) {
			if (!this.checks[category].hasOwnProperty(rule)) { continue; }

			if(match = (new RegExp(rule, 'i')).exec(notation)) {
				args.push(match);

				if(category === 'builtin' || this.plugins[category]) {
					this.checks[category][rule].apply(
						this.plugins[category] || this, args
					);
				}
			}
		}
	}
}

var rmove = /^position\.(my|at|adjust|target|container|viewport)|style|content|show\.ready/i,
	rrender = /^prerender|show\.ready/i;

PROTOTYPE.set = function(option, value) {
	if(this.destroyed) { return this; }

	var rendered = this.rendered,
		reposition = FALSE,
		options = this.options,
		name;

	// Convert singular option/value pair into object form
	if('string' === typeof option) {
		name = option; option = {}; option[name] = value;
	}
	else { option = $.extend({}, option); }

	// Set all of the defined options to their new values
	$.each(option, function(notation, val) {
		if(rendered && rrender.test(notation)) {
			delete option[notation]; return;
		}

		// Set new obj value
		var obj = convertNotation(options, notation.toLowerCase()), previous;
		previous = obj[0][ obj[1] ];
		obj[0][ obj[1] ] = val && val.nodeType ? $(val) : val;

		// Also check if we need to reposition
		reposition = rmove.test(notation) || reposition;

		// Set the new params for the callback
		option[notation] = [obj[0], obj[1], val, previous];
	});

	// Re-sanitize options
	sanitizeOptions(options);

	/*
	 * Execute any valid callbacks for the set options
	 * Also set positioning flag so we don't get loads of redundant repositioning calls.
	 */
	this.positioning = TRUE;
	$.each(option, $.proxy(setCallback, this));
	this.positioning = FALSE;

	// Update position if needed
	if(this.rendered && this.tooltip[0].offsetWidth > 0 && reposition) {
		this.reposition( options.position.target === 'mouse' ? NULL : this.cache.event );
	}

	return this;
};
;PROTOTYPE._update = function(content, element) {
	var self = this,
		cache = this.cache;

	// Make sure tooltip is rendered and content is defined. If not return
	if(!this.rendered || !content) { return FALSE; }

	// Use function to parse content
	if($.isFunction(content)) {
		content = content.call(this.elements.target, cache.event, this) || '';
	}

	// Handle deferred content
	if($.isFunction(content.then)) {
		cache.waiting = TRUE;
		return content.then(function(c) {
			cache.waiting = FALSE;
			return self._update(c, element);
		}, NULL, function(e) {
			return self._update(e, element);
		});
	}

	// If content is null... return false
	if(content === FALSE || !content && content !== '') { return FALSE; }

	// Append new content if its a DOM array and show it if hidden
	if(content.jquery && content.length > 0) {
		element.empty().append(
			content.css({ display: 'block', visibility: 'visible' })
		);
	}

	// Content is a regular string, insert the new content
	else { element.html(content); }

	// Wait for content to be loaded, and reposition
	return this._waitForContent(element).then(function(images) {
		if(self.rendered && self.tooltip[0].offsetWidth > 0) {
			self.reposition(cache.event, !images.length);
		}
	});
};

PROTOTYPE._waitForContent = function(element) {
	var cache = this.cache;

	// Set flag
	cache.waiting = TRUE;

	// If imagesLoaded is included, ensure images have loaded and return promise
	return ( $.fn.imagesLoaded ? element.imagesLoaded() : new $.Deferred().resolve([]) )
		.done(function() { cache.waiting = FALSE; })
		.promise();
};

PROTOTYPE._updateContent = function(content, reposition) {
	this._update(content, this.elements.content, reposition);
};

PROTOTYPE._updateTitle = function(content, reposition) {
	if(this._update(content, this.elements.title, reposition) === FALSE) {
		this._removeTitle(FALSE);
	}
};

PROTOTYPE._createTitle = function()
{
	var elements = this.elements,
		id = this._id+'-title';

	// Destroy previous title element, if present
	if(elements.titlebar) { this._removeTitle(); }

	// Create title bar and title elements
	elements.titlebar = $('<div />', {
		'class': NAMESPACE + '-titlebar ' + (this.options.style.widget ? createWidgetClass('header') : '')
	})
	.append(
		elements.title = $('<div />', {
			'id': id,
			'class': NAMESPACE + '-title',
			'aria-atomic': TRUE
		})
	)
	.insertBefore(elements.content)

	// Button-specific events
	.delegate('.qtip-close', 'mousedown keydown mouseup keyup mouseout', function(event) {
		$(this).toggleClass('ui-state-active ui-state-focus', event.type.substr(-4) === 'down');
	})
	.delegate('.qtip-close', 'mouseover mouseout', function(event){
		$(this).toggleClass('ui-state-hover', event.type === 'mouseover');
	});

	// Create button if enabled
	if(this.options.content.button) { this._createButton(); }
};

PROTOTYPE._removeTitle = function(reposition)
{
	var elements = this.elements;

	if(elements.title) {
		elements.titlebar.remove();
		elements.titlebar = elements.title = elements.button = NULL;

		// Reposition if enabled
		if(reposition !== FALSE) { this.reposition(); }
	}
};
;PROTOTYPE._createPosClass = function(my) {
	return NAMESPACE + '-pos-' + (my || this.options.position.my).abbrev();
};

PROTOTYPE.reposition = function(event, effect) {
	if(!this.rendered || this.positioning || this.destroyed) { return this; }

	// Set positioning flag
	this.positioning = TRUE;

	var cache = this.cache,
		tooltip = this.tooltip,
		posOptions = this.options.position,
		target = posOptions.target,
		my = posOptions.my,
		at = posOptions.at,
		viewport = posOptions.viewport,
		container = posOptions.container,
		adjust = posOptions.adjust,
		method = adjust.method.split(' '),
		tooltipWidth = tooltip.outerWidth(FALSE),
		tooltipHeight = tooltip.outerHeight(FALSE),
		targetWidth = 0,
		targetHeight = 0,
		type = tooltip.css('position'),
		position = { left: 0, top: 0 },
		visible = tooltip[0].offsetWidth > 0,
		isScroll = event && event.type === 'scroll',
		win = $(window),
		doc = container[0].ownerDocument,
		mouse = this.mouse,
		pluginCalculations, offset, adjusted, newClass;

	// Check if absolute position was passed
	if($.isArray(target) && target.length === 2) {
		// Force left top and set position
		at = { x: LEFT, y: TOP };
		position = { left: target[0], top: target[1] };
	}

	// Check if mouse was the target
	else if(target === 'mouse') {
		// Force left top to allow flipping
		at = { x: LEFT, y: TOP };

		// Use the mouse origin that caused the show event, if distance hiding is enabled
		if((!adjust.mouse || this.options.hide.distance) && cache.origin && cache.origin.pageX) {
			event =  cache.origin;
		}

		// Use cached event for resize/scroll events
		else if(!event || event && (event.type === 'resize' || event.type === 'scroll')) {
			event = cache.event;
		}

		// Otherwise, use the cached mouse coordinates if available
		else if(mouse && mouse.pageX) {
			event = mouse;
		}

		// Calculate body and container offset and take them into account below
		if(type !== 'static') { position = container.offset(); }
		if(doc.body.offsetWidth !== (window.innerWidth || doc.documentElement.clientWidth)) {
			offset = $(document.body).offset();
		}

		// Use event coordinates for position
		position = {
			left: event.pageX - position.left + (offset && offset.left || 0),
			top: event.pageY - position.top + (offset && offset.top || 0)
		};

		// Scroll events are a pain, some browsers
		if(adjust.mouse && isScroll && mouse) {
			position.left -= (mouse.scrollX || 0) - win.scrollLeft();
			position.top -= (mouse.scrollY || 0) - win.scrollTop();
		}
	}

	// Target wasn't mouse or absolute...
	else {
		// Check if event targetting is being used
		if(target === 'event') {
			if(event && event.target && event.type !== 'scroll' && event.type !== 'resize') {
				cache.target = $(event.target);
			}
			else if(!event.target) {
				cache.target = this.elements.target;
			}
		}
		else if(target !== 'event'){
			cache.target = $(target.jquery ? target : this.elements.target);
		}
		target = cache.target;

		// Parse the target into a jQuery object and make sure there's an element present
		target = $(target).eq(0);
		if(target.length === 0) { return this; }

		// Check if window or document is the target
		else if(target[0] === document || target[0] === window) {
			targetWidth = BROWSER.iOS ? window.innerWidth : target.width();
			targetHeight = BROWSER.iOS ? window.innerHeight : target.height();

			if(target[0] === window) {
				position = {
					top: (viewport || target).scrollTop(),
					left: (viewport || target).scrollLeft()
				};
			}
		}

		// Check if the target is an <AREA> element
		else if(PLUGINS.imagemap && target.is('area')) {
			pluginCalculations = PLUGINS.imagemap(this, target, at, PLUGINS.viewport ? method : FALSE);
		}

		// Check if the target is an SVG element
		else if(PLUGINS.svg && target && target[0].ownerSVGElement) {
			pluginCalculations = PLUGINS.svg(this, target, at, PLUGINS.viewport ? method : FALSE);
		}

		// Otherwise use regular jQuery methods
		else {
			targetWidth = target.outerWidth(FALSE);
			targetHeight = target.outerHeight(FALSE);
			position = target.offset();
		}

		// Parse returned plugin values into proper variables
		if(pluginCalculations) {
			targetWidth = pluginCalculations.width;
			targetHeight = pluginCalculations.height;
			offset = pluginCalculations.offset;
			position = pluginCalculations.position;
		}

		// Adjust position to take into account offset parents
		position = this.reposition.offset(target, position, container);

		// Adjust for position.fixed tooltips (and also iOS scroll bug in v3.2-4.0 & v4.3-4.3.2)
		if(BROWSER.iOS > 3.1 && BROWSER.iOS < 4.1 ||
			BROWSER.iOS >= 4.3 && BROWSER.iOS < 4.33 ||
			!BROWSER.iOS && type === 'fixed'
		){
			position.left -= win.scrollLeft();
			position.top -= win.scrollTop();
		}

		// Adjust position relative to target
		if(!pluginCalculations || pluginCalculations && pluginCalculations.adjustable !== FALSE) {
			position.left += at.x === RIGHT ? targetWidth : at.x === CENTER ? targetWidth / 2 : 0;
			position.top += at.y === BOTTOM ? targetHeight : at.y === CENTER ? targetHeight / 2 : 0;
		}
	}

	// Adjust position relative to tooltip
	position.left += adjust.x + (my.x === RIGHT ? -tooltipWidth : my.x === CENTER ? -tooltipWidth / 2 : 0);
	position.top += adjust.y + (my.y === BOTTOM ? -tooltipHeight : my.y === CENTER ? -tooltipHeight / 2 : 0);

	// Use viewport adjustment plugin if enabled
	if(PLUGINS.viewport) {
		adjusted = position.adjusted = PLUGINS.viewport(
			this, position, posOptions, targetWidth, targetHeight, tooltipWidth, tooltipHeight
		);

		// Apply offsets supplied by positioning plugin (if used)
		if(offset && adjusted.left) { position.left += offset.left; }
		if(offset && adjusted.top) {  position.top += offset.top; }

		// Apply any new 'my' position
		if(adjusted.my) { this.position.my = adjusted.my; }
	}

	// Viewport adjustment is disabled, set values to zero
	else { position.adjusted = { left: 0, top: 0 }; }

	// Set tooltip position class if it's changed
	if(cache.posClass !== (newClass = this._createPosClass(this.position.my))) {
		cache.posClass = newClass;
		tooltip.removeClass(cache.posClass).addClass(newClass);
	}

	// tooltipmove event
	if(!this._trigger('move', [position, viewport.elem || viewport], event)) { return this; }
	delete position.adjusted;

	// If effect is disabled, target it mouse, no animation is defined or positioning gives NaN out, set CSS directly
	if(effect === FALSE || !visible || isNaN(position.left) || isNaN(position.top) || target === 'mouse' || !$.isFunction(posOptions.effect)) {
		tooltip.css(position);
	}

	// Use custom function if provided
	else if($.isFunction(posOptions.effect)) {
		posOptions.effect.call(tooltip, this, $.extend({}, position));
		tooltip.queue(function(next) {
			// Reset attributes to avoid cross-browser rendering bugs
			$(this).css({ opacity: '', height: '' });
			if(BROWSER.ie) { this.style.removeAttribute('filter'); }

			next();
		});
	}

	// Set positioning flag
	this.positioning = FALSE;

	return this;
};

// Custom (more correct for qTip!) offset calculator
PROTOTYPE.reposition.offset = function(elem, pos, container) {
	if(!container[0]) { return pos; }

	var ownerDocument = $(elem[0].ownerDocument),
		quirks = !!BROWSER.ie && document.compatMode !== 'CSS1Compat',
		parent = container[0],
		scrolled, position, parentOffset, overflow;

	function scroll(e, i) {
		pos.left += i * e.scrollLeft();
		pos.top += i * e.scrollTop();
	}

	// Compensate for non-static containers offset
	do {
		if((position = $.css(parent, 'position')) !== 'static') {
			if(position === 'fixed') {
				parentOffset = parent.getBoundingClientRect();
				scroll(ownerDocument, -1);
			}
			else {
				parentOffset = $(parent).position();
				parentOffset.left += parseFloat($.css(parent, 'borderLeftWidth')) || 0;
				parentOffset.top += parseFloat($.css(parent, 'borderTopWidth')) || 0;
			}

			pos.left -= parentOffset.left + (parseFloat($.css(parent, 'marginLeft')) || 0);
			pos.top -= parentOffset.top + (parseFloat($.css(parent, 'marginTop')) || 0);

			// If this is the first parent element with an overflow of "scroll" or "auto", store it
			if(!scrolled && (overflow = $.css(parent, 'overflow')) !== 'hidden' && overflow !== 'visible') { scrolled = $(parent); }
		}
	}
	while(parent = parent.offsetParent);

	// Compensate for containers scroll if it also has an offsetParent (or in IE quirks mode)
	if(scrolled && (scrolled[0] !== ownerDocument[0] || quirks)) {
		scroll(scrolled, 1);
	}

	return pos;
};

// Corner class
var C = (CORNER = PROTOTYPE.reposition.Corner = function(corner, forceY) {
	corner = ('' + corner).replace(/([A-Z])/, ' $1').replace(/middle/gi, CENTER).toLowerCase();
	this.x = (corner.match(/left|right/i) || corner.match(/center/) || ['inherit'])[0].toLowerCase();
	this.y = (corner.match(/top|bottom|center/i) || ['inherit'])[0].toLowerCase();
	this.forceY = !!forceY;

	var f = corner.charAt(0);
	this.precedance = f === 't' || f === 'b' ? Y : X;
}).prototype;

C.invert = function(z, center) {
	this[z] = this[z] === LEFT ? RIGHT : this[z] === RIGHT ? LEFT : center || this[z];
};

C.string = function(join) {
	var x = this.x, y = this.y;

	var result = x !== y ?
		x === 'center' || y !== 'center' && (this.precedance === Y || this.forceY) ? 
			[y,x] : 
			[x,y] :
		[x];

	return join !== false ? result.join(' ') : result;
};

C.abbrev = function() {
	var result = this.string(false);
	return result[0].charAt(0) + (result[1] && result[1].charAt(0) || '');
};

C.clone = function() {
	return new CORNER( this.string(), this.forceY );
};

;
PROTOTYPE.toggle = function(state, event) {
	var cache = this.cache,
		options = this.options,
		tooltip = this.tooltip;

	// Try to prevent flickering when tooltip overlaps show element
	if(event) {
		if((/over|enter/).test(event.type) && cache.event && (/out|leave/).test(cache.event.type) &&
			options.show.target.add(event.target).length === options.show.target.length &&
			tooltip.has(event.relatedTarget).length) {
			return this;
		}

		// Cache event
		cache.event = $.event.fix(event);
	}

	// If we're currently waiting and we've just hidden... stop it
	this.waiting && !state && (this.hiddenDuringWait = TRUE);

	// Render the tooltip if showing and it isn't already
	if(!this.rendered) { return state ? this.render(1) : this; }
	else if(this.destroyed || this.disabled) { return this; }

	var type = state ? 'show' : 'hide',
		opts = this.options[type],
		posOptions = this.options.position,
		contentOptions = this.options.content,
		width = this.tooltip.css('width'),
		visible = this.tooltip.is(':visible'),
		animate = state || opts.target.length === 1,
		sameTarget = !event || opts.target.length < 2 || cache.target[0] === event.target,
		identicalState, allow, after;

	// Detect state if valid one isn't provided
	if((typeof state).search('boolean|number')) { state = !visible; }

	// Check if the tooltip is in an identical state to the new would-be state
	identicalState = !tooltip.is(':animated') && visible === state && sameTarget;

	// Fire tooltip(show/hide) event and check if destroyed
	allow = !identicalState ? !!this._trigger(type, [90]) : NULL;

	// Check to make sure the tooltip wasn't destroyed in the callback
	if(this.destroyed) { return this; }

	// If the user didn't stop the method prematurely and we're showing the tooltip, focus it
	if(allow !== FALSE && state) { this.focus(event); }

	// If the state hasn't changed or the user stopped it, return early
	if(!allow || identicalState) { return this; }

	// Set ARIA hidden attribute
	$.attr(tooltip[0], 'aria-hidden', !!!state);

	// Execute state specific properties
	if(state) {
		// Store show origin coordinates
		this.mouse && (cache.origin = $.event.fix(this.mouse));

		// Update tooltip content & title if it's a dynamic function
		if($.isFunction(contentOptions.text)) { this._updateContent(contentOptions.text, FALSE); }
		if($.isFunction(contentOptions.title)) { this._updateTitle(contentOptions.title, FALSE); }

		// Cache mousemove events for positioning purposes (if not already tracking)
		if(!trackingBound && posOptions.target === 'mouse' && posOptions.adjust.mouse) {
			$(document).bind('mousemove.'+NAMESPACE, this._storeMouse);
			trackingBound = TRUE;
		}

		// Update the tooltip position (set width first to prevent viewport/max-width issues)
		if(!width) { tooltip.css('width', tooltip.outerWidth(FALSE)); }
		this.reposition(event, arguments[2]);
		if(!width) { tooltip.css('width', ''); }

		// Hide other tooltips if tooltip is solo
		if(!!opts.solo) {
			(typeof opts.solo === 'string' ? $(opts.solo) : $(SELECTOR, opts.solo))
				.not(tooltip).not(opts.target).qtip('hide', new $.Event('tooltipsolo'));
		}
	}
	else {
		// Clear show timer if we're hiding
		clearTimeout(this.timers.show);

		// Remove cached origin on hide
		delete cache.origin;

		// Remove mouse tracking event if not needed (all tracking qTips are hidden)
		if(trackingBound && !$(SELECTOR+'[tracking="true"]:visible', opts.solo).not(tooltip).length) {
			$(document).unbind('mousemove.'+NAMESPACE);
			trackingBound = FALSE;
		}

		// Blur the tooltip
		this.blur(event);
	}

	// Define post-animation, state specific properties
	after = $.proxy(function() {
		if(state) {
			// Prevent antialias from disappearing in IE by removing filter
			if(BROWSER.ie) { tooltip[0].style.removeAttribute('filter'); }

			// Remove overflow setting to prevent tip bugs
			tooltip.css('overflow', '');

			// Autofocus elements if enabled
			if('string' === typeof opts.autofocus) {
				$(this.options.show.autofocus, tooltip).focus();
			}

			// If set, hide tooltip when inactive for delay period
			this.options.show.target.trigger('qtip-'+this.id+'-inactive');
		}
		else {
			// Reset CSS states
			tooltip.css({
				display: '',
				visibility: '',
				opacity: '',
				left: '',
				top: ''
			});
		}

		// tooltipvisible/tooltiphidden events
		this._trigger(state ? 'visible' : 'hidden');
	}, this);

	// If no effect type is supplied, use a simple toggle
	if(opts.effect === FALSE || animate === FALSE) {
		tooltip[ type ]();
		after();
	}

	// Use custom function if provided
	else if($.isFunction(opts.effect)) {
		tooltip.stop(1, 1);
		opts.effect.call(tooltip, this);
		tooltip.queue('fx', function(n) {
			after(); n();
		});
	}

	// Use basic fade function by default
	else { tooltip.fadeTo(90, state ? 1 : 0, after); }

	// If inactive hide method is set, active it
	if(state) { opts.target.trigger('qtip-'+this.id+'-inactive'); }

	return this;
};

PROTOTYPE.show = function(event) { return this.toggle(TRUE, event); };

PROTOTYPE.hide = function(event) { return this.toggle(FALSE, event); };
;PROTOTYPE.focus = function(event) {
	if(!this.rendered || this.destroyed) { return this; }

	var qtips = $(SELECTOR),
		tooltip = this.tooltip,
		curIndex = parseInt(tooltip[0].style.zIndex, 10),
		newIndex = QTIP.zindex + qtips.length;

	// Only update the z-index if it has changed and tooltip is not already focused
	if(!tooltip.hasClass(CLASS_FOCUS)) {
		// tooltipfocus event
		if(this._trigger('focus', [newIndex], event)) {
			// Only update z-index's if they've changed
			if(curIndex !== newIndex) {
				// Reduce our z-index's and keep them properly ordered
				qtips.each(function() {
					if(this.style.zIndex > curIndex) {
						this.style.zIndex = this.style.zIndex - 1;
					}
				});

				// Fire blur event for focused tooltip
				qtips.filter('.' + CLASS_FOCUS).qtip('blur', event);
			}

			// Set the new z-index
			tooltip.addClass(CLASS_FOCUS)[0].style.zIndex = newIndex;
		}
	}

	return this;
};

PROTOTYPE.blur = function(event) {
	if(!this.rendered || this.destroyed) { return this; }

	// Set focused status to FALSE
	this.tooltip.removeClass(CLASS_FOCUS);

	// tooltipblur event
	this._trigger('blur', [ this.tooltip.css('zIndex') ], event);

	return this;
};
;PROTOTYPE.disable = function(state) {
	if(this.destroyed) { return this; }

	// If 'toggle' is passed, toggle the current state
	if(state === 'toggle') {
		state = !(this.rendered ? this.tooltip.hasClass(CLASS_DISABLED) : this.disabled);
	}

	// Disable if no state passed
	else if('boolean' !== typeof state) {
		state = TRUE;
	}

	if(this.rendered) {
		this.tooltip.toggleClass(CLASS_DISABLED, state)
			.attr('aria-disabled', state);
	}

	this.disabled = !!state;

	return this;
};

PROTOTYPE.enable = function() { return this.disable(FALSE); };
;PROTOTYPE._createButton = function()
{
	var self = this,
		elements = this.elements,
		tooltip = elements.tooltip,
		button = this.options.content.button,
		isString = typeof button === 'string',
		close = isString ? button : 'Close tooltip';

	if(elements.button) { elements.button.remove(); }

	// Use custom button if one was supplied by user, else use default
	if(button.jquery) {
		elements.button = button;
	}
	else {
		elements.button = $('<a />', {
			'class': 'qtip-close ' + (this.options.style.widget ? '' : NAMESPACE+'-icon'),
			'title': close,
			'aria-label': close
		})
		.prepend(
			$('<span />', {
				'class': 'ui-icon ui-icon-close',
				'html': '&times;'
			})
		);
	}

	// Create button and setup attributes
	elements.button.appendTo(elements.titlebar || tooltip)
		.attr('role', 'button')
		.click(function(event) {
			if(!tooltip.hasClass(CLASS_DISABLED)) { self.hide(event); }
			return FALSE;
		});
};

PROTOTYPE._updateButton = function(button)
{
	// Make sure tooltip is rendered and if not, return
	if(!this.rendered) { return FALSE; }

	var elem = this.elements.button;
	if(button) { this._createButton(); }
	else { elem.remove(); }
};
;// Widget class creator
function createWidgetClass(cls) {
	return WIDGET.concat('').join(cls ? '-'+cls+' ' : ' ');
}

// Widget class setter method
PROTOTYPE._setWidget = function()
{
	var on = this.options.style.widget,
		elements = this.elements,
		tooltip = elements.tooltip,
		disabled = tooltip.hasClass(CLASS_DISABLED);

	tooltip.removeClass(CLASS_DISABLED);
	CLASS_DISABLED = on ? 'ui-state-disabled' : 'qtip-disabled';
	tooltip.toggleClass(CLASS_DISABLED, disabled);

	tooltip.toggleClass('ui-helper-reset '+createWidgetClass(), on).toggleClass(CLASS_DEFAULT, this.options.style.def && !on);

	if(elements.content) {
		elements.content.toggleClass( createWidgetClass('content'), on);
	}
	if(elements.titlebar) {
		elements.titlebar.toggleClass( createWidgetClass('header'), on);
	}
	if(elements.button) {
		elements.button.toggleClass(NAMESPACE+'-icon', !on);
	}
};
;function delay(callback, duration) {
	// If tooltip has displayed, start hide timer
	if(duration > 0) {
		return setTimeout(
			$.proxy(callback, this), duration
		);
	}
	else{ callback.call(this); }
}

function showMethod(event) {
	if(this.tooltip.hasClass(CLASS_DISABLED)) { return; }

	// Clear hide timers
	clearTimeout(this.timers.show);
	clearTimeout(this.timers.hide);

	// Start show timer
	this.timers.show = delay.call(this,
		function() { this.toggle(TRUE, event); },
		this.options.show.delay
	);
}

function hideMethod(event) {
	if(this.tooltip.hasClass(CLASS_DISABLED) || this.destroyed) { return; }

	// Check if new target was actually the tooltip element
	var relatedTarget = $(event.relatedTarget),
		ontoTooltip = relatedTarget.closest(SELECTOR)[0] === this.tooltip[0],
		ontoTarget = relatedTarget[0] === this.options.show.target[0];

	// Clear timers and stop animation queue
	clearTimeout(this.timers.show);
	clearTimeout(this.timers.hide);

	// Prevent hiding if tooltip is fixed and event target is the tooltip.
	// Or if mouse positioning is enabled and cursor momentarily overlaps
	if(this !== relatedTarget[0] &&
		(this.options.position.target === 'mouse' && ontoTooltip) ||
		this.options.hide.fixed && (
			(/mouse(out|leave|move)/).test(event.type) && (ontoTooltip || ontoTarget))
		)
	{
		/* eslint-disable no-empty */
		try {
			event.preventDefault();
			event.stopImmediatePropagation();
		} catch(e) {}
		/* eslint-enable no-empty */

		return;
	}

	// If tooltip has displayed, start hide timer
	this.timers.hide = delay.call(this,
		function() { this.toggle(FALSE, event); },
		this.options.hide.delay,
		this
	);
}

function inactiveMethod(event) {
	if(this.tooltip.hasClass(CLASS_DISABLED) || !this.options.hide.inactive) { return; }

	// Clear timer
	clearTimeout(this.timers.inactive);

	this.timers.inactive = delay.call(this,
		function(){ this.hide(event); },
		this.options.hide.inactive
	);
}

function repositionMethod(event) {
	if(this.rendered && this.tooltip[0].offsetWidth > 0) { this.reposition(event); }
}

// Store mouse coordinates
PROTOTYPE._storeMouse = function(event) {
	(this.mouse = $.event.fix(event)).type = 'mousemove';
	return this;
};

// Bind events
PROTOTYPE._bind = function(targets, events, method, suffix, context) {
	if(!targets || !method || !events.length) { return; }
	var ns = '.' + this._id + (suffix ? '-'+suffix : '');
	$(targets).bind(
		(events.split ? events : events.join(ns + ' ')) + ns,
		$.proxy(method, context || this)
	);
	return this;
};
PROTOTYPE._unbind = function(targets, suffix) {
	targets && $(targets).unbind('.' + this._id + (suffix ? '-'+suffix : ''));
	return this;
};

// Global delegation helper
function delegate(selector, events, method) {
	$(document.body).delegate(selector,
		(events.split ? events : events.join('.'+NAMESPACE + ' ')) + '.'+NAMESPACE,
		function() {
			var api = QTIP.api[ $.attr(this, ATTR_ID) ];
			api && !api.disabled && method.apply(api, arguments);
		}
	);
}
// Event trigger
PROTOTYPE._trigger = function(type, args, event) {
	var callback = new $.Event('tooltip'+type);
	callback.originalEvent = event && $.extend({}, event) || this.cache.event || NULL;

	this.triggering = type;
	this.tooltip.trigger(callback, [this].concat(args || []));
	this.triggering = FALSE;

	return !callback.isDefaultPrevented();
};

PROTOTYPE._bindEvents = function(showEvents, hideEvents, showTargets, hideTargets, showCallback, hideCallback) {
	// Get tasrgets that lye within both
	var similarTargets = showTargets.filter( hideTargets ).add( hideTargets.filter(showTargets) ),
		toggleEvents = [];

	// If hide and show targets are the same...
	if(similarTargets.length) {

		// Filter identical show/hide events
		$.each(hideEvents, function(i, type) {
			var showIndex = $.inArray(type, showEvents);

			// Both events are identical, remove from both hide and show events
			// and append to toggleEvents
			showIndex > -1 && toggleEvents.push( showEvents.splice( showIndex, 1 )[0] );
		});

		// Toggle events are special case of identical show/hide events, which happen in sequence
		if(toggleEvents.length) {
			// Bind toggle events to the similar targets
			this._bind(similarTargets, toggleEvents, function(event) {
				var state = this.rendered ? this.tooltip[0].offsetWidth > 0 : false;
				(state ? hideCallback : showCallback).call(this, event);
			});

			// Remove the similar targets from the regular show/hide bindings
			showTargets = showTargets.not(similarTargets);
			hideTargets = hideTargets.not(similarTargets);
		}
	}

	// Apply show/hide/toggle events
	this._bind(showTargets, showEvents, showCallback);
	this._bind(hideTargets, hideEvents, hideCallback);
};

PROTOTYPE._assignInitialEvents = function(event) {
	var options = this.options,
		showTarget = options.show.target,
		hideTarget = options.hide.target,
		showEvents = options.show.event ? $.trim('' + options.show.event).split(' ') : [],
		hideEvents = options.hide.event ? $.trim('' + options.hide.event).split(' ') : [];

	// Catch remove/removeqtip events on target element to destroy redundant tooltips
	this._bind(this.elements.target, ['remove', 'removeqtip'], function() {
		this.destroy(true);
	}, 'destroy');

	/*
	 * Make sure hoverIntent functions properly by using mouseleave as a hide event if
	 * mouseenter/mouseout is used for show.event, even if it isn't in the users options.
	 */
	if(/mouse(over|enter)/i.test(options.show.event) && !/mouse(out|leave)/i.test(options.hide.event)) {
		hideEvents.push('mouseleave');
	}

	/*
	 * Also make sure initial mouse targetting works correctly by caching mousemove coords
	 * on show targets before the tooltip has rendered. Also set onTarget when triggered to
	 * keep mouse tracking working.
	 */
	this._bind(showTarget, 'mousemove', function(moveEvent) {
		this._storeMouse(moveEvent);
		this.cache.onTarget = TRUE;
	});

	// Define hoverIntent function
	function hoverIntent(hoverEvent) {
		// Only continue if tooltip isn't disabled
		if(this.disabled || this.destroyed) { return FALSE; }

		// Cache the event data
		this.cache.event = hoverEvent && $.event.fix(hoverEvent);
		this.cache.target = hoverEvent && $(hoverEvent.target);

		// Start the event sequence
		clearTimeout(this.timers.show);
		this.timers.show = delay.call(this,
			function() { this.render(typeof hoverEvent === 'object' || options.show.ready); },
			options.prerender ? 0 : options.show.delay
		);
	}

	// Filter and bind events
	this._bindEvents(showEvents, hideEvents, showTarget, hideTarget, hoverIntent, function() {
		if(!this.timers) { return FALSE; }
		clearTimeout(this.timers.show);
	});

	// Prerendering is enabled, create tooltip now
	if(options.show.ready || options.prerender) { hoverIntent.call(this, event); }
};

// Event assignment method
PROTOTYPE._assignEvents = function() {
	var self = this,
		options = this.options,
		posOptions = options.position,

		tooltip = this.tooltip,
		showTarget = options.show.target,
		hideTarget = options.hide.target,
		containerTarget = posOptions.container,
		viewportTarget = posOptions.viewport,
		documentTarget = $(document),
		windowTarget = $(window),

		showEvents = options.show.event ? $.trim('' + options.show.event).split(' ') : [],
		hideEvents = options.hide.event ? $.trim('' + options.hide.event).split(' ') : [];


	// Assign passed event callbacks
	$.each(options.events, function(name, callback) {
		self._bind(tooltip, name === 'toggle' ? ['tooltipshow','tooltiphide'] : ['tooltip'+name], callback, null, tooltip);
	});

	// Hide tooltips when leaving current window/frame (but not select/option elements)
	if(/mouse(out|leave)/i.test(options.hide.event) && options.hide.leave === 'window') {
		this._bind(documentTarget, ['mouseout', 'blur'], function(event) {
			if(!/select|option/.test(event.target.nodeName) && !event.relatedTarget) {
				this.hide(event);
			}
		});
	}

	// Enable hide.fixed by adding appropriate class
	if(options.hide.fixed) {
		hideTarget = hideTarget.add( tooltip.addClass(CLASS_FIXED) );
	}

	/*
	 * Make sure hoverIntent functions properly by using mouseleave to clear show timer if
	 * mouseenter/mouseout is used for show.event, even if it isn't in the users options.
	 */
	else if(/mouse(over|enter)/i.test(options.show.event)) {
		this._bind(hideTarget, 'mouseleave', function() {
			clearTimeout(this.timers.show);
		});
	}

	// Hide tooltip on document mousedown if unfocus events are enabled
	if(('' + options.hide.event).indexOf('unfocus') > -1) {
		this._bind(containerTarget.closest('html'), ['mousedown', 'touchstart'], function(event) {
			var elem = $(event.target),
				enabled = this.rendered && !this.tooltip.hasClass(CLASS_DISABLED) && this.tooltip[0].offsetWidth > 0,
				isAncestor = elem.parents(SELECTOR).filter(this.tooltip[0]).length > 0;

			if(elem[0] !== this.target[0] && elem[0] !== this.tooltip[0] && !isAncestor &&
				!this.target.has(elem[0]).length && enabled
			) {
				this.hide(event);
			}
		});
	}

	// Check if the tooltip hides when inactive
	if('number' === typeof options.hide.inactive) {
		// Bind inactive method to show target(s) as a custom event
		this._bind(showTarget, 'qtip-'+this.id+'-inactive', inactiveMethod, 'inactive');

		// Define events which reset the 'inactive' event handler
		this._bind(hideTarget.add(tooltip), QTIP.inactiveEvents, inactiveMethod);
	}

	// Filter and bind events
	this._bindEvents(showEvents, hideEvents, showTarget, hideTarget, showMethod, hideMethod);

	// Mouse movement bindings
	this._bind(showTarget.add(tooltip), 'mousemove', function(event) {
		// Check if the tooltip hides when mouse is moved a certain distance
		if('number' === typeof options.hide.distance) {
			var origin = this.cache.origin || {},
				limit = this.options.hide.distance,
				abs = Math.abs;

			// Check if the movement has gone beyond the limit, and hide it if so
			if(abs(event.pageX - origin.pageX) >= limit || abs(event.pageY - origin.pageY) >= limit) {
				this.hide(event);
			}
		}

		// Cache mousemove coords on show targets
		this._storeMouse(event);
	});

	// Mouse positioning events
	if(posOptions.target === 'mouse') {
		// If mouse adjustment is on...
		if(posOptions.adjust.mouse) {
			// Apply a mouseleave event so we don't get problems with overlapping
			if(options.hide.event) {
				// Track if we're on the target or not
				this._bind(showTarget, ['mouseenter', 'mouseleave'], function(event) {
					if(!this.cache) {return FALSE; }
					this.cache.onTarget = event.type === 'mouseenter';
				});
			}

			// Update tooltip position on mousemove
			this._bind(documentTarget, 'mousemove', function(event) {
				// Update the tooltip position only if the tooltip is visible and adjustment is enabled
				if(this.rendered && this.cache.onTarget && !this.tooltip.hasClass(CLASS_DISABLED) && this.tooltip[0].offsetWidth > 0) {
					this.reposition(event);
				}
			});
		}
	}

	// Adjust positions of the tooltip on window resize if enabled
	if(posOptions.adjust.resize || viewportTarget.length) {
		this._bind( $.event.special.resize ? viewportTarget : windowTarget, 'resize', repositionMethod );
	}

	// Adjust tooltip position on scroll of the window or viewport element if present
	if(posOptions.adjust.scroll) {
		this._bind( windowTarget.add(posOptions.container), 'scroll', repositionMethod );
	}
};

// Un-assignment method
PROTOTYPE._unassignEvents = function() {
	var options = this.options,
		showTargets = options.show.target,
		hideTargets = options.hide.target,
		targets = $.grep([
			this.elements.target[0],
			this.rendered && this.tooltip[0],
			options.position.container[0],
			options.position.viewport[0],
			options.position.container.closest('html')[0], // unfocus
			window,
			document
		], function(i) {
			return typeof i === 'object';
		});

	// Add show and hide targets if they're valid
	if(showTargets && showTargets.toArray) {
		targets = targets.concat(showTargets.toArray());
	}
	if(hideTargets && hideTargets.toArray) {
		targets = targets.concat(hideTargets.toArray());
	}

	// Unbind the events
	this._unbind(targets)
		._unbind(targets, 'destroy')
		._unbind(targets, 'inactive');
};

// Apply common event handlers using delegate (avoids excessive .bind calls!)
$(function() {
	delegate(SELECTOR, ['mouseenter', 'mouseleave'], function(event) {
		var state = event.type === 'mouseenter',
			tooltip = $(event.currentTarget),
			target = $(event.relatedTarget || event.target),
			options = this.options;

		// On mouseenter...
		if(state) {
			// Focus the tooltip on mouseenter (z-index stacking)
			this.focus(event);

			// Clear hide timer on tooltip hover to prevent it from closing
			tooltip.hasClass(CLASS_FIXED) && !tooltip.hasClass(CLASS_DISABLED) && clearTimeout(this.timers.hide);
		}

		// On mouseleave...
		else {
			// When mouse tracking is enabled, hide when we leave the tooltip and not onto the show target (if a hide event is set)
			if(options.position.target === 'mouse' && options.position.adjust.mouse &&
				options.hide.event && options.show.target && !target.closest(options.show.target[0]).length) {
				this.hide(event);
			}
		}

		// Add hover class
		tooltip.toggleClass(CLASS_HOVER, state);
	});

	// Define events which reset the 'inactive' event handler
	delegate('['+ATTR_ID+']', INACTIVE_EVENTS, inactiveMethod);
});
;// Initialization method
function init(elem, id, opts) {
	var obj, posOptions, attr, config, title,

	// Setup element references
	docBody = $(document.body),

	// Use document body instead of document element if needed
	newTarget = elem[0] === document ? docBody : elem,

	// Grab metadata from element if plugin is present
	metadata = elem.metadata ? elem.metadata(opts.metadata) : NULL,

	// If metadata type if HTML5, grab 'name' from the object instead, or use the regular data object otherwise
	metadata5 = opts.metadata.type === 'html5' && metadata ? metadata[opts.metadata.name] : NULL,

	// Grab data from metadata.name (or data-qtipopts as fallback) using .data() method,
	html5 = elem.data(opts.metadata.name || 'qtipopts');

	// If we don't get an object returned attempt to parse it manualyl without parseJSON
	/* eslint-disable no-empty */
	try { html5 = typeof html5 === 'string' ? $.parseJSON(html5) : html5; }
	catch(e) {}
	/* eslint-enable no-empty */

	// Merge in and sanitize metadata
	config = $.extend(TRUE, {}, QTIP.defaults, opts,
		typeof html5 === 'object' ? sanitizeOptions(html5) : NULL,
		sanitizeOptions(metadata5 || metadata));

	// Re-grab our positioning options now we've merged our metadata and set id to passed value
	posOptions = config.position;
	config.id = id;

	// Setup missing content if none is detected
	if('boolean' === typeof config.content.text) {
		attr = elem.attr(config.content.attr);

		// Grab from supplied attribute if available
		if(config.content.attr !== FALSE && attr) { config.content.text = attr; }

		// No valid content was found, abort render
		else { return FALSE; }
	}

	// Setup target options
	if(!posOptions.container.length) { posOptions.container = docBody; }
	if(posOptions.target === FALSE) { posOptions.target = newTarget; }
	if(config.show.target === FALSE) { config.show.target = newTarget; }
	if(config.show.solo === TRUE) { config.show.solo = posOptions.container.closest('body'); }
	if(config.hide.target === FALSE) { config.hide.target = newTarget; }
	if(config.position.viewport === TRUE) { config.position.viewport = posOptions.container; }

	// Ensure we only use a single container
	posOptions.container = posOptions.container.eq(0);

	// Convert position corner values into x and y strings
	posOptions.at = new CORNER(posOptions.at, TRUE);
	posOptions.my = new CORNER(posOptions.my);

	// Destroy previous tooltip if overwrite is enabled, or skip element if not
	if(elem.data(NAMESPACE)) {
		if(config.overwrite) {
			elem.qtip('destroy', true);
		}
		else if(config.overwrite === FALSE) {
			return FALSE;
		}
	}

	// Add has-qtip attribute
	elem.attr(ATTR_HAS, id);

	// Remove title attribute and store it if present
	if(config.suppress && (title = elem.attr('title'))) {
		// Final attr call fixes event delegatiom and IE default tooltip showing problem
		elem.removeAttr('title').attr(oldtitle, title).attr('title', '');
	}

	// Initialize the tooltip and add API reference
	obj = new QTip(elem, config, id, !!attr);
	elem.data(NAMESPACE, obj);

	return obj;
}

// jQuery $.fn extension method
QTIP = $.fn.qtip = function(options, notation, newValue)
{
	var command = ('' + options).toLowerCase(), // Parse command
		returned = NULL,
		args = $.makeArray(arguments).slice(1),
		event = args[args.length - 1],
		opts = this[0] ? $.data(this[0], NAMESPACE) : NULL;

	// Check for API request
	if(!arguments.length && opts || command === 'api') {
		return opts;
	}

	// Execute API command if present
	else if('string' === typeof options) {
		this.each(function() {
			var api = $.data(this, NAMESPACE);
			if(!api) { return TRUE; }

			// Cache the event if possible
			if(event && event.timeStamp) { api.cache.event = event; }

			// Check for specific API commands
			if(notation && (command === 'option' || command === 'options')) {
				if(newValue !== undefined || $.isPlainObject(notation)) {
					api.set(notation, newValue);
				}
				else {
					returned = api.get(notation);
					return FALSE;
				}
			}

			// Execute API command
			else if(api[command]) {
				api[command].apply(api, args);
			}
		});

		return returned !== NULL ? returned : this;
	}

	// No API commands. validate provided options and setup qTips
	else if('object' === typeof options || !arguments.length) {
		// Sanitize options first
		opts = sanitizeOptions($.extend(TRUE, {}, options));

		return this.each(function(i) {
			var api, id;

			// Find next available ID, or use custom ID if provided
			id = $.isArray(opts.id) ? opts.id[i] : opts.id;
			id = !id || id === FALSE || id.length < 1 || QTIP.api[id] ? QTIP.nextid++ : id;

			// Initialize the qTip and re-grab newly sanitized options
			api = init($(this), id, opts);
			if(api === FALSE) { return TRUE; }
			else { QTIP.api[id] = api; }

			// Initialize plugins
			$.each(PLUGINS, function() {
				if(this.initialize === 'initialize') { this(api); }
			});

			// Assign initial pre-render events
			api._assignInitialEvents(event);
		});
	}
};

// Expose class
$.qtip = QTip;

// Populated in render method
QTIP.api = {};
;$.each({
	/* Allow other plugins to successfully retrieve the title of an element with a qTip applied */
	attr: function(attr, val) {
		if(this.length) {
			var self = this[0],
				title = 'title',
				api = $.data(self, 'qtip');

			if(attr === title && api && api.options && 'object' === typeof api && 'object' === typeof api.options && api.options.suppress) {
				if(arguments.length < 2) {
					return $.attr(self, oldtitle);
				}

				// If qTip is rendered and title was originally used as content, update it
				if(api && api.options.content.attr === title && api.cache.attr) {
					api.set('content.text', val);
				}

				// Use the regular attr method to set, then cache the result
				return this.attr(oldtitle, val);
			}
		}

		return $.fn['attr'+replaceSuffix].apply(this, arguments);
	},

	/* Allow clone to correctly retrieve cached title attributes */
	clone: function(keepData) {
		// Clone our element using the real clone method
		var elems = $.fn['clone'+replaceSuffix].apply(this, arguments);

		// Grab all elements with an oldtitle set, and change it to regular title attribute, if keepData is false
		if(!keepData) {
			elems.filter('['+oldtitle+']').attr('title', function() {
				return $.attr(this, oldtitle);
			})
			.removeAttr(oldtitle);
		}

		return elems;
	}
}, function(name, func) {
	if(!func || $.fn[name+replaceSuffix]) { return TRUE; }

	var old = $.fn[name+replaceSuffix] = $.fn[name];
	$.fn[name] = function() {
		return func.apply(this, arguments) || old.apply(this, arguments);
	};
});

/* Fire off 'removeqtip' handler in $.cleanData if jQuery UI not present (it already does similar).
 * This snippet is taken directly from jQuery UI source code found here:
 *     http://code.jquery.com/ui/jquery-ui-git.js
 */
if(!$.ui) {
	$['cleanData'+replaceSuffix] = $.cleanData;
	$.cleanData = function( elems ) {
		for(var i = 0, elem; (elem = $( elems[i] )).length; i++) {
			if(elem.attr(ATTR_HAS)) {
				/* eslint-disable no-empty */
				try { elem.triggerHandler('removeqtip'); }
				catch( e ) {}
				/* eslint-enable no-empty */
			}
		}
		$['cleanData'+replaceSuffix].apply(this, arguments);
	};
}
;// qTip version
QTIP.version = '3.0.3';

// Base ID for all qTips
QTIP.nextid = 0;

// Inactive events array
QTIP.inactiveEvents = INACTIVE_EVENTS;

// Base z-index for all qTips
QTIP.zindex = 15000;

// Define configuration defaults
QTIP.defaults = {
	prerender: FALSE,
	id: FALSE,
	overwrite: TRUE,
	suppress: TRUE,
	content: {
		text: TRUE,
		attr: 'title',
		title: FALSE,
		button: FALSE
	},
	position: {
		my: 'top left',
		at: 'bottom right',
		target: FALSE,
		container: FALSE,
		viewport: FALSE,
		adjust: {
			x: 0, y: 0,
			mouse: TRUE,
			scroll: TRUE,
			resize: TRUE,
			method: 'flipinvert flipinvert'
		},
		effect: function(api, pos) {
			$(this).animate(pos, {
				duration: 200,
				queue: FALSE
			});
		}
	},
	show: {
		target: FALSE,
		event: 'mouseenter',
		effect: TRUE,
		delay: 90,
		solo: FALSE,
		ready: FALSE,
		autofocus: FALSE
	},
	hide: {
		target: FALSE,
		event: 'mouseleave',
		effect: TRUE,
		delay: 0,
		fixed: FALSE,
		inactive: FALSE,
		leave: 'window',
		distance: FALSE
	},
	style: {
		classes: '',
		widget: FALSE,
		width: FALSE,
		height: FALSE,
		def: TRUE
	},
	events: {
		render: NULL,
		move: NULL,
		show: NULL,
		hide: NULL,
		toggle: NULL,
		visible: NULL,
		hidden: NULL,
		focus: NULL,
		blur: NULL
	}
};
;var TIP,
createVML,
SCALE,
PIXEL_RATIO,
BACKING_STORE_RATIO,

// Common CSS strings
MARGIN = 'margin',
BORDER = 'border',
COLOR = 'color',
BG_COLOR = 'background-color',
TRANSPARENT = 'transparent',
IMPORTANT = ' !important',

// Check if the browser supports <canvas/> elements
HASCANVAS = !!document.createElement('canvas').getContext,

// Invalid colour values used in parseColours()
INVALID = /rgba?\(0, 0, 0(, 0)?\)|transparent|#123456/i;

// Camel-case method, taken from jQuery source
// http://code.jquery.com/jquery-1.8.0.js
function camel(s) { return s.charAt(0).toUpperCase() + s.slice(1); }

/*
 * Modified from Modernizr's testPropsAll()
 * http://modernizr.com/downloads/modernizr-latest.js
 */
var cssProps = {}, cssPrefixes = ['Webkit', 'O', 'Moz', 'ms'];
function vendorCss(elem, prop) {
	var ucProp = prop.charAt(0).toUpperCase() + prop.slice(1),
		props = (prop + ' ' + cssPrefixes.join(ucProp + ' ') + ucProp).split(' '),
		cur, val, i = 0;

	// If the property has already been mapped...
	if(cssProps[prop]) { return elem.css(cssProps[prop]); }

	while(cur = props[i++]) {
		if((val = elem.css(cur)) !== undefined) {
			cssProps[prop] = cur;
			return val;
		}
	}
}

// Parse a given elements CSS property into an int
function intCss(elem, prop) {
	return Math.ceil(parseFloat(vendorCss(elem, prop)));
}


// VML creation (for IE only)
if(!HASCANVAS) {
	createVML = function(tag, props, style) {
		return '<qtipvml:'+tag+' xmlns="urn:schemas-microsoft.com:vml" class="qtip-vml" '+(props||'')+
			' style="behavior: url(#default#VML); '+(style||'')+ '" />';
	};
}

// Canvas only definitions
else {
	PIXEL_RATIO = window.devicePixelRatio || 1;
	BACKING_STORE_RATIO = (function() {
		var context = document.createElement('canvas').getContext('2d');
		return context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio ||
				context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || 1;
	})();
	SCALE = PIXEL_RATIO / BACKING_STORE_RATIO;
}


function Tip(qtip, options) {
	this._ns = 'tip';
	this.options = options;
	this.offset = options.offset;
	this.size = [ options.width, options.height ];

	// Initialize
	this.qtip = qtip;
	this.init(qtip);
}

$.extend(Tip.prototype, {
	init: function(qtip) {
		var context, tip;

		// Create tip element and prepend to the tooltip
		tip = this.element = qtip.elements.tip = $('<div />', { 'class': NAMESPACE+'-tip' }).prependTo(qtip.tooltip);

		// Create tip drawing element(s)
		if(HASCANVAS) {
			// save() as soon as we create the canvas element so FF2 doesn't bork on our first restore()!
			context = $('<canvas />').appendTo(this.element)[0].getContext('2d');

			// Setup constant parameters
			context.lineJoin = 'miter';
			context.miterLimit = 100000;
			context.save();
		}
		else {
			context = createVML('shape', 'coordorigin="0,0"', 'position:absolute;');
			this.element.html(context + context);

			// Prevent mousing down on the tip since it causes problems with .live() handling in IE due to VML
			qtip._bind( $('*', tip).add(tip), ['click', 'mousedown'], function(event) { event.stopPropagation(); }, this._ns);
		}

		// Bind update events
		qtip._bind(qtip.tooltip, 'tooltipmove', this.reposition, this._ns, this);

		// Create it
		this.create();
	},

	_swapDimensions: function() {
		this.size[0] = this.options.height;
		this.size[1] = this.options.width;
	},
	_resetDimensions: function() {
		this.size[0] = this.options.width;
		this.size[1] = this.options.height;
	},

	_useTitle: function(corner) {
		var titlebar = this.qtip.elements.titlebar;
		return titlebar && (
			corner.y === TOP || corner.y === CENTER && this.element.position().top + this.size[1] / 2 + this.options.offset < titlebar.outerHeight(TRUE)
		);
	},

	_parseCorner: function(corner) {
		var my = this.qtip.options.position.my;

		// Detect corner and mimic properties
		if(corner === FALSE || my === FALSE) {
			corner = FALSE;
		}
		else if(corner === TRUE) {
			corner = new CORNER( my.string() );
		}
		else if(!corner.string) {
			corner = new CORNER(corner);
			corner.fixed = TRUE;
		}

		return corner;
	},

	_parseWidth: function(corner, side, use) {
		var elements = this.qtip.elements,
			prop = BORDER + camel(side) + 'Width';

		return (use ? intCss(use, prop) : 
			intCss(elements.content, prop) ||
			intCss(this._useTitle(corner) && elements.titlebar || elements.content, prop) ||
			intCss(elements.tooltip, prop)
		) || 0;
	},

	_parseRadius: function(corner) {
		var elements = this.qtip.elements,
			prop = BORDER + camel(corner.y) + camel(corner.x) + 'Radius';

		return BROWSER.ie < 9 ? 0 :
			intCss(this._useTitle(corner) && elements.titlebar || elements.content, prop) ||
			intCss(elements.tooltip, prop) || 0;
	},

	_invalidColour: function(elem, prop, compare) {
		var val = elem.css(prop);
		return !val || compare && val === elem.css(compare) || INVALID.test(val) ? FALSE : val;
	},

	_parseColours: function(corner) {
		var elements = this.qtip.elements,
			tip = this.element.css('cssText', ''),
			borderSide = BORDER + camel(corner[ corner.precedance ]) + camel(COLOR),
			colorElem = this._useTitle(corner) && elements.titlebar || elements.content,
			css = this._invalidColour, color = [];

		// Attempt to detect the background colour from various elements, left-to-right precedance
		color[0] = css(tip, BG_COLOR) || css(colorElem, BG_COLOR) || css(elements.content, BG_COLOR) ||
			css(elements.tooltip, BG_COLOR) || tip.css(BG_COLOR);

		// Attempt to detect the correct border side colour from various elements, left-to-right precedance
		color[1] = css(tip, borderSide, COLOR) || css(colorElem, borderSide, COLOR) ||
			css(elements.content, borderSide, COLOR) || css(elements.tooltip, borderSide, COLOR) || elements.tooltip.css(borderSide);

		// Reset background and border colours
		$('*', tip).add(tip).css('cssText', BG_COLOR+':'+TRANSPARENT+IMPORTANT+';'+BORDER+':0'+IMPORTANT+';');

		return color;
	},

	_calculateSize: function(corner) {
		var y = corner.precedance === Y,
			width = this.options.width,
			height = this.options.height,
			isCenter = corner.abbrev() === 'c',
			base = (y ? width: height) * (isCenter ? 0.5 : 1),
			pow = Math.pow,
			round = Math.round,
			bigHyp, ratio, result,

		smallHyp = Math.sqrt( pow(base, 2) + pow(height, 2) ),
		hyp = [
			this.border / base * smallHyp,
			this.border / height * smallHyp
		];

		hyp[2] = Math.sqrt( pow(hyp[0], 2) - pow(this.border, 2) );
		hyp[3] = Math.sqrt( pow(hyp[1], 2) - pow(this.border, 2) );

		bigHyp = smallHyp + hyp[2] + hyp[3] + (isCenter ? 0 : hyp[0]);
		ratio = bigHyp / smallHyp;

		result = [ round(ratio * width), round(ratio * height) ];
		return y ? result : result.reverse();
	},

	// Tip coordinates calculator
	_calculateTip: function(corner, size, scale) {
		scale = scale || 1;
		size = size || this.size;

		var width = size[0] * scale,
			height = size[1] * scale,
			width2 = Math.ceil(width / 2), height2 = Math.ceil(height / 2),

		// Define tip coordinates in terms of height and width values
		tips = {
			br:	[0,0,		width,height,	width,0],
			bl:	[0,0,		width,0,		0,height],
			tr:	[0,height,	width,0,		width,height],
			tl:	[0,0,		0,height,		width,height],
			tc:	[0,height,	width2,0,		width,height],
			bc:	[0,0,		width,0,		width2,height],
			rc:	[0,0,		width,height2,	0,height],
			lc:	[width,0,	width,height,	0,height2]
		};

		// Set common side shapes
		tips.lt = tips.br; tips.rt = tips.bl;
		tips.lb = tips.tr; tips.rb = tips.tl;

		return tips[ corner.abbrev() ];
	},

	// Tip coordinates drawer (canvas)
	_drawCoords: function(context, coords) {
		context.beginPath();
		context.moveTo(coords[0], coords[1]);
		context.lineTo(coords[2], coords[3]);
		context.lineTo(coords[4], coords[5]);
		context.closePath();
	},

	create: function() {
		// Determine tip corner
		var c = this.corner = (HASCANVAS || BROWSER.ie) && this._parseCorner(this.options.corner);

		// If we have a tip corner...
		this.enabled = !!this.corner && this.corner.abbrev() !== 'c';
		if(this.enabled) {
			// Cache it
			this.qtip.cache.corner = c.clone();

			// Create it
			this.update();
		}

		// Toggle tip element
		this.element.toggle(this.enabled);

		return this.corner;
	},

	update: function(corner, position) {
		if(!this.enabled) { return this; }

		var elements = this.qtip.elements,
			tip = this.element,
			inner = tip.children(),
			options = this.options,
			curSize = this.size,
			mimic = options.mimic,
			round = Math.round,
			color, precedance, context,
			coords, bigCoords, translate, newSize, border;

		// Re-determine tip if not already set
		if(!corner) { corner = this.qtip.cache.corner || this.corner; }

		// Use corner property if we detect an invalid mimic value
		if(mimic === FALSE) { mimic = corner; }

		// Otherwise inherit mimic properties from the corner object as necessary
		else {
			mimic = new CORNER(mimic);
			mimic.precedance = corner.precedance;

			if(mimic.x === 'inherit') { mimic.x = corner.x; }
			else if(mimic.y === 'inherit') { mimic.y = corner.y; }
			else if(mimic.x === mimic.y) {
				mimic[ corner.precedance ] = corner[ corner.precedance ];
			}
		}
		precedance = mimic.precedance;

		// Ensure the tip width.height are relative to the tip position
		if(corner.precedance === X) { this._swapDimensions(); }
		else { this._resetDimensions(); }

		// Update our colours
		color = this.color = this._parseColours(corner);

		// Detect border width, taking into account colours
		if(color[1] !== TRANSPARENT) {
			// Grab border width
			border = this.border = this._parseWidth(corner, corner[corner.precedance]);

			// If border width isn't zero, use border color as fill if it's not invalid (1.0 style tips)
			if(options.border && border < 1 && !INVALID.test(color[1])) { color[0] = color[1]; }

			// Set border width (use detected border width if options.border is true)
			this.border = border = options.border !== TRUE ? options.border : border;
		}

		// Border colour was invalid, set border to zero
		else { this.border = border = 0; }

		// Determine tip size
		newSize = this.size = this._calculateSize(corner);
		tip.css({
			width: newSize[0],
			height: newSize[1],
			lineHeight: newSize[1]+'px'
		});

		// Calculate tip translation
		if(corner.precedance === Y) {
			translate = [
				round(mimic.x === LEFT ? border : mimic.x === RIGHT ? newSize[0] - curSize[0] - border : (newSize[0] - curSize[0]) / 2),
				round(mimic.y === TOP ? newSize[1] - curSize[1] : 0)
			];
		}
		else {
			translate = [
				round(mimic.x === LEFT ? newSize[0] - curSize[0] : 0),
				round(mimic.y === TOP ? border : mimic.y === BOTTOM ? newSize[1] - curSize[1] - border : (newSize[1] - curSize[1]) / 2)
			];
		}

		// Canvas drawing implementation
		if(HASCANVAS) {
			// Grab canvas context and clear/save it
			context = inner[0].getContext('2d');
			context.restore(); context.save();
			context.clearRect(0,0,6000,6000);

			// Calculate coordinates
			coords = this._calculateTip(mimic, curSize, SCALE);
			bigCoords = this._calculateTip(mimic, this.size, SCALE);

			// Set the canvas size using calculated size
			inner.attr(WIDTH, newSize[0] * SCALE).attr(HEIGHT, newSize[1] * SCALE);
			inner.css(WIDTH, newSize[0]).css(HEIGHT, newSize[1]);

			// Draw the outer-stroke tip
			this._drawCoords(context, bigCoords);
			context.fillStyle = color[1];
			context.fill();

			// Draw the actual tip
			context.translate(translate[0] * SCALE, translate[1] * SCALE);
			this._drawCoords(context, coords);
			context.fillStyle = color[0];
			context.fill();
		}

		// VML (IE Proprietary implementation)
		else {
			// Calculate coordinates
			coords = this._calculateTip(mimic);

			// Setup coordinates string
			coords = 'm' + coords[0] + ',' + coords[1] + ' l' + coords[2] +
				',' + coords[3] + ' ' + coords[4] + ',' + coords[5] + ' xe';

			// Setup VML-specific offset for pixel-perfection
			translate[2] = border && /^(r|b)/i.test(corner.string()) ?
				BROWSER.ie === 8 ? 2 : 1 : 0;

			// Set initial CSS
			inner.css({
				coordsize: newSize[0]+border + ' ' + newSize[1]+border,
				antialias: ''+(mimic.string().indexOf(CENTER) > -1),
				left: translate[0] - translate[2] * Number(precedance === X),
				top: translate[1] - translate[2] * Number(precedance === Y),
				width: newSize[0] + border,
				height: newSize[1] + border
			})
			.each(function(i) {
				var $this = $(this);

				// Set shape specific attributes
				$this[ $this.prop ? 'prop' : 'attr' ]({
					coordsize: newSize[0]+border + ' ' + newSize[1]+border,
					path: coords,
					fillcolor: color[0],
					filled: !!i,
					stroked: !i
				})
				.toggle(!!(border || i));

				// Check if border is enabled and add stroke element
				!i && $this.html( createVML(
					'stroke', 'weight="'+border*2+'px" color="'+color[1]+'" miterlimit="1000" joinstyle="miter"'
				) );
			});
		}

		// Opera bug #357 - Incorrect tip position
		// https://github.com/Craga89/qTip2/issues/367
		window.opera && setTimeout(function() {
			elements.tip.css({
				display: 'inline-block',
				visibility: 'visible'
			});
		}, 1);

		// Position if needed
		if(position !== FALSE) { this.calculate(corner, newSize); }
	},

	calculate: function(corner, size) {
		if(!this.enabled) { return FALSE; }

		var self = this,
			elements = this.qtip.elements,
			tip = this.element,
			userOffset = this.options.offset,
			position = {},
			precedance, corners;

		// Inherit corner if not provided
		corner = corner || this.corner;
		precedance = corner.precedance;

		// Determine which tip dimension to use for adjustment
		size = size || this._calculateSize(corner);

		// Setup corners and offset array
		corners = [ corner.x, corner.y ];
		if(precedance === X) { corners.reverse(); }

		// Calculate tip position
		$.each(corners, function(i, side) {
			var b, bc, br;

			if(side === CENTER) {
				b = precedance === Y ? LEFT : TOP;
				position[ b ] = '50%';
				position[MARGIN+'-' + b] = -Math.round(size[ precedance === Y ? 0 : 1 ] / 2) + userOffset;
			}
			else {
				b = self._parseWidth(corner, side, elements.tooltip);
				bc = self._parseWidth(corner, side, elements.content);
				br = self._parseRadius(corner);

				position[ side ] = Math.max(-self.border, i ? bc : userOffset + (br > b ? br : -b));
			}
		});

		// Adjust for tip size
		position[ corner[precedance] ] -= size[ precedance === X ? 0 : 1 ];

		// Set and return new position
		tip.css({ margin: '', top: '', bottom: '', left: '', right: '' }).css(position);
		return position;
	},

	reposition: function(event, api, pos) {
		if(!this.enabled) { return; }

		var cache = api.cache,
			newCorner = this.corner.clone(),
			adjust = pos.adjusted,
			method = api.options.position.adjust.method.split(' '),
			horizontal = method[0],
			vertical = method[1] || method[0],
			shift = { left: FALSE, top: FALSE, x: 0, y: 0 },
			offset, css = {}, props;

		function shiftflip(direction, precedance, popposite, side, opposite) {
			// Horizontal - Shift or flip method
			if(direction === SHIFT && newCorner.precedance === precedance && adjust[side] && newCorner[popposite] !== CENTER) {
				newCorner.precedance = newCorner.precedance === X ? Y : X;
			}
			else if(direction !== SHIFT && adjust[side]){
				newCorner[precedance] = newCorner[precedance] === CENTER ?
					adjust[side] > 0 ? side : opposite :
					newCorner[precedance] === side ? opposite : side;
			}
		}

		function shiftonly(xy, side, opposite) {
			if(newCorner[xy] === CENTER) {
				css[MARGIN+'-'+side] = shift[xy] = offset[MARGIN+'-'+side] - adjust[side];
			}
			else {
				props = offset[opposite] !== undefined ?
					[ adjust[side], -offset[side] ] : [ -adjust[side], offset[side] ];

				if( (shift[xy] = Math.max(props[0], props[1])) > props[0] ) {
					pos[side] -= adjust[side];
					shift[side] = FALSE;
				}

				css[ offset[opposite] !== undefined ? opposite : side ] = shift[xy];
			}
		}

		// If our tip position isn't fixed e.g. doesn't adjust with viewport...
		if(this.corner.fixed !== TRUE) {
			// Perform shift/flip adjustments
			shiftflip(horizontal, X, Y, LEFT, RIGHT);
			shiftflip(vertical, Y, X, TOP, BOTTOM);

			// Update and redraw the tip if needed (check cached details of last drawn tip)
			if(newCorner.string() !== cache.corner.string() || cache.cornerTop !== adjust.top || cache.cornerLeft !== adjust.left) {
				this.update(newCorner, FALSE);
			}
		}

		// Setup tip offset properties
		offset = this.calculate(newCorner);

		// Readjust offset object to make it left/top
		if(offset.right !== undefined) { offset.left = -offset.right; }
		if(offset.bottom !== undefined) { offset.top = -offset.bottom; }
		offset.user = this.offset;

		// Perform shift adjustments
		shift.left = horizontal === SHIFT && !!adjust.left;
		if(shift.left) {
			shiftonly(X, LEFT, RIGHT);
		}
		shift.top = vertical === SHIFT && !!adjust.top;
		if(shift.top) {
			shiftonly(Y, TOP, BOTTOM);
		}

		/*
		* If the tip is adjusted in both dimensions, or in a
		* direction that would cause it to be anywhere but the
		* outer border, hide it!
		*/
		this.element.css(css).toggle(
			!(shift.x && shift.y || newCorner.x === CENTER && shift.y || newCorner.y === CENTER && shift.x)
		);

		// Adjust position to accomodate tip dimensions
		pos.left -= offset.left.charAt ? offset.user :
			horizontal !== SHIFT || shift.top || !shift.left && !shift.top ? offset.left + this.border : 0;
		pos.top -= offset.top.charAt ? offset.user :
			vertical !== SHIFT || shift.left || !shift.left && !shift.top ? offset.top + this.border : 0;

		// Cache details
		cache.cornerLeft = adjust.left; cache.cornerTop = adjust.top;
		cache.corner = newCorner.clone();
	},

	destroy: function() {
		// Unbind events
		this.qtip._unbind(this.qtip.tooltip, this._ns);

		// Remove the tip element(s)
		if(this.qtip.elements.tip) {
			this.qtip.elements.tip.find('*')
				.remove().end().remove();
		}
	}
});

TIP = PLUGINS.tip = function(api) {
	return new Tip(api, api.options.style.tip);
};

// Initialize tip on render
TIP.initialize = 'render';

// Setup plugin sanitization options
TIP.sanitize = function(options) {
	if(options.style && 'tip' in options.style) {
		var opts = options.style.tip;
		if(typeof opts !== 'object') { opts = options.style.tip = { corner: opts }; }
		if(!(/string|boolean/i).test(typeof opts.corner)) { opts.corner = TRUE; }
	}
};

// Add new option checks for the plugin
CHECKS.tip = {
	'^position.my|style.tip.(corner|mimic|border)$': function() {
		// Make sure a tip can be drawn
		this.create();

		// Reposition the tooltip
		this.qtip.reposition();
	},
	'^style.tip.(height|width)$': function(obj) {
		// Re-set dimensions and redraw the tip
		this.size = [ obj.width, obj.height ];
		this.update();

		// Reposition the tooltip
		this.qtip.reposition();
	},
	'^content.title|style.(classes|widget)$': function() {
		this.update();
	}
};

// Extend original qTip defaults
$.extend(TRUE, QTIP.defaults, {
	style: {
		tip: {
			corner: TRUE,
			mimic: FALSE,
			width: 6,
			height: 6,
			border: TRUE,
			offset: 0
		}
	}
});
;var MODAL, OVERLAY,
	MODALCLASS = 'qtip-modal',
	MODALSELECTOR = '.'+MODALCLASS;

OVERLAY = function()
{
	var self = this,
		focusableElems = {},
		current,
		prevState,
		elem;

	// Modified code from jQuery UI 1.10.0 source
	// http://code.jquery.com/ui/1.10.0/jquery-ui.js
	function focusable(element) {
		// Use the defined focusable checker when possible
		if($.expr[':'].focusable) { return $.expr[':'].focusable; }

		var isTabIndexNotNaN = !isNaN($.attr(element, 'tabindex')),
			nodeName = element.nodeName && element.nodeName.toLowerCase(),
			map, mapName, img;

		if('area' === nodeName) {
			map = element.parentNode;
			mapName = map.name;
			if(!element.href || !mapName || map.nodeName.toLowerCase() !== 'map') {
				return false;
			}
			img = $('img[usemap=#' + mapName + ']')[0];
			return !!img && img.is(':visible');
		}

		return /input|select|textarea|button|object/.test( nodeName ) ?
			!element.disabled :
			'a' === nodeName ?
				element.href || isTabIndexNotNaN :
				isTabIndexNotNaN
		;
	}

	// Focus inputs using cached focusable elements (see update())
	function focusInputs(blurElems) {
		// Blurring body element in IE causes window.open windows to unfocus!
		if(focusableElems.length < 1 && blurElems.length) { blurElems.not('body').blur(); }

		// Focus the inputs
		else { focusableElems.first().focus(); }
	}

	// Steal focus from elements outside tooltip
	function stealFocus(event) {
		if(!elem.is(':visible')) { return; }

		var target = $(event.target),
			tooltip = current.tooltip,
			container = target.closest(SELECTOR),
			targetOnTop;

		// Determine if input container target is above this
		targetOnTop = container.length < 1 ? FALSE :
			parseInt(container[0].style.zIndex, 10) > parseInt(tooltip[0].style.zIndex, 10);

		// If we're showing a modal, but focus has landed on an input below
		// this modal, divert focus to the first visible input in this modal
		// or if we can't find one... the tooltip itself
		if(!targetOnTop && target.closest(SELECTOR)[0] !== tooltip[0]) {
			focusInputs(target);
		}
	}

	$.extend(self, {
		init: function() {
			// Create document overlay
			elem = self.elem = $('<div />', {
				id: 'qtip-overlay',
				html: '<div></div>',
				mousedown: function() { return FALSE; }
			})
			.hide();

			// Make sure we can't focus anything outside the tooltip
			$(document.body).bind('focusin'+MODALSELECTOR, stealFocus);

			// Apply keyboard "Escape key" close handler
			$(document).bind('keydown'+MODALSELECTOR, function(event) {
				if(current && current.options.show.modal.escape && event.keyCode === 27) {
					current.hide(event);
				}
			});

			// Apply click handler for blur option
			elem.bind('click'+MODALSELECTOR, function(event) {
				if(current && current.options.show.modal.blur) {
					current.hide(event);
				}
			});

			return self;
		},

		update: function(api) {
			// Update current API reference
			current = api;

			// Update focusable elements if enabled
			if(api.options.show.modal.stealfocus !== FALSE) {
				focusableElems = api.tooltip.find('*').filter(function() {
					return focusable(this);
				});
			}
			else { focusableElems = []; }
		},

		toggle: function(api, state, duration) {
			var tooltip = api.tooltip,
				options = api.options.show.modal,
				effect = options.effect,
				type = state ? 'show': 'hide',
				visible = elem.is(':visible'),
				visibleModals = $(MODALSELECTOR).filter(':visible:not(:animated)').not(tooltip);

			// Set active tooltip API reference
			self.update(api);

			// If the modal can steal the focus...
			// Blur the current item and focus anything in the modal we an
			if(state && options.stealfocus !== FALSE) {
				focusInputs( $(':focus') );
			}

			// Toggle backdrop cursor style on show
			elem.toggleClass('blurs', options.blur);

			// Append to body on show
			if(state) {
				elem.appendTo(document.body);
			}

			// Prevent modal from conflicting with show.solo, and don't hide backdrop is other modals are visible
			if(elem.is(':animated') && visible === state && prevState !== FALSE || !state && visibleModals.length) {
				return self;
			}

			// Stop all animations
			elem.stop(TRUE, FALSE);

			// Use custom function if provided
			if($.isFunction(effect)) {
				effect.call(elem, state);
			}

			// If no effect type is supplied, use a simple toggle
			else if(effect === FALSE) {
				elem[ type ]();
			}

			// Use basic fade function
			else {
				elem.fadeTo( parseInt(duration, 10) || 90, state ? 1 : 0, function() {
					if(!state) { elem.hide(); }
				});
			}

			// Reset position and detach from body on hide
			if(!state) {
				elem.queue(function(next) {
					elem.css({ left: '', top: '' });
					if(!$(MODALSELECTOR).length) { elem.detach(); }
					next();
				});
			}

			// Cache the state
			prevState = state;

			// If the tooltip is destroyed, set reference to null
			if(current.destroyed) { current = NULL; }

			return self;
		}
	});

	self.init();
};
OVERLAY = new OVERLAY();

function Modal(api, options) {
	this.options = options;
	this._ns = '-modal';

	this.qtip = api;
	this.init(api);
}

$.extend(Modal.prototype, {
	init: function(qtip) {
		var tooltip = qtip.tooltip;

		// If modal is disabled... return
		if(!this.options.on) { return this; }

		// Set overlay reference
		qtip.elements.overlay = OVERLAY.elem;

		// Add unique attribute so we can grab modal tooltips easily via a SELECTOR, and set z-index
		tooltip.addClass(MODALCLASS).css('z-index', QTIP.modal_zindex + $(MODALSELECTOR).length);

		// Apply our show/hide/focus modal events
		qtip._bind(tooltip, ['tooltipshow', 'tooltiphide'], function(event, api, duration) {
			var oEvent = event.originalEvent;

			// Make sure mouseout doesn't trigger a hide when showing the modal and mousing onto backdrop
			if(event.target === tooltip[0]) {
				if(oEvent && event.type === 'tooltiphide' && /mouse(leave|enter)/.test(oEvent.type) && $(oEvent.relatedTarget).closest(OVERLAY.elem[0]).length) {
					/* eslint-disable no-empty */
					try { event.preventDefault(); }
					catch(e) {}
					/* eslint-enable no-empty */
				}
				else if(!oEvent || oEvent && oEvent.type !== 'tooltipsolo') {
					this.toggle(event, event.type === 'tooltipshow', duration);
				}
			}
		}, this._ns, this);

		// Adjust modal z-index on tooltip focus
		qtip._bind(tooltip, 'tooltipfocus', function(event, api) {
			// If focus was cancelled before it reached us, don't do anything
			if(event.isDefaultPrevented() || event.target !== tooltip[0]) { return; }

			var qtips = $(MODALSELECTOR),

			// Keep the modal's lower than other, regular qtips
			newIndex = QTIP.modal_zindex + qtips.length,
			curIndex = parseInt(tooltip[0].style.zIndex, 10);

			// Set overlay z-index
			OVERLAY.elem[0].style.zIndex = newIndex - 1;

			// Reduce modal z-index's and keep them properly ordered
			qtips.each(function() {
				if(this.style.zIndex > curIndex) {
					this.style.zIndex -= 1;
				}
			});

			// Fire blur event for focused tooltip
			qtips.filter('.' + CLASS_FOCUS).qtip('blur', event.originalEvent);

			// Set the new z-index
			tooltip.addClass(CLASS_FOCUS)[0].style.zIndex = newIndex;

			// Set current
			OVERLAY.update(api);

			// Prevent default handling
			/* eslint-disable no-empty */
			try { event.preventDefault(); }
			catch(e) {}
			/* eslint-enable no-empty */
		}, this._ns, this);

		// Focus any other visible modals when this one hides
		qtip._bind(tooltip, 'tooltiphide', function(event) {
			if(event.target === tooltip[0]) {
				$(MODALSELECTOR).filter(':visible').not(tooltip).last().qtip('focus', event);
			}
		}, this._ns, this);
	},

	toggle: function(event, state, duration) {
		// Make sure default event hasn't been prevented
		if(event && event.isDefaultPrevented()) { return this; }

		// Toggle it
		OVERLAY.toggle(this.qtip, !!state, duration);
	},

	destroy: function() {
		// Remove modal class
		this.qtip.tooltip.removeClass(MODALCLASS);

		// Remove bound events
		this.qtip._unbind(this.qtip.tooltip, this._ns);

		// Delete element reference
		OVERLAY.toggle(this.qtip, FALSE);
		delete this.qtip.elements.overlay;
	}
});


MODAL = PLUGINS.modal = function(api) {
	return new Modal(api, api.options.show.modal);
};

// Setup sanitiztion rules
MODAL.sanitize = function(opts) {
	if(opts.show) {
		if(typeof opts.show.modal !== 'object') { opts.show.modal = { on: !!opts.show.modal }; }
		else if(typeof opts.show.modal.on === 'undefined') { opts.show.modal.on = TRUE; }
	}
};

// Base z-index for all modal tooltips (use qTip core z-index as a base)
/* eslint-disable camelcase */
QTIP.modal_zindex = QTIP.zindex - 200;
/* eslint-enable camelcase */

// Plugin needs to be initialized on render
MODAL.initialize = 'render';

// Setup option set checks
CHECKS.modal = {
	'^show.modal.(on|blur)$': function() {
		// Initialise
		this.destroy();
		this.init();

		// Show the modal if not visible already and tooltip is visible
		this.qtip.elems.overlay.toggle(
			this.qtip.tooltip[0].offsetWidth > 0
		);
	}
};

// Extend original api defaults
$.extend(TRUE, QTIP.defaults, {
	show: {
		modal: {
			on: FALSE,
			effect: TRUE,
			blur: TRUE,
			stealfocus: TRUE,
			escape: TRUE
		}
	}
});
;PLUGINS.viewport = function(api, position, posOptions, targetWidth, targetHeight, elemWidth, elemHeight)
{
	var target = posOptions.target,
		tooltip = api.elements.tooltip,
		my = posOptions.my,
		at = posOptions.at,
		adjust = posOptions.adjust,
		method = adjust.method.split(' '),
		methodX = method[0],
		methodY = method[1] || method[0],
		viewport = posOptions.viewport,
		container = posOptions.container,
		adjusted = { left: 0, top: 0 },
		fixed, newMy, containerOffset, containerStatic,
		viewportWidth, viewportHeight, viewportScroll, viewportOffset;

	// If viewport is not a jQuery element, or it's the window/document, or no adjustment method is used... return
	if(!viewport.jquery || target[0] === window || target[0] === document.body || adjust.method === 'none') {
		return adjusted;
	}

	// Cach container details
	containerOffset = container.offset() || adjusted;
	containerStatic = container.css('position') === 'static';

	// Cache our viewport details
	fixed = tooltip.css('position') === 'fixed';
	viewportWidth = viewport[0] === window ? viewport.width() : viewport.outerWidth(FALSE);
	viewportHeight = viewport[0] === window ? viewport.height() : viewport.outerHeight(FALSE);
	viewportScroll = { left: fixed ? 0 : viewport.scrollLeft(), top: fixed ? 0 : viewport.scrollTop() };
	viewportOffset = viewport.offset() || adjusted;

	// Generic calculation method
	function calculate(side, otherSide, type, adjustment, side1, side2, lengthName, targetLength, elemLength) {
		var initialPos = position[side1],
			mySide = my[side],
			atSide = at[side],
			isShift = type === SHIFT,
			myLength = mySide === side1 ? elemLength : mySide === side2 ? -elemLength : -elemLength / 2,
			atLength = atSide === side1 ? targetLength : atSide === side2 ? -targetLength : -targetLength / 2,
			sideOffset = viewportScroll[side1] + viewportOffset[side1] - (containerStatic ? 0 : containerOffset[side1]),
			overflow1 = sideOffset - initialPos,
			overflow2 = initialPos + elemLength - (lengthName === WIDTH ? viewportWidth : viewportHeight) - sideOffset,
			offset = myLength - (my.precedance === side || mySide === my[otherSide] ? atLength : 0) - (atSide === CENTER ? targetLength / 2 : 0);

		// shift
		if(isShift) {
			offset = (mySide === side1 ? 1 : -1) * myLength;

			// Adjust position but keep it within viewport dimensions
			position[side1] += overflow1 > 0 ? overflow1 : overflow2 > 0 ? -overflow2 : 0;
			position[side1] = Math.max(
				-containerOffset[side1] + viewportOffset[side1],
				initialPos - offset,
				Math.min(
					Math.max(
						-containerOffset[side1] + viewportOffset[side1] + (lengthName === WIDTH ? viewportWidth : viewportHeight),
						initialPos + offset
					),
					position[side1],

					// Make sure we don't adjust complete off the element when using 'center'
					mySide === 'center' ? initialPos - myLength : 1E9
				)
			);

		}

		// flip/flipinvert
		else {
			// Update adjustment amount depending on if using flipinvert or flip
			adjustment *= type === FLIPINVERT ? 2 : 0;

			// Check for overflow on the left/top
			if(overflow1 > 0 && (mySide !== side1 || overflow2 > 0)) {
				position[side1] -= offset + adjustment;
				newMy.invert(side, side1);
			}

			// Check for overflow on the bottom/right
			else if(overflow2 > 0 && (mySide !== side2 || overflow1 > 0)  ) {
				position[side1] -= (mySide === CENTER ? -offset : offset) + adjustment;
				newMy.invert(side, side2);
			}

			// Make sure we haven't made things worse with the adjustment and reset if so
			if(position[side1] < viewportScroll[side1] && -position[side1] > overflow2) {
				position[side1] = initialPos; newMy = my.clone();
			}
		}

		return position[side1] - initialPos;
	}

	// Set newMy if using flip or flipinvert methods
	if(methodX !== 'shift' || methodY !== 'shift') { newMy = my.clone(); }

	// Adjust position based onviewport and adjustment options
	adjusted = {
		left: methodX !== 'none' ? calculate( X, Y, methodX, adjust.x, LEFT, RIGHT, WIDTH, targetWidth, elemWidth ) : 0,
		top: methodY !== 'none' ? calculate( Y, X, methodY, adjust.y, TOP, BOTTOM, HEIGHT, targetHeight, elemHeight ) : 0,
		my: newMy
	};

	return adjusted;
};
;PLUGINS.polys = {
	// POLY area coordinate calculator
	//	Special thanks to Ed Cradock for helping out with this.
	//	Uses a binary search algorithm to find suitable coordinates.
	polygon: function(baseCoords, corner) {
		var result = {
			width: 0, height: 0,
			position: {
				top: 1e10, right: 0,
				bottom: 0, left: 1e10
			},
			adjustable: FALSE
		},
		i = 0, next,
		coords = [],
		compareX = 1, compareY = 1,
		realX = 0, realY = 0,
		newWidth, newHeight;

		// First pass, sanitize coords and determine outer edges
		i = baseCoords.length; 
		while(i--) {
			next = [ parseInt(baseCoords[--i], 10), parseInt(baseCoords[i+1], 10) ];

			if(next[0] > result.position.right){ result.position.right = next[0]; }
			if(next[0] < result.position.left){ result.position.left = next[0]; }
			if(next[1] > result.position.bottom){ result.position.bottom = next[1]; }
			if(next[1] < result.position.top){ result.position.top = next[1]; }

			coords.push(next);
		}

		// Calculate height and width from outer edges
		newWidth = result.width = Math.abs(result.position.right - result.position.left);
		newHeight = result.height = Math.abs(result.position.bottom - result.position.top);

		// If it's the center corner...
		if(corner.abbrev() === 'c') {
			result.position = {
				left: result.position.left + result.width / 2,
				top: result.position.top + result.height / 2
			};
		}
		else {
			// Second pass, use a binary search algorithm to locate most suitable coordinate
			while(newWidth > 0 && newHeight > 0 && compareX > 0 && compareY > 0)
			{
				newWidth = Math.floor(newWidth / 2);
				newHeight = Math.floor(newHeight / 2);

				if(corner.x === LEFT){ compareX = newWidth; }
				else if(corner.x === RIGHT){ compareX = result.width - newWidth; }
				else{ compareX += Math.floor(newWidth / 2); }

				if(corner.y === TOP){ compareY = newHeight; }
				else if(corner.y === BOTTOM){ compareY = result.height - newHeight; }
				else{ compareY += Math.floor(newHeight / 2); }

				i = coords.length;
				while(i--)
				{
					if(coords.length < 2){ break; }

					realX = coords[i][0] - result.position.left;
					realY = coords[i][1] - result.position.top;

					if(
						corner.x === LEFT && realX >= compareX ||
						corner.x === RIGHT && realX <= compareX ||
						corner.x === CENTER && (realX < compareX || realX > result.width - compareX) ||
						corner.y === TOP && realY >= compareY ||
						corner.y === BOTTOM && realY <= compareY ||
						corner.y === CENTER && (realY < compareY || realY > result.height - compareY)) {
						coords.splice(i, 1);
					}
				}
			}
			result.position = { left: coords[0][0], top: coords[0][1] };
		}

		return result;
	},

	rect: function(ax, ay, bx, by) {
		return {
			width: Math.abs(bx - ax),
			height: Math.abs(by - ay),
			position: {
				left: Math.min(ax, bx),
				top: Math.min(ay, by)
			}
		};
	},

	_angles: {
		tc: 3 / 2, tr: 7 / 4, tl: 5 / 4,
		bc: 1 / 2, br: 1 / 4, bl: 3 / 4,
		rc: 2, lc: 1, c: 0
	},
	ellipse: function(cx, cy, rx, ry, corner) {
		var c = PLUGINS.polys._angles[ corner.abbrev() ],
			rxc = c === 0 ? 0 : rx * Math.cos( c * Math.PI ),
			rys = ry * Math.sin( c * Math.PI );

		return {
			width: rx * 2 - Math.abs(rxc),
			height: ry * 2 - Math.abs(rys),
			position: {
				left: cx + rxc,
				top: cy + rys
			},
			adjustable: FALSE
		};
	},
	circle: function(cx, cy, r, corner) {
		return PLUGINS.polys.ellipse(cx, cy, r, r, corner);
	}
};
;PLUGINS.svg = function(api, svg, corner)
{
	var elem = svg[0],
		root = $(elem.ownerSVGElement),
		ownerDocument = elem.ownerDocument,
		strokeWidth2 = (parseInt(svg.css('stroke-width'), 10) || 0) / 2,
		frameOffset, mtx, transformed,
		len, next, i, points,
		result, position;

	// Ascend the parentNode chain until we find an element with getBBox()
	while(!elem.getBBox) { elem = elem.parentNode; }
	if(!elem.getBBox || !elem.parentNode) { return FALSE; }

	// Determine which shape calculation to use
	switch(elem.nodeName) {
		case 'ellipse':
		case 'circle':
			result = PLUGINS.polys.ellipse(
				elem.cx.baseVal.value,
				elem.cy.baseVal.value,
				(elem.rx || elem.r).baseVal.value + strokeWidth2,
				(elem.ry || elem.r).baseVal.value + strokeWidth2,
				corner
			);
		break;

		case 'line':
		case 'polygon':
		case 'polyline':
			// Determine points object (line has none, so mimic using array)
			points = elem.points || [
				{ x: elem.x1.baseVal.value, y: elem.y1.baseVal.value },
				{ x: elem.x2.baseVal.value, y: elem.y2.baseVal.value }
			];

			for(result = [], i = -1, len = points.numberOfItems || points.length; ++i < len;) {
				next = points.getItem ? points.getItem(i) : points[i];
				result.push.apply(result, [next.x, next.y]);
			}

			result = PLUGINS.polys.polygon(result, corner);
		break;

		// Unknown shape or rectangle? Use bounding box
		default:
			result = elem.getBBox();
			result = {
				width: result.width,
				height: result.height,
				position: {
					left: result.x,
					top: result.y
				}
			};
		break;
	}

	// Shortcut assignments
	position = result.position;
	root = root[0];

	// Convert position into a pixel value
	if(root.createSVGPoint) {
		mtx = elem.getScreenCTM();
		points = root.createSVGPoint();

		points.x = position.left;
		points.y = position.top;
		transformed = points.matrixTransform( mtx );
		position.left = transformed.x;
		position.top = transformed.y;
	}

	// Check the element is not in a child document, and if so, adjust for frame elements offset
	if(ownerDocument !== document && api.position.target !== 'mouse') {
		frameOffset = $((ownerDocument.defaultView || ownerDocument.parentWindow).frameElement).offset();
		if(frameOffset) {
			position.left += frameOffset.left;
			position.top += frameOffset.top;
		}
	}

	// Adjust by scroll offset of owner document
	ownerDocument = $(ownerDocument);
	position.left += ownerDocument.scrollLeft();
	position.top += ownerDocument.scrollTop();

	return result;
};
;PLUGINS.imagemap = function(api, area, corner)
{
	if(!area.jquery) { area = $(area); }

	var shape = (area.attr('shape') || 'rect').toLowerCase().replace('poly', 'polygon'),
		image = $('img[usemap="#'+area.parent('map').attr('name')+'"]'),
		coordsString = $.trim(area.attr('coords')),
		coordsArray = coordsString.replace(/,$/, '').split(','),
		imageOffset, coords, i, result, len;

	// If we can't find the image using the map...
	if(!image.length) { return FALSE; }

	// Pass coordinates string if polygon
	if(shape === 'polygon') {
		result = PLUGINS.polys.polygon(coordsArray, corner);
	}

	// Otherwise parse the coordinates and pass them as arguments
	else if(PLUGINS.polys[shape]) {
		for(i = -1, len = coordsArray.length, coords = []; ++i < len;) {
			coords.push( parseInt(coordsArray[i], 10) );
		}

		result = PLUGINS.polys[shape].apply(
			this, coords.concat(corner)
		);
	}

	// If no shapre calculation method was found, return false
	else { return FALSE; }

	// Make sure we account for padding and borders on the image
	imageOffset = image.offset();
	imageOffset.left += Math.ceil((image.outerWidth(FALSE) - image.width()) / 2);
	imageOffset.top += Math.ceil((image.outerHeight(FALSE) - image.height()) / 2);

	// Add image position to offset coordinates
	result.position.left += imageOffset.left;
	result.position.top += imageOffset.top;

	return result;
};
;var IE6,

/*
 * BGIFrame adaption (http://plugins.jquery.com/project/bgiframe)
 * Special thanks to Brandon Aaron
 */
BGIFRAME = '<iframe class="qtip-bgiframe" frameborder="0" tabindex="-1" src="javascript:\'\';" ' +
	' style="display:block; position:absolute; z-index:-1; filter:alpha(opacity=0); ' +
		'-ms-filter:"progid:DXImageTransform.Microsoft.Alpha(Opacity=0)";"></iframe>';

function Ie6(api) {
	this._ns = 'ie6';

	this.qtip = api;
	this.init(api);
}

$.extend(Ie6.prototype, {
	_scroll : function() {
		var overlay = this.qtip.elements.overlay;
		overlay && (overlay[0].style.top = $(window).scrollTop() + 'px');
	},

	init: function(qtip) {
		var tooltip = qtip.tooltip;

		// Create the BGIFrame element if needed
		if($('select, object').length < 1) {
			this.bgiframe = qtip.elements.bgiframe = $(BGIFRAME).appendTo(tooltip);

			// Update BGIFrame on tooltip move
			qtip._bind(tooltip, 'tooltipmove', this.adjustBGIFrame, this._ns, this);
		}

		// redraw() container for width/height calculations
		this.redrawContainer = $('<div/>', { id: NAMESPACE+'-rcontainer' })
			.appendTo(document.body);

		// Fixup modal plugin if present too
		if( qtip.elements.overlay && qtip.elements.overlay.addClass('qtipmodal-ie6fix') ) {
			qtip._bind(window, ['scroll', 'resize'], this._scroll, this._ns, this);
			qtip._bind(tooltip, ['tooltipshow'], this._scroll, this._ns, this);
		}

		// Set dimensions
		this.redraw();
	},

	adjustBGIFrame: function() {
		var tooltip = this.qtip.tooltip,
			dimensions = {
				height: tooltip.outerHeight(FALSE),
				width: tooltip.outerWidth(FALSE)
			},
			plugin = this.qtip.plugins.tip,
			tip = this.qtip.elements.tip,
			tipAdjust, offset;

		// Adjust border offset
		offset = parseInt(tooltip.css('borderLeftWidth'), 10) || 0;
		offset = { left: -offset, top: -offset };

		// Adjust for tips plugin
		if(plugin && tip) {
			tipAdjust = plugin.corner.precedance === 'x' ? [WIDTH, LEFT] : [HEIGHT, TOP];
			offset[ tipAdjust[1] ] -= tip[ tipAdjust[0] ]();
		}

		// Update bgiframe
		this.bgiframe.css(offset).css(dimensions);
	},

	// Max/min width simulator function
	redraw: function() {
		if(this.qtip.rendered < 1 || this.drawing) { return this; }

		var tooltip = this.qtip.tooltip,
			style = this.qtip.options.style,
			container = this.qtip.options.position.container,
			perc, width, max, min;

		// Set drawing flag
		this.qtip.drawing = 1;

		// If tooltip has a set height/width, just set it... like a boss!
		if(style.height) { tooltip.css(HEIGHT, style.height); }
		if(style.width) { tooltip.css(WIDTH, style.width); }

		// Simulate max/min width if not set width present...
		else {
			// Reset width and add fluid class
			tooltip.css(WIDTH, '').appendTo(this.redrawContainer);

			// Grab our tooltip width (add 1 if odd so we don't get wrapping problems.. huzzah!)
			width = tooltip.width();
			if(width % 2 < 1) { width += 1; }

			// Grab our max/min properties
			max = tooltip.css('maxWidth') || '';
			min = tooltip.css('minWidth') || '';

			// Parse into proper pixel values
			perc = (max + min).indexOf('%') > -1 ? container.width() / 100 : 0;
			max = (max.indexOf('%') > -1 ? perc : 1 * parseInt(max, 10)) || width;
			min = (min.indexOf('%') > -1 ? perc : 1 * parseInt(min, 10)) || 0;

			// Determine new dimension size based on max/min/current values
			width = max + min ? Math.min(Math.max(width, min), max) : width;

			// Set the newly calculated width and remvoe fluid class
			tooltip.css(WIDTH, Math.round(width)).appendTo(container);
		}

		// Set drawing flag
		this.drawing = 0;

		return this;
	},

	destroy: function() {
		// Remove iframe
		this.bgiframe && this.bgiframe.remove();

		// Remove bound events
		this.qtip._unbind([window, this.qtip.tooltip], this._ns);
	}
});

IE6 = PLUGINS.ie6 = function(api) {
	// Proceed only if the browser is IE6
	return BROWSER.ie === 6 ? new Ie6(api) : FALSE;
};

IE6.initialize = 'render';

CHECKS.ie6 = {
	'^content|style$': function() {
		this.redraw();
	}
};
;}));
}( window, document ));

},{}],226:[function(require,module,exports){
/*!
* screenfull
* v5.0.2 - 2020-02-13
* (c) Sindre Sorhus; MIT License
*/
(function () {
	'use strict';

	var document = typeof window !== 'undefined' && typeof window.document !== 'undefined' ? window.document : {};
	var isCommonjs = typeof module !== 'undefined' && module.exports;

	var fn = (function () {
		var val;

		var fnMap = [
			[
				'requestFullscreen',
				'exitFullscreen',
				'fullscreenElement',
				'fullscreenEnabled',
				'fullscreenchange',
				'fullscreenerror'
			],
			// New WebKit
			[
				'webkitRequestFullscreen',
				'webkitExitFullscreen',
				'webkitFullscreenElement',
				'webkitFullscreenEnabled',
				'webkitfullscreenchange',
				'webkitfullscreenerror'

			],
			// Old WebKit
			[
				'webkitRequestFullScreen',
				'webkitCancelFullScreen',
				'webkitCurrentFullScreenElement',
				'webkitCancelFullScreen',
				'webkitfullscreenchange',
				'webkitfullscreenerror'

			],
			[
				'mozRequestFullScreen',
				'mozCancelFullScreen',
				'mozFullScreenElement',
				'mozFullScreenEnabled',
				'mozfullscreenchange',
				'mozfullscreenerror'
			],
			[
				'msRequestFullscreen',
				'msExitFullscreen',
				'msFullscreenElement',
				'msFullscreenEnabled',
				'MSFullscreenChange',
				'MSFullscreenError'
			]
		];

		var i = 0;
		var l = fnMap.length;
		var ret = {};

		for (; i < l; i++) {
			val = fnMap[i];
			if (val && val[1] in document) {
				for (i = 0; i < val.length; i++) {
					ret[fnMap[0][i]] = val[i];
				}
				return ret;
			}
		}

		return false;
	})();

	var eventNameMap = {
		change: fn.fullscreenchange,
		error: fn.fullscreenerror
	};

	var screenfull = {
		request: function (element) {
			return new Promise(function (resolve, reject) {
				var onFullScreenEntered = function () {
					this.off('change', onFullScreenEntered);
					resolve();
				}.bind(this);

				this.on('change', onFullScreenEntered);

				element = element || document.documentElement;

				var returnPromise = element[fn.requestFullscreen]();

				if (returnPromise instanceof Promise) {
					returnPromise.then(onFullScreenEntered).catch(reject);
				}
			}.bind(this));
		},
		exit: function () {
			return new Promise(function (resolve, reject) {
				if (!this.isFullscreen) {
					resolve();
					return;
				}

				var onFullScreenExit = function () {
					this.off('change', onFullScreenExit);
					resolve();
				}.bind(this);

				this.on('change', onFullScreenExit);

				var returnPromise = document[fn.exitFullscreen]();

				if (returnPromise instanceof Promise) {
					returnPromise.then(onFullScreenExit).catch(reject);
				}
			}.bind(this));
		},
		toggle: function (element) {
			return this.isFullscreen ? this.exit() : this.request(element);
		},
		onchange: function (callback) {
			this.on('change', callback);
		},
		onerror: function (callback) {
			this.on('error', callback);
		},
		on: function (event, callback) {
			var eventName = eventNameMap[event];
			if (eventName) {
				document.addEventListener(eventName, callback, false);
			}
		},
		off: function (event, callback) {
			var eventName = eventNameMap[event];
			if (eventName) {
				document.removeEventListener(eventName, callback, false);
			}
		},
		raw: fn
	};

	if (!fn) {
		if (isCommonjs) {
			module.exports = {isEnabled: false};
		} else {
			window.screenfull = {isEnabled: false};
		}

		return;
	}

	Object.defineProperties(screenfull, {
		isFullscreen: {
			get: function () {
				return Boolean(document[fn.fullscreenElement]);
			}
		},
		element: {
			enumerable: true,
			get: function () {
				return document[fn.fullscreenElement];
			}
		},
		isEnabled: {
			enumerable: true,
			get: function () {
				// Coerce to boolean in case of old WebKit
				return Boolean(document[fn.fullscreenEnabled]);
			}
		}
	});

	if (isCommonjs) {
		module.exports = screenfull;
	} else {
		window.screenfull = screenfull;
	}
})();

},{}],227:[function(require,module,exports){
(function (Buffer){
(function() {
  var crypt = require('crypt'),
      utf8 = require('charenc').utf8,
      bin = require('charenc').bin,

  // The core
  sha1 = function (message) {
    // Convert to byte array
    if (message.constructor == String)
      message = utf8.stringToBytes(message);
    else if (typeof Buffer !== 'undefined' && typeof Buffer.isBuffer == 'function' && Buffer.isBuffer(message))
      message = Array.prototype.slice.call(message, 0);
    else if (!Array.isArray(message))
      message = message.toString();

    // otherwise assume byte array

    var m  = crypt.bytesToWords(message),
        l  = message.length * 8,
        w  = [],
        H0 =  1732584193,
        H1 = -271733879,
        H2 = -1732584194,
        H3 =  271733878,
        H4 = -1009589776;

    // Padding
    m[l >> 5] |= 0x80 << (24 - l % 32);
    m[((l + 64 >>> 9) << 4) + 15] = l;

    for (var i = 0; i < m.length; i += 16) {
      var a = H0,
          b = H1,
          c = H2,
          d = H3,
          e = H4;

      for (var j = 0; j < 80; j++) {

        if (j < 16)
          w[j] = m[i + j];
        else {
          var n = w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16];
          w[j] = (n << 1) | (n >>> 31);
        }

        var t = ((H0 << 5) | (H0 >>> 27)) + H4 + (w[j] >>> 0) + (
                j < 20 ? (H1 & H2 | ~H1 & H3) + 1518500249 :
                j < 40 ? (H1 ^ H2 ^ H3) + 1859775393 :
                j < 60 ? (H1 & H2 | H1 & H3 | H2 & H3) - 1894007588 :
                         (H1 ^ H2 ^ H3) - 899497514);

        H4 = H3;
        H3 = H2;
        H2 = (H1 << 30) | (H1 >>> 2);
        H1 = H0;
        H0 = t;
      }

      H0 += a;
      H1 += b;
      H2 += c;
      H3 += d;
      H4 += e;
    }

    return [H0, H1, H2, H3, H4];
  },

  // Public API
  api = function (message, options) {
    var digestbytes = crypt.wordsToBytes(sha1(message));
    return options && options.asBytes ? digestbytes :
        options && options.asString ? bin.bytesToString(digestbytes) :
        crypt.bytesToHex(digestbytes);
  };

  api._blocksize = 16;
  api._digestsize = 20;

  module.exports = api;
})();

}).call(this,require("buffer").Buffer)

},{"buffer":109,"charenc":110,"crypt":111}],228:[function(require,module,exports){
'use strict';

let fastProto = null;

// Creates an object with permanently fast properties in V8. See Toon Verwaest's
// post https://medium.com/@tverwaes/setting-up-prototypes-in-v8-ec9c9491dfe2#5f62
// for more details. Use %HasFastProperties(object) and the Node.js flag
// --allow-natives-syntax to check whether an object has fast properties.
function FastObject(o) {
	// A prototype object will have "fast properties" enabled once it is checked
	// against the inline property cache of a function, e.g. fastProto.property:
	// https://github.com/v8/v8/blob/6.0.122/test/mjsunit/fast-prototype.js#L48-L63
	if (fastProto !== null && typeof fastProto.property) {
		const result = fastProto;
		fastProto = FastObject.prototype = null;
		return result;
	}
	fastProto = FastObject.prototype = o == null ? Object.create(null) : o;
	return new FastObject;
}

// Initialize the inline property cache of FastObject
FastObject();

module.exports = function toFastproperties(o) {
	return FastObject(o);
};

},{}]},{},[15])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJtb2R1bGVzL2Fubm90YXRvci1jb25maWcuanNvbiIsIm1vZHVsZXMvYW5ub3RhdG9yL2Fubm90YXRpb24tbWFuYWdlci5qcyIsIm1vZHVsZXMvYW5ub3RhdG9yL2Fubm90YXRpb24uanMiLCJtb2R1bGVzL2Fubm90YXRvci9hbm5vdGF0b3IuanMiLCJtb2R1bGVzL2Fubm90YXRvci9jb21wb25lbnRzL2Fubm90YXRpb24tZ3VpLmpzIiwibW9kdWxlcy9hbm5vdGF0b3IvY29tcG9uZW50cy9pbmRleC1jb250YWluZXIuanMiLCJtb2R1bGVzL2Fubm90YXRvci9jb21wb25lbnRzL2luZm8tY29udGFpbmVyLmpzIiwibW9kdWxlcy9hbm5vdGF0b3IvY29tcG9uZW50cy9tZXNzYWdlLW92ZXJsYXkuanMiLCJtb2R1bGVzL2Fubm90YXRvci9jb21wb25lbnRzL3BvbHlnb24tZWRpdG9yLmpzIiwibW9kdWxlcy9hbm5vdGF0b3IvY29tcG9uZW50cy9wb2x5Z29uLW92ZXJsYXkuanMiLCJtb2R1bGVzL2Fubm90YXRvci9jb21wb25lbnRzL3RpY2stYmFyLmpzIiwibW9kdWxlcy9hbm5vdGF0b3Ivc2VydmVyLWludGVyZmFjZS5qcyIsIm1vZHVsZXMvYW5ub3RhdG9yL3Nlc3Npb24tbWFuYWdlci5qcyIsIm1vZHVsZXMvY29uZmlnLmpzb24iLCJtb2R1bGVzL21haW4uanMiLCJtb2R1bGVzL3V0aWxzL2FycmF5LWV4dGVuc2lvbnMuanMiLCJtb2R1bGVzL3V0aWxzL2NsaXAtcGF0aC1wb2x5Z29uLTEuMC4xNS5qcyIsIm1vZHVsZXMvdXRpbHMvanF1ZXJ5LWV4dGVuc2lvbnMuanMiLCJtb2R1bGVzL3V0aWxzL3ByZWZlcmVuY2UtbWFuYWdlci5qcyIsIm1vZHVsZXMvdXRpbHMvcmVxdWlyZW1lbnRzLmpzIiwibW9kdWxlcy91dGlscy9zdHJpbmctZXh0ZW5zaW9ucy5qcyIsIm1vZHVsZXMvdXRpbHMvdGltZS5qcyIsIm1vZHVsZXMvdmVuZG9yLmpzIiwibW9kdWxlcy92aWRlby1wbGF5ZXIvc2Vla2Jhci10b29sdGlwLmpzIiwibW9kdWxlcy92aWRlby1wbGF5ZXIvdmlkZW8tcGxheWVyLWJhci5qcyIsIm1vZHVsZXMvdmlkZW8tcGxheWVyL3ZpZGVvLXBsYXllci5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvaGVscGVyLXZhbGlkYXRvci1pZGVudGlmaWVyL2xpYi9pZGVudGlmaWVyLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9oZWxwZXItdmFsaWRhdG9yLWlkZW50aWZpZXIvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9oZWxwZXItdmFsaWRhdG9yLWlkZW50aWZpZXIvbGliL2tleXdvcmQuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9hc3NlcnRzL2Fzc2VydE5vZGUuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9hc3NlcnRzL2dlbmVyYXRlZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2J1aWxkZXJzL2J1aWxkZXIuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9idWlsZGVycy9mbG93L2NyZWF0ZUZsb3dVbmlvblR5cGUuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9idWlsZGVycy9mbG93L2NyZWF0ZVR5cGVBbm5vdGF0aW9uQmFzZWRPblR5cGVvZi5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2J1aWxkZXJzL2dlbmVyYXRlZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2J1aWxkZXJzL3JlYWN0L2J1aWxkQ2hpbGRyZW4uanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9idWlsZGVycy90eXBlc2NyaXB0L2NyZWF0ZVRTVW5pb25UeXBlLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY2xvbmUvY2xvbmUuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jbG9uZS9jbG9uZURlZXAuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jbG9uZS9jbG9uZURlZXBXaXRob3V0TG9jLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY2xvbmUvY2xvbmVOb2RlLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY2xvbmUvY2xvbmVXaXRob3V0TG9jLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY29tbWVudHMvYWRkQ29tbWVudC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2NvbW1lbnRzL2FkZENvbW1lbnRzLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY29tbWVudHMvaW5oZXJpdElubmVyQ29tbWVudHMuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb21tZW50cy9pbmhlcml0TGVhZGluZ0NvbW1lbnRzLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY29tbWVudHMvaW5oZXJpdFRyYWlsaW5nQ29tbWVudHMuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb21tZW50cy9pbmhlcml0c0NvbW1lbnRzLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY29tbWVudHMvcmVtb3ZlQ29tbWVudHMuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb25zdGFudHMvZ2VuZXJhdGVkL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY29uc3RhbnRzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY29udmVydGVycy9lbnN1cmVCbG9jay5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2NvbnZlcnRlcnMvZ2F0aGVyU2VxdWVuY2VFeHByZXNzaW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2NvbnZlcnRlcnMvdG9CaW5kaW5nSWRlbnRpZmllck5hbWUuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb252ZXJ0ZXJzL3RvQmxvY2suanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb252ZXJ0ZXJzL3RvQ29tcHV0ZWRLZXkuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb252ZXJ0ZXJzL3RvRXhwcmVzc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2NvbnZlcnRlcnMvdG9JZGVudGlmaWVyLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY29udmVydGVycy90b0tleUFsaWFzLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY29udmVydGVycy90b1NlcXVlbmNlRXhwcmVzc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2NvbnZlcnRlcnMvdG9TdGF0ZW1lbnQuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb252ZXJ0ZXJzL3ZhbHVlVG9Ob2RlLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvZGVmaW5pdGlvbnMvY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2RlZmluaXRpb25zL2V4cGVyaW1lbnRhbC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2RlZmluaXRpb25zL2Zsb3cuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9kZWZpbml0aW9ucy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2RlZmluaXRpb25zL2pzeC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2RlZmluaXRpb25zL21pc2MuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9kZWZpbml0aW9ucy9wbGFjZWhvbGRlcnMuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9kZWZpbml0aW9ucy90eXBlc2NyaXB0LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvZGVmaW5pdGlvbnMvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL21vZGlmaWNhdGlvbnMvYXBwZW5kVG9NZW1iZXJFeHByZXNzaW9uLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvbW9kaWZpY2F0aW9ucy9mbG93L3JlbW92ZVR5cGVEdXBsaWNhdGVzLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvbW9kaWZpY2F0aW9ucy9pbmhlcml0cy5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL21vZGlmaWNhdGlvbnMvcHJlcGVuZFRvTWVtYmVyRXhwcmVzc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL21vZGlmaWNhdGlvbnMvcmVtb3ZlUHJvcGVydGllcy5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL21vZGlmaWNhdGlvbnMvcmVtb3ZlUHJvcGVydGllc0RlZXAuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9tb2RpZmljYXRpb25zL3R5cGVzY3JpcHQvcmVtb3ZlVHlwZUR1cGxpY2F0ZXMuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9yZXRyaWV2ZXJzL2dldEJpbmRpbmdJZGVudGlmaWVycy5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3JldHJpZXZlcnMvZ2V0T3V0ZXJCaW5kaW5nSWRlbnRpZmllcnMuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi90cmF2ZXJzZS90cmF2ZXJzZS5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3RyYXZlcnNlL3RyYXZlcnNlRmFzdC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3V0aWxzL2luaGVyaXQuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi91dGlscy9yZWFjdC9jbGVhbkpTWEVsZW1lbnRMaXRlcmFsQ2hpbGQuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi91dGlscy9zaGFsbG93RXF1YWwuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL2J1aWxkTWF0Y2hNZW1iZXJFeHByZXNzaW9uLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvdmFsaWRhdG9ycy9nZW5lcmF0ZWQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL2lzLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvdmFsaWRhdG9ycy9pc0JpbmRpbmcuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL2lzQmxvY2tTY29wZWQuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL2lzSW1tdXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvdmFsaWRhdG9ycy9pc0xldC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvaXNOb2RlLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvdmFsaWRhdG9ycy9pc05vZGVzRXF1aXZhbGVudC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvaXNQbGFjZWhvbGRlclR5cGUuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL2lzUmVmZXJlbmNlZC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvaXNTY29wZS5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvaXNTcGVjaWZpZXJEZWZhdWx0LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvdmFsaWRhdG9ycy9pc1R5cGUuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL2lzVmFsaWRFUzNJZGVudGlmaWVyLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvdmFsaWRhdG9ycy9pc1ZhbGlkSWRlbnRpZmllci5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvaXNWYXIuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL21hdGNoZXNQYXR0ZXJuLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvdmFsaWRhdG9ycy9yZWFjdC9pc0NvbXBhdFRhZy5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvcmVhY3QvaXNSZWFjdENvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvdmFsaWRhdGUuanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jaGFyZW5jL2NoYXJlbmMuanMiLCJub2RlX21vZHVsZXMvY3J5cHQvY3J5cHQuanMiLCJub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX0RhdGFWaWV3LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fSGFzaC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX0xpc3RDYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcENhY2hlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fUHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX1NldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX1N0YWNrLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fU3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fVWludDhBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX1dlYWtNYXAuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUVhY2guanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5TGlrZUtleXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVB1c2guanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hc3NpZ25WYWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc29jSW5kZXhPZi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VBc3NpZ24uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduSW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduVmFsdWUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQ2xvbmUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQ3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldEFsbEtleXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0VGFnLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzQXJndW1lbnRzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTWFwLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmF0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzUmVnRXhwLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzU2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUtleXNJbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUaW1lcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VVbmFyeS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQXJyYXlCdWZmZXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZUJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lRGF0YVZpZXcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZVJlZ0V4cC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lU3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVUeXBlZEFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weUFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weU9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlTeW1ib2xzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weVN5bWJvbHNJbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcmVKc0RhdGEuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19kZWZpbmVQcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2ZyZWVHbG9iYWwuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXRBbGxLZXlzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0QWxsS2V5c0luLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TWFwRGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE5hdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFByb3RvdHlwZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFJhd1RhZy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFN5bWJvbHMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXRTeW1ib2xzSW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXRUYWcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19nZXRWYWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hDbGVhci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hEZWxldGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoR2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEhhcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hTZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19pbml0Q2xvbmVBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2luaXRDbG9uZUJ5VGFnLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faXNJbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzTWFza2VkLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faXNQcm90b3R5cGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVDbGVhci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZURlbGV0ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUdldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUhhcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZVNldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZURlbGV0ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlR2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVIYXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZVNldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUtleXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVLZXlzSW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19ub2RlVXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX29iamVjdFRvU3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlckFyZy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3Jvb3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0NsZWFyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tEZWxldGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0dldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrSGFzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tTZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL190b1NvdXJjZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvY2xvbmUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2VxLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FyZ3VtZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheUxpa2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzQnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc0Z1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc0xlbmd0aC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNNYXAuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdExpa2UuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzUGxhaW5PYmplY3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzUmVnRXhwLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc1NldC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNUeXBlZEFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzSW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL3N0dWJBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvc3R1YkZhbHNlLmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9xdGlwMi9kaXN0L2pxdWVyeS5xdGlwLmpzIiwibm9kZV9tb2R1bGVzL3NjcmVlbmZ1bGwvZGlzdC9zY3JlZW5mdWxsLmpzIiwibm9kZV9tb2R1bGVzL3NoYTEvc2hhMS5qcyIsIm5vZGVfbW9kdWxlcy90by1mYXN0LXByb3BlcnRpZXMvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ0xBOzs7Ozs7Ozs7Ozs7OztJQUVNLGlCO0FBQ0YsK0JBQWE7QUFBQTs7QUFDVCxTQUFLLFdBQUwsR0FBbUIsRUFBbkI7QUFDQSxTQUFLLGVBQUwsR0FBdUIsRUFBdkI7QUFDSDs7OztxQ0FFZ0IsSSxFQUFLO0FBRWxCLFVBQUksSUFBSSxDQUFDLE1BQUwsSUFBZSxDQUFuQixFQUFxQjtBQUNqQixRQUFBLE9BQU8sQ0FBQyxJQUFSLENBQWEsK0JBQWI7QUFDSDs7QUFFRCxVQUFJLGVBQWUsT0FBTyxJQUFJLENBQUMsS0FBL0IsRUFBdUM7QUFBRztBQUFILG1EQUNqQixJQURpQjtBQUFBOztBQUFBO0FBQ25DLDhEQUF1QjtBQUFBLGdCQUFmLE1BQWU7QUFDbkIsaUJBQUssa0JBQUwsQ0FBd0IsTUFBeEI7QUFDSDtBQUhr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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3Y3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNodENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbjhDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDanZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDLzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcImNsaWVudF9pZFwiOiBcInNjYWxhclwiLFxuICAgIFwiY2xpZW50X3ZlclwiOiBcIjIuNS4xMlwiLFxuICAgIFwiaWRcIjogXCJ1c2VyQGV4YW1wbGUuY29tXCIsXG4gICAgXCJhcGlfa2V5XCI6IFwiYWJjZC1oYXNoa2V5LWZyb20tc29tZXdoZXJlLWVsc2VcIlxufSIsImltcG9ydCB7IEFubm90YXRpb24gfSBmcm9tIFwiLi9hbm5vdGF0aW9uLmpzXCI7XG5cbmNsYXNzIEFubm90YXRpb25NYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLmFubm90YXRpb25zID0gW107XG4gICAgICAgIHRoaXMub25vbXlWb2NhYnVsYXJ5ID0gW107XG4gICAgfVxuXG4gICAgUG9wdWxhdGVGcm9tSlNPTihqc29uKXtcbiAgICBcbiAgICAgICAgaWYgKGpzb24ubGVuZ3RoID09IDApe1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiSlNPTiBjb250YWlucyBubyBhbm5vdGF0aW9ucy5cIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJ3VuZGVmaW5lZCcgPT0gdHlwZW9mKGpzb24uaXRlbXMpKSB7ICAvLyBWZXJzaW9uIDFcbiAgICAgICAgICAgIGZvcihsZXQgb2JqZWN0IG9mIGpzb24pe1xuICAgICAgICAgICAgICAgIHRoaXMuUmVnaXN0ZXJBbm5vdGF0aW9uKG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7ICAvLyBWZXJzaW9uIDJcbiAgICAgICAgICAgIGZvciAobGV0IG9iamVjdCBvZiBqc29uLml0ZW1zWzBdLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5SZWdpc3RlckFubm90YXRpb24ob2JqZWN0LCBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGpzb24uaXRlbXNbMF0pKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIFJlZ2lzdGVyQW5ub3RhdGlvbihqc29uT2JqZWN0LCBjYW52YXNPYmplY3Qpe1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiUmVnaXN0ZXJpbmcgbmV3IGFubm90YXRpb24gd2l0aCBJRCBcIiArIGpzb25PYmplY3QuaWQpO1xuICAgICAgICBsZXQgYW5ubyA9IG5ldyBBbm5vdGF0aW9uKGpzb25PYmplY3QsIGNhbnZhc09iamVjdCk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbnMucHVzaChhbm5vKTtcbiAgICB9XG5cbiAgICBSZW1vdmVBbm5vdGF0aW9uKGlkKXtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9ucyA9IHRoaXMuYW5ub3RhdGlvbnMuZmlsdGVyKChvYmopID0+IHtcbiAgICAgICAgICAgIGlmICgndW5kZWZpbmVkJyA9PSB0eXBlb2Yob2JqLml0ZW1zKSkgeyAvLyBWZXJzaW9uIDFcbiAgICAgICAgICAgICAgICByZXR1cm4gaWQgIT09IG9iai5pZDtcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIFZlcnNpb24gMlxuICAgICAgICAgICAgICAgIHJldHVybiBpZCAhPT0gb2JqLml0ZW1zWzBdLml0ZW1zWzBdLml0ZW1zWzBdLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGdpdmVuIGFubm90YXRpb24gaW4gdGhlIHN0b3JlZCBhcnJheVxuICAgICAqL1xuICAgIFVwZGF0ZUFubm90YXRpb24oYW5ub3RhdGlvbiwgb2xkSUQpe1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiVXBkYXRpbmcgYW5ub3RhdGlvbiBJRCBcIiArIG9sZElEICsgXCIgdG8gXCIgKyBhbm5vdGF0aW9uLm1ldGFkYXRhLmlkKTtcbiAgICAgICAgdGhpcy5SZW1vdmVBbm5vdGF0aW9uKG9sZElEKTtcbiAgICAgICAgLy90aGlzLlJlZ2lzdGVyQW5ub3RhdGlvbihhbm5vdGF0aW9uKTtcbiAgICAgICAgdGhpcy5Qb3B1bGF0ZUZyb21KU09OKGFubm90YXRpb24pO1xuICAgIH1cblxuICAgIEFubm90YXRpb25zQXRUaW1lKHRpbWUpe1xuXG4gICAgICAgIC8vIFRPRE86IFJlZW5hYmxlIHdpdGggc29tZSBraW5kIG9mIGZvcmNlIHBhcmFtZXRlclxuXG4gICAgICAgIC8vIC8vIElmIHRoZSBsYXN0IHRpbWUgcmVxdWVzdGVkIGlzIGFza2VkIGZvciBhZ2FpbiwganVzdCBnaXZlIGJhY2sgdGhlIGNhY2hlZCByZXN1bHRcbiAgICAgICAgLy8gaWYodGltZU1TID09IHRoaXMubGFzdFRpbWVSZXF1ZXN0ZWQpe1xuICAgICAgICAvLyAgICAgLy9jb25zb2xlLmxvZyhcIlVzaW5nIGNhY2hlXCIpO1xuICAgICAgICAvLyAgICAgcmV0dXJuIHRoaXMuY2FjaGVkO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIHRoaXMubGFzdFRpbWVSZXF1ZXN0ZWQgPSB0aW1lTVM7XG5cbiAgICAgICAgLy8gRmlsdGVyIGFsbCBsb2FkZWQgYW5ub3RhdGlvbnMgdGhhdCBmaXQgd2l0aGluIHRoZSByYW5nZSBxdWVyeS5cbiAgICAgICAgbGV0IGZpbHRlcmVkID0gdGhpcy5hbm5vdGF0aW9ucy5maWx0ZXIoZnVuY3Rpb24oaXRlbSl7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5iZWdpblRpbWUgPD0gdGltZSAmJiB0aW1lIDw9IGl0ZW0uZW5kVGltZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5jYWNoZWQgPSBmaWx0ZXJlZDtcblxuICAgICAgICByZXR1cm4gZmlsdGVyZWQ7XG4gICAgfVxuXG4gICAgR2V0T25vbXlWb2NhYnVsYXJ5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vbm9teVZvY2FidWxhcnk7XG4gICAgfVxuXG4gICAgVXBkYXRlT25vbXlWb2NhYnVsYXJ5KHZvY2FidWxhcnkpIHtcbiAgICAgICAgdGhpcy5vbm9teVZvY2FidWxhcnkgPSB2b2NhYnVsYXJ5O1xuICAgIH1cblxufVxuXG5leHBvcnQgeyBBbm5vdGF0aW9uTWFuYWdlciB9OyIsIi8vLyBBIHdyYXBwZXIgZm9yIEpTT04gb2JqZWN0cy5cbmNsYXNzIEFubm90YXRpb24ge1xuXG4gICAgY29uc3RydWN0b3IoanNvbiA9IG51bGwsIGNhbnZhcyA9IG51bGwpIHtcblxuICAgICAgICBsZXQgdmVyc2lvbiA9IFwidjJcIjtcblxuICAgICAgICBpZiAoanNvbikge1xuICAgICAgICAgICAgaWYgKCd1bmRlZmluZWQnID09IHR5cGVvZihqc29uLml0ZW1zKSkge1xuICAgICAgICAgICAgICAgIHZlcnNpb24gPSBcInYxXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZlcnNpb24gPSBcInYyXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyB2ZXIxXG4gICAgICAgIGlmICh2ZXJzaW9uID09IFwidjFcIikge1xuICAgICAgICAgICAgdGhpc1tcIkBjb250ZXh0XCJdID0gXCJodHRwOi8vd3d3LnczLm9yZy9ucy9hbm5vLmpzb25sZFwiO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzW1wicmVxdWVzdFwiXSA9IHtcbiAgICAgICAgICAgICAgICBcImNsaWVudF9pZFwiOiBcInNjYWxhclwiLFxuICAgICAgICAgICAgICAgIFwiY2xpZW50X3ZlclwiOiBcIjIuNS4xMlwiLFxuICAgICAgICAgICAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICAgICAgICAgICAgICBcIm5hdGl2ZVwiOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgXCJpZFwiOiBcIl9fQ0hFQ0tfQ09ORklHX0ZJTEVfX0lEX19cIixcbiAgICAgICAgICAgICAgICAgICAgXCJhcGlfa2V5XCI6IFwiX19DSEVDS19DT05GSUdfRklMRV9fQVBJX0tFWV9fXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYWN0aW9uXCI6IFwiVE9CRUZJTExFRFwiLFxuICAgICAgICAgICAgICAgICAgICBcImZvcm1hdFwiOiBcImpzb25cIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzW1widHlwZVwiXSA9IFwiQW5ub3RhdGlvblwiOyAgXG4gICAgICAgICAgICB0aGlzW1wibW90aXZhdGlvblwiXSA9IFwiaGlnaGxpZ2h0aW5nXCI7XG4gICAgICAgICAgICB0aGlzW1wiYm9keVwiXSA9IFtdO1xuICAgICAgICAgICAgdGhpc1tcInRhcmdldFwiXSA9IHt9O1xuICAgICAgICAgICAgdGhpc1tcImFubm90YXRpb25fdmVyc2lvblwiXSA9IFwidjFcIjtcblxuICAgICAgICAgICAgdGhpcy5yZWFkQ29uZmlnKHZlcnNpb24pO1xuXG4gICAgICAgICAgICBpZiAoanNvbikge1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywganNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB2ZXIyIGRvY3Mvd2ViYW5ub3RhdGlvbl9zcGVjL3NhbXBsZV8yLjAuanNvblxuICAgICAgICAgICAgdGhpc1tcIkBjb250ZXh0XCJdID0gW1wiaHR0cDovL3d3dy53My5vcmcvbnMvYW5uby5qc29ubGRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImh0dHA6Ly9paWlmLmlvL2FwaS9wcmVzZW50YXRpb24vMy9jb250ZXh0Lmpzb25cIl07XG4gICAgICAgICAgICB0aGlzW1wic2VydmljZVwiXSA9IFt7XG4gICAgICAgICAgICAgICAgXCJjbGllbnRfaWRcIjogXCJzY2FsYXJcIixcbiAgICAgICAgICAgICAgICBcImNsaWVudF92ZXJcIjogXCIyLjUuMTJcIixcbiAgICAgICAgICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJuYXRpdmVcIjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIFwiaWRcIjogXCJfX0NIRUNLX0NPTkZJR19GSUxFX19JRF9fXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYXBpX2tleVwiOiBcIl9fQ0hFQ0tfQ09ORklHX0ZJTEVfX0FQSV9LRVlfX1wiLFxuICAgICAgICAgICAgICAgICAgICBcImFjdGlvblwiOiBcIlRPQkVGSUxMRURcIixcbiAgICAgICAgICAgICAgICAgICAgXCJmb3JtYXRcIjogXCJqc29uXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIHRoaXNbXCJ0eXBlXCJdID0gXCJNYW5pZmVzdFwiO1xuICAgICAgICAgICAgdGhpc1tcIml0ZW1zXCJdID0gW107XG4gICAgICAgICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tcIml0ZW1zXCJdLnB1c2goIGNhbnZhcyApOyAgLy8gVGhlIFwiQ2FudmFzXCJcbiAgICAgICAgICAgICAgICB0aGlzW1wiaXRlbXNcIl1bMF0uaXRlbXMgPSBbIGpzb24gXTsgIC8vIFRoZSBcIkFubm90YXRpb25QYWdlXCIgKyBcIkFubm90YXRpb25cIlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpc1tcImFubm90YXRpb25fdmVyc2lvblwiXSA9IFwidjJcIjtcblxuICAgICAgICAgICAgdGhpcy5yZWFkQ29uZmlnKHZlcnNpb24pO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZihqc29uKSB7XG4gICAgICAgICAgICAvLyBDb21wdXRlIHJlYWQgb25seSBlYXN5IGFjY2VzcyBwcm9wZXJ0aWVzXG4gICAgICAgICAgICB0aGlzLnJlY2FsY3VsYXRlKCk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHJlYWRDb25maWcodmVyc2lvbikge1xuICAgICAgICBjb25zdCBjb25maWcgPSByZXF1aXJlKFwiLi4vYW5ub3RhdG9yLWNvbmZpZy5qc29uXCIpO1xuICAgICAgICBpZiAodmVyc2lvbiA9PSBcInYxXCIpIHtcbiAgICAgICAgICAgIC8vIHZlcjFcbiAgICAgICAgICAgIHRoaXNbXCJyZXF1ZXN0XCJdW1wiY2xpZW50X2lkXCJdID0gY29uZmlnLmNsaWVudF9pZDtcbiAgICAgICAgICAgIHRoaXNbXCJyZXF1ZXN0XCJdW1wiY2xpZW50X3ZlclwiXSA9IGNvbmZpZy5jbGllbnRfdmVyO1xuICAgICAgICAgICAgdGhpc1tcInJlcXVlc3RcIl1bXCJpdGVtc1wiXVtcIm5hdGl2ZVwiXSA9IGNvbmZpZy5uYXRpdmU7XG4gICAgICAgICAgICB0aGlzW1wicmVxdWVzdFwiXVtcIml0ZW1zXCJdW1wiaWRcIl0gPSBjb25maWcuaWQ7XG4gICAgICAgICAgICB0aGlzW1wicmVxdWVzdFwiXVtcIml0ZW1zXCJdW1wiYXBpX2tleVwiXSA9IGNvbmZpZy5hcGlfa2V5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdmVyMlxuICAgICAgICAgICAgdGhpc1tcInNlcnZpY2VcIl1bMF1bXCJjbGllbnRfaWRcIl0gPSBjb25maWcuY2xpZW50X2lkO1xuICAgICAgICAgICAgdGhpc1tcInNlcnZpY2VcIl1bMF1bXCJjbGllbnRfdmVyXCJdID0gY29uZmlnLmNsaWVudF92ZXI7XG4gICAgICAgICAgICB0aGlzW1wic2VydmljZVwiXVswXVtcIml0ZW1zXCJdW1wibmF0aXZlXCJdID0gY29uZmlnLm5hdGl2ZTtcbiAgICAgICAgICAgIHRoaXNbXCJzZXJ2aWNlXCJdWzBdW1wiaXRlbXNcIl1bXCJpZFwiXSA9IGNvbmZpZy5pZDtcbiAgICAgICAgICAgIHRoaXNbXCJzZXJ2aWNlXCJdWzBdW1wiaXRlbXNcIl1bXCJhcGlfa2V5XCJdID0gY29uZmlnLmFwaV9rZXk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLy8gQ29tcHV0ZSByZWFkIG9ubHkgZWFzeSBhY2Nlc3MgcHJvcGVydGllc1xuICAgIHJlY2FsY3VsYXRlKCkge1xuXG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMpO1xuXG4gICAgICAgIGlmICgndW5kZWZpbmVkJyA9PSB0eXBlb2YodGhpcy5pdGVtcykpIHsgLy8gVmVyc2lvbiAxXG4gICAgICAgICAgICB2YXIgdGltZVNsaWNlID0gdGhpcy50YXJnZXQuc2VsZWN0b3IuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0udHlwZSA9PT0gXCJGcmFnbWVudFNlbGVjdG9yXCI7XG4gICAgICAgICAgICAgIH0pWzBdLnZhbHVlO1xuICAgICAgICB9IGVsc2UgeyAvLyBWZXJzaW9uIDJcbiAgICAgICAgICAgIHZhciB0aW1lU2xpY2UgPSB0aGlzLml0ZW1zWzBdLml0ZW1zWzBdLml0ZW1zWzBdLnRhcmdldC5zZWxlY3Rvci52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aW1lU2xpY2UgPSB0aW1lU2xpY2UucmVwbGFjZSgnI3Q9bnB0OicsJ3Q9Jyk7XG4gICAgICAgIHRpbWVTbGljZSA9IHRpbWVTbGljZS5yZXBsYWNlKFwidD1cIiwgXCJcIik7XG5cbiAgICAgICAgLy8vIFN0YXJ0IHRpbWUgaW4gc2Vjb25kc1xuICAgICAgICB0aGlzLmJlZ2luVGltZSA9IHBhcnNlRmxvYXQodGltZVNsaWNlLnNwbGl0KFwiLFwiKVswXSk7XG4gICAgICAgIC8vLyBFbmQgdGltZSBpbiBzZWNvbmRzXG4gICAgICAgIHRoaXMuZW5kVGltZSA9IHBhcnNlRmxvYXQodGltZVNsaWNlLnNwbGl0KFwiLFwiKVsxXSk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdiZWdpblRpbWU6ICcgKyB0aGlzLmJlZ2luVGltZSArICcgZW5kVGltZTogJyArIHRoaXMuZW5kVGltZSk7XG5cbiAgICAgICAgLy8vIEV4dHJhY3QgdGFncyBmcm9tIGFubm90YXRpb25cbiAgICAgICAgaWYgKCd1bmRlZmluZWQnID09IHR5cGVvZih0aGlzLml0ZW1zKSkgeyAvLyBWZXJzaW9uIDFcbiAgICAgICAgICAgIHRoaXMudGFncyA9IHRoaXMuYm9keS5maWx0ZXIoaXRlbSA9PiBpdGVtLnB1cnBvc2UgPT09IFwidGFnZ2luZ1wiKS5tYXAoaXRlbSA9PiBpdGVtLnZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gVmVyc2lvbiAyXG4gICAgICAgICAgICB0aGlzLnRhZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5pdGVtc1swXS5pdGVtc1swXS5pdGVtc1swXS5ib2R5Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXRlbXNbMF0uaXRlbXNbMF0uaXRlbXNbMF0uYm9keVtqXS5wdXJwb3NlICE9ICd0YWdnaW5nJykgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKCd1bmRlZmluZWQnICE9IHR5cGVvZih0aGlzLml0ZW1zWzBdLml0ZW1zWzBdLml0ZW1zWzBdLmJvZHlbal0udmFsdWUpKSB7ICAvLyBCYXNpYyB0YWdcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YWdzLnB1c2godGhpcy5pdGVtc1swXS5pdGVtc1swXS5pdGVtc1swXS5ib2R5W2pdLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCd1bmRlZmluZWQnICE9IHR5cGVvZih0aGlzLml0ZW1zWzBdLml0ZW1zWzBdLml0ZW1zWzBdLmJvZHlbal0uc291cmNlKSkgeyAgLy8gT25vbXkgdGFnXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFncy5wdXNoKHRoaXMuaXRlbXNbMF0uaXRlbXNbMF0uaXRlbXNbMF0uYm9keVtqXS5zb3VyY2UubGFiZWxbJ2VuJ10pOyAgLy8gVE9ETzogZW5nbGlzaCBoYXJkLWNvZGVkIGhlcmVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coJ1RhZ3M6ICcgKyB0aGlzLnRhZ3MpO1xuXG4gICAgICAgIC8vIFN0YXJ0IGFuZCBlbmQgcG9seSBwb2ludHNcbiAgICAgICAgdGhpcy5wb2x5U3RhcnQgPSBudWxsO1xuICAgICAgICB0aGlzLnBvbHlFbmQgPSBudWxsO1xuXG4gICAgICAgIHZhciBwb2ludHNTZWxlY3RvciA9IFtdO1xuICAgICAgICBpZiAoJ3VuZGVmaW5lZCcgPT0gdHlwZW9mKHRoaXMuaXRlbXMpKSB7IC8vIFZlcnNpb24gMVxuICAgICAgICAgICAgcG9pbnRzU2VsZWN0b3IgPSB0aGlzLnRhcmdldC5zZWxlY3Rvci5maWx0ZXIoaXRlbSA9PiBpdGVtLnR5cGUgPT09IFwiU3ZnU2VsZWN0b3JcIik7XG4gICAgICAgIH0gZWxzZSB7IC8vIFZlcnNpb24gMlxuICAgICAgICAgICAgcG9pbnRzU2VsZWN0b3IgPSAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mKHRoaXMuaXRlbXNbMF0uaXRlbXNbMF0uaXRlbXNbMF0udGFyZ2V0LnNlbGVjdG9yLnJlZmluZWRCeSkpID8gW3RoaXMuaXRlbXNbMF0uaXRlbXNbMF0uaXRlbXNbMF0udGFyZ2V0LnNlbGVjdG9yLnJlZmluZWRCeV0gOiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9pbnRzU2VsZWN0b3IubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IHBvaW50c1N2ZyA9IHBvaW50c1NlbGVjdG9yWzBdLnZhbHVlO1xuICAgICAgICAgICAgbGV0IHJlZ0V4U3RyaW5nID0gbmV3IFJlZ0V4cChcIig/OnBvaW50cz0nKSguKj8pKD86JylcIiwgXCJpZ1wiKTtcbiAgICAgICAgICAgIHZhciBwb2ludHNSRSA9IHJlZ0V4U3RyaW5nLmV4ZWMocG9pbnRzU3ZnKVsxXTtcbiAgICAgICAgICAgIHZhciBwb2ludHNEYXRhID0gcG9pbnRzUkUudHJpbSgpLnNwbGl0KFwiIFwiKS5tYXAoaXRlbSA9PiBpdGVtLnNwbGl0KFwiLFwiKSk7XG4gICAgICAgICAgICB0aGlzLnBvbHlTdGFydCA9IHBvaW50c0RhdGE7XG5cbiAgICAgICAgICAgIGxldCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgICAgICAgICBsZXQgeG1sRG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhwb2ludHNTdmcsIFwidGV4dC94bWxcIik7XG4gICAgICAgICAgICBpZiAoeG1sRG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYW5pbWF0ZVwiKS5sZW5ndGgpIHsgIC8vIElmIHRoZXJlIGlzIG5vIGFuaW1hdGlvbiBlbGVtZW50LCBjcmVhdGUgYW4gXCJhbmltYXRpb25cIiBmcm9tIHRoZSBzdGF0aWMgcG9pbnRzXG4gICAgICAgICAgICAgICAgcG9pbnRzUkUgPSB4bWxEb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJhbmltYXRlXCIpWzBdLmdldEF0dHJpYnV0ZShcInRvXCIpO1xuICAgICAgICAgICAgICAgIHBvaW50c0RhdGEgPSBwb2ludHNSRS50cmltKCkuc3BsaXQoXCIgXCIpLm1hcChpdGVtID0+IGl0ZW0uc3BsaXQoXCIsXCIpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvbHlFbmQgPSBwb2ludHNEYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKCdwb2x5U3RhcnQ6ICcpO1xuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnBvbHlTdGFydCk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdwb2x5RW5kOiAnKTtcbiAgICAgICAgY29uc29sZS5sb2codGhpcy5wb2x5RW5kKTtcblxuICAgIH1cblxuICAgIGdldFBvbHkoKSB7XG4gICAgICAgIHZhciBwb2ludHNTZWxlY3RvciA9IFtdO1xuICAgICAgICBpZiAoJ3VuZGVmaW5lZCcgPT0gdHlwZW9mKHRoaXMuaXRlbXMpKSB7IC8vIFZlcnNpb24gMVxuICAgICAgICAgICAgcG9pbnRzU2VsZWN0b3IgPSB0aGlzLnRhcmdldC5zZWxlY3Rvci5maWx0ZXIoaXRlbSA9PiBpdGVtLnR5cGUgPT09IFwiU3ZnU2VsZWN0b3JcIik7XG4gICAgICAgIH0gZWxzZSB7IC8vIFZlcnNpb24gMlxuICAgICAgICAgICAgcG9pbnRzU2VsZWN0b3IgPSAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mKHRoaXMuaXRlbXNbMF0uaXRlbXNbMF0uaXRlbXNbMF0udGFyZ2V0LnNlbGVjdG9yLnJlZmluZWRCeSkpID8gW3RoaXMuaXRlbXNbMF0uaXRlbXNbMF0uaXRlbXNbMF0udGFyZ2V0LnNlbGVjdG9yLnJlZmluZWRCeV0gOiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb2ludHNTZWxlY3Rvci5sZW5ndGggPT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgLy8gUGFyc2UgdGhlIHBvaW50cyBhcnJheSBmcm9tIHRoZSBhbm5vdGF0aW9uXG4gICAgICAgIGxldCBwb2ludHNTdmcgPSBwb2ludHNTZWxlY3RvclswXS52YWx1ZTtcbiAgICAgICAgbGV0IHJlZ0V4U3RyaW5nID0gbmV3IFJlZ0V4cChcIig/OnBvaW50cz0nKSguKj8pKD86JylcIiwgXCJpZ1wiKTsgLy9zZXQgaWcgZmxhZyBmb3IgZ2xvYmFsIHNlYXJjaCBhbmQgY2FzZSBpbnNlbnNpdGl2ZVxuICAgICAgICBcbiAgICAgICAgbGV0IHBvaW50c1JFID0gcmVnRXhTdHJpbmcuZXhlYyhwb2ludHNTdmcpWzFdO1xuICAgICAgICBsZXQgcG9pbnRzRGF0YSA9IHBvaW50c1JFLnRyaW0oKS5zcGxpdChcIiBcIikubWFwKGl0ZW0gPT4gaXRlbS5zcGxpdChcIixcIikpO1xuXG4gICAgICAgIHJldHVybiBwb2ludHNEYXRhO1xuICAgIH1cblxuICAgIGdldFNWR1BvbHlQb2ludHMoKSB7XG4gICAgICAgIHZhciBwb2ludHNTZWxlY3RvciA9IFtdO1xuICAgICAgICBpZiAoJ3VuZGVmaW5lZCcgPT0gdHlwZW9mKHRoaXMuaXRlbXMpKSB7IC8vIFZlcnNpb24gMVxuICAgICAgICAgICAgcG9pbnRzU2VsZWN0b3IgPSB0aGlzLnRhcmdldC5zZWxlY3Rvci5maWx0ZXIoaXRlbSA9PiBpdGVtLnR5cGUgPT09IFwiU3ZnU2VsZWN0b3JcIik7XG4gICAgICAgIH0gZWxzZSB7IC8vIFZlcnNpb24gMlxuICAgICAgICAgICAgcG9pbnRzU2VsZWN0b3IgPSAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mKHRoaXMuaXRlbXNbMF0uaXRlbXNbMF0uaXRlbXNbMF0udGFyZ2V0LnNlbGVjdG9yLnJlZmluZWRCeSkpID8gW3RoaXMuaXRlbXNbMF0uaXRlbXNbMF0uaXRlbXNbMF0udGFyZ2V0LnNlbGVjdG9yLnJlZmluZWRCeV0gOiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHBvaW50c1NlbGVjdG9yLmxlbmd0aCA9PSAwKSByZXR1cm4gbnVsbDtcblxuICAgICAgICAvLyBQYXJzZSB0aGUgcG9pbnRzIGFycmF5IGZyb20gdGhlIGFubm90YXRpb25cbiAgICAgICAgbGV0IHBvaW50c1N2ZyA9IHBvaW50c1NlbGVjdG9yWzBdLnZhbHVlO1xuICAgICAgICBsZXQgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgICAgICBsZXQgeG1sRG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhwb2ludHNTdmcsIFwidGV4dC94bWxcIik7XG5cbiAgICAgICAgaWYgKCF4bWxEb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJhbmltYXRlXCIpLmxlbmd0aCkgeyAgLy8gSWYgdGhlcmUgaXMgbm8gYW5pbWF0aW9uIGVsZW1lbnQsIGNyZWF0ZSBhbiBcImFuaW1hdGlvblwiIGZyb20gdGhlIHN0YXRpYyBwb2ludHNcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmdldFBvbHkoKTtcbiAgICAgICAgICAgIHJldHVybiBbcG9pbnRzLCBwb2ludHNdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFt4bWxEb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJhbmltYXRlXCIpWzBdLmdldEF0dHJpYnV0ZShcImZyb21cIiksIHhtbERvYy5nZXRFbGVtZW50c0J5VGFnTmFtZShcImFuaW1hdGVcIilbMF0uZ2V0QXR0cmlidXRlKFwidG9cIildO1xuICAgICAgICB9XG4gICAgfVxuXG59XG5cblxuXG5leHBvcnQgeyBBbm5vdGF0aW9uIH07IiwiaW1wb3J0IHsgU2VydmVySW50ZXJmYWNlIH0gZnJvbSBcIi4vc2VydmVyLWludGVyZmFjZS5qc1wiO1xuaW1wb3J0IHsgQW5ub3RhdGlvbk1hbmFnZXIgfSBmcm9tIFwiLi9hbm5vdGF0aW9uLW1hbmFnZXIuanNcIjtcbmltcG9ydCB7IFRpY2tCYXIgfSBmcm9tIFwiLi9jb21wb25lbnRzL3RpY2stYmFyLmpzXCI7XG5pbXBvcnQgeyBQb2x5Z29uT3ZlcmxheSB9IGZyb20gXCIuL2NvbXBvbmVudHMvcG9seWdvbi1vdmVybGF5LmpzXCI7XG5pbXBvcnQgeyBwcmVmZXJlbmNlcyB9IGZyb20gXCIuLi91dGlscy9wcmVmZXJlbmNlLW1hbmFnZXIuanNcIjtcbmltcG9ydCB7IEFubm90YXRpb25HVUkgfSBmcm9tIFwiLi9jb21wb25lbnRzL2Fubm90YXRpb24tZ3VpLmpzXCI7XG5pbXBvcnQgeyBJbmZvQ29udGFpbmVyIH0gZnJvbSBcIi4vY29tcG9uZW50cy9pbmZvLWNvbnRhaW5lci5qc1wiO1xuaW1wb3J0IHsgSW5kZXhDb250YWluZXIgfSBmcm9tIFwiLi9jb21wb25lbnRzL2luZGV4LWNvbnRhaW5lci5qc1wiO1xuaW1wb3J0IHsgU2Vzc2lvbk1hbmFnZXIgfSBmcm9tIFwiLi9zZXNzaW9uLW1hbmFnZXIuanNcIjtcbmltcG9ydCB7IE1lc3NhZ2VPdmVybGF5IH0gZnJvbSBcIi4vY29tcG9uZW50cy9tZXNzYWdlLW92ZXJsYXkuanNcIjtcbmltcG9ydCB7IEFubm90YXRpb24gfSBmcm9tIFwiLi9hbm5vdGF0aW9uLmpzXCI7XG5sZXQgc2hhMSA9IHJlcXVpcmUoJ3NoYTEnKTtcblxuY2xhc3MgVmlkZW9Bbm5vdGF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGFyZ3Mpe1xuICAgICAgICBjb25zb2xlLmxvZyhcIltWaWRlb0Fubm90YXRvcl0gQ3JlYXRpbmcgVmlkZW9Bbm5vdGF0b3IuLi5cIik7XG5cbiAgICAgICAgLy9QYXJzZSBhcmd1bWVudHNcbiAgICAgICAgLy9UaGlzIGlzIGFjdHVhbGx5IHJlcXVpcmVkXG4gICAgICAgIGlmKHR5cGVvZiBhcmdzLnBsYXllciA9PT0gJ3VuZGVmaW5lZCcpe1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0NhbGxlZCBmb3IgYSBuZXcgVmlkZW9Bbm5vdGF0b3Igd2l0aG91dCBwYXNzaW5nIGEgcGxheWVyIScpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGxheWVyID0gYXJncy5wbGF5ZXI7ICAvLyBCcmluZyBpbiB0aGUgYXJndW1lbnQgZnJvbSB0aGUgY29uc3RydWN0b3JcbiAgICAgICAgXG5cbiAgICAgICAgLy9UaGVzZSBjb25maWcgb3B0aW9ucyBhcmUgcmVxdWlyZWQgZm9yIHNhdmluZyBhbm5vdGF0aW9ucyB0byBhIHNlcnZlclxuICAgICAgICB0aGlzLnNlcnZlclVSTCA9IHR5cGVvZiBhcmdzLnNlcnZlclVSTCA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6IGFyZ3Muc2VydmVyVVJMO1xuICAgICAgICB0aGlzLnRhZ3NVUkwgPSB0eXBlb2YgYXJncy50YWdzVVJMID09PSAndW5kZWZpbmVkJyA/ICcnIDogYXJncy50YWdzVVJMO1xuICAgICAgICB0aGlzLmFwaUtleSA9IHR5cGVvZiBhcmdzLmFwaUtleSA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6IGFyZ3MuYXBpS2V5O1xuXG4gICAgICAgIC8vSWYgYXBpS2V5IGlzIHNldCBhbmQgY21zVXNlcm5hbWUgYW5kIGNtc0VtYWlsIGFyZSBwYXNzZWQsIHdlJ2xsIGF1dG8gbG9naW4gbGF0ZXJcbiAgICAgICAgdGhpcy5jbXNVc2VybmFtZSA9IHR5cGVvZiBhcmdzLmNtc1VzZXJuYW1lID09PSAndW5kZWZpbmVkJyA/ICcnIDogYXJncy5jbXNVc2VybmFtZTtcbiAgICAgICAgdGhpcy5jbXNFbWFpbCA9IHR5cGVvZiBhcmdzLmNtc0VtYWlsID09PSAndW5kZWZpbmVkJyA/ICcnIDogYXJncy5jbXNFbWFpbDtcblxuICAgICAgICAvL1RoaXMgY29uZmlnIG9wdGlvbiBpcyByZXF1aXJlZCBmb3IgdXNpbmcgYSBzdGF0aWMgYW5ub3RhdGlvbiBmaWxlXG4gICAgICAgIHRoaXMubG9jYWxVUkwgPSB0eXBlb2YgYXJncy5sb2NhbFVSTCA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6IGFyZ3MubG9jYWxVUkw7XG5cbiAgICAgICAgLy9PcHRpb25hbCBwYXJhbXNcbiAgICAgICAgLy9SZW1vdmVzIHRoZSBlZGl0aW5nIGludGVyZmFjZVxuICAgICAgICB0aGlzLmtpb3NrTW9kZSA9IHR5cGVvZiBhcmdzLmtpb3NrTW9kZSA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6IGFyZ3Mua2lvc2tNb2RlO1xuICAgICAgICAvL1Nob3dzIHRoZSAnb3BlbiBtYW5pZmVzdCcgYnV0dG9uIGlmIGtpb3NrTW9kZSBpcyBvZmZcbiAgICAgICAgdGhpcy5zaG93TWFuaWZlc3QgPSB0eXBlb2YgYXJncy5zaG93TWFuaWZlc3QgPT09ICd1bmRlZmluZWQnID8gZmFsc2UgOiBhcmdzLnNob3dNYW5pZmVzdDsgICAgICAgIFxuICAgICAgICAvL0FsbG93cyBwYXNzaW5nIGluIGEgZnVuY3Rpb24gdGhhdCBvdmVycmlkZXMgdGhlIGRlZmF1bHQgYW5ub3RhdGlvbiByZW5kZXJlclxuICAgICAgICB0aGlzLnJlbmRlcmVyID0gdHlwZW9mIGFyZ3MucmVuZGVyZXIgPT09ICd1bmRlZmluZWQnID8gZmFsc2UgOiBhcmdzLnJlbmRlcmVyO1xuICAgICAgICAvL0FsbG93cyBwYXNzaW5nIGluIGEgZnVuY3Rpb24gdGhhdCBvdmVycmlkZXMgdGhlIGRlZmF1bHQgYW5ub3RhdGlvbiByZW5kZXJlclxuICAgICAgICB0aGlzLnVucmVuZGVyZXIgPSB0eXBlb2YgYXJncy51bnJlbmRlcmVyID09PSAndW5kZWZpbmVkJyA/IGZhbHNlIDogYXJncy51bnJlbmRlcmVyO1xuICAgICAgICAvL0RldGVybWluZXMgd2hldGhlciBvciBub3QgdGhlIGFubm90YXRpb24gY29udGFpbmVyIGlzIGNsZWFyZWQgZXZlcnkgdGltZSBpdCB1cGRhdGVzXG4gICAgICAgIHRoaXMuY2xlYXJDb250YWluZXIgPSB0eXBlb2YgYXJncy5jbGVhckNvbnRhaW5lciA9PT0gJ3VuZGVmaW5lZCcgPyB0cnVlIDogYXJncy5jbGVhckNvbnRhaW5lcjtcbiAgICAgICAgLy9EZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHRvIGNyZWF0ZSBhIG5hdmlnYWJsZSBpbmRleCBvZiBhbm5vdGF0aW9uc1xuICAgICAgICB0aGlzLmRpc3BsYXlJbmRleCA9IHR5cGVvZiBhcmdzLmRpc3BsYXlJbmRleCA9PT0gJ3VuZGVmaW5lZCcgPyBmYWxzZSA6IGFyZ3MuZGlzcGxheUluZGV4OyAgIFxuICAgICAgICBcbiAgICAgICAgLy9EZXRlcm1pbmUgdGhlIGxhbmd1YWdlIG9mIHRoZSBhbm5vdGF0aW9uXG4gICAgICAgIHRoaXMub25vbXlMYW5ndWFnZSA9IHR5cGVvZiBhcmdzLm9ub215TGFuZ3VhZ2UgPT09ICd1bmRlZmluZWQnID8gJycgOiBhcmdzLm9ub215TGFuZ3VhZ2U7XG5cbiAgICAgICAgdGhpcy5vbm9teVZvY2FidWxhcnkgPSBbXTtcbiAgICAgICAgLy9sb2NhbFVSTCBpbXBsaWVzIGtpb3NrIG1vZGVcbiAgICAgICAgaWYodGhpcy5sb2NhbFVSTCAhPSAnJykgdGhpcy5raW9za01vZGUgPSB0cnVlO1xuXG4gICAgICAgIC8vYWRkaXRpb25hbCBkYXRhIGZyb20gYW5ub3RhdGlvbnMgY29sbGVjdGVkIGZyb20gc2NhbGFyIHRvIGJlIGFkZGVkIGluIEFQSSAyLjAgXG4gICAgICAgIHRoaXMuY29udGVudExhYmVsID0gXCJcIjtcbiAgICAgICAgdGhpcy5hcnRVUkwgPSBcIlwiO1xuICAgICAgICB0aGlzLmFubm90YXRpb25QYWdlVVJMID0gXCJcIjtcblxuICAgICAgICB0aGlzLldyYXAoKTtcbiAgICAgICAgdGhpcy5Qb3B1bGF0ZUNvbnRyb2xzKCk7XG5cbiAgICAgICAgLy9tYXkgbmVlZCB0byBtb3ZlIHRoaXMgYmVsb3cgdGhlIHRoaXMuc2VydmVyIGJsb2NrIGxhdGVyP1xuICAgICAgICB0aGlzLm1lc3NhZ2VPdmVybGF5ID0gbmV3IE1lc3NhZ2VPdmVybGF5KHRoaXMpO1xuICAgICAgICB0aGlzLmFubm90YXRpb25NYW5hZ2VyID0gbmV3IEFubm90YXRpb25NYW5hZ2VyKCk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbk1hbmFnZXIgPSBuZXcgU2Vzc2lvbk1hbmFnZXIodGhpcyk7XG5cbiAgICAgICAgLy9sb2FkIG9ub215IHZvY2FidWxhcnlcbiAgICAgICAgJC5hamF4KHRoaXMuZ3VpLkdldFRhZ3NRdWVyeSgpKS5kb25lKCh2b2NhYnVsYXJ5KT0+e1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIk9ub215Vm9jYWJ1bGFyeSBpcyBsb2FkZWRcIik7XG4gICAgICAgICAgICBsZXQgcGFyc2VkVm9jYWJ1bGFyeSA9IHRoaXMuZ3VpLk9ub215Vm9jYWJ1bGFyUHJvY2Vzcyh2b2NhYnVsYXJ5LCB0aGlzLm9ub215TGFuZ3VhZ2UpO1xuICAgICAgICAgICAgdGhpcy5hbm5vdGF0aW9uTWFuYWdlci5VcGRhdGVPbm9teVZvY2FidWxhcnkocGFyc2VkVm9jYWJ1bGFyeSk7XG4gICAgICAgICAgICB0aGlzLm9ub215Vm9jYWJ1bGFyeSA9IHBhcnNlZFZvY2FidWxhcnk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vbG9jYWxVUkwgdGFrZXMgcHJlY2VuZGVuY2UgLSBpZiBpdCBpcyBhbnl0aGluZyBidXQgJycgdGhlbiBkbyBub3QgbG9hZCBmcm9tIHNlcnZlclxuICAgICAgICBpZih0aGlzLmxvY2FsVVJMID09ICcnKXtcbiAgICAgICAgICAgIHRoaXMuc2VydmVyID0gbmV3IFNlcnZlckludGVyZmFjZSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuc2VydmVyLlNldEJhc2VVUkwodGhpcy5zZXJ2ZXJVUkwpO1xuXG4gICAgICAgICAgICAvLyBMb2FkIGFubm90YXRpb25zIGZyb20gc2VydmVyIGJhc2VkIG9uIHRoZSBwbGF5ZXIncyB2aWRlbyBVUkxcbiAgICAgICAgICAgIHRoaXMuc2VydmVyLkZldGNoQW5ub3RhdGlvbnMoJ2xvY2F0aW9uJywgdGhpcy5wbGF5ZXIudmlkZW9FbGVtZW50LmN1cnJlbnRTcmMpXG4gICAgICAgICAgICAuZG9uZSgoanNvbik9PntcbiAgICAgICAgICAgICAgICBpZiAoJ3VuZGVmaW5lZCcgPT0gdHlwZW9mKGpzb24uaXRlbXMpKSB7ICAvLyBWZXJzaW9uIDFcbiAgICAgICAgICAgICAgICAgICAgLy9qc29uLnNoaWZ0KCkgIC8vIEFzc3VtZSBmaXJzdCBub2RlIGlzIGEgY29udGVudCBub2RlXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBqc29uLmxlbmd0aC0xOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoanNvbltqXS50eXBlICE9IFwiQW5ub3RhdGlvblwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW5ub3RhdGlvbl9pbmZvID0ganNvbltqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRMYWJlbCA9IGFubm90YXRpb25faW5mb1tcImRjdGVybXM6dGl0bGVcIl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcnRVUkwgPSBhbm5vdGF0aW9uX2luZm9bXCJhcnQ6dXJsXCJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGFubm90YXRpb25faW5mb1tcImRjdGVybXM6dGl0bGVcIl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb24uc3BsaWNlKGosMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwganNvbltqXS50YXJnZXQuc2VsZWN0b3IubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCdGcmFnbWVudFNlbGVjdG9yJyAhPSBqc29uW2pdLnRhcmdldC5zZWxlY3RvcltrXS50eXBlKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbltqXS50YXJnZXQuc2VsZWN0b3Jba10udmFsdWUgPSBqc29uW2pdLnRhcmdldC5zZWxlY3RvcltrXS52YWx1ZS5yZXBsYWNlKCcjdD1ucHQ6JywndD0nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAgLy8gVmVyc2lvbiAyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGVudExhYmVsID0ganNvbi5sYWJlbC5lblswXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcnRVUkwgPSBqc29uLml0ZW1zWzBdLmNvbnRlbnQuaWQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5ub3RhdGlvblBhZ2VVUkwgPSBqc29uLml0ZW1zWzBdLml0ZW1zWzBdLml0ZW1zWzBdLmlkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuYW5ub3RhdGlvbk1hbmFnZXIuUG9wdWxhdGVGcm9tSlNPTihqc29uKTtcbiAgICAgICAgICAgICAgICB0aGlzLkFubm90YXRpb25zTG9hZGVkKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy9hdXRvLWxvZ2luIGlmIG5vdCBpbiBraW9zayBtb2RlLCBhbmQgd2UgaGF2ZSB0aGUgY21zIHZhcmlhYmxlcyBhbmQgQVBJIGtleVxuICAgICAgICAgICAgaWYoIXRoaXMua2lvc2tNb2RlKXtcbiAgICAgICAgICAgICAgICBpZih0aGlzLmFwaUtleSAmJiB0aGlzLmNtc0VtYWlsICYmIHRoaXMuY21zVXNlcm5hbWUpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlcnZlci5Mb2dPdXQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXJ2ZXIuTG9nSW4odGhpcy5jbXNVc2VybmFtZSwgc2hhMSh0aGlzLmNtc0VtYWlsKSkuZG9uZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIltNYWluXSBDTVMgbG9naW4gc3VjY2Vzc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfSkuZmFpbCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIltNYWluXSBDTVMgbG9naW4gZmFpbGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdMb2FkaW5nIGxvY2FsIGNhY2hlIGZpbGU6ICcgKyB0aGlzLmxvY2FsVVJMKTtcbiAgICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgICAgdXJsOiB0aGlzLmxvY2FsVVJMLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXG4gICAgICAgICAgICAgICAgZGF0YVR5cGU6IFwianNvblwiLFxuICAgICAgICAgICAgICAgIGFzeW5jOiB0cnVlXG4gICAgICAgICAgICB9KS5kb25lKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEZldGNoZWQgJHtkYXRhLmxlbmd0aH0gYW5ub3RhdGlvbnMgZnJvbSBsb2NhbCBjYWNoZS5gKTtcbiAgICAgICAgICAgICAgICB2YXIganNvbiA9IGRhdGE7XG4gICAgICAgICAgICAgICAgaWYgKCd1bmRlZmluZWQnID09IHR5cGVvZihqc29uLml0ZW1zKSkgeyAgLy8gVmVyc2lvbiAxXG4gICAgICAgICAgICAgICAgICAgIC8vanNvbi5zaGlmdCgpICAvLyBBc3N1bWUgZmlyc3Qgbm9kZSBpcyBhIGNvbnRlbnQgbm9kZVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0ganNvbi5sZW5ndGgtMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGpzb25bal0udHlwZSAhPSBcIkFubm90YXRpb25cIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFubm90YXRpb25faW5mbyA9IGpzb25bal07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZW50TGFiZWwgPSBhbm5vdGF0aW9uX2luZm9bXCJkY3Rlcm1zOnRpdGxlXCJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXJ0VVJMID0gYW5ub3RhdGlvbl9pbmZvW1wiYXJ0OnVybFwiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhhbm5vdGF0aW9uX2luZm9bXCJkY3Rlcm1zOnRpdGxlXCJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uLnNwbGljZShqLDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGpzb25bal0udGFyZ2V0LnNlbGVjdG9yLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgnRnJhZ21lbnRTZWxlY3RvcicgIT0ganNvbltqXS50YXJnZXQuc2VsZWN0b3Jba10udHlwZSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb25bal0udGFyZ2V0LnNlbGVjdG9yW2tdLnZhbHVlID0ganNvbltqXS50YXJnZXQuc2VsZWN0b3Jba10udmFsdWUucmVwbGFjZSgnI3Q9bnB0OicsJ3Q9Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgIC8vIFZlcnNpb24gMlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRMYWJlbCA9IGpzb24ubGFiZWwuZW5bMF07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXJ0VVJMID0ganNvbi5pdGVtc1swXS5jb250ZW50LmlkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmFubm90YXRpb25NYW5hZ2VyLlBvcHVsYXRlRnJvbUpTT04oZGF0YSk7XG4gICAgICAgICAgICAgICAgdGhpcy5Bbm5vdGF0aW9uc0xvYWRlZCgpO1xuICAgICAgICAgICAgfSkuZmFpbCgocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgYW5ub3RhdGlvbnMgZnJvbSBsb2NhbCBjYWNoZVwiXFxuJHtyZXNwb25zZS5yZXNwb25zZUpTT04uZGV0YWlsfS5gKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFubm90YXRvci5tZXNzYWdlT3ZlcmxheS5TaG93RXJyb3IoYENvdWxkIG5vdCByZXRyaWV2ZSBhbm5vdGF0aW9ucyE8YnI+KCR7cmVzcG9uc2UucmVzcG9uc2VKU09OLmRldGFpbH0pYCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucGxheWVyLiRjb250YWluZXIub24oXCJPblRpbWVVcGRhdGVcIiwgKGV2ZW50LCB0aW1lKSA9PiB7XG4gICAgICAgICAgICB0aGlzLk9uVGltZVVwZGF0ZSh0aW1lKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy4kY29udGFpbmVyLm9uKFwiT25Qb2x5Q2xpY2tlZFwiLCAoZXZlbnQsIGFubm90YXRpb24pID0+IHtcbiAgICAgICAgICAgIC8vIEVkaXQgYSBwb2x5IHdoZW4gY2xpY2tlZCwgYnV0IG9ubHkgaWYgdGhlIGVkaXRvciBpc24ndCBhbHJlYWR5IG9wZW5cbiAgICAgICAgICAgIGlmKCF0aGlzLmd1aS5vcGVuKXtcbiAgICAgICAgICAgICAgICB0aGlzLiRhZGRBbm5vdGF0aW9uQnV0dG9uLmJ1dHRvbihcImRpc2FibGVcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5ndWkuQmVnaW5FZGl0aW5nKGFubm90YXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLiRjb250YWluZXIub24oXCJPblBvbHlnb25DbGlja2VkXCIsIChldmVudCwgYW5ub3RhdGlvbikgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJPblBvbHlnb25DbGlja2VkIGV2ZW50IGNhcHR1cmVkXCIpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLiRjb250YWluZXIub24oXCJPbkFuaW1hdGlvbkNsaWNrZWRcIiwgKGV2ZW50LCBhbm5vdGF0aW9uKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIk9uQW5pbWF0aW9uQ2xpY2tlZCBldmVudCBjYXB0dXJlZFwiKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5ndWkuJGNvbnRhaW5lci5vbihcIk9uR1VJQ2xvc2VkXCIsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy4kYWRkQW5ub3RhdGlvbkJ1dHRvbi5idXR0b24oXCJlbmFibGVcIik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMudXJsID0gdGhpcy5wbGF5ZXIudmlkZW9FbGVtZW50LmN1cnJlbnRTcmM7XG5cbiAgICAgICAgY29uc29sZS5sb2coXCJbVmlkZW9Bbm5vdGF0b3JdIEFubm90YXRvciBjcmVhdGVkIGZvciB2aWRlby5cIik7XG4gICAgfVxuXG5cbiAgICByZWFkQ29uZmlnKCkge1xuICAgICAgICBjb25zdCBjb25maWcgPSByZXF1aXJlKFwiLi4vYW5ub3RhdG9yLWNvbmZpZy5qc29uXCIpOyBcbiAgICAgICAgdGhpcy5hcGlLZXkgPSBjb25maWcuYXBpX2tleTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgZGl2cyB0aGF0IHN1cnJvdW5kIHRoZSB2aWRlbyBwbGF5ZXIuXG4gICAgICovXG4gICAgV3JhcCgpe1xuICAgICAgICAvLyBXcmFwIHRoZSB2aWRlbyBwbGF5ZXIgd2l0aCB0aGlzIGNvbnRhaW5lci4gQ2FuJ3QgdXNlIC53cmFwIGR1ZSB0byBkdXBsaWNhdGlvbiBpc3N1ZXMgICAgXG4gICAgICAgIHZhciB2aWRlb0NvbnRhaW5lciA9ICQodGhpcy5wbGF5ZXIuJGNvbnRhaW5lcikucGFyZW50KCk7XG4gICAgICAgIHZhciB3YWxkb3JmQ29udGFpbmVyID0gJChcIjxkaXYgY2xhc3M9J3dhbGRvcmYtY29udGFpbmVyJz48L2Rpdj5cIik7XG4gICAgICAgIHdhbGRvcmZDb250YWluZXIuaW5zZXJ0QmVmb3JlKCQodGhpcy5wbGF5ZXIuJGNvbnRhaW5lcikpO1xuICAgICAgICB3YWxkb3JmQ29udGFpbmVyLmFwcGVuZCh0aGlzLnBsYXllci4kY29udGFpbmVyKTtcbiAgICAgICAgdGhpcy4kY29udGFpbmVyID0gdmlkZW9Db250YWluZXIucGFyZW50KCk7XG5cbiAgICAgICAgLy8gU2V0IHRoZSBjb250YWluZXIgdG8gdGhlIHdpZHRoIG9mIHRoZSB2aWRlbyBwbGF5ZXJcbiAgICAgICAgdGhpcy4kY29udGFpbmVyLndpZHRoKHRoaXMucGxheWVyLiRjb250YWluZXIud2lkdGgoKSk7XG5cbiAgICAgICAgLy8gQWxsb3cgdGhlIHZpZGVvIHBsYXllciBjb250YWluZXIgdG8gZ3Jvd1xuICAgICAgICAvL3RoaXMucGxheWVyLiRjb250YWluZXIud2lkdGgoXCIxMDAlXCIpO1xuICAgICAgICAvL3RoaXMucGxheWVyLiRjb250YWluZXIuaGVpZ2h0KFwiMTAwJVwiKTtcblxuICAgICAgICAvLyBDb3B5IHRoZSB2aWRlbyBzdHlsZXMgdG8gdGhlIGNvbnRhaW5lclxuICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLnBsYXllci5vcmlnaW5hbFN0eWxlcyk7XG4gICAgICAgIHRoaXMuJGNvbnRhaW5lci5jc3ModGhpcy5wbGF5ZXIub3JpZ2luYWxTdHlsZXMpO1xuICAgIH1cblxuICAgIFBvcHVsYXRlQ29udHJvbHMoKXtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSB0aWNrIGJhclxuICAgICAgICB0aGlzLnRpY2tCYXIgPSBuZXcgVGlja0Jhcih0aGlzKTtcblxuICAgICAgICAvLyBDcmVhdGUgdGhlIHBvbHlnb24gb3ZlcmxheVxuICAgICAgICB0aGlzLnBvbHlPdmVybGF5ID0gbmV3IFBvbHlnb25PdmVybGF5KHRoaXMpO1xuXG4gICAgICAgIGlmKCF0aGlzLmtpb3NrTW9kZSAmJiB0aGlzLnNob3dNYW5pZmVzdCl7XG4gICAgICAgICAgICB0aGlzLiRkZWJ1Z0NvbnRyb2xzID0gJChcIjxkaXYgY2xhc3M9J3dhbGRvcmYtZGVidWctY29udHJvbHMnPjwvZGl2PlwiKS5hcHBlbmRUbyh0aGlzLiRjb250YWluZXIpO1xuICAgICAgICAgICAgdmFyICRzaG93QWxsQW5ub3RhdGlvbnNCdXR0b24gPSB0aGlzLiRkZWJ1Z0NvbnRyb2xzLmFwcGVuZCgnPGJ1dHRvbj5PcGVuIEFubm90YXRpb24gTWFuaWZlc3QgaW4gTmV3IFdpbmRvdzwvYnV0dG9uPicpO1xuICAgICAgICAgICAgJHNob3dBbGxBbm5vdGF0aW9uc0J1dHRvbi5jbGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHVybCA9IHRoaXMucGxheWVyLnZpZGVvRWxlbWVudC5jdXJyZW50U3JjO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VydmVyLkZldGNoQW5ub3RhdGlvbnMoXCJsb2NhdGlvblwiLCB1cmwpLmRvbmUoKGpzb24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHdpbiA9IHdpbmRvdy5vcGVuKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmKHdpbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkNvdWxkbid0IHNob3cgYW5ub3RhdGlvbiBtYW5pZmVzdDsgcGxlYXNlIGFsbG93IHBvcC11cHMuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlT3ZlcmxheS5TaG93RXJyb3IoXCJDb3VsZG4ndCBzaG93IGFubm90YXRpb24gbWFuaWZlc3Q7IHBsZWFzZSBhbGxvdyBwb3AtdXBzLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbi5kb2N1bWVudC5vcGVuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW4uZG9jdW1lbnQud3JpdGUoYDx0aXRsZT5Bbm5vdGF0aW9uIE1hbmlmZXN0IGZvciAke3VybH08L3RpdGxlPmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luLmRvY3VtZW50LndyaXRlKFwiPHByZT5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW4uZG9jdW1lbnQud3JpdGUoSlNPTi5zdHJpbmdpZnkoanNvbiwgbnVsbCwgMikuZXNjYXBlSFRNTCgpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgd2luLmRvY3VtZW50LndyaXRlKFwiPC9wcmU+XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luLmRvY3VtZW50LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV3JhcCBhbGwgdGhlIGJ1dHRvbnMgd2l0aCB0aGUgbGlzdCB0YWdcbiAgICAgICAgLy90aGlzLiRkZWJ1Z0NvbnRyb2xzLndyYXBJbm5lcihcIjx1bD48L3VsPlwiKTtcbiAgICAgICAgLy8gV3JhcCBlYWNoIGJ1dHRvbiB3aXRoIHRoZSBsaXN0IGVsZW1lbnQgdGFnXG4gICAgICAgIC8vdGhpcy4kZGVidWdDb250cm9scy5maW5kKFwiYnV0dG9uXCIpLndyYXAoXCI8bGk+PC9saT5cIik7XG5cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBpbmZvIGNvbnRhaW5lclxuICAgICAgICB0aGlzLmluZm9Db250YWluZXIgPSBuZXcgSW5mb0NvbnRhaW5lcih0aGlzKTtcblxuICAgICAgICBpZih0aGlzLmRpc3BsYXlJbmRleCkgdGhpcy5pbmRleENvbnRhaW5lciA9IG5ldyBJbmRleENvbnRhaW5lcih0aGlzKTtcblxuICAgICAgICAvLyBJbmplY3QgdGhlIGFubm90YXRpb24gZWRpdCBidXR0b24gaW50byB0aGUgdG9vbGJhclxuICAgICAgICBpZighdGhpcy5raW9za01vZGUpe1xuICAgICAgICAgICAgdGhpcy4kYWRkQW5ub3RhdGlvbkJ1dHRvbiA9ICQoXCI8YnV0dG9uPkFkZCBOZXcgQW5ub3RhdGlvbjwvYnV0dG9uPlwiKS5idXR0b24oe1xuICAgICAgICAgICAgICAgIGljb246IFwiZmEgZmEtcGx1c1wiLFxuICAgICAgICAgICAgICAgIHNob3dMYWJlbDogZmFsc2VcbiAgICAgICAgICAgIH0pLmNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiRhZGRBbm5vdGF0aW9uQnV0dG9uLmJ1dHRvbihcImRpc2FibGVcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5ndWkuQmVnaW5FZGl0aW5nKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucGxheWVyLmNvbnRyb2xCYXIuUmVnaXN0ZXJFbGVtZW50KHRoaXMuJGFkZEFubm90YXRpb25CdXR0b24sIDMsICdmbGV4LWVuZCcpO1xuXG4gICAgICAgICAgICAvLyBJbmplY3QgdGhlIGFubm90YXRpb24gdXBsb2FkIGJ1dHRvbiBpbnRvIHRoZSB0b29sYmFyXG4gICAgICAgICAgICB0aGlzLiR1cGxvYWRBbm5vdGF0aW9uQnV0dG9uID0gJChcIjxidXR0b24gdHlwZT0nZmlsZSc+SW1wb3J0IEFubm90YXRpb24gRnJvbSBGaWxlPC9idXR0b24+XCIpLmJ1dHRvbih7XG4gICAgICAgICAgICAgICAgaWNvbjogXCJmYSBmYS11cGxvYWRcIixcbiAgICAgICAgICAgICAgICBzaG93TGFiZWw6IGZhbHNlXG4gICAgICAgICAgICB9KS5jbGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5Mb2FkRnJvbUZpbGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5wbGF5ZXIuY29udHJvbEJhci5SZWdpc3RlckVsZW1lbnQodGhpcy4kdXBsb2FkQW5ub3RhdGlvbkJ1dHRvbiwgMiwgJ2ZsZXgtZW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ndWkgPSBuZXcgQW5ub3RhdGlvbkdVSSh0aGlzKTtcblxuICAgIH1cblxuICAgIEFubm90YXRpb25zTG9hZGVkKCl7XG4gICAgICAgIC8vU2VuZCBhbm5vdGF0aW9uIGxvYWRlZCBldmVudFxuICAgICAgICB0aGlzLiRjb250YWluZXIudHJpZ2dlcihcIk9uQW5ub3RhdGlvbnNMb2FkZWRcIiwgdGhpcy5hbm5vdGF0aW9uTWFuYWdlcik7XG4gICAgfVxuXG4gICAgT25UaW1lVXBkYXRlKHRpbWUpe1xuICAgICAgICB0aGlzLmFubm90YXRpb25zTm93ID0gdGhpcy5hbm5vdGF0aW9uTWFuYWdlci5Bbm5vdGF0aW9uc0F0VGltZSh0aW1lKTtcblxuICAgICAgICBpZih0aGlzLmFubm90YXRpb25zTm93LmVxdWFscyh0aGlzLmxhc3RBbm5vdGF0aW9uU2V0KSl7ICBcbiAgICAgICAgICAgIHRoaXMuU2V0QW5ub3RhdGlvblRpbWVQb3NpdGlvbih0aW1lKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBcbiAgICAgICAgdGhpcy5sYXN0QW5ub3RhdGlvblNldCA9IHRoaXMuYW5ub3RhdGlvbnNOb3c7XG5cbiAgICAgICAgdGhpcy5VcGRhdGVWaWV3cygpO1xuICAgIH1cblxuICAgIFNldEFubm90YXRpb25UaW1lUG9zaXRpb24odGltZSl7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJ0aW1lOiBcIiArIHRpbWUpO1xuICAgICAgICAvL0NoZWNrIHNhZmFyaSBhbmQgbXVsdGlwbGUgZ2VvbWV0cmljIGFubm90YXRpb25cbiAgICAgICAgaWYgKHRoaXMuSXNTYWZhcmkoKSAmJiB0aGlzLmFubm90YXRpb25zTm93Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxldCBtc2cgPSBcIk11bHRpcGxlIGdlb21ldHJpYyBhbm5vdGF0aW9ucyBhcmUgZGV0ZWN0ZWQuPGJyPlwiO1xuICAgICAgICAgICAgbXNnICs9IFwiU2FmYXJpIGRvZXNuJ3Qgc3VwcG9ydCBtdWx0aXBsZSBnZW9tZXRyaWMgYW5ub3RhdGlvbnMuPGJyPlwiO1xuICAgICAgICAgICAgbXNnICs9IFwiQ2hyb21lIG9yIEZpcmVmb3ggYXJlIHJlY29tbWVuZGVkLlwiO1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlT3ZlcmxheS5TaG93TWVzc2FnZShtc2csIDIuMCk7XG4gICAgICAgICAgICByZXR1cm47IC8vbm8gYW5pbWF0aW9uIGZvciBzYWZhcmkgYnJvd3NlciB3aXRoIG11bHRpcGxlIGdlb21ldHJpYyBhbm5vdGF0aW9uXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYW5ub3RhdGlvbnNOb3cubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICBsZXQgYW5ub3RhdGlvbl9pZCA9IHRoaXMuYW5ub3RhdGlvbnNOb3dbaV0uaWQ7XG4gICAgICAgICAgICBpZiAodGhpcy5wb2x5T3ZlcmxheS5zdmdFbGVtZW50c0hhc2hbYW5ub3RhdGlvbl9pZF0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvbHlPdmVybGF5LnN2Z0VsZW1lbnRzSGFzaFthbm5vdGF0aW9uX2lkXS5hbmltYXRlLmJlZ2luRWxlbWVudCgpO1xuICAgICAgICAgICAgICAgIGxldCB0aW1lX2RpZmYgPSB0aW1lIC0gdGhpcy5hbm5vdGF0aW9uc05vd1tpXS5iZWdpblRpbWU7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRfdGltZSA9IHRoaXMucG9seU92ZXJsYXkuc3ZnRWxlbWVudHNIYXNoW2Fubm90YXRpb25faWRdLnN2Z0VsZW1lbnQuZ2V0Q3VycmVudFRpbWUoKTtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiXFx0IGk6XCIgKyBpICsgXCIgKFwiICsgYW5ub3RhdGlvbl9pZCArIFwiKSwgc3ZnIGN1cnJlbnRfdGltZTpcIiArIGN1cnJlbnRfdGltZSArIFwiLCBhbmltYXRlIHRpbWVfZGlmZjogXCIgKyB0aW1lX2RpZmYpO1xuICAgICAgICAgICAgICAgIHRoaXMucG9seU92ZXJsYXkuc3ZnRWxlbWVudHNIYXNoW2Fubm90YXRpb25faWRdLnN2Z0VsZW1lbnQuc2V0Q3VycmVudFRpbWUoY3VycmVudF90aW1lICsgdGltZV9kaWZmKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvbHlPdmVybGF5LnN2Z0VsZW1lbnRzSGFzaFthbm5vdGF0aW9uX2lkXS5hbmltYXRlLmVuZEVsZW1lbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICB9XG5cbiAgICBVcGRhdGVWaWV3cygpe1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiYW5ub3RhdG9yLmpzOjI2NyBVcGRhdGVWaWV3c1wiKTtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uc05vdyA9IHRoaXMuYW5ub3RhdGlvbk1hbmFnZXIuQW5ub3RhdGlvbnNBdFRpbWUodGhpcy5wbGF5ZXIudmlkZW9FbGVtZW50LmN1cnJlbnRUaW1lKTtcblxuICAgICAgICAvLyBVcGRhdGUgdGhlIGluZm8gY29udGFpbmVyXG4gICAgICAgIHRoaXMuaW5mb0NvbnRhaW5lci5SZWJ1aWxkKHRoaXMuYW5ub3RhdGlvbnNOb3csIHRoaXMuY2xlYXJDb250YWluZXIpO1xuXG4gICAgICAgIHRoaXMuJGNvbnRhaW5lci50cmlnZ2VyKFwiT25OZXdBbm5vdGF0aW9uU2V0XCIsIFt0aGlzLmFubm90YXRpb25zTm93XSk7XG4gICAgICAgIHRoaXMuU2V0QW5ub3RhdGlvblRpbWVQb3NpdGlvbih0aGlzLnBsYXllci52aWRlb0VsZW1lbnQuY3VycmVudFRpbWUpO1xuICAgIH1cblxuICAgIEdldEFubm90YXRpb25zKCl7XG4gICAgICAgIGxldCBvcmRlcmVkID0gdGhpcy5hbm5vdGF0aW9uTWFuYWdlci5hbm5vdGF0aW9ucy5zbGljZSgpO1xuICAgICAgICBsZXQgb3JkZXJCeVN0YXJ0ID0gZnVuY3Rpb24oYSwgYil7XG4gICAgICAgICAgICBsZXQgYVRpbWUgPSBhLmJlZ2luVGltZTtcbiAgICAgICAgICAgIGxldCBiVGltZSA9IGIuYmVnaW5UaW1lO1xuICAgICAgICAgICAgcmV0dXJuICgoYVRpbWUgPCBiVGltZSkgPyAtMSA6ICgoYVRpbWUgPiBiVGltZSkgPyAxIDogMCkpO1xuICAgICAgICB9XG4gICAgICAgIG9yZGVyZWQuc29ydChvcmRlckJ5U3RhcnQpO1xuICAgICAgICByZXR1cm4gb3JkZXJlZDtcbiAgICB9XG5cbiAgICBSZWdpc3Rlck5ld0Fubm90YXRpb24oYW5ub3RhdGlvbil7XG4gICAgICAgIC8vY29uc29sZS5sb2coYW5ub3RhdGlvbik7XG4gICAgICAgIC8vdGhpcy5hbm5vdGF0aW9uTWFuYWdlci5SZWdpc3RlckFubm90YXRpb24oYW5ub3RhdGlvbik7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbk1hbmFnZXIuUG9wdWxhdGVGcm9tSlNPTihhbm5vdGF0aW9uKTtcblxuICAgICAgICAvLyBUaHJvdyBldmVudCBmb3IgbGlzdGVuaW5nIG9iamVjdHMgKGUuZy4gdGljay1iYXIpXG4gICAgICAgIHRoaXMuJGNvbnRhaW5lci50cmlnZ2VyKFwiT25Bbm5vdGF0aW9uUmVnaXN0ZXJlZFwiLCBbYW5ub3RhdGlvbl0pO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBkZXBlbmRlbnQgdmlld3NcbiAgICAgICAgdGhpcy5VcGRhdGVWaWV3cygpO1xuICAgIH1cblxuICAgIFVwZGF0ZUFubm90YXRpb24oYW5ub3RhdGlvbiwgb2xkSUQpe1xuICAgICAgICB0aGlzLmFubm90YXRpb25NYW5hZ2VyLlVwZGF0ZUFubm90YXRpb24oYW5ub3RhdGlvbiwgb2xkSUQpO1xuXG4gICAgICAgIC8vIFRocm93IGV2ZW50IGZvciBsaXN0ZW5pbmcgb2JqZWN0cyAoZS5nLiB0aWNrLWJhcilcbiAgICAgICAgdGhpcy4kY29udGFpbmVyLnRyaWdnZXIoXCJPbkFubm90YXRpb25SZW1vdmVkXCIsIFtvbGRJRF0pO1xuICAgICAgICB0aGlzLiRjb250YWluZXIudHJpZ2dlcihcIk9uQW5ub3RhdGlvblJlZ2lzdGVyZWRcIiwgW2Fubm90YXRpb25dKTtcblxuICAgICAgICAvLyBVcGRhdGUgZGVwZW5kZW50IHZpZXdzXG4gICAgICAgIHRoaXMuVXBkYXRlVmlld3MoKTtcbiAgICB9XG5cbiAgICBEZXJlZ2lzdGVyQW5ub3RhdGlvbihhbm5vdGF0aW9uKXtcbiAgICAgICAgdmFyIGlkID0gJyc7XG4gICAgICAgIGlmICgndW5kZWZpbmVkJyA9PSB0eXBlb2YoYW5ub3RhdGlvbi5pdGVtcykpIHsgLy8gVmVyIDFcbiAgICAgICAgICAgIGlkID0gYW5ub3RhdGlvbi5pZDtcbiAgICAgICAgfSBlbHNlIHsgLy8gVmVyIDJcbiAgICAgICAgICAgIGlkID0gYW5ub3RhdGlvbi5pdGVtc1swXS5pdGVtc1swXS5pdGVtc1swXS5pZDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uTWFuYWdlci5SZW1vdmVBbm5vdGF0aW9uKGlkKTtcbiAgICAgICAgLy90aGlzLmFubm90YXRpb25zTm93ID0gdGhpcy5hbm5vdGF0aW9uTWFuYWdlci5Bbm5vdGF0aW9uc0F0VGltZSh0aGlzLnBsYXllci52aWRlb0VsZW1lbnQuY3VycmVudFRpbWUpO1xuXG4gICAgICAgIC8vIFRocm93IGV2ZW50IGZvciBsaXN0ZW5pbmcgb2JqZWN0cyAoZS5nLiB0aWNrLWJhcilcbiAgICAgICAgdGhpcy4kY29udGFpbmVyLnRyaWdnZXIoXCJPbkFubm90YXRpb25SZW1vdmVkXCIsIFtpZF0pO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBkZXBlbmRlbnQgdmlld3NcbiAgICAgICAgdGhpcy5VcGRhdGVWaWV3cygpO1xuXG4gICAgfVxuXG4gICAgTG9hZEZyb21GaWxlKCkge1xuICAgICAgICAvLyBDcmVhdGUgdGhlIGRpYWxvZ1xuICAgICAgICBsZXQgJGNvbnRhaW5lciA9ICQoXCI8ZGl2IGNsYXNzPSd3YWxkb3JmLXNlc3Npb24tbW9kYWwnIHRpdGxlPSdJbXBvcnQgQW5ub3RhdGlvbic+PC9kaXY+XCIpOyAvLyBPdXRlcm1vc3QgSFRNTFxuICAgICAgICBsZXQgJGhlYWRUZXh0ID0gJChcIjxwIGNsYXNzPSd2YWxpZGF0ZVRpcHMnPkFubm90YXRpb25zIG11c3QgYmUgVzNDIE9BIGNvbXBsaWFudCBpbiBKU09OIGZvcm1hdC48L3A+XCIpLmFwcGVuZFRvKCRjb250YWluZXIpO1xuICAgICAgICBsZXQgJGVycm9yVGV4dCA9ICQoXCI8cCBjbGFzcz0ndmFsaWRhdGVUaXBzIG1vZGFsLWVycm9yLXRleHQnPjwvcD5cIikuYXBwZW5kVG8oJGNvbnRhaW5lcik7XG4gICAgICAgICRlcnJvclRleHQuaGlkZSgpO1xuICAgICAgICBsZXQgJGZvcm0gPSAkKFwiPGZvcm0+PC9mb3JtPlwiKS5hcHBlbmRUbygkY29udGFpbmVyKTtcblxuICAgICAgICBsZXQgJGltcG9ydEZpZWxkO1xuXG4gICAgICAgICQoXCI8bGFiZWwgZm9yPSdpbXBvcnRGaWxlJz5TZWxlY3QgRmlsZTwvbGFiZWw+XCIpLmFwcGVuZFRvKCRmb3JtKTtcbiAgICAgICAgJGltcG9ydEZpZWxkID0gJChcIjxpbnB1dCB0eXBlPSdmaWxlJyBuYW1lPSdpbXBvcnRGaWxlJyBjbGFzcz0nZmlsZSB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYWxsJz5cIikuYXBwZW5kVG8oJGZvcm0pO1xuICAgICAgICBcbiAgICAgICAgJGZvcm0ud3JhcElubmVyKFwiPGZpZWxkc2V0IC8+XCIpO1xuXG4gICAgICAgIGxldCBlcnJvciA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgJGVycm9yVGV4dC5odG1sKG1lc3NhZ2UpO1xuICAgICAgICAgICAgJGVycm9yVGV4dC5zaG93KCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgICAgICRpbXBvcnRGaWVsZC5vbignY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgbGV0IGZpbGVzID0gJGltcG9ydEZpZWxkLmdldCgwKS5maWxlcztcbiAgICAgICAgICAgIGxldCBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cbiAgICAgICAgICAgIGZyLm9ubG9hZCA9ICgobG9jYWxGaWxlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIEpTT04gaXMgbWFsZm9ybWVkLCBzaG93IGFuIGVycm9yIGFuZCBzdG9wIGhlcmUuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgSlNPTi5wYXJzZShsb2NhbEZpbGUudGFyZ2V0LnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcihcIkpTT04gZmlsZSBpcyBtYWxmb3JtZWQhXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IGxvY2FsSnNvbiA9IEpTT04ucGFyc2UobG9jYWxGaWxlLnRhcmdldC5yZXN1bHQpO1xuICAgICAgICAgICAgICAgIGlmKHR5cGVvZihsb2NhbEpzb24udGFyZ2V0KSE9XCJ1bmRlZmluZWRcIil7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhbm5vdGF0aW9uID0gbmV3IEFubm90YXRpb24obG9jYWxKc29uKTtcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5WYWxpZGF0ZUFubm90YXRpb24oYW5ub3RhdGlvbikpe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3BlbiB0aGUgR1VJIGFuZCBwb3B1bGF0ZSBpdCB3aXRoIHRoaXMgYW5ub3RhdGlvbidzIGRhdGEuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmd1aS5CZWdpbkVkaXRpbmcoYW5ub3RhdGlvbiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmd1aS5Db21taXRBbm5vdGF0aW9uVG9TZXJ2ZXIoZnVuY3Rpb24oKXtyZXR1cm47fSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcihcIkpTT04gaXMgaW52YWxpZCFcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGk9MDsgaTxsb2NhbEpzb24ubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGFubm90YXRpb24gPSBuZXcgQW5ub3RhdGlvbihsb2NhbEpzb25baV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5WYWxpZGF0ZUFubm90YXRpb24oYW5ub3RhdGlvbikpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZW4gdGhlIEdVSSBhbmQgcG9wdWxhdGUgaXQgd2l0aCB0aGlzIGFubm90YXRpb24ncyBkYXRhLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ3VpLkJlZ2luRWRpdGluZyhhbm5vdGF0aW9uLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmd1aS5Db21taXRBbm5vdGF0aW9uVG9TZXJ2ZXIoKGFubm90YXRpb24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5SZWdpc3Rlck5ld0Fubm90YXRpb24oYW5ub3RhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ3VpLkNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcihcIkpTT04gaXMgaW52YWxpZCFcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJGRpYWxvZy5kaWFsb2coXCJjbG9zZVwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZnIucmVhZEFzVGV4dChmaWxlc1swXSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxldCAkZGlhbG9nID0gJGNvbnRhaW5lci5kaWFsb2coe1xuICAgICAgICAgICAgYXV0b09wZW46IHRydWUsXG4gICAgICAgICAgICBkcmFnZ2FibGU6IGZhbHNlLFxuICAgICAgICAgICAgbW9kYWw6IHRydWUsXG4gICAgICAgICAgICBidXR0b25zOiB7XG4gICAgICAgICAgICAgICAgQ2FuY2VsOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICRkaWFsb2cuZGlhbG9nKFwiY2xvc2VcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgJGRpYWxvZy5maW5kKFwiZm9ybVwiKVsgMCBdLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgJGRpYWxvZy5maW5kKFwiaW5wdXRcIikucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtZXJyb3JcIiApO1xuICAgICAgICAgICAgICAgIC8vdGhpcy5Pbk1vZGFsQ2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgVmFsaWRhdGVBbm5vdGF0aW9uKGFubm90YXRpb24pIHtcbiAgICAgICAgLy8gVE9ETzogVmFsaWRhdGUgYW5ub3RhdGlvbiBoZXJlLiBSZXR1cm4gZmFsc2UgaWYgYW55XG4gICAgICAgIC8vIHJlcXVpcmVkIHByb3BlcnRpZXMgYXJlIG5vdCBwcmVzZW50LlxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGNoZWNraW5nIHdoZXRoZXIgdGhlIGJyb3dzZXIgaXMgc2FmYXJpIG9yIG5vdFxuICAgIElzU2FmYXJpKCkge1xuICAgICAgICAvL3JlZjogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDk4NzIxMTEvZGV0ZWN0LXNhZmFyaS1hbmQtc3RvcC1zY3JpcHRcbiAgICAgICAgbGV0IGlzU2FmYXJpID0gL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAgICAgcmV0dXJuIGlzU2FmYXJpO1xuICAgIH1cblxuXG59XG5cbmV4cG9ydCB7IFZpZGVvQW5ub3RhdG9yIH07IiwiaW1wb3J0IHsgR2V0Rm9ybWF0dGVkVGltZSwgR2V0U2Vjb25kc0Zyb21ITVMgfSBmcm9tIFwiLi4vLi4vdXRpbHMvdGltZS5qc1wiO1xuaW1wb3J0IHsgUG9seWdvbkVkaXRvciB9IGZyb20gXCIuL3BvbHlnb24tZWRpdG9yLmpzXCI7XG5pbXBvcnQgeyBBbm5vdGF0aW9uIH0gZnJvbSBcIi4uL2Fubm90YXRpb24uanNcIjtcbmltcG9ydCB7IHRzVGhpc1R5cGUgfSBmcm9tIFwiQGJhYmVsL3R5cGVzXCI7XG5cbmNsYXNzIEFubm90YXRpb25HVUkge1xuXG4gICAgY29uc3RydWN0b3IoYW5ub3RhdG9yKXtcbiAgICAgICAgdGhpcy5hbm5vdGF0b3IgPSBhbm5vdGF0b3I7XG5cbiAgICAgICAgdGhpcy5DcmVhdGUoKTtcblxuICAgICAgICB0aGlzLm9wZW4gPSBmYWxzZTtcblxuICAgICAgICAvL0hpZGUgdGhlIGNvbnRhaW5lclxuICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLiRjb250YWluZXIubWFrZVZpc2libGUoZmFsc2UpO1xuXG4gICAgICAgIHRoaXMucG9seUVkaXRvciA9IG5ldyBQb2x5Z29uRWRpdG9yKHRoaXMuYW5ub3RhdG9yKTtcblxuICAgICAgICB0aGlzLmFubm90YXRvci4kY29udGFpbmVyLm9uKFwiT25Qb2x5Z29uRWRpdGluZ0VuZGVkXCIsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuU2V0VmlzaWJsZSh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMucG9seUVkaXRvci5TaG93SnVzdFBvbHlnb24oKTtcbiAgICAgICAgfSk7XG5cbiAgICB9XG5cbiAgICBDcmVhdGUoKXtcbiAgICAgICAgLypcbiAgICAgICAgICogLy9uZXcgVUlcbiAgICAgICAgICogXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLiRjb250YWluZXIgPSAkKFwiPGRpdiBpZD0nY3JlYXRlLWRpYWxvZycgY2xhc3M9J3VpLXdpZGdldC1jb250ZW50IGNlbnRlcic+XCIpLmFwcGVuZFRvKHRoaXMuYW5ub3RhdG9yLnBsYXllci4kY29udGFpbmVyKTtcbiAgICAgICAgdGhpcy4kY29udGFpbmVyLmRyYWdnYWJsZSgpO1xuICAgICAgICB0aGlzLiR0aXRsZSA9ICQoXCI8ZGl2IGNsYXNzPSdkaWFsb2ctdGl0bGUnPkNyZWF0ZSBBbm5vdGF0aW9uPC9kaXY+XCIpLmFwcGVuZFRvKHRoaXMuJGNvbnRhaW5lcik7XG5cbiAgICAgICAgLy8gTWFrZSBjYW5jZWwgYnV0dG9uXG4gICAgICAgIGxldCAkZXhpdEJ1dHRvbiA9ICQoXCI8YnV0dG9uPkV4aXQgQW5ub3RhdGlvbiBFZGl0aW5nPC9idXR0b24+XCIpLmJ1dHRvbih7XG4gICAgICAgICAgICBpY29uczoge3ByaW1hcnk6ICdmYSBmYS1yZW1vdmUnfSxcbiAgICAgICAgICAgIHNob3dMYWJlbDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgICRleGl0QnV0dG9uLmNzcyhcImZsb2F0XCIsIFwicmlnaHRcIik7XG4gICAgICAgICRleGl0QnV0dG9uLmF0dHIoJ3RpdGxlJywgXCJFeGl0IGFubm90YXRpb24gZWRpdGluZ1wiKTtcbiAgICAgICAgJGV4aXRCdXR0b24uYWRkQ2xhc3MoXCJ3YWxkb3JmLWNhbmNlbC1idXR0b25cIik7XG4gICAgICAgICRleGl0QnV0dG9uLmNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucG9seUVkaXRvci5SZXNldFBvbHlnb25zKCk7XG4gICAgICAgICAgICB0aGlzLkNsb3NlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLlJlZ2lzdGVyRWxlbWVudCgkZXhpdEJ1dHRvbiwgdGhpcy4kdGl0bGUsIC0xKTtcblxuICAgICAgICB0aGlzLiR0YWJzID0gJChcIjxkaXYgaWQ9J3RhYnMnPjwvZGl2PlwiKS5hcHBlbmRUbyh0aGlzLiRjb250YWluZXIpO1xuICAgIFxuICAgICAgICBcbiAgICAgICAgbGV0ICR0YWJVSSA9ICQoXCI8dWw+PC91bD5cIik7XG4gICAgICAgIGxldCAkc3RhcnRVSSA9ICQoXCI8bGk+PGEgaHJlZj0nI3N0YXJ0X3RhYic+U3RhcnQgPC9hPjwvbGk+XCIpO1xuICAgICAgICBsZXQgJGJvZHlVSSA9ICQoXCI8bGk+PGEgaHJlZj0nI2JvZHlfdGFiJz5Cb2R5IDwvYT48L2xpPlwiKTtcbiAgICAgICAgbGV0ICRzdG9wVUkgPSAkKFwiPGxpPjxhIGhyZWY9JyNzdG9wX3RhYic+U3RvcCA8L2E+PC9saT5cIik7XG4gICAgICAgIHRoaXMuUmVnaXN0ZXJFbGVtZW50KCR0YWJVSSwgdGhpcy4kdGFicywgLTEpO1xuICAgICAgICB0aGlzLlJlZ2lzdGVyRWxlbWVudCgkc3RhcnRVSSwgJHRhYlVJLCAtMSk7XG4gICAgICAgIHRoaXMuUmVnaXN0ZXJFbGVtZW50KCRib2R5VUksICR0YWJVSSwgLTEpO1xuICAgICAgICB0aGlzLlJlZ2lzdGVyRWxlbWVudCgkc3RvcFVJLCAkdGFiVUksIC0xKTtcblxuICAgICAgICAvL0NyZWF0ZSB0YWJzXG4gICAgICAgIGxldCAkc3RhcnRUYWIgPSAkKFwiPGRpdiBpZD0nc3RhcnRfdGFiJyBjbGFzcz0ndWktZmllbGQtY29udGFpbic+PC9kaXY+XCIpO1xuICAgICAgICB0aGlzLlJlZ2lzdGVyRWxlbWVudCgkc3RhcnRUYWIsIHRoaXMuJHRhYnMsIC0xKTtcblxuICAgICAgICBsZXQgJGJvZHlUYWIgPSAkKFwiPGRpdiBpZD0nYm9keV90YWInPjwvZGl2PlwiKTtcbiAgICAgICAgdGhpcy5SZWdpc3RlckVsZW1lbnQoJGJvZHlUYWIsIHRoaXMuJHRhYnMsIC0xKTtcblxuICAgICAgICBsZXQgJHN0b3BUYWIgPSAkKFwiPGRpdiBpZD0nc3RvcF90YWInPjwvZGl2PlwiKTtcbiAgICAgICAgdGhpcy5SZWdpc3RlckVsZW1lbnQoJHN0b3BUYWIsIHRoaXMuJHRhYnMsIC0xKTtcblxuICAgICAgICAvL0JlZ2luIGZpbGxpbmcgc3RhcnQgdGFiXG4gICAgICAgIC8vIE1ha2UgXCJTdGFydCB0aW1lXCIgbGFiZWwgYW5kIGZpZWxkXG4gICAgICAgIHRoaXMuJHRpbWVTdGFydEZpZWxkID0gJCgnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cInRpbWUtc3RhcnRcIiBpZD1cInRpbWUtc3RhcnRcIiB2YWx1ZT1cIlwiPjxicj48YnI+Jyk7XG4gICAgICAgIHRoaXMuJHRpbWVTdGFydEZpZWxkLndpZHRoKDcyKTtcbiAgICAgICAgdGhpcy4kdGltZVN0YXJ0RmllbGQuY3NzKFwiZm9udC1mYW1pbHlcIiwgXCJDb3VyaWVyLCBtb25vc3BhY2VcIik7XG4gICAgICAgIHRoaXMuJHRpbWVTdGFydEZpZWxkLmNzcyhcIm1hcmdpbi1yaWdodFwiLCBcIjJweFwiKTtcbiAgICAgICAgdGhpcy4kdGltZVN0YXJ0RmllbGQuYWRkQ2xhc3MoXCJ1aS13aWRnZXQgdWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWFsbFwiKTtcbiAgICAgICAgdGhpcy4kdGltZVN0YXJ0RmllbGQuYXR0cigndGl0bGUnLCBcIlN0YXJ0IHRpbWUgKGhoOm1tOnNzLnNzKVwiKTtcbiAgICAgICAgdGhpcy4kdGltZVN0YXJ0RmllbGQub24oJ2tleXByZXNzJywgZnVuY3Rpb24oZXZlbnQpe1xuICAgICAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gNDYgfHwgKGV2ZW50LmtleUNvZGUgPj0gNDggJiYgZXZlbnQua2V5Q29kZSA8PSA1OCkpeyAvLzAtOSwgcGVyaW9kLCBhbmQgY29sb25cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy9hZGQgc3RhcnQgbWFya2VyIGJ1dHRvblxuICAgICAgICB0aGlzLiRzdGFydFRpbWVNYXJrZXIgPSAkKFwiPGJ1dHRvbiBzdHlsZT0ncGFkZGluZzowOyBsaW5lLWhlaWdodDoxLjQnPlNldCBTdGFydDwvYnV0dG9uPiBcIikuYnV0dG9uKHtcbiAgICAgICAgICAgIGljb246IFwiZmEgZmEtbWFwLW1hcmtlclwiLFxuICAgICAgICAgICAgc2hvd0xhYmVsOiBmYWxzZVxuICAgICAgICB9KS5jbGljaygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLiR0aW1lU3RhcnRGaWVsZFswXS52YWx1ZSA9IEdldEZvcm1hdHRlZFRpbWUodGhpcy5hbm5vdGF0b3IucGxheWVyLnZpZGVvRWxlbWVudC5jdXJyZW50VGltZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLlJlZ2lzdGVyRWxlbWVudCh0aGlzLiRzdGFydFRpbWVNYXJrZXIsICRzdGFydFRhYiwgLTIpOyAgIFxuXG4gICAgICAgICQoXCI8bGFiZWwgZm9yPSd0aW1lLXN0YXJ0Jz5TdGFydCBUaW1lOiA8L2xhYmVsPiBcIikuYXBwZW5kVG8oJHN0YXJ0VGFiKTtcbiAgICAgICAgdGhpcy4kdGltZVN0YXJ0RmllbGQuYXBwZW5kVG8oJHN0YXJ0VGFiKTtcblxuICAgICAgICAvL01ha2UgXCJFZGl0IHBvbHlnb25cIiBidXR0b25cbiAgICAgICAgbGV0ICRlZGl0UG9seUJ1dHRvbiA9ICQoXCI8YnV0dG9uIHN0eWxlPSdwYWRkaW5nOjA7IGxpbmUtaGVpZ2h0OjEuNCc+RWRpdCBQb2x5Z29uPC9idXR0b24+XCIpLmJ1dHRvbih7XG4gICAgICAgICAgICBpY29uOiBcImZhIGZhLXBlbmNpbFwiLFxuICAgICAgICAgICAgc2hvd0xhYmVsOiBmYWxzZVxuICAgICAgICB9KS5jbGljaygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLlNldFZpc2libGUoZmFsc2UpO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcImFubm90YXRpb24tZ3VpOjM1MyBDcmVhdGVcIik7XG4gICAgICAgICAgICB0aGlzLnBvbHlFZGl0b3IuQmVnaW5FZGl0aW5nKCdzdGFydCcpO1xuICAgICAgICB9KTtcbiAgICAgICAgJGVkaXRQb2x5QnV0dG9uLmF0dHIoJ3RpdGxlJywgXCJFZGl0IHBvbHlnb25cIik7XG4gICAgICAgIHRoaXMuUmVnaXN0ZXJFbGVtZW50KCRlZGl0UG9seUJ1dHRvbiwgJHN0YXJ0VGFiLCAtMSk7XG5cbiAgICAgICAgbGV0ICRzdGFydFRhcmdldExhYmVsID0gJChcIjxsYWJlbD5TdGFydCBUYXJnZXQ8L2xhYmVsPiBcIik7XG4gICAgICAgICRzdGFydFRhcmdldExhYmVsLmNzcyhcImNvbG9yXCIsIFwid2hpdGVcIik7XG4gICAgICAgIHRoaXMuUmVnaXN0ZXJFbGVtZW50KCRzdGFydFRhcmdldExhYmVsLCAkc3RhcnRUYWIsIC0xKTtcblxuICBcbiAgICAgICAgXG4gICAgICAgIC8vc3RhcnQgcG9pbnQgcG9seWdvbiBpcyBhZGRlZCAoVGhpcyBzZWVtcyB0byBiZSB1bnVzZWQ/IEpQQiAyMDIxLTA5LTE2KVxuICAgICAgICAvLyB0aGlzLiRzdGFydFBvbHlnb25TZXQgPSAkKFwiPGJ1dHRvbiBzdHlsZT0ncGFkZGluZzowOyBsaW5lLWhlaWdodDoxLjQnPlN0YXJ0IFBvbHlnb24gU2V0PC9idXR0b24+XCIpLmJ1dHRvbih7XG4gICAgICAgIC8vICAgICBpY29uOiBcImZhIGZhLWNoZWNrLXNxdWFyZS1vXCIsXG4gICAgICAgIC8vICAgICBzaG93TGFiZWw6IGZhbHNlXG4gICAgICAgIC8vIH0pO1xuICAgICAgICAvLyAvL3RoaXMuJHN0YXJ0UG9seWdvblNldC5jc3MoXCJ2aXNpYmlsaXR5XCIsIFwiaW5oZXJpdFwiKTtcbiAgICAgICAgLy8gdGhpcy4kc3RhcnRQb2x5Z29uU2V0LmNzcyhcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIik7XG4gICAgICAgIC8vIHRoaXMuJHN0YXJ0UG9seWdvblNldC5hZGRDbGFzcyhcIndhbGRvcmYtY29uZmlybS1idXR0b25cIik7XG4gICAgICAgIC8vdGhpcy5SZWdpc3RlckVsZW1lbnQodGhpcy4kc3RhcnRQb2x5Z29uU2V0LCAkc3RhcnRUYWIsIC0yKTsgXG5cblxuICAgICAgICAvLyBBZGQgdGFncyBpbnB1dCBmaWVsZFxuICAgICAgICB0aGlzLiR0YWdzRmllbGQgPSAkKCc8c2VsZWN0IGNsYXNzPVwiZm9ybS1jb250cm9sXCIgbXVsdGlwbGU9XCJtdWx0aXBsZVwiPjwvc2VsZWN0PicpO1xuICAgICAgICB0aGlzLiR0YWdzRmllbGQud2lkdGgoXCIxMDAlXCIpO1xuICAgICAgICB0aGlzLiR0YWdzRmllbGQuY3NzKFwibWFyZ2luLXRvcFwiLCBcIi04cHhcIik7XG4gICAgICAgIHRoaXMuUmVnaXN0ZXJFbGVtZW50KHRoaXMuJHRhZ3NGaWVsZCwgJGJvZHlUYWIsIC0xKTtcbiAgICAgICAgdGhpcy4kdGFnc0ZpZWxkLnNlbGVjdDIoe1xuICAgICAgICAgICAgdGFnczogdHJ1ZSxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBcIlRhZ3NcIixcbiAgICAgICAgICAgIGFqYXg6IHRoaXMuR2V0VGFnc1F1ZXJ5KCksXG4gICAgICAgICAgICBzZWxlY3RPbkJsdXI6IHRydWUsXG4gICAgICAgICAgICAvLyBBbGxvdyBtYW51YWxseSBlbnRlcmVkIHRleHQgaW4gZHJvcCBkb3duLlxuICAgICAgICAgICAgY3JlYXRlVGFnOiBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHBhcmFtcy50ZXJtLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBwYXJhbXMudGVybSxcbiAgICAgICAgICAgICAgICAgICAgbmV3T3B0aW9uOiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQWRkIGN1c3RvbSBjbGFzcyBmb3IgYnJpbmdpbmcgdGhlIGRyb3Bkb3duIHRvIHRoZSBmcm9udCAoZnVsbHNjcmVlbiBmaXgpXG4gICAgICAgIHRoaXMuJHRhZ3NGaWVsZC5kYXRhKCdzZWxlY3QyJykuJGRyb3Bkb3duLmFkZENsYXNzKFwic2VsZWN0Mi1kcm9wZG93bi1hbm5vdGF0b3JcIik7XG5cbiAgICAgICAgLy8gTWFrZSBub3RlcyB0ZXh0IGZpZWxkXG4gICAgICAgIHRoaXMuJHRleHRGaWVsZCA9ICQoJzx0ZXh0YXJlYSB0eXBlPVwidGV4dFwiIG5hbWU9XCJhbm5vLXRleHRcIiBpZD1cImFubm8tdGV4dFwiIHZhbHVlPVwiXCIgcGxhY2Vob2xkZXI9XCJOb3Rlc1wiPicpO1xuICAgICAgICB0aGlzLiR0ZXh0RmllbGQuY3NzKFwibWFyZ2luLXRvcFwiLCBcIjJweFwiKTtcbiAgICAgICAgdGhpcy4kdGV4dEZpZWxkLndpZHRoKFwiOTguNSVcIik7XG4gICAgICAgIHRoaXMuJHRleHRGaWVsZC5hZGRDbGFzcyhcInVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYWxsXCIpO1xuICAgICAgICB0aGlzLiR0ZXh0RmllbGQuYXR0cigndGl0bGUnLCAnQW5ub3RhdGlvbiB0ZXh0Jyk7XG4gICAgICAgIHRoaXMuJHRleHRGaWVsZC5jc3MoXCJmbGV4LWdyb3dcIiwgMik7XG4gICAgICAgIHRoaXMuUmVnaXN0ZXJFbGVtZW50KHRoaXMuJHRleHRGaWVsZCwgJGJvZHlUYWIsIC0xKTtcblxuICAgICAgICAvLyBNYWtlIFwiU3RvcCB0aW1lXCIgbGFiZWwgYW5kIGZpZWxkXG4gICAgICAgIHRoaXMuJHRpbWVFbmRGaWVsZCA9ICQoJzxpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJ0aW1lLXN0b3BcIiBpZD1cInRpbWUtc3RvcFwiIHZhbHVlPVwiXCI+PGJyPjxicj4nKTtcbiAgICAgICAgdGhpcy4kdGltZUVuZEZpZWxkLndpZHRoKDcyKTtcbiAgICAgICAgdGhpcy4kdGltZUVuZEZpZWxkLmNzcyhcImZvbnQtZmFtaWx5XCIsIFwiQ291cmllciwgbW9ub3NwYWNlXCIpO1xuICAgICAgICB0aGlzLiR0aW1lRW5kRmllbGQuY3NzKFwibWFyZ2luLXJpZ2h0XCIsIFwiMnB4XCIpO1xuICAgICAgICB0aGlzLiR0aW1lRW5kRmllbGQuYWRkQ2xhc3MoXCJ1aS13aWRnZXQgdWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWFsbFwiKTtcbiAgICAgICAgdGhpcy4kdGltZUVuZEZpZWxkLmF0dHIoJ3RpdGxlJywgXCJTdGFydCB0aW1lIChoaDptbTpzcy5zcylcIik7XG4gICAgICAgIHRoaXMuJHRpbWVFbmRGaWVsZC5vbigna2V5cHJlc3MnLCBmdW5jdGlvbihldmVudCl7XG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSA0NiB8fCAoZXZlbnQua2V5Q29kZSA+PSA0OCAmJiBldmVudC5rZXlDb2RlIDw9IDU4KSl7IC8vMC05LCBwZXJpb2QsIGFuZCBjb2xvblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcblxuICAgICAgICAvL2FkZCBlbmQgbWFya2VyIGJ1dHRvblxuICAgICAgICB0aGlzLiRlbmRUaW1lTWFya2VyID0gJChcIjxidXR0b24gc3R5bGU9J3BhZGRpbmc6MDsgbGluZS1oZWlnaHQ6MS40Jz5TZXQgRW5kPC9idXR0b24+XCIpLmJ1dHRvbih7XG4gICAgICAgICAgICBpY29uOiBcImZhIGZhLW1hcC1tYXJrZXJcIixcbiAgICAgICAgICAgIHNob3dMYWJlbDogZmFsc2VcbiAgICAgICAgfSkuY2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy4kdGltZUVuZEZpZWxkWzBdLnZhbHVlID0gR2V0Rm9ybWF0dGVkVGltZSh0aGlzLmFubm90YXRvci5wbGF5ZXIudmlkZW9FbGVtZW50LmN1cnJlbnRUaW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLlJlZ2lzdGVyRWxlbWVudCh0aGlzLiRlbmRUaW1lTWFya2VyLCAkc3RvcFRhYiwgLTIpO1xuICAgICAgICAkKFwiPGxhYmVsIGZvcj0nc3RvcF90aW1lJz5TdG9wIFRpbWU6IDwvbGFiZWw+IFwiKS5hcHBlbmRUbygkc3RvcFRhYik7XG4gICAgICAgIHRoaXMuJHRpbWVFbmRGaWVsZC5hcHBlbmRUbygkc3RvcFRhYik7XG5cbiAgICAgICAgLy9NYWtlIFwiRWRpdCBwb2x5Z29uXCIgYnV0dG9uXG4gICAgICAgIGxldCAkZWRpdFN0b3BQb2x5QnV0dG9uID0gJChcIjxidXR0b24gc3R5bGU9J3BhZGRpbmc6MDsgbGluZS1oZWlnaHQ6MS40Jz5FZGl0IFBvbHlnb248L2J1dHRvbj5cIikuYnV0dG9uKHtcbiAgICAgICAgICAgIGljb246IFwiZmEgZmEtcGVuY2lsXCIsXG4gICAgICAgICAgICBzaG93TGFiZWw6IGZhbHNlXG4gICAgICAgIH0pLmNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuU2V0VmlzaWJsZShmYWxzZSk7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiYW5ub3RhdGlvbi1ndWk6MzUzIENyZWF0ZVwiKTtcbiAgICAgICAgICAgIHRoaXMucG9seUVkaXRvci5CZWdpbkVkaXRpbmcoJ3N0b3AnKTtcbiAgICAgICAgfSk7XG4gICAgICAgICRlZGl0U3RvcFBvbHlCdXR0b24uYXR0cigndGl0bGUnLCBcIkVkaXQgcG9seWdvblwiKTtcbiAgICAgICAgdGhpcy5SZWdpc3RlckVsZW1lbnQoJGVkaXRTdG9wUG9seUJ1dHRvbiwgJHN0b3BUYWIsIC0xKTtcblxuICAgICAgICBsZXQgJHN0b3BUYXJnZXRMYWJlbCA9ICQoXCI8bGFiZWw+U3RvcCBUYXJnZXQ8L2xhYmVsPiBcIik7XG4gICAgICAgICRzdG9wVGFyZ2V0TGFiZWwuY3NzKFwiY29sb3JcIiwgXCJ3aGl0ZVwiKTtcbiAgICAgICAgdGhpcy5SZWdpc3RlckVsZW1lbnQoJHN0b3BUYXJnZXRMYWJlbCwgJHN0b3BUYWIsIC0xKTtcblxuICAgICAgICAvL3N0b3AgcG9pbnQgcG9seWdvbiBpcyBhZGRlZFxuICAgICAgICB0aGlzLiRlbmRQb2x5Z29uU2V0ID0gJChcIjxidXR0b24gc3R5bGU9J3BhZGRpbmc6MDsgbGluZS1oZWlnaHQ6MS40Jz5FbmQgUG9seWdvbiBTZXQ8L2J1dHRvbj5cIikuYnV0dG9uKHtcbiAgICAgICAgICAgIGljb246IFwiZmEgZmEtY2hlY2stc3F1YXJlLW9cIixcbiAgICAgICAgICAgIHNob3dMYWJlbDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIC8vdGhpcy4kZW5kUG9seWdvblNldC5jc3MoXCJ2aXNpYmlsaXR5XCIsIFwiaW5oZXJpdFwiKTtcbiAgICAgICAgdGhpcy4kZW5kUG9seWdvblNldC5jc3MoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpO1xuICAgICAgICAvL3RoaXMuJGVuZFBvbHlnb25TZXQuYWRkQ2xhc3MoXCJ3YWxkb3JmLWNvbmZpcm0tYnV0dG9uXCIpO1xuICAgIFxuICAgICAgICAvL0FkZCBzb21lIGVycm9yIGNoZWNraW5nLi4uXG4gICAgICAgIHRoaXMuJHRpbWVFbmRGaWVsZC5ibHVyKCgpID0+IHtcbiAgICAgICAgICAgIGxldCBlID0gJCh0aGlzLiR0aW1lRW5kRmllbGQpLnZhbCgpO1xuICAgICAgICAgICAgbGV0IHMgPSAkKHRoaXMuJHRpbWVTdGFydEZpZWxkKS52YWwoKTtcbiAgICAgICAgICAgIGlmKEdldFNlY29uZHNGcm9tSE1TKHMrMSkgPiBHZXRTZWNvbmRzRnJvbUhNUyhlKSl7XG4gICAgICAgICAgICAgICAgJCh0aGlzLiR0aW1lRW5kRmllbGQpLnZhbChHZXRGb3JtYXR0ZWRUaW1lKEdldFNlY29uZHNGcm9tSE1TKHMpKy4wMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4kdGltZVN0YXJ0RmllbGQuYmx1cigoKSA9PiB7XG4gICAgICAgICAgICBsZXQgZSA9ICQodGhpcy4kdGltZUVuZEZpZWxkKS52YWwoKTtcbiAgICAgICAgICAgIGxldCBzID0gJCh0aGlzLiR0aW1lU3RhcnRGaWVsZCkudmFsKCk7XG4gICAgICAgICAgICBpZihHZXRTZWNvbmRzRnJvbUhNUyhzKzEpID4gR2V0U2Vjb25kc0Zyb21ITVMoZSkpe1xuICAgICAgICAgICAgICAgICQodGhpcy4kdGltZUVuZEZpZWxkKS52YWwoR2V0Rm9ybWF0dGVkVGltZShHZXRTZWNvbmRzRnJvbUhNUyhzKSsuMDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5SZWdpc3RlckVsZW1lbnQodGhpcy4kZW5kUG9seWdvblNldCwgJHN0b3BUYWIsIC0yKTsgXG5cbiAgICAgICAgbGV0ICRidXR0b25QYW5lbCA9ICQoXCI8ZGl2IGNsYXNzPSdidXR0b25fcGFuZWwnPjwvZGl2PlwiKS5hcHBlbmRUbyh0aGlzLiRjb250YWluZXIpO1xuXG4gICAgICAgIC8vIE1ha2UgZGVsZXRlIGJ1dHRvbi4gVGhpcyBzaG91bGQgb25seSBhcHBlYXIgaWYgd2UncmUgZWRpdGluZywgbm90IGlmIGl0J3MgYSBuZXcgYW5ub3RhdGlvblxuICAgICAgICB0aGlzLiRkZWxldGVCdXR0b24gPSAkKFwiPGJ1dHRvbj5EZWxldGUgQW5ub3RhdGlvbjwvYnV0dG9uPlwiKS5idXR0b24oe1xuICAgICAgICAgICAgLy8gaWNvbjogXCJmYSBmYS1ib21iXCIsXG4gICAgICAgICAgICBzaG93TGFiZWw6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuJGRlbGV0ZUJ1dHRvbi5oaWRlKCk7XG4gICAgICAgIHRoaXMuJGRlbGV0ZUJ1dHRvbi5hdHRyKCd0aXRsZScsIFwiRGVsZXRlIGFubm90YXRpb25cIik7XG4gICAgICAgIHRoaXMuJGRlbGV0ZUJ1dHRvbi5jbGljaygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFubm90YXRvci5zZXJ2ZXIuRGVsZXRlQW5ub3RhdGlvbih0aGlzLm9yaWdpbmFsQW5ub3RhdGlvbiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYW5ub3RhdG9yLkRlcmVnaXN0ZXJBbm5vdGF0aW9uKHRoaXMub3JpZ2luYWxBbm5vdGF0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLkNsb3NlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuUmVnaXN0ZXJFbGVtZW50KHRoaXMuJGRlbGV0ZUJ1dHRvbiwgJGJ1dHRvblBhbmVsLCAtMSk7XG5cblxuICAgICAgICAvLyBNYWtlIGNhbmNlbCBidXR0b25cbiAgICAgICAgbGV0ICRjYW5jZWxCdXR0b24gPSAkKFwiPGJyPjxicj48YnV0dG9uPkNhbmNlbDwvYnV0dG9uPlwiKS5idXR0b24oe1xuICAgICAgICAgICAgc2hvd0xhYmVsOiB0cnVlXG4gICAgICAgIH0pLmNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucG9seUVkaXRvci5SZXNldFBvbHlnb25zKCk7XG4gICAgICAgICAgICB0aGlzLkNsb3NlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICAkY2FuY2VsQnV0dG9uLmNzcyhcImZsb2F0XCIsIFwicmlnaHRcIik7XG4gICAgICAgICRjYW5jZWxCdXR0b24uYXR0cigndGl0bGUnLCBcIkV4aXQgYW5ub3RhdGlvbiBlZGl0aW5nXCIpO1xuICAgICAgICAvLyRjYW5jZWxfYnV0dG9uLmFkZENsYXNzKFwid2FsZG9yZi1jYW5jZWwtYnV0dG9uXCIpO1xuICAgICAgICB0aGlzLlJlZ2lzdGVyRWxlbWVudCgkY2FuY2VsQnV0dG9uLCAkYnV0dG9uUGFuZWwsIC0xKTtcbiAgICAgICAgXG4gICAgICAgIC8vIE1ha2Ugc2F2ZSBidXR0b25cbiAgICAgICAgbGV0ICRzYXZlQnV0dG9uID0gJChcIjxidXR0b24+U2F2ZTwvYnV0dG9uPlwiKS5idXR0b24oe1xuICAgICAgICAgICAgc2hvd0xhYmVsOiB0cnVlXG4gICAgICAgIH0pLmNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuQ29tbWl0QW5ub3RhdGlvblRvU2VydmVyKChhbm5vdGF0aW9uLCBvbGRJRCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuZWRpdE1vZGUpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFubm90YXRvci5VcGRhdGVBbm5vdGF0aW9uKGFubm90YXRpb24sIG9sZElEKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFubm90YXRvci5SZWdpc3Rlck5ld0Fubm90YXRpb24oYW5ub3RhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucG9seUVkaXRvci5SZXNldFBvbHlnb25zKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5DbG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAkc2F2ZUJ1dHRvbi5jc3MoXCJmbG9hdFwiLCBcImxlZnRcIik7XG4gICAgICAgIHRoaXMuUmVnaXN0ZXJFbGVtZW50KCRzYXZlQnV0dG9uLCAkYnV0dG9uUGFuZWwsIC0xKTtcblxuICAgICAgICAvL2h0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEzODM3MzA0L2pxdWVyeS11aS1ub24tYWpheC10YWItbG9hZGluZy13aG9sZS13ZWJzaXRlLWludG8taXRzZWxmXG4gICAgICAgICQoJ2Jhc2UnKS5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy4kdGFicy50YWJzKCkuYWRkQ2xhc3MoJ3VpLXRhYnMtdmVydGljYWwnKTtcbiAgICAgICAgLy9sZXQgJHNjcmlwdF9zZWN0aW9uID0gJFxuICAgICAgICAvL3RoaXMuJGNvbnRhaW5lci5oaWRlKCk7XG4gICAgfVxuXG4gICAgUmVnaXN0ZXJFbGVtZW50KCRlbGVtZW50LCAkY29udGFpbmVyLCBvcmRlciwganVzdGlmaWNhdGlvbiA9ICdmbGV4LXN0YXJ0Jyl7XG4gICAgICAgICRlbGVtZW50LmNzcygnb3JkZXInLCBvcmRlcik7XG4gICAgICAgICRlbGVtZW50LmNzcygnYWxpZ24tc2VsZicsIGp1c3RpZmljYXRpb24pO1xuICAgICAgICAvLyBTZXRzIGdyb3cgW3Nocmlua10gW2Jhc2lzXVxuICAgICAgICAvLyRlbGVtZW50LmNzcygnZmxleCcsICcwIDAgYXV0bycpO1xuICAgICAgICAkY29udGFpbmVyLmFwcGVuZCgkZWxlbWVudCk7XG4gICAgfVxuXG4gICAgU2V0VmlzaWJsZShpc1Zpc2libGUsIGR1cmF0aW9uID0gMCl7XG5cbiAgICAgICAgLy9jb25zb2xlLmxvZyhpc1Zpc2libGUgKyBcIiBcIiArIGR1cmF0aW9uKTtcbiAgICAgICAgaWYoaXNWaXNpYmxlKXtcbiAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci5mYWRlVG8oZHVyYXRpb24sIDEuMCk7XG4gICAgICAgICAgICB0aGlzLiRjb250YWluZXIubWFrZVZpc2libGUodHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiRjb250YWluZXIuc3RvcCh0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci5mYWRlVG8oZHVyYXRpb24sIDAuMCk7XG4gICAgICAgICAgICB0aGlzLiRjb250YWluZXIubWFrZVZpc2libGUoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNWaXNpYmxlID0gaXNWaXNpYmxlO1xuXG4gICAgfVxuXG4gICAgVG9nZ2xlT3Blbigpe1xuXG4gICAgICAgIGlmKHRoaXMub3Blbil7XG4gICAgICAgICAgICB0aGlzLkNsb3NlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLk9wZW4oKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgT3Blbigpe1xuICAgICAgICB0aGlzLlNldFZpc2libGUodHJ1ZSk7XG4gICAgICAgIHRoaXMub3BlbiA9IHRydWU7XG4gICAgICAgIHRoaXMucG9seUVkaXRvci5Eb25lKCk7XG4gICAgICAgIC8vIERpc2FibGUgYXV0b2ZhZGluZyB3aGVuIHRoZSBndWkgaXMgdmlzaWJsZVxuICAgICAgICB0aGlzLmFubm90YXRvci5wbGF5ZXIuU2V0QXV0b0ZhZGUoZmFsc2UpO1xuICAgIH1cblxuICAgIENsb3NlKCl7XG4gICAgICAgIHRoaXMuU2V0VmlzaWJsZShmYWxzZSk7XG4gICAgICAgIHRoaXMub3BlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBvbHlFZGl0b3IuRG9uZSgpO1xuICAgICAgICAvLyBSZS1lbmFibGUgYXV0b2ZhZGluZyB3aGVuIHRoZSBndWkgaXMgaGlkZGVuXG4gICAgICAgIHRoaXMuYW5ub3RhdG9yLnBsYXllci5TZXRBdXRvRmFkZSh0cnVlKTtcbiAgICAgICAgdGhpcy4kY29udGFpbmVyLnRyaWdnZXIoXCJPbkdVSUNsb3NlZFwiKTtcbiAgICB9XG4gICAgXG4gICAgVG9nZ2xlVmlzaWJsZSgpe1xuICAgICAgICB0aGlzLlNldFZpc2libGUoIXRoaXMuaXNWaXNpYmxlLCAwKTtcbiAgICB9XG5cbiAgICBCZWdpbkVkaXRpbmcoYW5ub3RhdGlvbiA9IG51bGwsIGZvcmNlTmV3ID0gZmFsc2Upe1xuICAgICAgICAvLyBPcGVuIHRoZSBHVUkgaWYgaXQgaXNuJ3QgYWxyZWFkeVxuICAgICAgICB0aGlzLk9wZW4oKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFBvcHVsYXRlIGRhdGEgZnJvbSB0aGUgcGFzc2VkIGluIGFubm90YXRpb25cbiAgICAgICAgaWYgKGFubm90YXRpb24gfHwgZm9yY2VOZXcpIHtcbiAgICAgICAgICAgIC8vIFBvcHVsYXRlIHRoZSBmaWVsZHMgZnJvbSB0aGUgYW5ub3RhdGlvblxuICAgICAgICAgICAgdGhpcy5lZGl0TW9kZSA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIEZsaXAgZWRpdCBtb2RlIGJhY2sgdG8gZmFsc2UgaWYgZm9yY2VOZXcuIFdlIHdhbnQgdG9cbiAgICAgICAgICAgIC8vIHBvcHVsYXRlIGZyb20gdGhlIGVudGlyZSBwYXNzZWQgaW4gYW5ub3RhdGlvbiwgYnV0IHRyZWF0XG4gICAgICAgICAgICAvLyBpdCBhcyBuZXcuXG4gICAgICAgICAgICBpZihmb3JjZU5ldykgdGhpcy5lZGl0TW9kZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICB0aGlzLm9yaWdpbmFsQW5ub3RhdGlvbiA9IGFubm90YXRpb247XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUG9wdWxhdGVkIGZyb20gYW4gZXhpc3RpbmcgYW5ub3RhdGlvblwiKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGFubm90YXRpb24pO1xuICAgICAgICAgICAgdGhpcy4kdGltZVN0YXJ0RmllbGQudmFsKEdldEZvcm1hdHRlZFRpbWUoYW5ub3RhdGlvbi5iZWdpblRpbWUpKTtcbiAgICAgICAgICAgIHRoaXMuJHRpbWVFbmRGaWVsZC52YWwoR2V0Rm9ybWF0dGVkVGltZShhbm5vdGF0aW9uLmVuZFRpbWUpKTtcbiAgICAgICAgICAgIGlmICgndW5kZWZpbmVkJyA9PSB0eXBlb2YoYW5ub3RhdGlvbi5pdGVtcykpIHsgLy8gVmVyc2lvbiAxXG4gICAgICAgICAgICAgICAgdGhpcy4kdGV4dEZpZWxkLnZhbChhbm5vdGF0aW9uLmJvZHkuZmlsdGVyKGl0ZW0gPT4gaXRlbS5wdXJwb3NlID09IFwiZGVzY3JpYmluZ1wiKVswXS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgLy8gVmVyc2lvbiAxIGRvZXNuJ3QgaGF2ZSBhIHRoaXMuaWQgY29udGV4dFxuICAgICAgICAgICAgfSBlbHNlIHsgLy8gVmVyc2lvbiAyXG4gICAgICAgICAgICAgICAgdGhpcy4kdGV4dEZpZWxkLnZhbChhbm5vdGF0aW9uLml0ZW1zWzBdLml0ZW1zWzBdLml0ZW1zWzBdLmJvZHkuZmlsdGVyKGl0ZW0gPT4gaXRlbS5wdXJwb3NlID09IFwiZGVzY3JpYmluZ1wiKVswXS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZCA9IGFubm90YXRpb24uaXRlbXNbMF0uaXRlbXNbMF0uaXRlbXNbMF0uaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXNldCB0aGUgdGFncyBmaWVsZFxuICAgICAgICAgICAgdGhpcy4kdGFnc0ZpZWxkLnZhbChcIlwiKS50cmlnZ2VyKFwiY2hhbmdlXCIpO1xuICAgICAgICAgICAgdGhpcy4kdGFnc0ZpZWxkLmZpbmQoXCJvcHRpb25cIikucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgIGZvcihsZXQgdGFnIG9mIGFubm90YXRpb24udGFncyl7XG4gICAgICAgICAgICAgICAgdGhpcy4kdGFnc0ZpZWxkLmFwcGVuZChcIjxvcHRpb24gdmFsdWU9J1wiK3RhZytcIicgc2VsZWN0ZWQ+XCIrdGFnK1wiPC9vcHRpb24+XCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuJHRhZ3NGaWVsZC50cmlnZ2VyKFwiY2hhbmdlXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnBvbHlFZGl0b3IuSW5pdFBvbHkoYW5ub3RhdGlvbi5nZXRQb2x5KCkpO1xuICAgICAgICAgICAgdGhpcy5wb2x5RWRpdG9yLlNob3dKdXN0UG9seWdvbigpO1xuXG4gICAgICAgICAgICAvLyBQcm9wYWdhdGUgdGhlIHBvbHlnb24gZWRpdG9yJ3MgcG9seWdvbnMgYXJyYXkgd2l0aCBwb2x5Z29ucyBmcm9tIHRoZSBhbm5vdGF0aW9uXG4gICAgICAgICAgICB0aGlzLnBvbHlFZGl0b3IuJHBvbHlnb25zID0gW107XG4gICAgICAgICAgICBpZiAoYW5ub3RhdGlvbi5wb2x5U3RhcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMucG9seUVkaXRvci4kcG9seWdvbnMucHVzaChhbm5vdGF0aW9uLnBvbHlTdGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKGFubm90YXRpb24ucG9seUVuZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9seUVkaXRvci4kcG9seWdvbnMucHVzaChhbm5vdGF0aW9uLnBvbHlFbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIC8vIEluc2VydCB0ZW1wbGF0ZSBkYXRhIGlmIG5vIGFubm90YXRpb24gaXMgZ2l2ZW5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBQb3B1bGF0ZSBmaWVsZHMgaWYgbm8gYW5ub3RhdGlvbiBpcyBnaXZlblxuICAgICAgICAgICAgdGhpcy5lZGl0TW9kZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICB0aGlzLm9yaWdpbmFsQW5ub3RhdGlvbiA9IG51bGw7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUG9wdWxhdGVkIHdpdGggdGVtcGxhdGUgZGF0YVwiKTtcbiAgICAgICAgICAgIHRoaXMuJHRpbWVTdGFydEZpZWxkLnZhbChHZXRGb3JtYXR0ZWRUaW1lKHRoaXMuYW5ub3RhdG9yLnBsYXllci52aWRlb0VsZW1lbnQuY3VycmVudFRpbWUpKTtcbiAgICAgICAgICAgIHRoaXMuJHRpbWVFbmRGaWVsZC52YWwoR2V0Rm9ybWF0dGVkVGltZSh0aGlzLmFubm90YXRvci5wbGF5ZXIudmlkZW9FbGVtZW50LmR1cmF0aW9uKSk7XG4gICAgICAgICAgICB0aGlzLiR0ZXh0RmllbGQudmFsKFwiXCIpO1xuICAgICAgICAgICAgLy8gUmVzZXQgdGhlIHRhZ3MgZmllbGRcbiAgICAgICAgICAgIHRoaXMuJHRhZ3NGaWVsZC52YWwoXCJcIikudHJpZ2dlcihcImNoYW5nZVwiKTtcbiAgICAgICAgICAgIHRoaXMuJHRhZ3NGaWVsZC5maW5kKFwib3B0aW9uXCIpLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICB0aGlzLnBvbHlFZGl0b3IuSW5pdFBvbHkoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1vZGlmeSBHVUkgYmFzZWQgb24gZWRpdCBtb2RlXG4gICAgICAgIGlmKHRoaXMuZWRpdE1vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuJHRpdGxlLnRleHQoXCJFZGl0IEFubm90YXRpb25cIik7XG4gICAgICAgICAgICB0aGlzLiRkZWxldGVCdXR0b24uYnV0dG9uKFwiZW5hYmxlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4kdGl0bGUudGV4dChcIkNyZWF0ZSBBbm5vdGF0aW9uXCIpO1xuICAgICAgICAgICAgdGhpcy4kZGVsZXRlQnV0dG9uLmJ1dHRvbihcImRpc2FibGVcIik7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIENvbW1pdEFubm90YXRpb25Ub1NlcnZlcihjYWxsYmFjayl7XG4gICAgICAgIGlmKHRoaXMuZWRpdE1vZGUpe1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJTZW5kaW5nIGVkaXRlZCBhbm5vdGF0aW9uIHRvIHNlcnZlci4uLlwiKTtcbiAgICAgICAgICAgIHRoaXMuYW5ub3RhdG9yLnNlcnZlci5FZGl0QW5ub3RhdGlvbihjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU2VuZGluZyBuZXcgYW5ub3RhdGlvbiB0byBzZXJ2ZXIuLi5cIik7XG4gICAgICAgICAgICB0aGlzLmFubm90YXRvci5zZXJ2ZXIuUG9zdEFubm90YXRpb24oY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgYW4gb2JqZWN0IGZyb20gdGhlIGRhdGEuXG4gICAgR2V0QW5ub3RhdGlvbk9iamVjdCgpIHtcblxuICAgICAgICBsZXQgYW5ub3RhdGlvbiA9IG5ldyBBbm5vdGF0aW9uKCk7XG4gICAgICAgXG4gICAgICAgIGlmICgndW5kZWZpbmVkJyA9PSB0eXBlb2YoYW5ub3RhdGlvbi5pdGVtcykpIHsgLy8gVmVyc2lvbiAxXG4gICAgICAgICAgICBhbm5vdGF0aW9uW1wiYm9keVwiXSA9IHRoaXMuQnVpbGRBbm5vdGF0aW9uQm9keVYxKCk7XG4gICAgICAgICAgICBhbm5vdGF0aW9uW1widGFyZ2V0XCJdID0gdGhpcy5CdWlsZEFubm90YXRpb25UYXJnZXQodHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7IC8vIFZlcnNpb24gMlxuICAgICAgICAgICAgYW5ub3RhdGlvbltcImxhYmVsXCJdID0ge1xuICAgICAgICAgICAgICAgIFwiZW5cIjogW3RoaXMuYW5ub3RhdG9yLmNvbnRlbnRMYWJlbF1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhbm5vdGF0aW9uW1wiaXRlbXNcIl0gPSB0aGlzLkJ1aWxkQW5ub3RhdGlvbkl0ZW1zKCk7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgLy8gUmVjb21wdXRlIHJlYWQtb25seSBhY2Nlc3MgcHJvcGVydGllcyBhZnRlciBhbGwgb3RoZXIgcHJvcGVydGllcyBoYXZlIGJlZW4gc2V0XG4gICAgICAgIGFubm90YXRpb24ucmVjYWxjdWxhdGUoKTtcblxuICAgICAgICAvLyBDbG9uZSB0aGUgb2JqZWN0IHNvIHdlIGRvbid0IG1vZGlmeSBhbnl0aGluZyBieSBjaGFuZ2luZyB0aGlzIG9iamVjdFxuICAgICAgICBsZXQgY2xvbmUgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGFubm90YXRpb24pKVxuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuXG4gICAgQnVpbGRBbm5vdGF0aW9uSXRlbXMoKSB7XG4gICAgICAgIGxldCBidWlsZFRpbWUgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7IC8vXCIyMDIwLTA4LTE2VDEyOjAwOjAwWlwiXG4gICAgICAgIGxldCB2aWRlb0R1cmF0aW9uID0gdGhpcy5hbm5vdGF0b3IucGxheWVyLnZpZGVvRWxlbWVudC5kdXJhdGlvbjtcbiAgICAgICAgbGV0IHZpZGVvV2lkdGggPSB0aGlzLmFubm90YXRvci5wbGF5ZXIudmlkZW9FbGVtZW50LnZpZGVvV2lkdGg7XG4gICAgICAgIGxldCB2aWRlb0hlaWdodCA9IHRoaXMuYW5ub3RhdG9yLnBsYXllci52aWRlb0VsZW1lbnQudmlkZW9IZWlnaHQ7XG5cbiAgICAgICAgLy8gbGV0IHZpZGVvRGltZW5zaW9uID0gdGhpcy5hbm5vdGF0b3IucGxheWVyLkdldFZpZGVvRGltZW5zaW9ucygpXG4gICAgICAgIC8vIHZpZGVvV2lkdGggPSB2aWRlb0RpbWVuc2lvbi53aWR0aDtcbiAgICAgICAgLy8gdmlkZW9IZWlnaHQgPSB2aWRlb0RpbWVuc2lvbi5oZWlnaHQ7XG5cbiAgICAgICAgbGV0IGl0ZW1zID0gW3tcbiAgICAgICAgICAgIFwiaWRcIjogdGhpcy5hbm5vdGF0b3IudXJsLCAvL1RPRE86IHNjYWxhciBzcGVjaWZpYyB1cmwgLSBzaG91bGQgYmUgc3VwcGxpZWQgdG8gcGx1Z2luIFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiQ2FudmFzXCIsXG4gICAgICAgICAgICBcImhlaWdodFwiOiB2aWRlb0hlaWdodCxcbiAgICAgICAgICAgIFwid2lkdGhcIjogdmlkZW9XaWR0aCxcbiAgICAgICAgICAgIFwiZHVyYXRpb25cIjogdmlkZW9EdXJhdGlvbiwgXG4gICAgICAgICAgICBcImNvbnRlbnRcIjoge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogdGhpcy5hbm5vdGF0b3IudXJsLCBcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJWaWRlb1wiLFxuICAgICAgICAgICAgICAgIFwiaGVpZ2h0XCI6IHZpZGVvSGVpZ2h0LFxuICAgICAgICAgICAgICAgIFwid2lkdGhcIjogdmlkZW9XaWR0aCxcbiAgICAgICAgICAgICAgICBcImR1cmF0aW9uXCI6IHZpZGVvRHVyYXRpb24sXG4gICAgICAgICAgICAgICAgXCJsYWJlbFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiZW5cIjogdGhpcy5hbm5vdGF0b3IuY29udGVudExhYmVsIC8vXCJkY3Rlcm1zOnRpdGxlXCIgZnJvbSB0aGUgYW5ub3RhdGlvbiBqc29uIGZpbGUgZnJvbSBzY2FsYXJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjoge1xuICAgICAgICAgICAgICAgICAgICBcImVuXCI6IFwiXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJpdGVtc1wiOiBbe1xuICAgICAgICAgICAgICAgIFwiaWRcIjogdGhpcy5hbm5vdGF0b3IudXJsLCAgXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiQW5ub3RhdGlvblBhZ2VcIixcbiAgICAgICAgICAgICAgICBcImdlbmVyYXRvclwiOiBcImh0dHA6Ly9naXRodWIuY29tL2FudmMvc2NhbGFyXCIsXG4gICAgICAgICAgICAgICAgXCJnZW5lcmF0ZWRcIjogYnVpbGRUaW1lLCBcbiAgICAgICAgICAgICAgICBcIml0ZW1zXCI6IFt7XG4gICAgICAgICAgICAgICAgICAgIFwiaWRcIjogdGhpcy5pZCwgLy8gVVJMIHRvIHRoZSBhbm5vdGF0aW9uLXBhZ2VcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiQW5ub3RhdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBcImdlbmVyYXRvclwiOiBcImh0dHA6Ly9naXRodWIuY29tL25vdm9tYW5jeS93YWxkb3JmLXNjYWxhclwiLCBcbiAgICAgICAgICAgICAgICAgICAgXCJtb3RpdmF0aW9uXCI6IFwiaGlnaGxpZ2h0aW5nXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiY3JlYXRvclwiOiB0aGlzLkJ1aWxkQ3JlYXRvclRlbXBsYXRlKCksICBcbiAgICAgICAgICAgICAgICAgICAgXCJjcmVhdGVkXCI6IGJ1aWxkVGltZSwgIFxuICAgICAgICAgICAgICAgICAgICBcInJpZ2h0c1wiOiBcImh0dHBzOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS80LjAvXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYm9keVwiOiB0aGlzLkJ1aWxkQW5ub3RhdGlvbkJvZHlWMigpLFxuICAgICAgICAgICAgICAgICAgICBcInRhcmdldFwiOiB0aGlzLkJ1aWxkQW5ub3RhdGlvblRhcmdldChmYWxzZSlcbiAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1dXG4gICAgXG4gICAgICAgIH1dO1xuXG5cbiAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgICAgICAgICAgICAgIFxuICAgIH1cblxuICAgIEJ1aWxkQ3JlYXRvclRlbXBsYXRlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiUGVyc29uXCIsXG4gICAgICAgICAgICBcIm5pY2tuYW1lXCI6IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd3YWxkb3JmX3VzZXJfbmFtZScpLFxuICAgICAgICAgICAgXCJlbWFpbF9zaGExXCI6IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd3YWxkb3JmX3VzZXJfZW1haWwnKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy9CdWlsZCB3aXRoIHRhZ3MgZW50cmllcyBmcm9tIG9ub215XG4gICAgQnVpbGRBbm5vdGF0aW9uQm9keVYyKCkge1xuICAgICAgICBsZXQgYm9keSA9IFtdO1xuXG4gICAgICAgIC8vIEJ1aWxkIHRleHQgZGVzY3JpcHRvclxuICAgICAgICBsZXQgYm9keVRleHQgPSB7XG4gICAgICAgICAgICBcInR5cGVcIiA6IFwiVGV4dHVhbEJvZHlcIixcbiAgICAgICAgICAgIFwidmFsdWVcIiA6IHRoaXMuJHRleHRGaWVsZC52YWwoKSxcbiAgICAgICAgICAgIFwiZm9ybWF0XCIgOiBcInRleHQvcGxhaW5cIixcbiAgICAgICAgICAgIFwibGFuZ3VhZ2VcIiA6IFwiZW5cIixcbiAgICAgICAgICAgIFwicHVycG9zZVwiOiBcImRlc2NyaWJpbmdcIlxuICAgICAgICB9O1xuICAgICAgICBib2R5LnB1c2goYm9keVRleHQpO1xuXG4gICAgICAgIC8vIEJ1aWxkIHRhZyBkZXNjcmlwdG9yc1xuICAgICAgICAvL2xldCB0YWdzID0gdGhpcy4kdGFnc0ZpZWxkLnNlbGVjdDIoXCJkYXRhXCIpLm1hcCgoaXRlbSkgPT4geyByZXR1cm4gaXRlbS50ZXh0OyB9KTtcbiAgICAgICAgbGV0IHNlbGVjdGVkX3RhZ3MgPSB0aGlzLiR0YWdzRmllbGQuc2VsZWN0MihcImRhdGFcIikubWFwKChpdGVtKSA9PiB7IHJldHVybiB7aWQ6IGl0ZW0uaWQsIHRleHQ6IGl0ZW0udGV4dH19KTtcbiAgICAgICAgbGV0IG9ub215X21hcCA9IHRoaXMuYW5ub3RhdG9yLmFubm90YXRpb25NYW5hZ2VyLm9ub215Vm9jYWJ1bGFyeS5yZXN1bHRzLnJlZHVjZShmdW5jdGlvbihhY2MsIGN1cnIpIHthY2NbY3VyclsnaWQnXV0gPSBjdXJyOyByZXR1cm4gYWNjO30sIHt9KTtcblxuICAgICAgICBmb3IobGV0IHRhZyBvZiBzZWxlY3RlZF90YWdzKXtcbiAgICAgICAgICAgIGxldCBvbm9teV9yZWYgPSBvbm9teV9tYXBbdGFnLmlkXTtcbiAgICAgICAgICAgIGxldCBib2R5VGFnID0ge31cbiAgICAgICAgICAgIGlmIChvbm9teV9yZWYpIHtcbiAgICAgICAgICAgICAgICBib2R5VGFnID0ge1xuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJTcGVjaWZpY1Jlc291cmNlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwicHVycG9zZVwiOiBcInRhZ2dpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzb3VyY2VcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIFwiaWRcIjogb25vbXlfcmVmLnRlcm1zX2lkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZm9ybWF0XCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwibGFiZWxcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJlblwiOiBvbm9teV9yZWYudGV4dFxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImVuXCI6IG9ub215X3JlZi5jb21tZW50XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJvZHlUYWcgPSB7XG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIlRleHR1YWxCb2R5XCIsXG4gICAgICAgICAgICAgICAgICAgIFwicHVycG9zZVwiOiBcInRhZ2dpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiB0YWcudGV4dFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJvZHkucHVzaChib2R5VGFnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBib2R5O1xuICAgIH1cblxuICAgIEJ1aWxkQW5ub3RhdGlvbkJvZHlWMSgpIHtcbiAgICAgICAgbGV0IGJvZHkgPSBbXTtcblxuICAgICAgICAvLyBCdWlsZCB0ZXh0IGRlc2NyaXB0b3JcbiAgICAgICAgbGV0IGJvZHlUZXh0ID0ge1xuICAgICAgICAgICAgXCJ0eXBlXCIgOiBcIlRleHR1YWxCb2R5XCIsXG4gICAgICAgICAgICBcInZhbHVlXCIgOiB0aGlzLiR0ZXh0RmllbGQudmFsKCksXG4gICAgICAgICAgICBcImZvcm1hdFwiIDogXCJ0ZXh0L3BsYWluXCIsXG4gICAgICAgICAgICBcImxhbmd1YWdlXCIgOiBcImVuXCIsXG4gICAgICAgICAgICBcInB1cnBvc2VcIjogXCJkZXNjcmliaW5nXCJcbiAgICAgICAgfTtcbiAgICAgICAgYm9keS5wdXNoKGJvZHlUZXh0KTtcblxuICAgICAgICAvLyBCdWlsZCB0YWcgZGVzY3JpcHRvcnNcbiAgICAgICAgbGV0IHRhZ3MgPSB0aGlzLiR0YWdzRmllbGQuc2VsZWN0MihcImRhdGFcIikubWFwKChpdGVtKSA9PiB7IHJldHVybiBpdGVtLnRleHQ7IH0pO1xuICAgICAgICBmb3IobGV0IHRhZ1N0ciBvZiB0YWdzKXtcbiAgICAgICAgICAgIGxldCBib2R5VGFnID0ge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIlRleHR1YWxCb2R5XCIsXG4gICAgICAgICAgICAgICAgXCJwdXJwb3NlXCI6IFwidGFnZ2luZ1wiLFxuICAgICAgICAgICAgICAgIFwidmFsdWVcIjogdGFnU3RyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib2R5LnB1c2goYm9keVRhZyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYm9keTtcbiAgICB9XG5cbiAgICAvL3VzZWQgYm90aCB2MSBhbmQgdjJcbiAgICBCdWlsZEFubm90YXRpb25UYXJnZXQoc2VsZWN0b3JzSW5BcnJheSkge1xuXG4gICAgICAgIGlmICgndW5kZWZpbmVkJyA9PSB0eXBlb2Yoc2VsZWN0b3JzSW5BcnJheSkpIHNlbGVjdG9yc0luQXJyYXkgPSBmYWxzZTtcblxuICAgICAgICBsZXQgdGFyZ2V0ID0ge1xuICAgICAgICAgICAgXCJpZFwiOiB0aGlzLmFubm90YXRvci51cmwsIC8vIFVSTCBvZiB0aGUgdmlkZW9cbiAgICAgICAgICAgIFwidHlwZVwiOiBcIlZpZGVvXCJcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzZWxlY3RvcnMgPSBbXTtcblxuICAgICAgICBsZXQgc2FmZUVuZFRpbWUgPSBHZXRTZWNvbmRzRnJvbUhNUyh0aGlzLiR0aW1lU3RhcnRGaWVsZC52YWwoKSk7XG4gICAgICAgIGlmKEdldFNlY29uZHNGcm9tSE1TKHRoaXMuJHRpbWVFbmRGaWVsZC52YWwoKSkgPiBHZXRTZWNvbmRzRnJvbUhNUyh0aGlzLiR0aW1lU3RhcnRGaWVsZC52YWwoKSkpe1xuICAgICAgICAgICAgc2FmZUVuZFRpbWUgPSBHZXRTZWNvbmRzRnJvbUhNUyh0aGlzLiR0aW1lRW5kRmllbGQudmFsKCkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydFRpbWUgPSBHZXRTZWNvbmRzRnJvbUhNUyh0aGlzLiR0aW1lU3RhcnRGaWVsZC52YWwoKSk7XG5cbiAgICAgICAgLy8gQnVpbGQgdGltZSBzZWxlY3RvclxuICAgICAgICBsZXQgdGltZVNlbGVjdG9yID0ge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiRnJhZ21lbnRTZWxlY3RvclwiLFxuICAgICAgICAgICAgXCJjb25mb3Jtc1RvXCI6IFwiaHR0cDovL3d3dy53My5vcmcvVFIvbWVkaWEtZnJhZ3MvXCIsIC8vIFNlZSBtZWRpYSBmcmFnbWVudCBzcGVjaWZpY2F0aW9uXG4gICAgICAgICAgICBcInZhbHVlXCI6IGB0PSR7c3RhcnRUaW1lfSwke3NhZmVFbmRUaW1lfWAgLy8gVGltZSBpbnRlcnZhbCBpbiBzZWNvbmRzXG4gICAgICAgIH1cblxuICAgICAgICAvL0J1aWxkIFN2Z1NlbGVjdG9yXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5wb2x5RWRpdG9yLiR2ZXJ0aWNlcy5zdGFydCAhPSAndW5kZWZpbmVkJyAmJiB0aGlzLnBvbHlFZGl0b3IuJHZlcnRpY2VzLnN0YXJ0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbGV0IHBvaW50c1N0ciA9IHRoaXMucG9seUVkaXRvci4kdmVydGljZXMuc3RhcnQubWFwKGl0ZW0gPT4geyByZXR1cm4gYCR7aXRlbVswXX0sJHtpdGVtWzFdfWAgfSkuam9pbihcIiBcIik7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBcIjxzdmcgdmlld0JveD0nMCAwIDEwMCAxMDAnIHByZXNlcnZlQXNwZWN0UmF0aW89J25vbmUnPlwiO1xuICAgICAgICAgICAgdmFsdWUgKz0gXCI8cG9seWdvbiBwb2ludHM9J1wiICsgcG9pbnRzU3RyICsgXCInIC8+XCI7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnBvbHlFZGl0b3IuSXNBbmltYXRlZCgpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGFuaW1lU3RyID0gdGhpcy5wb2x5RWRpdG9yLiR2ZXJ0aWNlcy5zdG9wLm1hcChpdGVtID0+IHsgcmV0dXJuIGAke2l0ZW1bMF19LCR7aXRlbVsxXX1gIH0pLmpvaW4oXCIgXCIpO1xuICAgICAgICAgICAgICAgIHZhbHVlICs9IFwiPGFuaW1hdGUgYXR0cmlidXRlTmFtZT0ncG9pbnRzJyBmcm9tPSdcIiArIHBvaW50c1N0ciArIFwiJyB0bz0nXCIgKyBhbmltZVN0ciArIFwiJ1wiO1xuICAgICAgICAgICAgICAgIHZhbHVlICs9IFwiIHN0YXJ0PSdcIiArIHN0YXJ0VGltZSArIFwiJyBlbmQ9J1wiICsgc2FmZUVuZFRpbWUgKyBcIicgLz5cIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWUgKz0gXCI8L3N2Zz5cIjtcblxuICAgICAgICAgICAgbGV0IHBvbHlnb25TZWxlY3RvciA9IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJTdmdTZWxlY3RvclwiLFxuICAgICAgICAgICAgICAgIFwiY29uZm9ybXNUb1wiOiBcImh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9cIiwgLy9hZGRlZCBmb3IgdjJcbiAgICAgICAgICAgICAgICBcInZhbHVlXCI6IGAke3ZhbHVlfWAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjQ4OTg3MjhcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxlY3RvcnNJbkFycmF5KSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3JzLnB1c2gocG9seWdvblNlbGVjdG9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGltZVNlbGVjdG9yW1wicmVmaW5lZEJ5XCJdID0gcG9seWdvblNlbGVjdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGVjdG9yc0luQXJyYXkpIHtcbiAgICAgICAgICAgIHNlbGVjdG9ycy5wdXNoKHRpbWVTZWxlY3Rvcik7ICAgXG4gICAgICAgICAgICB0YXJnZXRbXCJzZWxlY3RvclwiXSA9IHNlbGVjdG9ycztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldFtcInNlbGVjdG9yXCJdID0gdGltZVNlbGVjdG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBHZXRUYWdzUXVlcnkoKSB7XG4gICAgICAgIGlmICh0aGlzLmFubm90YXRvci5hbm5vdGF0aW9uTWFuYWdlciAhPSB1bmRlZmluZWQgJiYgdGhpcy5hbm5vdGF0b3IuYW5ub3RhdGlvbk1hbmFnZXIub25vbXlWb2NhYnVsYXJ5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFubm90YXRvci5hbm5vdGF0aW9uTWFuYWdlci5vbm9teVZvY2FidWxhcnk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXJsOiB0aGlzLmFubm90YXRvci50YWdzVVJMLFxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgICAgICAgIGRlbGF5OiAyNTAsXG4gICAgICAgICAgICBjYWNoZTogdHJ1ZSxcbiAgICAgICAgICAgIG9ub215TGFuZ3VhZ2U6IHRoaXMuYW5ub3RhdG9yLm9ub215TGFuZ3VhZ2UsXG4gICAgICAgICAgICBhbm5vdGF0aW9uTWFuYWdlcjogdGhpcy5hbm5vdGF0b3IuYW5ub3RhdGlvbk1hbmFnZXIsXG4gICAgICAgICAgICBwYXJzZUZ1bmN0aW9uOiB0aGlzLk9ub215Vm9jYWJ1bGFyUHJvY2VzcyxcbiAgICAgICAgICAgIHByb2Nlc3NSZXN1bHRzOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFqYXhPcHRpb25zLnBhcnNlRnVuY3Rpb24oZGF0YSwgdGhpcy5hamF4T3B0aW9ucy5vbm9teUxhbmd1YWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBPbm9teVZvY2FidWxhclByb2Nlc3MoZGF0YSwgb25vbXlMYW5ndWFnZSkgeyAgXG4gICAgICAgIC8vIFBhcnNlIHRoZSBsYWJlbHMgaW50byB0aGUgZm9ybWF0IGV4cGVjdGVkIGJ5IFNlbGVjdDJcbiAgICAgICAgLy8gbXVsdGlsaW5ndWFsIHRhZ3NcbiAgICAgICAgbGV0IG11bHRpbGluZ3VhbF90YWdzID0gW107XG4gICAgICAgIGxldCBtX2NvbW1lbnRzID0ge307XG4gICAgICAgIGxldCBjb21tZW50cyA9IHt9O1xuICAgICAgICBsZXQgbV9pbmRleCA9IDE7XG5cbiAgICAgICAgbGV0IHRhZ3MgPSBbXTtcbiAgICAgICAgbGV0IGluZGV4ID0gMTtcbiAgICAgICAgXG4gICAgICAgIGZvcihsZXQgdGVybSBvZiBkYXRhW1widGVybXNcIl0pe1xuICAgICAgICAgICAgLy9pZiBvbm9teUxhbmd1YWdlIGlzIGRlZmluZWQgY29sbGVjdCBtdWx0aWxpbmd1YWwgdGFnc1xuICAgICAgICAgICAgbGV0IHRlcm1zX2lkID0gdGVybVtcInJkZnM6YWJvdXRcIl07XG4gICAgICAgICAgICBsZXQgdGVybXNfY29tbWVudCA9IHRlcm1bXCJyZGZzOmNvbW1lbnRcIl07XG4gICAgICAgICAgICBpZiAob25vbXlMYW5ndWFnZSAhPSAnJyAmJiB0ZXJtWydsYWJlbHMnXSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgdF9sYWJlbCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgbGV0IHRfY29tbWVudCA9IFwiXCI7XG5cbiAgICAgICAgICAgICAgICAvL2dldCBsYWJlbHNcbiAgICAgICAgICAgICAgICBmb3IobGV0IGxhYmVsIG9mIHRlcm1bXCJsYWJlbHNcIl0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHhtbF9sYW5nID0gbGFiZWxbXCJ4bWw6bGFuZ1wiXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1fbGFiZWwgPSBsYWJlbFtcInJkZnM6bGFiZWxcIl07XG4gICAgICAgICAgICAgICAgICAgIGlmICh4bWxfbGFuZyA9PSBvbm9teUxhbmd1YWdlICYmIG1fbGFiZWwgJiYgbV9sYWJlbC50cmltICE9IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRfbGFiZWwgPSBtX2xhYmVsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vZ2V0IGNvbW1lbnRzXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbGFiZWwgb2YgdGVybVsnY29tbWVudHMnXSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeG1sX2xhbmcgPSBsYWJlbFtcInhtbDpsYW5nXCJdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbV9jb21tZW50ID0gbGFiZWxbXCJyZGZzOmNvbW1lbnRzXCJdOyAvL1RPRE86IGNoYW5nZSB0byBjb21tZW50IGFmdGVyIGZpeGluZyBPbm9teVxuICAgICAgICAgICAgICAgICAgICBpZiAoeG1sX2xhbmcgPT0gb25vbXlMYW5ndWFnZSAmJiBtX2NvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRfY29tbWVudCA9IG1fY29tbWVudDtcbiAgICAgICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyB1c2UgdGhlIHRlcm0gY29tbWVudCB2YWx1ZSBpZiBjb21tZW50IGlzIGJsYW5rXG4gICAgICAgICAgICAgICAgaWYgKHRfY29tbWVudCA9PSB1bmRlZmluZWQgfHwgdF9jb21tZW50LnRyaW0gPT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICB0X2NvbW1lbnQgPSB0ZXJtc19jb21tZW50XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG11bHRpbGluZ3VhbF90YWdzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZDogbV9pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogdF9sYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgdGVybXNfaWQ6IHRlcm1zX2lkLFxuICAgICAgICAgICAgICAgICAgICBjb21tZW50OiB0X2NvbW1lbnRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBtX2luZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgdGFncy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZDogaW5kZXgsXG4gICAgICAgICAgICAgICAgdGV4dDogdGVybVtcInJkZnM6bGFiZWxcIl0sXG4gICAgICAgICAgICAgICAgdGVybXNfaWQ6IHRlcm1bXCJyZGZzOmFib3V0XCJdLFxuICAgICAgICAgICAgICAgIGNvbW1lbnQ6IHRlcm1bXCJyZGZzOmNvbW1lbnRcIl1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJldHVybl90YWdzID0gbXVsdGlsaW5ndWFsX3RhZ3NcbiAgICAgICAgaWYgKHJldHVybl90YWdzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm5fdGFncyA9IHRhZ3NcbiAgICAgICAgfVxuICAgICAgICAvL2NvbnNvbGUubG9nKFwicmV0dXJuX3RhZ3NcIik7XG4gICAgICAgIC8vY29uc29sZS5sb2cocmV0dXJuX3RhZ3MpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdWx0czogcmV0dXJuX3RhZ3MsXG4gICAgICAgIH07XG4gICAgfVxuXG5cblxufVxuXG5leHBvcnQgeyBBbm5vdGF0aW9uR1VJIH07IiwiaW1wb3J0IHsgR2V0Rm9ybWF0dGVkVGltZSB9IGZyb20gXCIuLi8uLi91dGlscy90aW1lLmpzXCI7XG5sZXQgc2hhMSA9IHJlcXVpcmUoJ3NoYTEnKTtcblxuY2xhc3MgSW5kZXhDb250YWluZXIge1xuICAgIGNvbnN0cnVjdG9yKGFubm90YXRvcil7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiW0luZGV4IENvbnRhaW5lcl0gQ3JlYXRpbmcgYW5ub3RhdGlvbiBpbmRleFwiKTtcbiAgICAgICAgdGhpcy5hbm5vdGF0b3IgPSBhbm5vdGF0b3I7XG4gICAgICAgIGxldCBjb250YWluZXIgPSAkKFwiLndhbGRvcmYtaW5kZXhcIik7XG4gICAgICAgIGlmKGNvbnRhaW5lci5sZW5ndGggPiAwKXtcbiAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lciA9IGNvbnRhaW5lci5maXJzdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyID0gJChcIjxkaXYgY2xhc3M9J3dhbGRvcmYtaW5kZXgnIGFyaWEtbGl2ZT0ncG9saXRlJyByb2xlPSduYXZpZ2F0aW9uJz48L2Rpdj5cIikuYXBwZW5kVG8odGhpcy5hbm5vdGF0b3IuJGNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uTGlzdCA9ICQoXCI8dWwgY2xhc3M9J3dhbGRvcmYtYW5ub3RhdGlvbi1saXN0JyByb2xlPSdtZW51YmFyJz48L3VsPlwiKS5hcHBlbmRUbyh0aGlzLiRjb250YWluZXIpO1xuICAgICAgICAvLyBBdHRhY2ggZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgdGhpcy5hbm5vdGF0b3IuJGNvbnRhaW5lci5vbihcIk9uQW5ub3RhdGlvbnNMb2FkZWRcIiwgXG4gICAgICAgICAgICAoZXZlbnQsIGFubm90YXRpb25NYW5hZ2VyKSA9PiB0aGlzLlJlYnVpbGQoKSk7XG4gICAgICAgIHRoaXMuYW5ub3RhdG9yLiRjb250YWluZXIub24oXCJPbkFubm90YXRpb25SZWdpc3RlcmVkXCIsXG4gICAgICAgICAgICAoZXZlbnQsIGFubm90YXRpb24pID0+IHRoaXMuUmVidWlsZCgpKTtcbiAgICAgICAgdGhpcy5hbm5vdGF0b3IuJGNvbnRhaW5lci5vbihcIk9uQW5ub3RhdGlvblJlbW92ZWRcIixcbiAgICAgICAgICAgIChldmVudCwgaWQpID0+IHRoaXMuUmVidWlsZCgpKTsgICAgICAgICAgICBcblxuICAgIH1cblxuICAgIFJlYnVpbGQoKXtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uTGlzdC5lbXB0eSgpO1xuICAgICAgICAvLyBpZih0aGlzLmFubm90YXRvci51bnJlbmRlcmVyKSB0aGlzLmFubm90YXRvci51bnJlbmRlcmVyKHRoaXMuYW5ub3RhdG9yKTtcblxuICAgICAgICAvLyBsZXQgcGx1cmFsID0gYW5ub3RhdGlvbnMubGVuZ3RoID09IDEgPyBcIlwiIDogXCJzXCI7XG4gICAgICAgIC8vIGxldCB0b3RhbEFubm90YXRpb25zID0gdGhpcy5hbm5vdGF0b3IuYW5ub3RhdGlvbk1hbmFnZXIuYW5ub3RhdGlvbnMubGVuZ3RoO1xuICAgICAgICAvLyB0aGlzLiRjb250YWluZXIuaHRtbChgPHA+U2hvd2luZyAke2Fubm90YXRpb25zLmxlbmd0aH0gYW5ub3RhdGlvbiR7cGx1cmFsfSAoJHt0b3RhbEFubm90YXRpb25zfSB0b3RhbCkuPC9wPmApO1xuXG4gICAgICAgIC8vIEFkZCBlYWNoIGFubm90YXRpb24gdG8gdGhlIHJlYWRvdXRcbiAgICAgICAgbGV0IG9yZGVyZWQgPSB0aGlzLmFubm90YXRvci5HZXRBbm5vdGF0aW9ucygpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yZGVyZWQubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdGhpcy5hbm5vdGF0aW9uTGlzdC5hcHBlbmQodGhpcy5NYWtlQ29udGFpbmVyKHRoaXMuYW5ub3RhdG9yLCBvcmRlcmVkW2ldLCBpKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBNYWtlQ29udGFpbmVyKGFubm90YXRvciwgYW5ub3RhdGlvbil7XG4gICAgICAgIC8vVE9ETzogQVJJQSBhbmQgZ2VuZXJhbCBzY3JlZW4gcmVhZGVyIGNvbXBhdGliaWxpdHlcbiAgICAgICAgbGV0ICRwYW5lbCA9ICQoXCI8bGkgcm9sZT0ncHJlc2VudGF0aW9uJyBkYXRhLWNyZWF0b3I9XCIrYW5ub3RhdGlvbi5jcmVhdG9yLmVtYWlsK1wiIGRhdGEtdGFncz0nXCIrYW5ub3RhdGlvbi50YWdzLmpvaW4oXCIsIFwiKS5yZXBsYWNlKFwiJ1wiLCBcIiUyN1wiKStcIic+PC9saT5cIik7XG4gICAgICAgIC8vbGV0IHRleHQgPSBKU09OLnN0cmluZ2lmeShhbm5vdGF0aW9uLkFzT3BlbkFubm90YXRpb24oKSwgbnVsbCwgMik7XG5cbiAgICAgICAgbGV0IGhlYWRlclRleHQgPSBHZXRGb3JtYXR0ZWRUaW1lKGFubm90YXRpb24uYmVnaW5UaW1lKSArIFwiIC0gXCIgKyBHZXRGb3JtYXR0ZWRUaW1lKGFubm90YXRpb24uZW5kVGltZSk7XG4gXG4gICAgICAgIC8vIEFkZCBjbGlja2FibGUgaGVhZGVyIHRoYXQgYnJpbmdzIHVwIHRoZSBlZGl0IGludGVyZmFjZS5cbiAgICAgICAgbGV0ICRoZWFkZXIgPSAkKFwiPGEgaHJlZj0nJyB0aXRsZT0nR28gdG8gQW5ub3RhdGlvbicgcm9sZT0nbWVudWl0ZW0nPlwiK2hlYWRlclRleHQrXCI8L2E+PGJyPlwiKTtcbiAgICAgICAgJGhlYWRlci5jbGljayggKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgYW5ub3RhdG9yLnBsYXllci52aWRlb0VsZW1lbnQuY3VycmVudFRpbWUgPSBhbm5vdGF0aW9uLmJlZ2luVGltZTtcbiAgICAgICAgICAgIC8vIGlmKGFubm90YXRvci5wbGF5ZXIudmlkZW9FbGVtZW50LmFubm90YXRpb25UaW1lb3V0KSBjbGVhclRpbWVvdXQoYW5ub3RhdG9yLnBsYXllci52aWRlb0VsZW1lbnQuYW5ub3RhdGlvblRpbWVvdXQpO1xuICAgICAgICAgICAgLy8gYW5ub3RhdG9yLnBsYXllci52aWRlb0VsZW1lbnQuYW5ub3RhdGlvblRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAvLyAgICAgYW5ub3RhdG9yLnBsYXllci52aWRlb0VsZW1lbnQucGF1c2UoKX0sIChhbm5vdGF0aW9uLmVuZFRpbWUtYW5ub3RhdGlvbi5iZWdpblRpbWUpICogMTAwMFxuICAgICAgICAgICAgLy8gKTtcbiAgICAgICAgICAgIC8vYW5ub3RhdG9yLnBsYXllci52aWRlb0VsZW1lbnQuc3JjPWFubm90YXRvci51cmwgKyBcIiN0PVwiICsgYW5ub3RhdGlvbi5iZWdpblRpbWUgK1wiLFwiK2Fubm90YXRpb24uZW5kVGltZTtcbiAgICAgICAgICAgIC8vYW5ub3RhdG9yLnBsYXllci52aWRlb0VsZW1lbnQucGxheSgpO1xuICAgICAgICAgICAgYW5ub3RhdG9yLnBsYXllci5QbGF5KCk7XG4gICAgICAgICAgICBhbm5vdGF0b3IucGxheWVyLmVuZFRpbWUgPSBhbm5vdGF0aW9uLmVuZFRpbWU7XG4gICAgICAgICAgICBpZihhbm5vdGF0aW9uLmJlZ2luVGltZSsxID4gYW5ub3RhdGlvbi5lbmRUaW1lKXtcbiAgICAgICAgICAgICAgICBhbm5vdGF0b3IucGxheWVyLlBhdXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgICRwYW5lbC5hcHBlbmQoJGhlYWRlcik7XG4gICAgICAgIGxldCAkY29udGVudCA9ICQoXCI8cD48L3A+XCIpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAkY29udGVudC5hcHBlbmQoXCI8Yj5UZXh0OiA8L2I+IFwiICsgYW5ub3RhdGlvbi5ib2R5LmZpbHRlcihpdGVtID0+IGl0ZW0ucHVycG9zZSA9PT0gXCJkZXNjcmliaW5nXCIpWzBdLnZhbHVlKTtcbiAgICAgICAgJGNvbnRlbnQuYXBwZW5kKFwiPGJyPlwiKTtcbiAgICAgICAgJGNvbnRlbnQuYXBwZW5kKFwiPGI+VGFnczogPC9iPiBcIiArIGFubm90YXRpb24udGFncy5qb2luKFwiLCBcIikpO1xuICAgICAgICAkY29udGVudC5hcHBlbmQoXCI8YnI+XCIpO1xuXG4gICAgICAgICRwYW5lbC5hcHBlbmQoJGNvbnRlbnQpO1xuICAgICAgICAkcGFuZWwuYXBwZW5kVG8oYW5ub3RhdG9yLiRhbm5vdGF0aW9uTGlzdCk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCRwYW5lbCk7XG4gICAgICAgIHJldHVybiAkcGFuZWw7XG4gICAgfVxuXG59XG5cbmV4cG9ydCB7IEluZGV4Q29udGFpbmVyIH07IiwiaW1wb3J0IHsgR2V0Rm9ybWF0dGVkVGltZSB9IGZyb20gXCIuLi8uLi91dGlscy90aW1lLmpzXCI7XG5sZXQgc2hhMSA9IHJlcXVpcmUoJ3NoYTEnKTtcblxuY2xhc3MgSW5mb0NvbnRhaW5lciB7XG4gICAgY29uc3RydWN0b3IoYW5ub3RhdG9yKXtcbiAgICAgICAgdGhpcy5hbm5vdGF0b3IgPSBhbm5vdGF0b3I7XG4gICAgICAgIGxldCBjb250YWluZXIgPSAkKFwiLndhbGRvcmYtaW5mb1wiKTtcbiAgICAgICAgaWYoY29udGFpbmVyLmxlbmd0aCA+IDApe1xuICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyID0gY29udGFpbmVyLmZpcnN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiRjb250YWluZXIgPSAkKFwiPGRpdiBjbGFzcz0nd2FsZG9yZi1pbmZvJyBhcmlhLWxpdmU9J3BvbGl0ZScgYXJpYS1hdG9taWM9J3RydWUnPjwvZGl2PlwiKS5hcHBlbmRUbyh0aGlzLmFubm90YXRvci4kY29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIFJlYnVpbGQoYW5ub3RhdGlvbnMsIGNsZWFyQ29udGFpbmVyKXtcbiAgICAgICAgaWYoY2xlYXJDb250YWluZXIpIHRoaXMuJGNvbnRhaW5lci5lbXB0eSgpO1xuICAgICAgICBpZih0aGlzLmFubm90YXRvci51bnJlbmRlcmVyKSB0aGlzLmFubm90YXRvci51bnJlbmRlcmVyKHRoaXMuYW5ub3RhdG9yKTtcblxuICAgICAgICAvLyBsZXQgcGx1cmFsID0gYW5ub3RhdGlvbnMubGVuZ3RoID09IDEgPyBcIlwiIDogXCJzXCI7XG4gICAgICAgIC8vIGxldCB0b3RhbEFubm90YXRpb25zID0gdGhpcy5hbm5vdGF0b3IuYW5ub3RhdGlvbk1hbmFnZXIuYW5ub3RhdGlvbnMubGVuZ3RoO1xuICAgICAgICAvLyB0aGlzLiRjb250YWluZXIuaHRtbChgPHA+U2hvd2luZyAke2Fubm90YXRpb25zLmxlbmd0aH0gYW5ub3RhdGlvbiR7cGx1cmFsfSAoJHt0b3RhbEFubm90YXRpb25zfSB0b3RhbCkuPC9wPmApO1xuXG4gICAgICAgIC8vIEFkZCBlYWNoIGFubm90YXRpb24gdG8gdGhlIHJlYWRvdXRcbiAgICAgICAgbGV0IHJlbmRlcmVyID0gdGhpcy5hbm5vdGF0b3IucmVuZGVyZXIgPT09IGZhbHNlID8gdGhpcy5NYWtlQ29udGFpbmVyIDogdGhpcy5hbm5vdGF0b3IucmVuZGVyZXI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYW5ub3RhdGlvbnMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyLmFwcGVuZChyZW5kZXJlcih0aGlzLmFubm90YXRvciwgYW5ub3RhdGlvbnNbaV0sIGkpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIE1ha2VDb250YWluZXIoYW5ub3RhdG9yLCBhbm5vdGF0aW9uLCBpbmRleCl7XG4gICAgICAgIGxldCAkcGFuZWwgPSAkKFwiPHA+PC9wPlwiKS5hcHBlbmRUbygkKFwiPGRpdj48L2Rpdj5cIikuYXBwZW5kVG8oYW5ub3RhdG9yLiRjb250YWluZXIpKTtcbiAgICAgICAgLy9sZXQgdGV4dCA9IEpTT04uc3RyaW5naWZ5KGFubm90YXRpb24uQXNPcGVuQW5ub3RhdGlvbigpLCBudWxsLCAyKTtcblxuICAgICAgICAvLyBBZGQgY2xpY2thYmxlIGhlYWRlciB0aGF0IGJyaW5ncyB1cCB0aGUgZWRpdCBpbnRlcmZhY2UuXG4gICAgICAgIGxldCAkaGVhZGVyID0gJChgPGI+QW5ub3RhdGlvbiAke2luZGV4ICsgMX06PC9iPjxicj5gKTtcbiAgICAgICAgaWYoYW5ub3RhdG9yLmtpb3NrTW9kZT09ZmFsc2Upe1xuICAgICAgICAgICAgJGhlYWRlciA9ICQoYDxhIGhyZWY9JycgdGl0bGU9J0VkaXQgQW5ub3RhdGlvbic+PGI+QW5ub3RhdGlvbiAke2luZGV4ICsgMX06PC9iPjxicj48L2E+YCk7XG4gICAgICAgICAgICAkaGVhZGVyLmNsaWNrKCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGFubm90YXRvci5ndWkuQmVnaW5FZGl0aW5nKGFubm90YXRpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAkcGFuZWwuYXBwZW5kKCRoZWFkZXIpO1xuICAgICAgICBsZXQgJGNvbnRlbnQgPSAkKFwiPHA+PC9wPlwiKTtcbiAgICAgICAgXG4gICAgICAgIGlmICgndW5kZWZpbmVkJyA9PSB0eXBlb2YoYW5ub3RhdGlvbi5pdGVtcykpIHsgLy8gVmVyc2lvbiAxXG4gICAgICAgICAgICB2YXIgYW5ub3RhdGlvbl9ib2R5ID0gYW5ub3RhdGlvbi5ib2R5LmZpbHRlcihpdGVtID0+IGl0ZW0ucHVycG9zZSA9PT0gXCJkZXNjcmliaW5nXCIpWzBdO1xuICAgICAgICAgICAgdmFyIGFubm90YXRpb25fY3JlYXRvciA9IChhbm5vdGF0aW9uLmNyZWF0b3IgIT0gbnVsbCkgPyBhbm5vdGF0aW9uLmNyZWF0b3IgOiB7fTtcbiAgICAgICAgfSBlbHNlIHsgLy8gVmVyc2lvbiAyXG4gICAgICAgICAgICB2YXIgYW5ub3RhdGlvbl9ib2R5ID0gYW5ub3RhdGlvbi5pdGVtc1swXS5pdGVtc1swXS5pdGVtc1swXS5ib2R5LmZpbHRlcihpdGVtID0+IGl0ZW0ucHVycG9zZSA9PT0gXCJkZXNjcmliaW5nXCIpWzBdO1xuICAgICAgICAgICAgdmFyIGFubm90YXRpb25fY3JlYXRvciA9IGFubm90YXRpb24uaXRlbXNbMF0uaXRlbXNbMF0uaXRlbXNbMF0uY3JlYXRvcjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgJGNvbnRlbnQuYXBwZW5kKFwiPGI+VGV4dDogPC9iPiBcIiArIGFubm90YXRpb25fYm9keS52YWx1ZSk7XG4gICAgICAgICRjb250ZW50LmFwcGVuZChcIjxicj5cIik7XG4gICAgICAgICRjb250ZW50LmFwcGVuZChcIjxiPlRhZ3M6IDwvYj4gXCIgKyBhbm5vdGF0aW9uLnRhZ3Muam9pbihcIiwgXCIpKTtcbiAgICAgICAgJGNvbnRlbnQuYXBwZW5kKFwiPGJyPlwiKTtcbiAgICAgICAgJGNvbnRlbnQuYXBwZW5kKFwiPGI+VGltZTogPC9iPiBcIiBcbiAgICAgICAgICAgICAgICArIEdldEZvcm1hdHRlZFRpbWUoYW5ub3RhdGlvbi5iZWdpblRpbWUpIFxuICAgICAgICAgICAgICAgICsgXCIgLSBcIiBcbiAgICAgICAgICAgICAgICArIEdldEZvcm1hdHRlZFRpbWUoYW5ub3RhdGlvbi5lbmRUaW1lKSk7XG4gICAgICAgICRjb250ZW50LmFwcGVuZChcIjxicj5cIik7XG5cbiAgICAgICAgJGNvbnRlbnQuYXBwZW5kKFwiPGI+U3VibWl0dGVyOjwvYj4gXCJcbiAgICAgICAgICAgICAgICArICgoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mKGFubm90YXRpb25fY3JlYXRvci5uaWNrbmFtZSkgJiYgYW5ub3RhdGlvbl9jcmVhdG9yLm5pY2tuYW1lLmxlbmd0aCkgPyBhbm5vdGF0aW9uX2NyZWF0b3Iubmlja25hbWUgOiBcIjxpPk5vdCBhdmFpbGFibGU8L2k+XCIpXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAvLyRwYXJhZ3JhcGguYXBwZW5kKFwiPHN0cm9uZz5Bbm5vdGF0aW9uIFwiICsgKGluZGV4ICsgMSkgKyBcIjo8L3N0cm9uZz48YnI+PHByZT5cIiArIHRleHQuZXNjYXBlSFRNTCgpICsgXCI8L3ByZT5cIik7XG5cbiAgICAgICAgJHBhbmVsLmFwcGVuZCgkY29udGVudCk7XG4gICAgICAgIHJldHVybiAkcGFuZWw7XG4gICAgfVxuXG59XG5cbmV4cG9ydCB7IEluZm9Db250YWluZXIgfTsiLCJcbmNsYXNzIE1lc3NhZ2VPdmVybGF5IHtcbiAgICBjb25zdHJ1Y3Rvcihhbm5vdGF0b3Ipe1xuICAgICAgICB0aGlzLmFubm90YXRvciA9IGFubm90YXRvcjtcblxuICAgICAgICB0aGlzLiRjb250YWluZXIgPSAkKFwiPGRpdiBjbGFzcz0nd2FsZG9yZi1tZXNzYWdlLW92ZXJsYXknPjwvZGl2PlwiKTtcbiAgICAgICAgdGhpcy4kY29udGFpbmVyLmFwcGVuZFRvKHRoaXMuYW5ub3RhdG9yLnBsYXllci4kY29udGFpbmVyKTtcblxuICAgICAgICB0aGlzLiR0ZXh0ID0gJChcIjxwIHJvbGU9J2FsZXJ0JyBhcmlhLWxpdmU9J2Fzc2VydGl2ZScgYXJpYS1hdG9taWM9J3RydWUnPjwvcD5cIikuYXBwZW5kVG8odGhpcy4kY29udGFpbmVyKTtcbiAgICAgICAgdGhpcy4kY29udGFpbmVyLmZhZGVPdXQoMCk7XG5cbiAgICB9XG5cbiAgICBTaG93RXJyb3IobWVzc2FnZSwgZHVyYXRpb24gPSAzLjApe1xuICAgICAgICB0aGlzLiRjb250YWluZXIuYWRkQ2xhc3MoXCJ3YWxkb3JmLW1lc3NhZ2Utb3ZlcmxheS1lcnJvclwiKTtcblxuICAgICAgICB0aGlzLl9TaG93VGV4dChtZXNzYWdlLCBkdXJhdGlvbik7XG4gICAgfVxuXG4gICAgU2hvd01lc3NhZ2UobWVzc2FnZSwgZHVyYXRpb24gPSA1LjApe1xuICAgICAgICB0aGlzLiRjb250YWluZXIucmVtb3ZlQ2xhc3MoXCJ3YWxkb3JmLW1lc3NhZ2Utb3ZlcmxheS1lcnJvclwiKTtcblxuICAgICAgICB0aGlzLl9TaG93VGV4dChtZXNzYWdlLCBkdXJhdGlvbik7XG4gICAgfVxuXG4gICAgX1Nob3dUZXh0KG1lc3NhZ2UsIGR1cmF0aW9uID0gNS4wKXtcbiAgICAgICAgdGhpcy4kdGV4dC5odG1sKG1lc3NhZ2UpO1xuICAgICAgICAvL3RoaXMuJGNvbnRhaW5lci5zdG9wKHRydWUsIHRydWUpO1xuICAgICAgICB0aGlzLiRjb250YWluZXIuZmluaXNoKCk7XG4gICAgICAgIHRoaXMuJGNvbnRhaW5lci5cbiAgICAgICAgICAgIGZhZGVJbigwKS5cbiAgICAgICAgICAgIGRlbGF5KGR1cmF0aW9uICogMTAwMCkuXG4gICAgICAgICAgICBmYWRlT3V0KDQwMCk7XG4gICAgfVxuXG59XG5cbmV4cG9ydCB7IE1lc3NhZ2VPdmVybGF5IH07IiwiXG4vKipcbiAqIE1hbmFnZXMgdGhlIGNyZWF0aW5nIG9yIGVkaXRpbmcgb2YgYSBzaW5nbGUgcG9seWdvbiBvbiB0aGUgdmlkZW8uXG4gKiBDb25zaXN0cyBvZiBhIHRvb2xiYXIsIGFuIG92ZXJsYXksIGFuZCB0aGUgcG9seWdvbiBpbnNpZGUgdGhlIG92ZXJsYXkuXG4gKlxuICogQ2xpY2sgdG8gcGxhY2Ugb3IgcmVtb3ZlIGEgZHJhZ2dhYmxlIHBvaW50LiBQb2ludHMgc2hvdWxkIGJlXG4gKiBwdXQgZG93biBpbiBjbG9ja3dpc2Ugb3JkZXIuXG4gKi9cbmNsYXNzIFBvbHlnb25FZGl0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGFubm90YXRvcil7XG4gICAgICAgIHRoaXMuYW5ub3RhdG9yID0gYW5ub3RhdG9yO1xuICAgICAgICB0aGlzLmJhc2VaID0gMjE0NzQ4MzY0OTtcbiAgICAgICAgdGhpcy4kYnJlYWRjcnVtYnMgPSBbXTtcbiAgICAgICAgdGhpcy4kdmVydGljZXMgPSB7ICdzdGFydCc6IFtdLCAnc3RvcCc6IFtdIH07ICAgLy9hcnJheXMgb2YgdmVydGljZXMgZm9yIHN0YXJ0L3N0b3AgcG9seXNcbiAgICAgICAgdGhpcy4kcG9seWdvbnMgPSB7ICdzdGFydCc6IG51bGwsICdzdG9wJzogbnVsbCB9OyAgIC8vRE9NIG5vZGVzIGZvciB0aGUgYWN0dWFsIHBvbHlnb25zXG4gICAgICAgIC8vIHRoaXMuJHRlbXBCcmVhZENydW1icyA9IFtdO1xuICAgICAgICB0aGlzLiRzdGFydFN0b3AgPSBudWxsO1xuXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgdmlkZW8gb3ZlcmxheVxuICAgICAgICB0aGlzLiRjbGlja1N1cmZhY2UgPSAkKFwiPGRpdiBjbGFzcz0nd2FsZG9yZi1lZGl0LW92ZXJsYXkgd2FsZG9yZi12cC1jbGljay1zdXJmYWNlJz48L2Rpdj5cIikuYXBwZW5kVG8odGhpcy5hbm5vdGF0b3IucGxheWVyLiRjb250YWluZXIpO1xuICAgICAgICAvL3RoaXMuJGNsaWNrU3VyZmFjZS5jc3MoXCJ6LWluZGV4XCIsIHRoaXMuYmFzZVopO1xuICAgICAgICB0aGlzLiRjbGlja1N1cmZhY2UuY2xpY2soKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLk9uU3VyZmFjZUNsaWNrKGV2ZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgcG9seWdvbiBET00gbm9kZXNcbiAgICAgICAgdGhpcy4kcG9seWdvbnMuc3RhcnQgPSAkKFwiPGRpdiBjbGFzcz0nd2FsZG9yZi1zdGFydC1wb2x5Jz48L2Rpdj5cIikuYXBwZW5kVG8odGhpcy4kY2xpY2tTdXJmYWNlKTtcbiAgICAgICAgdGhpcy4kcG9seWdvbnMuc3RhcnQuY3NzKFwiei1pbmRleFwiLCB0aGlzLmJhc2VaICsgMSk7XG4gICAgICAgIHRoaXMuJHBvbHlnb25zLnN0b3AgPSAkKFwiPGRpdiBjbGFzcz0nd2FsZG9yZi1zdG9wLXBvbHknPjwvZGl2PlwiKS5hcHBlbmRUbyh0aGlzLiRjbGlja1N1cmZhY2UpO1xuICAgICAgICB0aGlzLiRwb2x5Z29ucy5zdG9wLmNzcyhcInotaW5kZXhcIiwgdGhpcy5iYXNlWiArIDEpO1xuXG4gICAgICAgIHRoaXMuUmVzaXplT3ZlcmxheSgpO1xuICAgICAgICB0aGlzLmFubm90YXRvci5wbGF5ZXIuJGNvbnRhaW5lci5vbihcIk9uRnVsbHNjcmVlbkNoYW5nZVwiLCAoZXZlbnQsIHNldEZ1bGxzY3JlZW4pID0+IHRoaXMuUmVzaXplT3ZlcmxheSgpKTtcblxuICAgICAgICAvLyBDcmVhdGUgdGhlIHRvb2xiYXIgdXAgdG9wXG4gICAgICAgIC8vIHRoaXMuJGJhciA9ICQoXCI8ZGl2IGNsYXNzPSd3YWxkb3JmLXZwLXBvc3QnPjwvZGl2PlwiKS5hcHBlbmRUbyh0aGlzLmFubm90YXRvci5wbGF5ZXIuJGNvbnRhaW5lcik7XG4gICAgICAgIC8vIHRoaXMuJHBvc3RUb29sYmFyID0gJChcIjxkaXYgY2xhc3M9J2ZsZXgtdG9vbGJhcic+PC9kaXY+XCIpLmFwcGVuZFRvKHRoaXMuJGJhcik7XG4gICAgICAgIC8vIEludmlzaWJsZSBleHBhbmRpbmcgZGl2aWRlclxuICAgICAgICAvLy0zLy90aGlzLiRwb3N0VG9vbGJhci5hcHBlbmQoJChcIjxkaXY+PHAgc3R5bGU9J2NvbG9yOndoaXRlJz5FZGl0IFBvbHlnb248L3A+PC9kaXY+XCIpLmNzcyhcImZsZXgtZ3Jvd1wiLCAxKS5jc3MoXCJvcmRlclwiLCAwKSk7XG5cblxuICAgICAgICAvLyBNYWtlIFwiQ29sbGVjdCBQb2x5Z29uIHN0YXRlXCIgYnV0dG9uXG4gICAgICAgIC8vIHRoaXMuJGNhcFBvbHlCdXR0b24gPSAkKFwiPGJ1dHRvbj5DYXB0dXJlIFBvbHlnb248L2J1dHRvbj5cIikuYnV0dG9uKHtcbiAgICAgICAgLy8gICAgIGljb246IFwiZmEgZmEtY2FtZXJhLXJldHJvXCIsXG4gICAgICAgIC8vICAgICBzaG93TGFiZWw6IGZhbHNlXG4gICAgICAgIC8vIH0pLmNsaWNrKCgpID0+IHtcbiAgICAgICAgLy8gICAgIC8vdGhpcy5TZXRWaXNpYmxlKGZhbHNlKTtcbiAgICAgICAgLy8gICAgIC8vdGhpcy5HZXRQb2ludHMoKTtcblxuICAgICAgICAvLyAgICAgLy8gQnVpbGQgcG9seWdvbiBzZWxlY3RvclxuICAgICAgICAvLyAgICAgLy8gbGV0IHBvaW50cyA9IHRoaXMuR2V0UG9pbnRzKCk7XG4gICAgICAgIC8vICAgICAvLyBpZihwb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyAgICAgLy8gICAgIGxldCBwb2ludHNTdHIgPSBwb2ludHMubWFwKGl0ZW0gPT4geyByZXR1cm4gYCR7aXRlbVswXX0sJHtpdGVtWzFdfWAgfSkuam9pbihcIiBcIik7XG4gICAgICAgIC8vICAgICAvLyAgICAgbGV0IHBvbHlnb25TZWxlY3RvciA9IHtcbiAgICAgICAgLy8gICAgIC8vICAgICAgICAgXCJ0eXBlXCI6IFwiU3ZnU2VsZWN0b3JcIixcbiAgICAgICAgLy8gICAgIC8vICAgICAgICAgXCJ2YWx1ZVwiOiBgPHN2Zzpzdmcgdmlld0JveD0nMCAwIDEwMCAxMDAnIHByZXNlcnZlQXNwZWN0UmF0aW89J25vbmUnPjxwb2x5Z29uIHBvaW50cz0nJHtwb2ludHNTdHJ9JyAvPjwvc3ZnOnN2Zz5gIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI0ODk4NzI4XG4gICAgICAgIC8vICAgICAvLyAgICAgfVxuICAgICAgICAvLyAgICAgLy8gICAgIHRtcFNlbGVjdG9ycy5wdXNoKHBvbHlnb25TZWxlY3Rvcik7XG4gICAgICAgIC8vICAgICAvLyB9XG4gICAgICAgIC8vICAgICAvLyBjb25zb2xlLmxvZyhcInRtcFNlbGVjdG9yc1wiKTtcbiAgICAgICAgLy8gICAgIC8vIGNvbnNvbGUubG9nKHRtcFNlbGVjdG9ycyk7XG4gICAgICAgIC8vICAgICB0aGlzLmFubm90YXRvci5BZGRQb2x5Z29uU2V0KHRoaXMuYW5ub3RhdG9yLmFubm90YXRpb24uZ2V0UG9seSgpKTtcblxuICAgICAgICAvLyB9KTtcbiAgICAgICAgLy8gdGhpcy4kY2FwUG9seUJ1dHRvbi5jc3MoXCJtYXJnaW4tcmlnaHRcIiwgXCIxNXB4XCIpO1xuICAgICAgICAvLyB0aGlzLiRjYXBQb2x5QnV0dG9uLmF0dHIoJ3RpdGxlJywgXCJDYXB0dXJlIHBvbHlnb25cIik7XG4gICAgICAgIC8vLTMvL3RoaXMuUmVnaXN0ZXJFbGVtZW50KHRoaXMuJGNhcFBvbHlCdXR0b24sIHRoaXMuJHBvc3RUb29sYmFyLCAxLCAnZmxleC1lbmQnKTtcblxuICAgICAgICAvLyBDcmVhdGUgdW5kbyBidXR0b25cbiAgICAgICAgLy8gdGhpcy4kdW5kb0J1dHRvbiA9ICQoXCI8YnV0dG9uPlJlbW92ZSBMYXN0IFBvaW50PC9idXR0b24+XCIpLmJ1dHRvbih7XG4gICAgICAgIC8vICAgICBpY29uOiBcImZhIGZhLXVuZG9cIixcbiAgICAgICAgLy8gICAgIHNob3dMYWJlbDogZmFsc2VcbiAgICAgICAgLy8gfSk7XG4gICAgICAgIC8vIHRoaXMuJHVuZG9CdXR0b24uY3NzKFwibWFyZ2luLXJpZ2h0XCIsIFwiMTVweFwiKTtcbiAgICAgICAgLy8gdGhpcy4kdW5kb0J1dHRvbi5hdHRyKCd0aXRsZScsIFwiUmVtb3ZlIGxhc3QgcG9pbnRcIik7XG4gICAgICAgIC8vIHRoaXMuJHVuZG9CdXR0b24uY2xpY2soKCkgPT4ge1xuICAgICAgICAvLyAgICAgdGhpcy5SZW1vdmVMYXN0QnJlYWRjcnVtYigpO1xuICAgICAgICAvLyB9KTtcbiAgICAgICAgLy8tMy8vdGhpcy5SZWdpc3RlckVsZW1lbnQodGhpcy4kdW5kb0J1dHRvbiwgdGhpcy4kcG9zdFRvb2xiYXIsIDEsICdmbGV4LWVuZCcpO1xuXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgY29uZmlybSBidXR0b25cbiAgICAgICAgLy8gdGhpcy4kY29uZmlybUJ1dHRvbiA9ICQoXCI8YnV0dG9uPkZpbmlzaCBwb2x5Z29uPC9idXR0b24+XCIpLmJ1dHRvbih7XG4gICAgICAgIC8vICAgICBpY29uOiBcImZhIGZhLWNoZWNrXCIsXG4gICAgICAgIC8vICAgICBzaG93TGFiZWw6IGZhbHNlXG4gICAgICAgIC8vIH0pO1xuICAgICAgICAvLyB0aGlzLiRjb25maXJtQnV0dG9uLmF0dHIoJ3RpdGxlJywgXCJGaW5pc2ggcG9seWdvblwiKTtcbiAgICAgICAgLy8gdGhpcy4kY29uZmlybUJ1dHRvbi5hZGRDbGFzcyhcIndhbGRvcmYtY29uZmlybS1idXR0b25cIik7XG4gICAgICAgIC8vIHRoaXMuJGNvbmZpcm1CdXR0b24uY2xpY2soKCkgPT4ge1xuICAgICAgICAvLyAgICAgdGhpcy5vcmlnaW5hbEpTT04gPSB0aGlzLkdldEpTT04oKTtcbiAgICAgICAgLy8gICAgIHRoaXMuRG9uZSgpO1xuICAgICAgICAvLyAgICAgdGhpcy5hbm5vdGF0b3IuJGNvbnRhaW5lci50cmlnZ2VyKFwiT25Qb2x5Z29uRWRpdGluZ0VuZGVkXCIpO1xuICAgICAgICAvLyB9KTtcbiAgICAgICAgLy8gLy8tMy8vdGhpcy5SZWdpc3RlckVsZW1lbnQodGhpcy4kY29uZmlybUJ1dHRvbiwgdGhpcy4kcG9zdFRvb2xiYXIsIDMsICdmbGV4LWVuZCcpO1xuXG4gICAgICAgIC8vIC8vIENyZWF0ZSB0aGUgY2FuY2VsIGJ1dHRvblxuICAgICAgICAvLyB0aGlzLiRjYW5jZWxCdXR0b24gPSAkKFwiPGJ1dHRvbj5TdG9wIHBvbHlnb24gZWRpdGluZzwvYnV0dG9uPlwiKS5idXR0b24oe1xuICAgICAgICAvLyAgICAgaWNvbjogXCJmYSBmYS1yZW1vdmVcIixcbiAgICAgICAgLy8gICAgIHNob3dMYWJlbDogZmFsc2VcbiAgICAgICAgLy8gfSk7XG4gICAgICAgIC8vIHRoaXMuJGNhbmNlbEJ1dHRvbi5hZGRDbGFzcyhcIndhbGRvcmYtY2FuY2VsLWJ1dHRvblwiKTtcbiAgICAgICAgLy8gdGhpcy4kY2FuY2VsQnV0dG9uLmF0dHIoJ3RpdGxlJywgXCJTdG9wIHBvbHlnb24gZWRpdGluZ1wiKTtcbiAgICAgICAgLy8gdGhpcy4kY2FuY2VsQnV0dG9uLmNsaWNrKCgpID0+IHtcbiAgICAgICAgLy8gICAgIC8vUmVzdG9yZSB0aGUgb3JpZ2luYWwgc3RhdGVcbiAgICAgICAgLy8gICAgIHRoaXMuUmVzdG9yZSgpO1xuICAgICAgICAvLyAgICAgdGhpcy5Eb25lKCk7XG4gICAgICAgIC8vICAgICB0aGlzLmFubm90YXRvci4kY29udGFpbmVyLnRyaWdnZXIoXCJPblBvbHlnb25FZGl0aW5nRW5kZWRcIik7XG4gICAgICAgIC8vIH0pO1xuICAgICAgICAvLyAvLy0zLy90aGlzLlJlZ2lzdGVyRWxlbWVudCh0aGlzLiRjYW5jZWxCdXR0b24sIHRoaXMuJHBvc3RUb29sYmFyLCAyLCAnZmxleC1lbmQnKTtcblxuICAgICAgICAvLyAkKHdpbmRvdykucmVzaXplKCgpID0+IHRoaXMuUmVzaXplT3ZlcmxheSgpKTtcblxuXG4gICAgICAgIC8qIFxuICAgICAgICAqIG5ldyBVSVxuICAgICAgICAqL1xuICAgICAgICB0aGlzLiRlZGl0RGlhbG9nID0gJChcIjxkaXYgaWQ9J2VkaXQtZGlhbG9nJyBjbGFzcz0nd2FsZG9yZi1lZGl0LW92ZXJsYXkgd2FsZG9yZi12cC1jbGljay1zdXJmYWNlJz48L2Rpdj5cIikuYXBwZW5kVG8odGhpcy5hbm5vdGF0b3IucGxheWVyLiRjb250YWluZXIpO1xuICAgICAgICB0aGlzLiRlZGl0RGlhbG9nLmRyYWdnYWJsZSgpO1xuICAgICAgICB0aGlzLiRlZGl0RGlhbG9nLmNzcygnei1pbmRleCcsIHRoaXMuYmFzZVogKyAxMDApO1xuICAgICAgICB0aGlzLiRlZGl0RGlhbG9nLmNsaWNrKChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5PblN1cmZhY2VDbGljayhldmVudCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuJHNwYWNlID0gJChcIjxkaXY+Jm5ic3A7PC9kaXY+PGhyPlwiKTtcbiAgICAgICAgdGhpcy5SZWdpc3RlckVsZW1lbnQodGhpcy4kc3BhY2UsIHRoaXMuJGVkaXREaWFsb2csIDEsICdmbGV4LWVuZCcpO1xuXG4gICAgICAgIC8vIENyZWF0ZSB1bmRvIGJ1dHRvblxuICAgICAgICB0aGlzLiR1bmRvQnV0dG9uID0gJChcIjxidXR0b24+UmVtb3ZlIExhc3QgUG9pbnQ8L2J1dHRvbj5cIikuYnV0dG9uKHtcbiAgICAgICAgICAgIGljb246IFwiZmEgZmEtdW5kb1wiLFxuICAgICAgICAgICAgc2hvd0xhYmVsOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4kdW5kb0J1dHRvbi5jc3MoXCJtYXJnaW5cIiwgXCIwcHggNXB4IDRweCA1cHhcIik7XG4gICAgICAgIHRoaXMuJHVuZG9CdXR0b24uYXR0cigndGl0bGUnLCBcIlJlbW92ZSBsYXN0IHBvaW50XCIpO1xuICAgICAgICB0aGlzLiR1bmRvQnV0dG9uLmNzcygnei1pbmRleCcsIHRoaXMuYmFzZVogKyAxMDUpO1xuICAgICAgICB0aGlzLiR1bmRvQnV0dG9uLmNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuUmVtb3ZlTGFzdEJyZWFkY3J1bWIoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuUmVnaXN0ZXJFbGVtZW50KHRoaXMuJHVuZG9CdXR0b24sIHRoaXMuJGVkaXREaWFsb2csIDEsICdmbGV4LWVuZCcpO1xuXG4gICAgICAgIC8vIE1ha2UgXCJDb2xsZWN0IFBvbHlnb24gc3RhdGVcIiBidXR0b25cbiAgICAgICAgdGhpcy4kY2FwUG9seUJ1dHRvbiA9ICQoXCI8YnV0dG9uPkNhcHR1cmUgUG9seWdvbjwvYnV0dG9uPlwiKS5idXR0b24oe1xuICAgICAgICAgICAgaWNvbjogXCJmYSBmYS1jYW1lcmEtcmV0cm9cIixcbiAgICAgICAgICAgIHNob3dMYWJlbDogZmFsc2VcbiAgICAgICAgfSkuY2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5BZGRQb2x5Z29uU2V0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiRjYXBQb2x5QnV0dG9uLmNzcyhcIm1hcmdpblwiLCBcIjBweCA1cHggNHB4IDVweFwiKTtcbiAgICAgICAgdGhpcy4kY2FwUG9seUJ1dHRvbi5hdHRyKCd0aXRsZScsIFwiQ2FwdHVyZSBQb2x5Z29uXCIpO1xuICAgICAgICB0aGlzLiRjYXBQb2x5QnV0dG9uLmNzcygnei1pbmRleCcsIHRoaXMuYmFzZVogKyAxMDUpO1xuICAgICAgICB0aGlzLlJlZ2lzdGVyRWxlbWVudCh0aGlzLiRjYXBQb2x5QnV0dG9uLCB0aGlzLiRlZGl0RGlhbG9nLCAxLCAnZmxleC1lbmQnKTtcblxuICAgICAgICAvLyBDcmVhdGUgdGhlIGNhbmNlbCBidXR0b25cbiAgICAgICAgdGhpcy4kY2FuY2VsQnV0dG9uID0gJChcIjxidXR0b24+U3RvcCBwb2x5Z29uIGVkaXRpbmc8L2J1dHRvbj5cIikuYnV0dG9uKHtcbiAgICAgICAgICAgIGljb246IFwiZmEgZmEtcmVtb3ZlXCIsXG4gICAgICAgICAgICBzaG93TGFiZWw6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiRjYW5jZWxCdXR0b24uY3NzKFwibWFyZ2luXCIsIFwiMHB4IDVweCA0cHggNXB4XCIpO1xuICAgICAgICB0aGlzLiRjYW5jZWxCdXR0b24uYWRkQ2xhc3MoXCJ3YWxkb3JmLWNhbmNlbC1idXR0b25cIik7XG4gICAgICAgIHRoaXMuJGNhbmNlbEJ1dHRvbi5hdHRyKCd0aXRsZScsIFwiU3RvcCBQb2x5Z29uIEVkaXRpbmdcIik7XG4gICAgICAgIHRoaXMuJGNhbmNlbEJ1dHRvbi5jbGljaygoKSA9PiB7XG4gICAgICAgICAgICAvL1Jlc3RvcmUgdGhlIG9yaWdpbmFsIHN0YXRlXG4gICAgICAgICAgICAvL3RoaXMuUmVzdG9yZSgpO1xuICAgICAgICAgICAgdGhpcy5SZW1vdmVBbGxCcmVhZGNydW1icygpO1xuICAgICAgICAgICAgdGhpcy5hbm5vdGF0b3IuJGNvbnRhaW5lci50cmlnZ2VyKFwiT25Qb2x5Z29uRWRpdGluZ0VuZGVkXCIpO1xuICAgICAgICAgICAgdGhpcy5Eb25lKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLlJlZ2lzdGVyRWxlbWVudCh0aGlzLiRjYW5jZWxCdXR0b24sIHRoaXMuJGVkaXREaWFsb2csIDIsICdmbGV4LWVuZCcpO1xuXG4gICAgICAgICQod2luZG93KS5yZXNpemUoKCkgPT4gdGhpcy5SZXNpemVPdmVybGF5KCkpO1xuXG4gICAgICAgIHRoaXMuRG9uZSgpO1xuICAgIH1cblxuICAgIE9uU3VyZmFjZUNsaWNrKGV2ZW50KXtcbiAgICAgICAgaWYgKCQoZXZlbnQuY3VycmVudFRhcmdldCkuYXR0cihcImlkXCIpID09IFwiZWRpdC1kaWFsb2dcIiB8fCB0aGlzLiRzdGFydFN0b3AgIT0gXCJzdGFydFwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgYSBicmVhZGNydW1iIG9uIGNsaWNrLCBidXQgb25seSBmb3IgdGhlIHN0YXJ0IHBvbHlnb24uIEVuZCB2ZXJ0aWNlcyBjYW4gb25seSBiZSBkcmFnZ2VkXG4gICAgICAgIGxldCB0YXJnZXQgPSAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xuICAgICAgICBsZXQgeCA9IGV2ZW50LnBhZ2VYIC0gdGFyZ2V0Lm9mZnNldCgpLmxlZnQ7XG4gICAgICAgIGxldCB5ID0gZXZlbnQucGFnZVkgLSB0YXJnZXQub2Zmc2V0KCkudG9wO1xuICAgICAgICBcbiAgICAgICAgbGV0IHhQZXJjZW50ID0gKHggLyB0YXJnZXQud2lkdGgoKSkgKiAxMDA7XG4gICAgICAgIGxldCB5UGVyY2VudCA9ICh5IC8gdGFyZ2V0LmhlaWdodCgpKSAqIDEwMDtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuQWRkQnJlYWRjcnVtYih4UGVyY2VudCwgeVBlcmNlbnQpO1xuICAgICAgICBcbiAgICAgICAgLy90aGlzLm5ld1BvbHlQb2ludHMucHVzaChbeFBlcmNlbnQudG9GaXhlZCgzKSwgeVBlcmNlbnQudG9GaXhlZCgzKV0pO1xuICAgICAgICB0aGlzLlVwZGF0ZVBvbHlDbGlwcGluZygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgYnJlYWRjcnVtYiBhdCB0aGUgZ2l2ZW4gKHgsIHkpIHBvaW50IG9uIHRoZVxuICAgICAqIGNsaWNrU3VyZmFjZSwgd2hlcmUgeCBhbmQgeSBhcmUgcGVyY2VudGFnZXMgZnJvbSAwIHRvIDEwMC5cbiAgICAgKi9cbiAgICBBZGRCcmVhZGNydW1iKHhQZXJjZW50LCB5UGVyY2VudCl7XG4gICAgICAgIGxldCAkYnJlYWRjcnVtYiA9ICQoXCI8ZGl2IGNsYXNzPSdicmVhZGNydW1iJz48L2Rpdj5cIik7XG4gICAgICAgICRicmVhZGNydW1iLmFwcGVuZFRvKHRoaXMuJGNsaWNrU3VyZmFjZSk7XG4gICAgICAgICRicmVhZGNydW1iLmNzcyhcInBvc2l0aW9uXCIsIFwiYWJzb2x1dGVcIik7XG5cbiAgICAgICAgLy8gUGVyY2VudGFnZSByZXByZXNlbnRhdGlvbnMgb2YgYnJlYWRjcnVtYiB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICAgIGxldCBvZmZQZXJjZW50WCA9ICgkYnJlYWRjcnVtYi5vdXRlcldpZHRoKCkgLyB0aGlzLiRjbGlja1N1cmZhY2Uud2lkdGgoKSkgKiAxMDA7XG4gICAgICAgIGxldCBvZmZQZXJjZW50WSA9ICgkYnJlYWRjcnVtYi5vdXRlckhlaWdodCgpIC8gdGhpcy4kY2xpY2tTdXJmYWNlLmhlaWdodCgpKSAqIDEwMDtcbiAgICAgICAgLy8gUGVyY2VudGFnZSByZXByZXNlbnRhdGlvbnMgb2YgYnJlYWRjcnVtYiB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICAgICRicmVhZGNydW1iLmNzcyhcImxlZnRcIiwgKHhQZXJjZW50IC0gKG9mZlBlcmNlbnRYIC8gMikpLnRvU3RyaW5nKCkgKyBcIiVcIik7XG4gICAgICAgICRicmVhZGNydW1iLmNzcyhcInRvcFwiLCAoeVBlcmNlbnQgLSAob2ZmUGVyY2VudFkgLyAyKSkudG9TdHJpbmcoKSArIFwiJVwiKTtcbiAgICAgICAgLy8kYnJlYWRjcnVtYi5jc3MoXCJ6LWluZGV4XCIsIHRoaXMuYmFzZVogLSA1MCk7XG5cbiAgICAgICAgXG4gICAgICAgICRicmVhZGNydW1iLmRyYWdnYWJsZSh7IFxuICAgICAgICAgICAgLy9jb250YWlubWVudDogXCJwYXJlbnRcIixcbiAgICAgICAgICAgIGRyYWc6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBSZWNhbGN1bGF0ZSBwZXJjZW50YWdlcyAobWFuZ2xlZCBieSBqUXVlcnkgVUkgZHJhZ2dhYmxlIGNvZGUpXG4gICAgICAgICAgICAgICAgLy8gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIzNjczNDYyXG4gICAgICAgICAgICAgICAgdmFyIGwgPSAoIDEwMCAqIHBhcnNlRmxvYXQoJGJyZWFkY3J1bWIuY3NzKFwibGVmdFwiKSkgLyBwYXJzZUZsb2F0KCRicmVhZGNydW1iLnBhcmVudCgpLmNzcyhcIndpZHRoXCIpKSApKyBcIiVcIiA7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSAoIDEwMCAqIHBhcnNlRmxvYXQoJGJyZWFkY3J1bWIuY3NzKFwidG9wXCIpKSAvIHBhcnNlRmxvYXQoJGJyZWFkY3J1bWIucGFyZW50KCkuY3NzKFwiaGVpZ2h0XCIpKSApKyBcIiVcIiA7XG4gICAgICAgICAgICAgICAgJGJyZWFkY3J1bWIuY3NzKFwibGVmdFwiICwgbCk7XG4gICAgICAgICAgICAgICAgJGJyZWFkY3J1bWIuY3NzKFwidG9wXCIgLCB0KTtcbiAgICAgICAgICAgICAgICB0aGlzLlVwZGF0ZVBvbHlDbGlwcGluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYodGhpcy4kc3RhcnRTdG9wPT1cInN0YXJ0XCIpe1xuICAgICAgICAgICAgLy9icmVhZGNydW1icyBjYW4gb25seSBiZSBhZGRlZCBvciByZW1vdmVkIGluIHRoZSBmaXJzdCBwb2x5Z29uXG4gICAgICAgICAgICAkYnJlYWRjcnVtYi5jbGljaygoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGJyZWFkY3J1bWIgb24gY2xpY2tcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAkYnJlYWRjcnVtYi5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRicmVhZGNydW1icy5zcGxpY2UodGhpcy4kYnJlYWRjcnVtYnMuaW5kZXhPZigkYnJlYWRjcnVtYiksIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuVXBkYXRlUG9seUNsaXBwaW5nKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5VcGRhdGVCcmVhZGNydW1iQ29sb3JpbmcoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLiRicmVhZGNydW1icy5wdXNoKCRicmVhZGNydW1iKTtcblxuICAgICAgICAvL3RoaXMuVXBkYXRlUG9seUNsaXBwaW5nKCk7XG4gICAgICAgIHRoaXMuVXBkYXRlQnJlYWRjcnVtYkNvbG9yaW5nKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgbGFzdC1wbGFjZWQgYnJlYWRjcnVtYiBmcm9tIHRoZSBsaXN0XG4gICAgICogYW5kIHVwZGF0ZXMgdGhlIHZpZXcuXG4gICAgICovXG4gICAgUmVtb3ZlTGFzdEJyZWFkY3J1bWIoKXtcbiAgICAgICAgbGV0ICRyZW1vdmVkID0gdGhpcy4kYnJlYWRjcnVtYnMucG9wKCk7XG4gICAgICAgICRyZW1vdmVkLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLlVwZGF0ZVBvbHlDbGlwcGluZygpO1xuICAgICAgICB0aGlzLlVwZGF0ZUJyZWFkY3J1bWJDb2xvcmluZygpO1xuICAgIH1cblxuICAgIFJlbW92ZUFsbEJyZWFkY3J1bWJzKCl7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiUmVtb3ZpbmcgYWxsIGJyZWFkY3J1bWJzXCIpO1xuICAgICAgICB3aGlsZSh0aGlzLiRicmVhZGNydW1icy5sZW5ndGggPiAwKXtcbiAgICAgICAgICAgIHRoaXMuUmVtb3ZlTGFzdEJyZWFkY3J1bWIoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGNlbnRlciBvZiB0aGUgYnJlYWRjcnVtYiBhcyBhbiAoeCwgeSkgcGFpclxuICAgICAqIHJlcHJlc2VudGluZyB0aGUgcGVyY2VudGFnZSBkaXN0YW5jZSBmcm9tIHRoZSB0b3AgYW5kIGxlZnRcbiAgICAgKiBvZiB0aGUgY2xpY2sgc3VyZmFjZSAoMCUgLSAxMDAlKS5cbiAgICAgKi9cbiAgICBHZXRDZW50ZXJQZXJjZW50YWdlKCRicmVhZGNydW1iKXtcbiAgICAgICAgbGV0IHRvcFBlcmNlbnQgPSAoJGJyZWFkY3J1bWIucG9zaXRpb24oKS50b3AgLyAkYnJlYWRjcnVtYi5wYXJlbnQoKS5oZWlnaHQoKSkgKiAxMDA7XG4gICAgICAgIGxldCBsZWZ0UGVyY2VudCA9ICgkYnJlYWRjcnVtYi5wb3NpdGlvbigpLmxlZnQgLyAkYnJlYWRjcnVtYi5wYXJlbnQoKS53aWR0aCgpKSAqIDEwMDtcblxuICAgICAgICAvLyBQZXJjZW50YWdlIHZhbHVlcyBmb3IgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGJyZWFkY3J1bWIgcmVsYXRpdmUgdG8gdGhlIGNsaWNrIHN1cmZhY2VcbiAgICAgICAgbGV0IG9mZlBlcmNlbnRYID0gKCRicmVhZGNydW1iLm91dGVyV2lkdGgoKSAvICRicmVhZGNydW1iLnBhcmVudCgpLndpZHRoKCkpICogMTAwO1xuICAgICAgICBsZXQgb2ZmUGVyY2VudFkgPSAoJGJyZWFkY3J1bWIub3V0ZXJIZWlnaHQoKSAvICRicmVhZGNydW1iLnBhcmVudCgpLmhlaWdodCgpKSAqIDEwMDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogbGVmdFBlcmNlbnQgKyAob2ZmUGVyY2VudFggLyAyLjApLFxuICAgICAgICAgICAgeTogdG9wUGVyY2VudCArIChvZmZQZXJjZW50WSAvIDIuMClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIFJlc2V0KCl7XG4gICAgICAgIFxuICAgICAgICAvLyBSZW1vdmUgYWxsIGJyZWFkY3J1bWJzXG4gICAgICAgIGZvcihsZXQgJGJyZWFkY3J1bWIgb2YgdGhpcy4kYnJlYWRjcnVtYnMpe1xuICAgICAgICAgICAgJGJyZWFkY3J1bWIucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kYnJlYWRjcnVtYnMgPSBbXTtcblxuICAgICAgICAvLyBSZW1vdmUgdGhlIHBvbHkgaWYgaXQgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgLy8gaWYodGhpcy4kcG9seSAhPSBudWxsKXtcbiAgICAgICAgLy8gICAgIHRoaXMuJHBvbHkucmVtb3ZlKCk7XG4gICAgICAgIC8vIH1cbiAgICB9XG5cbiAgICBSZXNldFBvbHlnb25zKCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcInJlc2V0dGluZyBwb2x5Z29uc1wiKTtcbiAgICAgICAgaWYgKHRoaXMuJHBvbHlnb25zLnN0YXJ0KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInJlc2V0IHN0YXJ0IHBvbHlcIik7XG4gICAgICAgICAgICB0aGlzLiRwb2x5Z29ucy5zdGFydC5tYWtlVmlzaWJsZShmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLiRwb2x5Z29ucy5zdGFydC5jc3MoXCJjbGlwLXBhdGhcIiwgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuJHBvbHlnb25zLnN0b3ApIHtcbiAgICAgICAgICAgIHRoaXMuJHBvbHlnb25zLnN0b3AubWFrZVZpc2libGUoZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy4kcG9seWdvbnMuc3RvcC5jc3MoXCJjbGlwLXBhdGhcIiwgXCJcIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiR2ZXJ0aWNlcyA9IHsgJ3N0YXJ0JzogW10sICdzdG9wJzogW10gfTtcbiAgICAgICAgdGhpcy5VcGRhdGVQb2x5Q2xpcHBpbmcoKTtcbiAgICAgICAgdGhpcy5SZW1vdmVBbGxCcmVhZGNydW1icygpO1xuICAgIH1cblxuICAgIFJlc3RvcmUoKXtcbiAgICAgICAgdGhpcy5Jbml0UG9seSh0aGlzLm9yaWdpbmFsSlNPTik7XG4gICAgfVxuXG4gICAgSW5pdFBvbHkocG9pbnRzID0gbnVsbCl7XG4gICAgICAgIHRoaXMuUmVzZXQoKTtcblxuICAgICAgICAvLyBJZiBKU09OIHdhcyBzcGVjaWZpZWQsIGdlbmVyYXRlIGJyZWFkY3J1bWJzIGZyb20gaXQuXG4gICAgICAgIGlmKHBvaW50cyAhPSBudWxsKXtcbiAgICAgICAgICAgIC8vIFB1dCBkb3duIHRoZSBicmVhZGNydW1ic1xuICAgICAgICAgICAgZm9yKGxldCBwb2ludCBvZiBwb2ludHMpe1xuICAgICAgICAgICAgICAgIHRoaXMuQWRkQnJlYWRjcnVtYihwb2ludFswXSwgcG9pbnRbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5VcGRhdGVQb2x5Q2xpcHBpbmcoKTtcblxuICAgICAgICB0aGlzLm9yaWdpbmFsSlNPTiA9IHBvaW50cztcbiAgICB9XG5cbiAgICBEcmF3UG9seWdvbnMoKSB7XG4gICAgICAgIHRoaXMuUmVtb3ZlQWxsQnJlYWRjcnVtYnMoKTtcbiAgICAgICAgaWYgKHRoaXMuJHZlcnRpY2VzLnN0YXJ0ICE9IFtdKSB7XG4gICAgICAgICAgICAvL2xldCBzdGFydFBvbHlnb24gPSB0aGlzLiR2ZXJ0aWNlcy5zdGFydDsgLy8ubWFwKGl0ZW0gPT4geyByZXR1cm4gYCR7aXRlbVswXX0sJHtpdGVtWzFdfWAgfSkuam9pbihcIiBcIik7O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIHBvbHkgb2JqZWN0c1xuICAgICAgICAgICAgLy8gdGhpcy4kcG9seWdvbnMuc3RhcnQgPSAkKFwiPGRpdiBjbGFzcz0nd2FsZG9yZi1zdGFydC1wb2x5Jz48L2Rpdj5cIikuYXBwZW5kVG8odGhpcy4kY2xpY2tTdXJmYWNlKTtcbiAgICAgICAgICAgIC8vIHRoaXMuJHBvbHlnb25zLnN0YXJ0LmNzcyhcInotaW5kZXhcIiwgdGhpcy5iYXNlWiArIDEwMDApO1xuXG4gICAgICAgICAgICBpZih0aGlzLiR2ZXJ0aWNlcy5zdGFydC5sZW5ndGggPCAzKXtcbiAgICAgICAgICAgICAgICB0aGlzLiRwb2x5Z29ucy5zdGFydC5tYWtlVmlzaWJsZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgdGhpcy4kcG9seWdvbnMuc3RhcnQuY2xpcFBhdGgoW10sIHtcbiAgICAgICAgICAgICAgICAgICAgc3ZnRGVmSWQ6ICdhbm5vdGF0b3JTdGFydFBvbHlTdmcnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuJHBvbHlnb25zLnN0YXJ0Lm1ha2VWaXNpYmxlKHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuJHBvbHlnb25zLnN0YXJ0LmNsaXBQYXRoKHRoaXMuJHZlcnRpY2VzLnN0YXJ0LCB7XG4gICAgICAgICAgICAgICAgICAgIGlzUGVyY2VudGFnZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3ZnRGVmSWQ6ICdhbm5vdGF0b3JTdGFydFBvbHlTdmcnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYodGhpcy4kc3RhcnRTdG9wPT1cInN0YXJ0XCIpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiR2ZXJ0aWNlcy5zdGFydC5tYXAoKHBvaW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkFkZEJyZWFkY3J1bWIocG9pbnRbMF0sIHBvaW50WzFdKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiR2ZXJ0aWNlcy5zdG9wICE9IFtdKSB7XG5cbiAgICAgICAgICAgIC8vIHRoaXMuJHN0b3BQb2x5LnJlbW92ZSgpO1xuICAgICAgICAgICAgLy8gdGhpcy4kc3RvcFBvbHkgPSAkKFwiPGRpdiBjbGFzcz0nd2FsZG9yZi1zdG9wLXBvbHknPjwvZGl2PlwiKS5hcHBlbmRUbyh0aGlzLiRjbGlja1N1cmZhY2UpO1xuICAgICAgICAgICAgLy8gdGhpcy4kc3RvcFBvbHkuY3NzKFwiei1pbmRleFwiLCB0aGlzLmJhc2VaICsgMTAwMCk7XG5cbiAgICAgICAgICAgIGlmKHRoaXMuJHZlcnRpY2VzLnN0b3AubGVuZ3RoIDwgMyl7XG4gICAgICAgICAgICAgICAgdGhpcy4kcG9seWdvbnMuc3RvcC5jbGlwUGF0aChbXSwge1xuICAgICAgICAgICAgICAgICAgICBzdmdEZWZJZDogJ2Fubm90YXRvclN0b3BQb2x5U3ZnJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRwb2x5Z29ucy5zdG9wLmNsaXBQYXRoKHRoaXMuJHZlcnRpY2VzLnN0b3AsIHtcbiAgICAgICAgICAgICAgICAgICAgaXNQZXJjZW50YWdlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzdmdEZWZJZDogJ2Fubm90YXRvclN0b3BQb2x5U3ZnJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuJHN0YXJ0U3RvcD09XCJzdG9wXCIpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiR2ZXJ0aWNlcy5zdG9wLm1hcCgocG9pbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuQWRkQnJlYWRjcnVtYihwb2ludFswXSwgcG9pbnRbMV0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgVXBkYXRlUG9seUNsaXBwaW5nKCl7XG4gICAgICAgIGlmKHRoaXMuJHN0YXJ0U3RvcD09bnVsbCkgcmV0dXJuO1xuICAgICAgICBsZXQgc3ZnSWQgPSB0aGlzLiRzdGFydFN0b3AgPT0gXCJzdGFydFwiID8gXCJhbm5vdGF0b3JTdGFydFBvbHlTdmdcIiA6IFwiYW5ub3RhdG9yU3RvcFBvbHlTdmdcIjtcbiAgICAgICAgaWYodGhpcy4kYnJlYWRjcnVtYnMubGVuZ3RoIDwgMyl7XG4gICAgICAgICAgICB0aGlzLiRwb2x5Z29uc1t0aGlzLiRzdGFydFN0b3BdLm1ha2VWaXNpYmxlKGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuJHBvbHlnb25zW3RoaXMuJHN0YXJ0U3RvcF0uY2xpcFBhdGgoW10sIHtcbiAgICAgICAgICAgICAgICBzdmdEZWZJZDogc3ZnSWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHBvaW50cyA9IHRoaXMuJGJyZWFkY3J1bWJzLm1hcCgoJGNydW1iKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHBvcyA9IHRoaXMuR2V0Q2VudGVyUGVyY2VudGFnZSgkY3J1bWIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbcG9zLngsIHBvcy55XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy4kcG9seWdvbnNbdGhpcy4kc3RhcnRTdG9wXS5tYWtlVmlzaWJsZSh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuJHBvbHlnb25zW3RoaXMuJHN0YXJ0U3RvcF0uY2xpcFBhdGgocG9pbnRzLCB7XG4gICAgICAgICAgICAgICAgaXNQZXJjZW50YWdlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHN2Z0RlZklkOiBzdmdJZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBVcGRhdGVCcmVhZGNydW1iQ29sb3JpbmcoKXtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuJGJyZWFkY3J1bWJzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGxldCAkY3J1bWIgPSB0aGlzLiRicmVhZGNydW1ic1tpXTtcbiAgICAgICAgICAgIC8vIFJlY29sb3IgZWFjaCBicmVhZGNydW1iXG4gICAgICAgICAgICBsZXQgY29sb3IgPSBcIiMwMDAwMDBcIjtcblxuICAgICAgICAgICAgaWYgKGkgPT0gdGhpcy4kYnJlYWRjcnVtYnMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIGNvbG9yID0gXCIjRkYwMDAwXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpID09IDApe1xuICAgICAgICAgICAgICAgIGNvbG9yID0gXCIjMDBGRjAwXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiRicmVhZGNydW1ic1tpXS5jc3MoXCJib3JkZXItY29sb3JcIiwgY29sb3IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbiBhcnJheSBvZiBwZXJjZW50YWdlcyByZXByZXNlbnRpbmcgdGhlIHggYW5kIHkgcGVyY2VudGFnZXMgb2YgZWFjaFxuICAgICAqIHBvaW50IGluIHRoZSBwb2x5Z29uLlxuICAgICAqL1xuICAgIEdldEpTT04oKXtcbiAgICAgICAgLy8gRXh0cmFjdCB0aGUgY29vcmRpbmF0ZXMgZnJvbSB0aGUgY3J1bWJzIGFuZCBwdXQgdGhlbSBpbiB0aGUgYXJyYXlcbiAgICAgICAgbGV0IHBvaW50cyA9IFtdO1xuICAgICAgICBmb3IobGV0IGNydW1iIG9mIHRoaXMuJGJyZWFkY3J1bWJzKXtcbiAgICAgICAgICAgIGxldCBwb2ludCA9IHRoaXMuR2V0Q2VudGVyUGVyY2VudGFnZShjcnVtYik7XG4gICAgICAgICAgICBwb2ludHMucHVzaChbcG9pbnQueC50b1N0cmluZygpLCBwb2ludC55LnRvU3RyaW5nKCldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwb2ludHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYW4gYXJyYXkgb2YgcGVyY2VudGFnZXMgcmVwcmVzZW50aW5nIHRoZSB4IGFuZCB5IHBlcmNlbnRhZ2VzIG9mIGVhY2hcbiAgICAgKiBwb2ludCBpbiB0aGUgcG9seWdvbi5cbiAgICAgKi9cbiAgICBHZXRQb2ludHMoKSB7XG4gICAgICAgIGxldCBwb2ludHMgPSBbXTtcbiAgICAgICAgZm9yKGxldCBjcnVtYiBvZiB0aGlzLiRicmVhZGNydW1icyl7XG4gICAgICAgICAgICBsZXQgcG9pbnQgPSB0aGlzLkdldENlbnRlclBlcmNlbnRhZ2UoY3J1bWIpO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goW3BvaW50LngsIHBvaW50LnldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgYWxsIHN0YXJ0IHZlcnRpY2VzIG1hdGNoIHN0b3AgdmVydGljZXNcbiAgICAgKiByZXR1cm5zIHRydWUgaWYgdGhlIHZlcnRpY2VzIGRvbid0IG1hdGNoIGV4YWN0bHlcbiAgICAgKi9cbiAgICBJc0FuaW1hdGVkKCkge1xuICAgICAgICBsZXQgY29tcCA9IHRoaXMuJHZlcnRpY2VzLnN0YXJ0O1xuICAgICAgICBsZXQgc3RhcnRTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShjb21wKTtcbiAgICAgICAgY29tcCA9IHRoaXMuJHZlcnRpY2VzLnN0b3A7XG4gICAgICAgIGxldCBzdG9wU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoY29tcCk7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdGFydFN0cmluZykgIT0gSlNPTi5zdHJpbmdpZnkoc3RvcFN0cmluZyk7XG4gICAgfVxuXG4gICAgQmVnaW5FZGl0aW5nKHN0YXJ0U3RvcCl7XG4gICAgICAgIHRoaXMuJHN0YXJ0U3RvcCA9IHN0YXJ0U3RvcDtcbiAgICAgICAgLy9zdGFydFN0b3AgaXMgZWl0aGVyICdzdGFydCcgb3IgJ3N0b3AnLCBkZXBlbmRpbmcgb24gd2hpY2ggcG9seWdvbiBpcyBiZWluZyBlZGl0ZWRcbiAgICAgICAgdGhpcy4kY2xpY2tTdXJmYWNlLm1ha2VWaXNpYmxlKHRydWUpO1xuICAgICAgICB0aGlzLiRlZGl0RGlhbG9nLm1ha2VWaXNpYmxlKHRydWUpO1xuICAgICAgICB0aGlzLiRwb2x5Z29ucy5zdGFydC5tYWtlVmlzaWJsZSh0cnVlKTtcbiAgICAgICAgdGhpcy4kcG9seWdvbnMuc3RvcC5tYWtlVmlzaWJsZSh0cnVlKTtcbiAgICAgICAgLy8tMy8vdGhpcy4kYmFyLm1ha2VWaXNpYmxlKHRydWUpO1xuICAgICAgICB0aGlzLkRyYXdQb2x5Z29ucygpO1xuICAgICAgICB0aGlzLlVwZGF0ZVBvbHlDbGlwcGluZygpO1xuICAgIH1cblxuICAgIERvbmUoKXtcbiAgICAgICAgdGhpcy4kY2xpY2tTdXJmYWNlLm1ha2VWaXNpYmxlKGZhbHNlKTtcbiAgICAgICAgdGhpcy4kZWRpdERpYWxvZy5tYWtlVmlzaWJsZShmYWxzZSk7XG4gICAgICAgIHRoaXMuJHBvbHlnb25zLnN0YXJ0Lm1ha2VWaXNpYmxlKGZhbHNlKTtcbiAgICAgICAgdGhpcy4kcG9seWdvbnMuc3RvcC5tYWtlVmlzaWJsZShmYWxzZSk7XG4gICAgICAgIC8vLTMvL3RoaXMuJGJhci5tYWtlVmlzaWJsZShmYWxzZSk7XG4gICAgfVxuXG4gICAgUmVzaXplT3ZlcmxheSgpe1xuICAgICAgICAvLyBSZXNpemUgdmlkZW8gb3ZlcmxheSB0byBmaXQgYWN0dWFsIHZpZGVvIGRpbWVuc2lvbnNcbiAgICAgICAgbGV0IHZpZGVvRGltcyA9IHRoaXMuYW5ub3RhdG9yLnBsYXllci5HZXRWaWRlb0RpbWVuc2lvbnMoKTtcbiAgICAgICAgdGhpcy4kY2xpY2tTdXJmYWNlLmNzcygnd2lkdGgnLCB2aWRlb0RpbXMud2lkdGgpO1xuICAgICAgICB0aGlzLiRjbGlja1N1cmZhY2UuY3NzKCdoZWlnaHQnLCB2aWRlb0RpbXMuaGVpZ2h0KTtcblxuICAgICAgICBsZXQgaGVpZ2h0RGlmZiA9ICh0aGlzLmFubm90YXRvci5wbGF5ZXIuJHZpZGVvLmhlaWdodCgpIC0gdmlkZW9EaW1zLmhlaWdodCkgLyAyO1xuICAgICAgICB0aGlzLiRjbGlja1N1cmZhY2UuY3NzKCd0b3AnLCBoZWlnaHREaWZmKTtcblxuICAgICAgICBsZXQgd2lkdGhEaWZmID0gKHRoaXMuYW5ub3RhdG9yLnBsYXllci4kdmlkZW8ud2lkdGgoKSAtIHZpZGVvRGltcy53aWR0aCkgLyAyO1xuICAgICAgICB0aGlzLiRjbGlja1N1cmZhY2UuY3NzKCdsZWZ0Jywgd2lkdGhEaWZmKTtcblxuICAgICAgICB0aGlzLiRwb2x5Z29ucy5zdGFydC53aWR0aCh2aWRlb0RpbXMud2lkdGgpO1xuICAgICAgICB0aGlzLiRwb2x5Z29ucy5zdGFydC5oZWlnaHQodmlkZW9EaW1zLmhlaWdodCk7XG4gICAgICAgIHRoaXMuJHBvbHlnb25zLnN0YXJ0LmNzcyhcInRvcFwiLCBoZWlnaHREaWZmKTtcbiAgICAgICAgdGhpcy4kcG9seWdvbnMuc3RhcnQuY3NzKFwibGVmdFwiLCB3aWR0aERpZmYpO1xuICAgICAgICB0aGlzLiRwb2x5Z29ucy5zdGFydC5jc3MoXCJwb3NpdGlvblwiLCBcImFic29sdXRlXCIpO1xuICAgICAgICB0aGlzLiRwb2x5Z29ucy5zdGFydC5tYWtlVmlzaWJsZShmYWxzZSk7XG5cbiAgICAgICAgdGhpcy4kcG9seWdvbnMuc3RvcC53aWR0aCh2aWRlb0RpbXMud2lkdGgpO1xuICAgICAgICB0aGlzLiRwb2x5Z29ucy5zdG9wLmhlaWdodCh2aWRlb0RpbXMuaGVpZ2h0KTtcbiAgICAgICAgdGhpcy4kcG9seWdvbnMuc3RvcC5jc3MoXCJ0b3BcIiwgaGVpZ2h0RGlmZik7XG4gICAgICAgIHRoaXMuJHBvbHlnb25zLnN0b3AuY3NzKFwibGVmdFwiLCB3aWR0aERpZmYpO1xuICAgICAgICB0aGlzLiRwb2x5Z29ucy5zdG9wLmNzcyhcInBvc2l0aW9uXCIsIFwiYWJzb2x1dGVcIik7XG4gICAgICAgIHRoaXMuJHBvbHlnb25zLnN0b3AubWFrZVZpc2libGUoZmFsc2UpO1xuXG4gICAgfVxuXG4gICAgUmVnaXN0ZXJFbGVtZW50KCRlbGVtZW50LCAkY29udGFpbmVyLCBvcmRlciwganVzdGlmaWNhdGlvbiA9ICdmbGV4LXN0YXJ0Jyl7XG4gICAgICAgICRlbGVtZW50LmNzcygnb3JkZXInLCBvcmRlcik7XG4gICAgICAgICRlbGVtZW50LmNzcygnYWxpZ24tc2VsZicsIGp1c3RpZmljYXRpb24pO1xuICAgICAgICAvLyBTZXRzIGdyb3cgW3Nocmlua10gW2Jhc2lzXVxuICAgICAgICAvLyRlbGVtZW50LmNzcygnZmxleCcsICcwIDAgYXV0bycpO1xuICAgICAgICAkY29udGFpbmVyLmFwcGVuZCgkZWxlbWVudCk7XG4gICAgfVxuXG4gICAgU2hvd0p1c3RQb2x5Z29uKCl7XG4gICAgICAgIHRoaXMuJHBvbHlnb25zLnN0YXJ0Lm1ha2VWaXNpYmxlKHRydWUpO1xuICAgICAgICB0aGlzLiRwb2x5Z29ucy5zdG9wLm1ha2VWaXNpYmxlKHRydWUpO1xuICAgIH1cblxuICAgIEFkZFBvbHlnb25TZXQoKSB7XG4gICAgICAgIC8vVGhpcyBpcyBzYXZpbmcgYSBzZXQgb2YgYnJlYWRjcnVtYnMgaW50byB0aGUgdmVydGljZXMgZm9yIGEgcG9seWdvblxuICAgICAgICB0aGlzLiR2ZXJ0aWNlc1t0aGlzLiRzdGFydFN0b3BdID0gdGhpcy5HZXRQb2ludHMoKTtcbiAgICAgICAgaWYodGhpcy4kc3RhcnRTdG9wPT1cInN0YXJ0XCIgJiYgdGhpcy4kdmVydGljZXMuc3RvcC5sZW5ndGggIT0gdGhpcy4kdmVydGljZXMuc3RhcnQubGVuZ3RoKXtcbiAgICAgICAgICAgIHRoaXMuJHZlcnRpY2VzLnN0b3AgPSB0aGlzLkdldFBvaW50cygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuUmVtb3ZlQWxsQnJlYWRjcnVtYnMoKTtcbiAgICAgICAgdGhpcy5hbm5vdGF0b3IubWVzc2FnZU92ZXJsYXkuU2hvd01lc3NhZ2UoXCJDYXB0dXJlZCBcIit0aGlzLiRzdGFydFN0b3ArXCIgcG9seWdvbi5cIik7XG5cbiAgICAgICAgLy8gaWYgKHRoaXMuJHZlcnRpY2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgLy8gICAgIHRoaXMuJHBvbHlnb25zID0gW107XG4gICAgICAgIC8vICAgICB0aGlzLiR0ZW1wQnJlYWRDcnVtYnMgPSBbXTtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIGlmICghdGhpcy4kcG9seWdvbnMubGVuZ3RoKSB7XG4gICAgICAgIC8vICAgICB0aGlzLiRwb2x5Z29ucy5zdGFydCA9IHRoaXMuR2V0UG9pbnRzKCk7XG4gICAgICAgIC8vICAgICB0aGlzLiR0ZW1wQnJlYWRDcnVtYnNbMF0gPSBbdGhpcy4kYnJlYWRjcnVtYnNdO1xuICAgICAgICAvLyAgICAgdmFyIG1zZyA9IFwiU3VjY2Vzc2Z1bGx5IGNhcHR1cmVkIGZpcnN0IHBvbHlnb24uXCI7XG4gICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgIC8vICAgICB0aGlzLiRwb2x5Z29ucy5zdG9wID0gdGhpcy5HZXRQb2ludHMoKTtcbiAgICAgICAgLy8gICAgIHRoaXMuJHRlbXBCcmVhZENydW1ic1sxXSA9IFt0aGlzLiRicmVhZGNydW1ic107XG4gICAgICAgIC8vICAgICB2YXIgbXNnID0gXCJTdWNjZXNzZnVsbHkgY2FwdHVyZWQgc2Vjb25kIHBvbHlnb24uXCI7XG4gICAgICAgIC8vIH0gXG5cbiAgICAgICAgdGhpcy5hbm5vdGF0b3IuJGNvbnRhaW5lci50cmlnZ2VyKFwiT25Qb2x5Z29uRWRpdGluZ0VuZGVkXCIpO1xuICAgICAgICB0aGlzLkRvbmUoKTtcblxuXG4gICAgfVxuXG59XG5cbmV4cG9ydCB7IFBvbHlnb25FZGl0b3IgfTsiLCJjbGFzcyBQb2x5Z29uT3ZlcmxheSB7XG4gICAgY29uc3RydWN0b3IoYW5ub3RhdG9yKXtcbiAgICAgICAgdGhpcy5hbm5vdGF0b3IgPSBhbm5vdGF0b3I7XG4gICAgICAgIHRoaXMucG9seUVsZW1lbnRzID0gW107XG4gICAgICAgIHRoaXMuc3ZnRWxlbWVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5hbmltYXRlRWxlbWVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5iYXNlWiA9IDIxNDc0ODM2NDk7XG4gICAgICAgIHRoaXMubGFzdEFubm90YXRpb25zID0gW107XG4gICAgICAgIHRoaXMuc3ZnRWxlbWVudHNIYXNoID0ge307XG5cbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgdmlkZW8gb3ZlcmxheVxuICAgICAgICB0aGlzLiR2aWRlb092ZXJsYXkgPSAkKFwiPGRpdiBjbGFzcz0nd2FsZG9yZi12aWRlby1vdmVybGF5Jz48L2Rpdj5cIikuYXBwZW5kVG8odGhpcy5hbm5vdGF0b3IucGxheWVyLiRjb250YWluZXIpO1xuICAgICAgICB0aGlzLlJlc2l6ZU92ZXJsYXkoKTtcbiAgICAgICAgdGhpcy5hbm5vdGF0b3IucGxheWVyLiRjb250YWluZXIub24oXCJPbkZ1bGxzY3JlZW5DaGFuZ2VcIiwgKGV2ZW50LCBzZXRGdWxsc2NyZWVuKSA9PiB0aGlzLlJlc2l6ZU92ZXJsYXkoKSk7XG5cbiAgICAgICAgdGhpcy5hbm5vdGF0b3IuJGNvbnRhaW5lci5vbihcIk9uTmV3QW5ub3RhdGlvblNldFwiLCAoZXZlbnQsIGFubm90YXRpb25zKSA9PiB0aGlzLlVwZGF0ZShhbm5vdGF0aW9ucykpO1xuICAgICAgICB0aGlzLnZpZGVvRGltcyA9IHRoaXMuYW5ub3RhdG9yLnBsYXllci5HZXRWaWRlb0RpbWVuc2lvbnMoKTtcblxuICAgICAgICAkKHdpbmRvdykucmVzaXplKCgpID0+IHRoaXMuUmVzaXplT3ZlcmxheSgpKTtcbiAgICB9XG5cbiAgICBVcGRhdGUoYW5ub3RhdGlvbnMpe1xuICAgICAgICB0aGlzLkNsZWFyKCk7XG5cbiAgICAgICAgLy8gbGV0IHByZXZTZXQgPSBuZXcgU2V0KHRoaXMubGFzdEFubm90YXRpb25zKTtcbiAgICAgICAgLy8gbGV0IG5ld1NldCA9IG5ldyBTZXQoYW5ub3RhdGlvbnMpO1xuXG4gICAgICAgIC8vIC8vIGluIG5ld1NldCBhbmQgbm90IGluIHByZXZTZXRcbiAgICAgICAgLy8gbGV0IHRvQWRkID0gbmV3IFNldChcbiAgICAgICAgLy8gICAgIFsuLi5uZXdTZXRdLmZpbHRlcih4ID0+ICFwcmV2U2V0Lmhhcyh4KSkpO1xuXG4gICAgICAgIC8vIC8vIGluIHByZXZBbm5vdGF0aW9ucyBhbmQgbm90IGluIGFubm90YXRpb25zXG4gICAgICAgIC8vIGxldCB0b0Rlc3Ryb3kgPSBuZXcgU2V0KFxuICAgICAgICAvLyAgICAgWy4uLnByZXZTZXRdLmZpbHRlcih4ID0+ICFuZXdTZXQuaGFzKHgpKSk7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coQXJyYXkuZnJvbSh0b0FkZCkpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhBcnJheS5mcm9tKHRvRGVzdHJveSkpO1xuICAgICAgICBcbiAgICAgICAgLy9Tb3J0IHBvbHlnb24gb3JkZXIgYnkgc2l6ZSAoYXNjZW5kaW5nKVxuICAgICAgICAvLyBwb2x5Z29ucy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgLy8gICAgIHJldHVybiB0aGlzLkdldEFyZWEoYSkgPiB0aGlzLkdldEFyZWEoYik7XG4gICAgICAgIC8vIH0pXG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbm5vdGF0aW9ucy5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgICAgICBsZXQgYW5ub3RhdGlvblBvbHlQb2ludHMgPSBhbm5vdGF0aW9uc1tpXS5nZXRQb2x5KCk7XG4gICAgICAgICAgICBpZiAoYW5ub3RhdGlvblBvbHlQb2ludHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZSB0aGlzIGFubm90YXRpb24gaWYgaXQgaGFzIG5vIHBvbHlnb25cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHN2Z1BvbHlQb2ludHMgPSBhbm5vdGF0aW9uc1tpXS5nZXRTVkdQb2x5UG9pbnRzKCk7XG4gICAgICAgIFxuICAgICAgICAgICAgbGV0IGR1cmF0aW9uID0gYW5ub3RhdGlvbnNbaV0uZW5kVGltZSAtIGFubm90YXRpb25zW2ldLmJlZ2luVGltZTtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBwb2x5IG9iamVjdFxuICAgICAgICAgICAgbGV0ICRzdmc7XG4gICAgICAgICAgICBpZiAodGhpcy5zdmdFbGVtZW50cy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICRzdmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInN2Z1wiKTtcbiAgICAgICAgICAgICAgICAkc3ZnLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMTAwJScpO1xuICAgICAgICAgICAgICAgICRzdmcuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAnMTAwJScpO1xuICAgICAgICAgICAgICAgICRzdmcuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgJzAgMCAxMDAgMTAwJyk7XG4gICAgICAgICAgICAgICAgJHN2Zy5zZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLCAnbm9uZScpO1xuXG4gICAgICAgICAgICAgICAgLy8kc3ZnLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLkNsaWNrRXZlbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuJHZpZGVvT3ZlcmxheS5hcHBlbmQoJHN2Zyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdmdFbGVtZW50cy5wdXNoKCRzdmcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkc3ZnID0gdGhpcy5zdmdFbGVtZW50c1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuXG4gICAgICAgICAgICBsZXQgJHBvbHlnb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ3BvbHlnb24nKTtcbiAgICAgICAgICAgICRwb2x5Z29uLnNldEF0dHJpYnV0ZSgncG9pbnRzJywgc3ZnUG9seVBvaW50c1swXSk7XG4gICAgICAgICAgICAkcG9seWdvbi5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCAncmdiYSgwLCAxMTgsIDI1NSwgMC41NSknKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgJHN2Zy5hcHBlbmRDaGlsZCgkcG9seWdvbik7XG5cbiAgICAgICAgICAgIGxldCAkYW5pbWF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAnYW5pbWF0ZScpO1xuICAgICAgICAgICAgJGFuaW1hdGUuc2V0QXR0cmlidXRlKCdhdHRyaWJ1dGVOYW1lJywgJ3BvaW50cycpO1xuICAgICAgICAgICAgJGFuaW1hdGUuc2V0QXR0cmlidXRlKCdmaWxsJywgJ2ZyZWV6ZScpO1xuICAgICAgICAgICAgJGFuaW1hdGUuc2V0QXR0cmlidXRlKCdmcm9tJywgc3ZnUG9seVBvaW50c1swXSk7XG4gICAgICAgICAgICAkYW5pbWF0ZS5zZXRBdHRyaWJ1dGUoJ3RvJywgc3ZnUG9seVBvaW50c1sxXSk7XG4gICAgICAgICAgICAkYW5pbWF0ZS5zZXRBdHRyaWJ1dGUoJ2JlZ2luJywgJ2luZGVmaW5pdGUnKTtcbiAgICAgICAgICAgICRhbmltYXRlLnNldEF0dHJpYnV0ZSgnZHVyJywgZHVyYXRpb24gKyBcInNcIik7XG4gICAgICAgICAgICAkcG9seWdvbi5hcHBlbmRDaGlsZCgkYW5pbWF0ZSk7XG5cbiAgICAgICAgICAgIGxldCAkc3ZnSGFzaCA9IHtcbiAgICAgICAgICAgICAgICBzdmdFbGVtZW50OiAkc3ZnLFxuICAgICAgICAgICAgICAgIHBvbHlnb246ICRwb2x5Z29uLFxuICAgICAgICAgICAgICAgIGFuaW1hdGU6ICRhbmltYXRlLFxuICAgICAgICAgICAgICAgIGJlZ2luVGltZTogYW5ub3RhdGlvbnNbaV0uYmVnaW5UaW1lXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLnN2Z0VsZW1lbnRzSGFzaFthbm5vdGF0aW9uc1tpXS5pZF0gPSAkc3ZnSGFzaDtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBwb2x5IG9iamVjdFxuICAgICAgICAgICAgLy8gbGV0ICRwb2x5ID0gJChcIjxkaXYgY2xhc3M9J3dhbGRvcmYtb3ZlcmxheS1wb2x5Jz48L2Rpdj5cIikuYXBwZW5kVG8odGhpcy4kdmlkZW9PdmVybGF5KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gJHBvbHkuY2xpcFBhdGgoYW5ub3RhdGlvblBvbHlQb2ludHMsIHtcbiAgICAgICAgICAgIC8vICAgICBpc1BlcmNlbnRhZ2U6IHRydWUsXG4gICAgICAgICAgICAvLyAgICAgc3ZnRGVmSWQ6ICdhbm5vdGF0b3JQb2x5U3ZnJ1xuICAgICAgICAgICAgLy8gfSk7XG4gICAgICAgICAgICAvLyAkcG9seS5jbGljaygoKSA9PiB7XG4gICAgICAgICAgICAvLyAgICAgdGhpcy5hbm5vdGF0b3IuJGNvbnRhaW5lci50cmlnZ2VyKFwiT25Qb2x5Q2xpY2tlZFwiLCBhbm5vdGF0aW9uc1tpXSk7XG4gICAgICAgICAgICAvLyB9KTtcbiAgICAgICAgICAgIC8vIHRoaXMuQWRkVG9vbHRpcCgkcG9seSwgYW5ub3RhdGlvbnNbaV0pO1xuICAgICAgICAgICAgLy8gdGhpcy5wb2x5RWxlbWVudHMucHVzaCgkcG9seSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMucG9seUVsZW1lbnRzLnB1c2goJHBvbHlnb24pO1xuICAgICAgICAgICAgdGhpcy5hbmltYXRlRWxlbWVudHMucHVzaCgkYW5pbWF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvL3RoaXMubGFzdEFubm90YXRpb25zID0gYW5ub3RhdGlvbnM7XG4gICAgfVxuXG4gICAgQ2xpY2tFdmVudChldmVudCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcImFuaW1hdGUgaXMgY2xpY2tlZFwiKTtcbiAgICB9XG5cbiAgICBBZGRUb29sdGlwKCRwb2x5LCBhbm5vdGF0aW9uKXtcbiAgICAgICAgJC5mbi5xdGlwLnppbmRleCA9IHRoaXMuYmFzZVorIDE7XG4gICAgICAgICRwb2x5LnF0aXAoe1xuICAgICAgICAgICAgY29udGVudDoge1xuICAgICAgICAgICAgICAgIHRpdGxlOiBhbm5vdGF0aW9uLmlkLFxuICAgICAgICAgICAgICAgIHRleHQ6IGFubm90YXRpb24uYm9keS5maWx0ZXIoaXRlbSA9PiBpdGVtLnB1cnBvc2UgPT09IFwiZGVzY3JpYmluZ1wiKVswXS52YWx1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgbXk6ICdib3R0b20gcmlnaHQnLFxuICAgICAgICAgICAgICAgIGF0OiAndG9wIGxlZnQnLFxuICAgICAgICAgICAgICAgIHRhcmdldDogJ21vdXNlJywgLy8gRm9sbG93IHRoZSBtb3VzZVxuICAgICAgICAgICAgICAgIGFkanVzdDoge1xuICAgICAgICAgICAgICAgICAgICBtb3VzZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcInNoaWZ0IHNoaWZ0XCIgLy8gaG9yaXpvbnRhbCwgdmVydGljYWxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHZpZXdwb3J0OiB0aGlzLmFubm90YXRvci5wbGF5ZXIuJGNvbnRhaW5lclxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhpZGU6IHtcbiAgICAgICAgICAgICAgICBkZWxheTogMCAvLyBObyBoaWRlIGRlbGF5IGJ5IGRlZmF1bHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIGNsYXNzZXM6ICdxdGlwLWRhcmsgcXRpcC1yb3VuZGVkIGFubm90YXRvci1xdGlwJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBDbGVhcigpe1xuICAgICAgICAvLyBDbGVhciBhbGwgIGFuaW1hdGUgZWxlbWVudCBmcm9tIHRoZSBET01cbiAgICAgICAgZm9yKGxldCBhaSA9IDA7IGFpIDwgdGhpcy5hbmltYXRlRWxlbWVudHMubGVuZ3RoOyBhaSsrKXtcbiAgICAgICAgICAgIC8vdGhpcy5wb2x5RWxlbWVudHNbaV0uZGF0YShcInF0aXBcIikuZGVzdHJveSh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0ZUVsZW1lbnRzW2FpXS5yZW1vdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENsZWFyIGFsbCBwb2x5Z29ucyBcbiAgICAgICAgZm9yKGxldCBwaSA9IDA7IHBpIDwgdGhpcy5wb2x5RWxlbWVudHMubGVuZ3RoOyBwaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnBvbHlFbGVtZW50c1twaV0ucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENsZWFyIGFsbCAgc3ZnIGVsZW1lbnRzIGZyb20gdGhlIERPTVxuICAgICAgICBmb3IobGV0IHNpID0gMDsgc2kgPCB0aGlzLnN2Z0VsZW1lbnRzLmxlbmd0aDsgc2krKyl7XG4gICAgICAgICAgICB0aGlzLnN2Z0VsZW1lbnRzW3NpXS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gTWFyayB0aGUgYXJyYXkgYXMgZW1wdHlcbiAgICAgICAgdGhpcy5hbmltYXRlRWxlbWVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5wb2x5RWxlbWVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5zdmdFbGVtZW50cyA9IFtdO1xuICAgICAgICB0aGlzLnN2Z0VsZW1lbnRzSGFzaCA9IHt9O1xuXG4gICAgfVxuXG4gICAgUmVzaXplT3ZlcmxheSgpe1xuICAgICAgICAvLyBSZXNpemUgdmlkZW8gb3ZlcmxheSB0byBmaXQgYWN0dWFsIHZpZGVvIGRpbWVuc2lvbnNcbiAgICAgICAgbGV0IHZpZGVvRGltcyA9IHRoaXMuYW5ub3RhdG9yLnBsYXllci5HZXRWaWRlb0RpbWVuc2lvbnMoKTtcbiAgICAgICAgdGhpcy4kdmlkZW9PdmVybGF5LmNzcygnd2lkdGgnLCB2aWRlb0RpbXMud2lkdGgpO1xuICAgICAgICB0aGlzLiR2aWRlb092ZXJsYXkuY3NzKCdoZWlnaHQnLCB2aWRlb0RpbXMuaGVpZ2h0KTtcblxuICAgICAgICBsZXQgaGVpZ2h0RGlmZiA9ICh0aGlzLmFubm90YXRvci5wbGF5ZXIuJHZpZGVvLmhlaWdodCgpIC0gdmlkZW9EaW1zLmhlaWdodCkgLyAyO1xuICAgICAgICB0aGlzLiR2aWRlb092ZXJsYXkuY3NzKCd0b3AnLCBoZWlnaHREaWZmKTtcblxuICAgICAgICBsZXQgd2lkdGhEaWZmID0gKHRoaXMuYW5ub3RhdG9yLnBsYXllci4kdmlkZW8ud2lkdGgoKSAtIHZpZGVvRGltcy53aWR0aCkgLyAyO1xuICAgICAgICB0aGlzLiR2aWRlb092ZXJsYXkuY3NzKCdsZWZ0Jywgd2lkdGhEaWZmKTtcbiAgICB9XG5cbiAgICBnZXRQbGF5ZXJTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbm5vdGF0b3IucGxheWVyLkdldFZpZGVvRGltZW5zaW9ucygpO1xuICAgIH1cblxufVxuXG5leHBvcnQgeyBQb2x5Z29uT3ZlcmxheSB9OyIsIlxuY2xhc3MgVGlja0JhciB7XG4gICAgY29uc3RydWN0b3IoYW5ub3RhdG9yKXtcbiAgICAgICAgdGhpcy5hbm5vdGF0b3IgPSBhbm5vdGF0b3I7XG5cbiAgICAgICAgdGhpcy50aWNrcyA9IFtdO1xuXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgZWxlbWVudFxuICAgICAgICB0aGlzLiR0aWNrQmFyID0gJChcIjxkaXYgY2xhc3M9J3dhbGRvcmYtdGlja2Jhcic+PC9kaXY+XCIpO1xuICAgICAgICB0aGlzLmFubm90YXRvci5wbGF5ZXIuY29udHJvbEJhci4kY29udGFpbmVyLmFwcGVuZCh0aGlzLiR0aWNrQmFyKTtcblxuICAgICAgICAvLyBBdHRhY2ggZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgdGhpcy5hbm5vdGF0b3IuJGNvbnRhaW5lci5vbihcIk9uQW5ub3RhdGlvbnNMb2FkZWRcIiwgXG4gICAgICAgICAgICAoZXZlbnQsIGFubm90YXRpb25NYW5hZ2VyKSA9PiB0aGlzLkxvYWRBbm5vdGF0aW9ucyhhbm5vdGF0aW9uTWFuYWdlcikpO1xuXG4gICAgICAgIHRoaXMuYW5ub3RhdG9yLiRjb250YWluZXIub24oXCJPbkFubm90YXRpb25SZWdpc3RlcmVkXCIsXG4gICAgICAgICAgICAoZXZlbnQsIGFubm90YXRpb24pID0+IHRoaXMuTG9hZEFubm90YXRpb24oYW5ub3RhdGlvbikpO1xuXG4gICAgICAgIHRoaXMuYW5ub3RhdG9yLiRjb250YWluZXIub24oXCJPbkFubm90YXRpb25SZW1vdmVkXCIsXG4gICAgICAgICAgICAoZXZlbnQsIGlkKSA9PiB0aGlzLlJlbW92ZUFubm90YXRpb24oaWQpKTtcbiAgICAgICAgICAgIFxuICAgIH1cblxuICAgIExvYWRBbm5vdGF0aW9ucyhhbm5vdGF0aW9uTWFuYWdlcil7XG4gICAgICAgIHRoaXMuQ2xlYXIoKTtcblxuICAgICAgICBmb3IobGV0IGFubm90YXRpb24gb2YgYW5ub3RhdGlvbk1hbmFnZXIuYW5ub3RhdGlvbnMpe1xuICAgICAgICAgICAgdGhpcy5Mb2FkQW5ub3RhdGlvbihhbm5vdGF0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIExvYWRBbm5vdGF0aW9uKGFubm90YXRpb24pe1xuICAgICAgICBsZXQgJHRpY2sgPSAkKFwiPGRpdiBjbGFzcz0nd2FsZG9yZi10aWNrYmFyLXRpY2snPjwvZGl2PlwiKS5hcHBlbmRUbyh0aGlzLiR0aWNrQmFyKTtcblxuICAgICAgICAvLyBBZGQgdGhlIElEIG9mIHRoZSBhbm5vdGF0aW9uIHRvIGl0cyBjb3JyZXNwb25kaW5nIHRpY2sgc28gd2UgY2FuIHJlZmVyZW5jZSBpdCBsYXRlclxuICAgICAgICBpZiAoJ3VuZGVmaW5lZCcgPT0gdHlwZW9mKGFubm90YXRpb24uaXRlbXMpKSB7IC8vIFZlciAxXG4gICAgICAgICAgICAkdGljay5kYXRhKFwiYW5ub3RhdGlvbi1pZFwiLCBhbm5vdGF0aW9uLmlkKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gVmVyIDJcbiAgICAgICAgICAgICR0aWNrLmRhdGEoXCJhbm5vdGF0aW9uLWlkXCIsIGFubm90YXRpb24uaXRlbXNbMF0uaXRlbXNbMF0uaXRlbXNbMF0uaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGJlZ2luVGltZSA9IGFubm90YXRpb24uYmVnaW5UaW1lO1xuICAgICAgICBsZXQgYmVnaW5QZXJjZW50ID0gYmVnaW5UaW1lIC8gdGhpcy5hbm5vdGF0b3IucGxheWVyLnZpZGVvRWxlbWVudC5kdXJhdGlvbjtcbiAgICAgICAgJHRpY2suY3NzKCdsZWZ0JywgKGJlZ2luUGVyY2VudCAqIDEwMCkudG9TdHJpbmcoKSArIFwiJVwiKTtcblxuICAgICAgICBsZXQgZW5kVGltZSA9IGFubm90YXRpb24uZW5kVGltZTtcbiAgICAgICAgbGV0IGVuZFBlcmNlbnQgPSBlbmRUaW1lIC8gdGhpcy5hbm5vdGF0b3IucGxheWVyLnZpZGVvRWxlbWVudC5kdXJhdGlvbjtcbiAgICAgICAgJHRpY2suY3NzKCd3aWR0aCcsICgoZW5kUGVyY2VudCAtIGJlZ2luUGVyY2VudCkgKiAxMDApLnRvU3RyaW5nKCkgKyBcIiVcIik7XG5cbiAgICAgICAgdGhpcy50aWNrcy5wdXNoKCR0aWNrKTtcbiAgICB9XG5cbiAgICBSZW1vdmVBbm5vdGF0aW9uKGlkKXtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIlJlbW92aW5nIHRpY2sgXCIgKyBpZCk7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgb2JqZWN0IGZyb20gdGhlIGRvY3VtZW50LCBhbmQgdGhlIGFycmF5XG4gICAgICAgIGxldCBuZXdUaWNrcyA9IFtdO1xuICAgICAgICBmb3IobGV0ICR0aWNrIG9mIHRoaXMudGlja3Mpe1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1RpY2s6ICcgKyAkdGljay5kYXRhKFwiYW5ub3RhdGlvbi1pZFwiKSk7XG4gICAgICAgICAgICBpZigkdGljay5kYXRhKFwiYW5ub3RhdGlvbi1pZFwiKSA9PSBpZCl7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFJlbW92ZWQgdGljayAke2lkfWApO1xuICAgICAgICAgICAgICAgICR0aWNrLnJlbW92ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdUaWNrcy5wdXNoKCR0aWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpY2tzID0gbmV3VGlja3M7XG4gICAgfVxuXG4gICAgQ2xlYXIoKXtcbiAgICAgICAgZm9yKGxldCAkdGljayBvZiB0aGlzLnRpY2tzKXtcbiAgICAgICAgICAgICR0aWNrLnJlbW92ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50aWNrcyA9IFtdO1xuICAgIH1cblxufVxuXG5cbmV4cG9ydCB7IFRpY2tCYXIgfTsiLCJsZXQgc2hhMSA9IHJlcXVpcmUoJ3NoYTEnKTtcblxuY2xhc3MgU2VydmVySW50ZXJmYWNlIHtcbiAgICBjb25zdHJ1Y3Rvcihhbm5vdGF0b3Ipe1xuICAgICAgICB0aGlzLmFubm90YXRvciA9IGFubm90YXRvcjtcbiAgICAgICAgLy9sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnd2FsZG9yZl9hdXRoX3Rva2VuJyk7XG4gICAgfVxuXG4gICAgU2V0QmFzZVVSTCh1cmwpe1xuICAgICAgICB0aGlzLmJhc2VVUkwgPSB1cmw7XG4gICAgfVxuXG4gICAgbWFrZV9iYXNlX2F1dGgodXNlciwgcGFzc3dvcmQpIHtcbiAgICAgICAgdmFyIHRvayA9IHVzZXIgKyAnOicgKyBwYXNzd29yZDtcbiAgICAgICAgdmFyIGhhc2ggPSBidG9hKHRvayk7XG4gICAgICAgIHJldHVybiAnQmFzaWMgJyArIGhhc2g7XG4gICAgfVxuXG4gICAgbWFrZV93cml0ZV9hdXRoKHRleHQpe1xuICAgICAgICBpZih0aGlzLmFubm90YXRvci5hcGlLZXkpe1xuICAgICAgICAgICAgcmV0dXJuICdBcGlLZXkgJyArIHRleHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJ1Rva2VuICcgKyB0ZXh0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgTG9nZ2VkSW4oKXtcbiAgICAgICAgaWYodGhpcy5hbm5vdGF0b3IuYXBpS2V5KXtcbiAgICAgICAgICAgIC8vIFJldHVybiB0cnVlIGlmIGFuIGVtYWlsIGhhcyBiZWVuIGVudGVyZWRcbiAgICAgICAgICAgIGxldCB1c2VyX2VtYWlsID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3dhbGRvcmZfdXNlcl9lbWFpbCcpO1xuICAgICAgICAgICAgcmV0dXJuIHVzZXJfZW1haWwgIT09IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBSZXR1cm4gdHJ1ZSBpZiBhIHRva2VuIGhhcyBiZWVuIHJlZ2lzdGVyZWRcbiAgICAgICAgICAgIGxldCBhdXRoX3Rva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3dhbGRvcmZfYXV0aF90b2tlbicpO1xuICAgICAgICAgICAgcmV0dXJuIGF1dGhfdG9rZW4gIT09IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBMb2dJbih1c2VybmFtZSwgcGFzc3dvcmQpe1xuICAgICAgICAvLyBJZiBBUEkga2V5IGlzIHVzZWQsIGp1c3Qgc3RvcmUgdGhlIGVtYWlsIGFkZHJlc3NcbiAgICAgICAgaWYodGhpcy5hbm5vdGF0b3IuYXBpS2V5KXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW1NlcnZlciBJbnRlcmZhY2VdIFN1Y2Nlc3NmdWxseSBsb2dnZWQgaW4uXCIpO1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3dhbGRvcmZfdXNlcl9lbWFpbCcsIHBhc3N3b3JkKTtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd3YWxkb3JmX3VzZXJfbmFtZScsIHVzZXJuYW1lKTtcbiAgICAgICAgICAgIHRoaXMuYW5ub3RhdG9yLm1lc3NhZ2VPdmVybGF5LlNob3dNZXNzYWdlKFwiTG9nZ2VkIGluIGFzIFwiK3VzZXJuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiAkLkRlZmVycmVkKCkucmVzb2x2ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICQuYWpheCh7XG4gICAgICAgICAgICB1cmw6IHRoaXMuYmFzZVVSTCArIFwiL2FwaS9sb2dpblwiLFxuICAgICAgICAgICAgdHlwZTogXCJQT1NUXCIsXG4gICAgICAgICAgICBhc3luYzogdHJ1ZSxcbiAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMsXG4gICAgICAgICAgICBiZWZvcmVTZW5kOiBmdW5jdGlvbiAoeGhyKSB7XG4gICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0F1dGhvcml6YXRpb24nLCB0aGlzLm1ha2VfYmFzZV9hdXRoKHVzZXJuYW1lLCBwYXNzd29yZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS5kb25lKChkYXRhKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIltTZXJ2ZXIgSW50ZXJmYWNlXSBTdWNjZXNzZnVsbHkgbG9nZ2VkIGluLlwiKTtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd3YWxkb3JmX2F1dGhfdG9rZW4nLCBkYXRhLmF1dGhfdG9rZW4pO1xuICAgICAgICB9KS5mYWlsKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIltTZXJ2ZXIgSW50ZXJmYWNlXSBDb3VsZCBub3QgbG9nIGluLlwiKTtcbiAgICAgICAgICAgIHRoaXMuYW5ub3RhdG9yLm1lc3NhZ2VPdmVybGF5LlNob3dFcnJvcihcIkNvdWxkIG5vdCBsb2cgaW4hXCIpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBMb2dPdXQoKXtcbiAgICAgICAgLy8gSWYgQVBJIGtleSBpcyB1c2VkLCBqdXN0IHJlbW92ZSB0aGUgZW1haWwgZnJvbSBsb2NhbCBzdG9yYWdlLlxuICAgICAgICBpZih0aGlzLmFubm90YXRvci5hcGlLZXkpe1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJbU2VydmVyIEludGVyZmFjZV0gU3VjY2Vzc2Z1bGx5IGxvZ2dlZCBvdXQuXCIpO1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3dhbGRvcmZfdXNlcl9lbWFpbCcpO1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3dhbGRvcmZfdXNlcl9uYW1lJyk7XG4gICAgICAgICAgICByZXR1cm4gJC5EZWZlcnJlZCgpLnJlc29sdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAkLmFqYXgoe1xuICAgICAgICAgICAgdXJsOiB0aGlzLmJhc2VVUkwgKyBcIi9hcGkvbG9nb3V0XCIsXG4gICAgICAgICAgICB0eXBlOiBcIkRFTEVURVwiLFxuICAgICAgICAgICAgYXN5bmM6IHRydWUsXG4gICAgICAgICAgICBjb250ZXh0OiB0aGlzLFxuICAgICAgICAgICAgYmVmb3JlU2VuZDogZnVuY3Rpb24gKHhocikge1xuICAgICAgICAgICAgICAgIGxldCBhdXRoX3Rva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3dhbGRvcmZfYXV0aF90b2tlbicpIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtTZXJ2ZXIgSW50ZXJmYWNlXSB0b2tlbjogJHthdXRoX3Rva2VufWApO1xuICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBdXRob3JpemF0aW9uJywgdGhpcy5tYWtlX3dyaXRlX2F1dGgoYXV0aF90b2tlbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS5kb25lKChkYXRhKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIltTZXJ2ZXIgSW50ZXJmYWNlXSBTdWNjZXNzZnVsbHkgbG9nZ2VkIG91dC5cIik7XG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnd2FsZG9yZl9hdXRoX3Rva2VuJyk7XG4gICAgICAgIH0pLmZhaWwoKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiW1NlcnZlciBJbnRlcmZhY2VdIENvdWxkIG5vdCBsb2cgb3V0LlwiKTtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCd3YWxkb3JmX2F1dGhfdG9rZW4nKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgRmV0Y2hBbm5vdGF0aW9ucyhzZWFyY2hLZXksIHNlYXJjaFBhcmFtKSB7XG4gICAgICAgIC8vVGhpcyBpcyByZXBsYWNlZCBieSB0aGlzLmJhc2VVUkwsIHdoaWNoIGlzIGRlZmluZWQgaW4gY29uZmlnXG4gICAgICAgIC8vdmFyIGJvb2tfdXJsID0gJ2h0dHA6Ly9zY2FsYXIudXNjLmVkdS9kZXYvc2VtYW50aWMtYW5ub3RhdGlvbi10b29sLyc7ICAvLyBUaGlzIHdpbGwgYmUgZGVmaW5lZCBpbiB0aGUgQm9vaydzIEpTXG4gICAgICAgIC8vaHR0cHM6Ly9zY2FsYXIudXNjLmVkdS9kZXYvc2VtYW50aWMtYW5ub3RhdGlvbi10b29sL3JkZi9maWxlL21lZGlhL0luY2VwdGlvbiUyMENvcmdpJTIwRmxvcC5tcDQ/Zm9ybWF0PW9hYyZwcm92PTEmcmVjPTJcbiAgICAgICAvLyB2YXIgYWpheF91cmwgPSB0aGlzLmJhc2VVUkwgKyAncmRmL2ZpbGUvJyArIHNlYXJjaFBhcmFtLnJlcGxhY2UodGhpcy5iYXNlVVJMLCAnJykgKyAnP2Zvcm1hdD1vYWMmcHJvdj0xJnJlYz0yJztcbiAgICAgICAgdmFyIGFqYXhfdXJsID0gdGhpcy5iYXNlVVJMICsgJ3JkZi9maWxlLycgKyBzZWFyY2hQYXJhbS5yZXBsYWNlKHRoaXMuYmFzZVVSTCwnJykgKyAnP2Zvcm1hdD1paWlmJnByb3Y9MSZyZWM9Mic7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJhamF4X3VybDogXCIgKyBhamF4X3VybCk7XG4gICAgICAgIHJldHVybiAkLmFqYXgoe1xuICAgICAgICAgICAgdXJsOiBhamF4X3VybCxcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXG4gICAgICAgICAgICBqc29ucDogXCJjYWxsYmFja1wiLFxuICAgICAgICAgICAgZGF0YVR5cGU6IFwianNvbnBcIixcbiAgICAgICAgICAgIGFzeW5jOiB0cnVlXG4gICAgICAgIH0pLmRvbmUoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbU2VydmVyIEludGVyZmFjZV0gRmV0Y2hlZCAnICsgKCgndW5kZWZpbmVkJz09dHlwZW9mKGRhdGEuaXRlbXMpKT9kYXRhLmxlbmd0aC0xOmRhdGEuaXRlbXNbMF0uaXRlbXMubGVuZ3RoKSArICcgYW5ub3RhdGlvbnMgZm9yICcgKyBzZWFyY2hLZXkgKyAnOiBcIicgKyBzZWFyY2hQYXJhbSArICdcIi4nKTtcbiAgICAgICAgfSkuZmFpbChmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHZhciByZXR1cm5lZF9yZXNwb25zZSA9IHJlc3BvbnNlLnJlc3BvbnNlSlNPTi5lcnJvci5jb2RlWzBdLnZhbHVlICsgXCIgOiBcIiArIHJlc3BvbnNlLnJlc3BvbnNlSlNPTi5lcnJvci5tZXNzYWdlWzBdLnZhbHVlIDtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTZXJ2ZXIgSW50ZXJmYWNlXSBFcnJvciBmZXRjaGluZyBhbm5vdGF0aW9ucyBmb3IgJyArIHNlYXJjaEtleSArICc6IFwiJyArIHNlYXJjaFBhcmFtICsgJ1wiXFxuICcgKyByZXR1cm5lZF9yZXNwb25zZSk7XG4gICAgICAgICAgICBfdGhpczIuYW5ub3RhdG9yLm1lc3NhZ2VPdmVybGF5LlNob3dFcnJvcignQ291bGQgbm90IHJldHJpZXZlIGFubm90YXRpb25zITxicj4oJyArIHJldHVybmVkX3Jlc3BvbnNlICsgJyknKTtcblxuICAgICAgICB9KTsgIFxuICAgIH1cblxuICAgIFBvc3RBbm5vdGF0aW9uKGNhbGxiYWNrKXtcbiAgICAgICAgY29uc29sZS5sb2coXCJQb3N0aW5nIGFubm90YXRpb24uLi5cIik7XG4gICAgICAgIGxldCBhbm5vdGF0aW9uID0gdGhpcy5hbm5vdGF0b3IuZ3VpLkdldEFubm90YXRpb25PYmplY3QoKTtcbiAgICAgICAgY29uc29sZS5sb2coYW5ub3RhdGlvbik7XG5cbiAgICAgICAgbGV0IGtleTtcbiAgICAgICAgaWYgKHRoaXMuYW5ub3RhdG9yLmFwaUtleSl7XG4gICAgICAgICAgICBrZXkgPSB0aGlzLmFubm90YXRvci5hcGlLZXk7XG4gICAgICAgICAgICBsZXQgZW1haWxfc3RvcmFnZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd3YWxkb3JmX3VzZXJfZW1haWwnKTtcbiAgICAgICAgICAgIGxldCBuYW1lX3N0b3JhZ2UgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnd2FsZG9yZl91c2VyX25hbWUnKTtcbiAgICAgICAgICAgIGlmKG5hbWVfc3RvcmFnZSA9PSBudWxsKSBuYW1lX3N0b3JhZ2UgPSBlbWFpbF9zdG9yYWdlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAga2V5ID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3dhbGRvcmZfYXV0aF90b2tlbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5hbm5vdGF0b3IuYXBpS2V5KXtcbiAgICAgICAgICAgIGlmKGFubm90YXRpb25bXCJjcmVhdG9yXCJdID09IG51bGwpIGFubm90YXRpb25bXCJjcmVhdG9yXCJdID0ge307XG4gICAgICAgICAgICBhbm5vdGF0aW9uW1wiY3JlYXRvclwiXVtcImVtYWlsXCJdID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3dhbGRvcmZfdXNlcl9lbWFpbCcpO1xuICAgICAgICAgICAgYW5ub3RhdGlvbltcImNyZWF0b3JcIl1bXCJuaWNrbmFtZVwiXSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd3YWxkb3JmX3VzZXJfbmFtZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFubm90YXRpb25bXCJhbm5vdGF0aW9uX3ZlcnNpb25cIl0gPT0gXCJ2MVwiKSB7XG4gICAgICAgICAgICBhbm5vdGF0aW9uW1wicmVxdWVzdFwiXVtcIml0ZW1zXCJdW1wiYWN0aW9uXCJdID0gXCJhZGRcIjtcbiAgICAgICAgICAgIGRlbGV0ZSBhbm5vdGF0aW9uW1wiaXRlbXNcIl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbm5vdGF0aW9uW1wic2VydmljZVwiXVswXVtcIml0ZW1zXCJdW1wiYWN0aW9uXCJdID0gXCJhZGRcIjtcbiAgICAgICAgICAgIGRlbGV0ZSBhbm5vdGF0aW9uW1widGFyZ2V0XCJdO1xuICAgICAgICAgICAgZGVsZXRlIGFubm90YXRpb25bXCJib2R5XCJdO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBhbm5vdGF0aW9uW1wiYW5ub3RhdGlvbl92ZXJzaW9uXCJdO1xuXG4gICAgICAgIGFubm90YXRpb25bXCJpZFwiXSA9IHRoaXMuYmFzZVVSTCArIFwiYXBpL2FkZFwiO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKFwiUG9zdEFubm90YXRpb24gcGF5bG9hZDogXCIgKyBKU09OLnN0cmluZ2lmeShhbm5vdGF0aW9uKSk7XG4gICAgICAgIFxuICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgLy91cmw6IHRoaXMuYmFzZVVSTCArIFwiL2FwaS9hZGRBbm5vdGF0aW9uXCIsXG4gICAgICAgICAgICB1cmw6IHRoaXMuYmFzZVVSTCArIFwiYXBpL2FkZFwiLFxuICAgICAgICAgICAgdHlwZTogXCJQT1NUXCIsXG4gICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLCAvLyBOZWNlc3NhcnkgZm9yIFJhaWxzIHRvIHNlZSB0aGlzIGRhdGEgdHlwZSBjb3JyZWN0bHlcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vanNvbicsICAvLyBOZWNlc3NhcnkgZm9yIFJhaWxzIHRvIHNlZSB0aGlzIGRhdGEgdHlwZSBjb3JyZWN0bHlcbiAgICAgICAgICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5KGFubm90YXRpb24pLCAgLy8gU3RyaW5naWZ5IG5lY2Vzc2FyeSBmb3IgUmFpbHMgdG8gc2VlIHRoaXMgZGF0YSB0eXBlIGNvcnJlY3RseVxuICAgICAgICAgICAgYXN5bmM6IHRydWUsXG4gICAgICAgICAgICBjb250ZXh0OiB0aGlzLFxuICAgICAgICAgICAgYmVmb3JlU2VuZDogZnVuY3Rpb24gKHhocikge1xuICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBdXRob3JpemF0aW9uJywgdGhpcy5tYWtlX3dyaXRlX2F1dGgoa2V5KSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3VjY2VzczogKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlN1Y2Nlc3NmdWxseSBwb3N0ZWQgbmV3IGFubm90YXRpb24uXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuYW5ub3RhdG9yLm1lc3NhZ2VPdmVybGF5LlNob3dNZXNzYWdlKFwiU3VjY2Vzc2Z1bGx5IGNyZWF0ZWQgbmV3IGFubm90YXRpb24uXCIpO1xuICAgICAgICAgICAgICAgIGFubm90YXRpb24uaWQgPSBkYXRhLmlkOyAvLyBBcHBlbmQgdGhlIElEIGdpdmVuIGJ5IHRoZSByZXNwb25zZVxuICAgICAgICAgICAgICAgIGlmKGNhbGxiYWNrKSBjYWxsYmFjayhhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcjogKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIHJldHVybmVkX3Jlc3BvbnNlID0gXCJ1bmRlZmluZWQgZXJyb3Igd2hpbGUgZWRpdGluZyB0aGUgYW5ub3RhdGlvblwiO1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5yZXNwb25zZUpTT04pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuZWRfcmVzcG9uc2UgPSByZXNwb25zZS5yZXNwb25zZUpTT04uZXJyb3IuY29kZVswXS52YWx1ZSArIFwiIDogXCIgKyByZXNwb25zZS5yZXNwb25zZUpTT04uZXJyb3IubWVzc2FnZVswXS52YWx1ZSA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYENvdWxkIG5vdCBlZGl0IHRoZSBhbm5vdGF0aW9uISBNZXNzYWdlOlxcbiAke3JldHVybmVkX3Jlc3BvbnNlfWApO1xuICAgICAgICAgICAgICAgIHRoaXMuYW5ub3RhdG9yLm1lc3NhZ2VPdmVybGF5LlNob3dFcnJvcihgQ291bGQgbm90IGVkaXQgdGhlIGFubm90YXRpb24hPGJyPigke3JldHVybmVkX3Jlc3BvbnNlfSlgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgRWRpdEFubm90YXRpb24oY2FsbGJhY2spe1xuICAgICAgICBjb25zb2xlLmxvZyhcIkVkaXRpbmcgYW5ub3RhdGlvbi4uLlwiKTtcbiAgICAgICAgbGV0IGFubm90YXRpb24gPSB0aGlzLmFubm90YXRvci5ndWkuR2V0QW5ub3RhdGlvbk9iamVjdCgpO1xuICAgICAgICBjb25zb2xlLmxvZyhhbm5vdGF0aW9uKTtcblxuICAgICAgICBsZXQga2V5O1xuICAgICAgICBpZiAodGhpcy5hbm5vdGF0b3IuYXBpS2V5KXtcbiAgICAgICAgICAgIGtleSA9IHRoaXMuYW5ub3RhdG9yLmFwaUtleTtcbiAgICAgICAgICAgIGxldCBlbWFpbF9zdG9yYWdlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3dhbGRvcmZfdXNlcl9lbWFpbCcpO1xuICAgICAgICAgICAgbGV0IG5hbWVfc3RvcmFnZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd3YWxkb3JmX3VzZXJfbmFtZScpO1xuICAgICAgICAgICAgaWYobmFtZV9zdG9yYWdlID09IG51bGwpIG5hbWVfc3RvcmFnZSA9IGVtYWlsX3N0b3JhZ2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBrZXkgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnd2FsZG9yZl9hdXRoX3Rva2VuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLmFubm90YXRvci5hcGlLZXkpe1xuICAgICAgICAgICAgaWYoYW5ub3RhdGlvbltcImNyZWF0b3JcIl0gPT0gbnVsbCkgYW5ub3RhdGlvbltcImNyZWF0b3JcIl0gPSB7fTtcbiAgICAgICAgICAgIGFubm90YXRpb25bXCJjcmVhdG9yXCJdW1wiZW1haWxcIl0gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnd2FsZG9yZl91c2VyX2VtYWlsJyk7XG4gICAgICAgICAgICBhbm5vdGF0aW9uW1wiY3JlYXRvclwiXVtcIm5pY2tuYW1lXCJdID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3dhbGRvcmZfdXNlcl9uYW1lJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYW5ub3RhdGlvbltcImFubm90YXRpb25fdmVyc2lvblwiXSA9PSBcInYxXCIpIHtcbiAgICAgICAgICAgIGFubm90YXRpb25bXCJyZXF1ZXN0XCJdW1wiaXRlbXNcIl1bXCJhY3Rpb25cIl0gPSBcInVwZGF0ZVwiO1xuICAgICAgICAgICAgZGVsZXRlIGFubm90YXRpb25bXCJpdGVtc1wiXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFubm90YXRpb25bXCJzZXJ2aWNlXCJdWzBdW1wiaXRlbXNcIl1bXCJhY3Rpb25cIl0gPSBcInVwZGF0ZVwiO1xuICAgICAgICAgICAgZGVsZXRlIGFubm90YXRpb25bXCJ0YXJnZXRcIl07XG4gICAgICAgICAgICBkZWxldGUgYW5ub3RhdGlvbltcImJvZHlcIl07XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIGFubm90YXRpb25bXCJhbm5vdGF0aW9uX3ZlcnNpb25cIl07XG5cbiAgICAgICAgdmFyIG9sZElEID0gJyc7XG4gICAgICAgIGlmICgndW5kZWZpbmVkJyA9PSB0eXBlb2YoYW5ub3RhdGlvbi5pdGVtcykpIHsgLy8gVmVyc2lvbiAxXG4gICAgICAgICAgICBvbGRJRCA9IGFubm90YXRpb24uaWQ7XG4gICAgICAgIH0gZWxzZSB7IC8vIFZlcnNpb24gMlxuICAgICAgICAgICAgb2xkSUQgPSBhbm5vdGF0aW9uLml0ZW1zWzBdLml0ZW1zWzBdLml0ZW1zWzBdLmlkO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coXCJNb2RpZnlpbmcgYW5ub3RhdGlvbjogXCIgKyBvbGRJRCk7XG4gICAgICAgIFxuICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgdXJsOiB0aGlzLmJhc2VVUkwgKyBcImFwaS91cGRhdGVcIixcbiAgICAgICAgICAgIHR5cGU6IFwiUE9TVFwiLFxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICBkYXRhOiBKU09OLnN0cmluZ2lmeShhbm5vdGF0aW9uKSxcbiAgICAgICAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgICAgICAgY29udGV4dDogdGhpcyxcbiAgICAgICAgICAgIGJlZm9yZVNlbmQ6IGZ1bmN0aW9uICh4aHIpIHtcbiAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQXV0aG9yaXphdGlvbicsIHRoaXMubWFrZV93cml0ZV9hdXRoKGtleSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9uLmlkID0gZGF0YS5pZDsgLy8gQXBwZW5kIHRoZSBJRCBnaXZlbiBieSB0aGUgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiU3VjY2Vzc2Z1bGx5IGVkaXRlZCB0aGUgYW5ub3RhdGlvbi4gKElEIGlzIG5vdyBcIiArIGRhdGEuaWQgKyBcIilcIik7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmFubm90YXRvci5tZXNzYWdlT3ZlcmxheS5TaG93TWVzc2FnZShcIlN1Y2Nlc3NmdWxseSBlZGl0ZWQgdGhlIGFub3RhdGlvbi5cIik7XG4gICAgICAgICAgICAgICAgaWYoY2FsbGJhY2spIGNhbGxiYWNrKGFubm90YXRpb24sIG9sZElEKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcjogKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmVycm9yKGBDb3VsZCBub3QgZWRpdCB0aGUgYW5ub3RhdGlvbiEgTWVzc2FnZTpcXG4gJHtyZXNwb25zZS5yZXNwb25zZUpTT04uZGV0YWlsfWApO1xuICAgICAgICAgICAgICAgIC8vdGhpcy5hbm5vdGF0b3IubWVzc2FnZU92ZXJsYXkuU2hvd0Vycm9yKGBDb3VsZCBub3QgZWRpdCB0aGUgYW5ub3RhdGlvbiE8YnI+KCR7cmVzcG9uc2UucmVzcG9uc2VKU09OLmRldGFpbH0pYCk7XG4gICAgICAgICAgICAgICAgdmFyIHJldHVybmVkX3Jlc3BvbnNlID0gXCJ1bmRlZmluZWQgZXJyb3Igd2hpbGUgZWRpdGluZyB0aGUgYW5ub3RhdGlvblwiO1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5yZXNwb25zZUpTT04pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuZWRfcmVzcG9uc2UgPSByZXNwb25zZS5yZXNwb25zZUpTT04uZXJyb3IuY29kZVswXS52YWx1ZSArIFwiIDogXCIgKyByZXNwb25zZS5yZXNwb25zZUpTT04uZXJyb3IubWVzc2FnZVswXS52YWx1ZSA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYENvdWxkIG5vdCBlZGl0IHRoZSBhbm5vdGF0aW9uISBNZXNzYWdlOlxcbiAke3JldHVybmVkX3Jlc3BvbnNlfWApO1xuICAgICAgICAgICAgICAgIHRoaXMuYW5ub3RhdG9yLm1lc3NhZ2VPdmVybGF5LlNob3dFcnJvcihgQ291bGQgbm90IGVkaXQgdGhlIGFubm90YXRpb24hPGJyPigke3JldHVybmVkX3Jlc3BvbnNlfSlgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBEZWxldGVBbm5vdGF0aW9uKGFubm90YXRpb24sIGNhbGxiYWNrKXtcbiAgICAgICAgaWYgKCFjb25maXJtKCdBcmUgeW91IHN1cmUgeW91IHdpc2ggdG8gZGVsZXRlIHRoaXMgYW5ub3RhdGlvbj8nKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGtleTtcbiAgICAgICAgaWYgKHRoaXMuYW5ub3RhdG9yLmFwaUtleSl7XG4gICAgICAgICAgICBrZXkgPSB0aGlzLmFubm90YXRvci5hcGlLZXk7XG4gICAgICAgICAgICBsZXQgZW1haWxfc3RvcmFnZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd3YWxkb3JmX3VzZXJfZW1haWwnKTtcbiAgICAgICAgICAgIGxldCBuYW1lX3N0b3JhZ2UgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnd2FsZG9yZl91c2VyX25hbWUnKTtcbiAgICAgICAgICAgIGlmKG5hbWVfc3RvcmFnZSA9PSBudWxsKSBuYW1lX3N0b3JhZ2UgPSBlbWFpbF9zdG9yYWdlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAga2V5ID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3dhbGRvcmZfYXV0aF90b2tlbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5hbm5vdGF0b3IuYXBpS2V5KXtcbiAgICAgICAgICAgIGlmKGFubm90YXRpb25bXCJjcmVhdG9yXCJdID09IG51bGwpIGFubm90YXRpb25bXCJjcmVhdG9yXCJdID0ge307XG4gICAgICAgICAgICBhbm5vdGF0aW9uW1wiY3JlYXRvclwiXVtcImVtYWlsXCJdID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3dhbGRvcmZfdXNlcl9lbWFpbCcpO1xuICAgICAgICAgICAgYW5ub3RhdGlvbltcImNyZWF0b3JcIl1bXCJuaWNrbmFtZVwiXSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd3YWxkb3JmX3VzZXJfbmFtZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFubm90YXRpb25bXCJhbm5vdGF0aW9uX3ZlcnNpb25cIl0gPT0gXCJ2MVwiKSB7XG4gICAgICAgICAgICBhbm5vdGF0aW9uW1wicmVxdWVzdFwiXVtcIml0ZW1zXCJdW1wiYWN0aW9uXCJdID0gXCJ1cGRhdGVcIjtcbiAgICAgICAgICAgIGRlbGV0ZSBhbm5vdGF0aW9uW1wiaXRlbXNcIl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbm5vdGF0aW9uW1wic2VydmljZVwiXVswXVtcIml0ZW1zXCJdW1wiYWN0aW9uXCJdID0gXCJ1cGRhdGVcIjtcbiAgICAgICAgICAgIGRlbGV0ZSBhbm5vdGF0aW9uW1widGFyZ2V0XCJdO1xuICAgICAgICAgICAgZGVsZXRlIGFubm90YXRpb25bXCJib2R5XCJdO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBhbm5vdGF0aW9uW1wiYW5ub3RhdGlvbl92ZXJzaW9uXCJdO1xuXG4gICAgICAgIHZhciBvbGRJRCA9ICcnO1xuICAgICAgICBpZiAoJ3VuZGVmaW5lZCcgPT0gdHlwZW9mKGFubm90YXRpb24uaXRlbXMpKSB7IC8vIFZlcnNpb24gMVxuICAgICAgICAgICAgb2xkSUQgPSBhbm5vdGF0aW9uLmlkO1xuICAgICAgICB9IGVsc2UgeyAvLyBWZXJzaW9uIDJcbiAgICAgICAgICAgIG9sZElEID0gYW5ub3RhdGlvbi5pdGVtc1swXS5pdGVtc1swXS5pdGVtc1swXS5pZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKFwiRGVsZXRpbmcgYW5ub3RhdGlvbjogXCIgKyBvbGRJRClcblxuICAgICAgICBpZiAoJ3VuZGVmaW5lZCcgPT0gdHlwZW9mKGFubm90YXRpb24uaXRlbXMpKSB7IC8vIFZlcnNpb24gMVxuICAgICAgICAgICAgdmFyIGRlbF9kYXRhID0ge1xuICAgICAgICAgICAgICAgIFwic2NhbGFyOnVyblwiOiBcInVybjpzY2FsYXI6dmVyc2lvbjpcIiArIGFubm90YXRpb24uaWQsXG4gICAgICAgICAgICAgICAgXCJuYXRpdmVcIjogYW5ub3RhdGlvbi5yZXF1ZXN0Lml0ZW1zLm5hdGl2ZSxcbiAgICAgICAgICAgICAgICBcImFjdGlvblwiOiBcIkRFTEVURVwiLFxuICAgICAgICAgICAgICAgIFwiYXBpX2tleVwiOiBhbm5vdGF0aW9uLnJlcXVlc3QuaXRlbXMuYXBpX2tleSxcbiAgICAgICAgICAgICAgICBcImlkXCI6IGFubm90YXRpb24ucmVxdWVzdC5pdGVtcy5pZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiAkLnBvc3QodGhpcy5iYXNlVVJMICsgXCJhcGkvZGVsZXRlXCIsIGRlbF9kYXRhLCBmdW5jdGlvbihyZXNwb25zZSl7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkRlbGV0ZSBlcnJvciByZXNwb25zZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXNwb25zZS5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgIH0gIFxuICAgICAgICAgICAgfSkuZG9uZSgocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlN1Y2Nlc3NmdWxseSBkZWxldGVkIHRoZSBhbm5vdGF0aW9uLlwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFubm90YXRvci5tZXNzYWdlT3ZlcmxheS5TaG93TWVzc2FnZShcIlN1Y2Nlc3NmdWxseSBkZWxldGVkIHRoZSBhbm5vdGF0aW9uLlwiKTtcbiAgICAgICAgICAgICAgICBpZihjYWxsYmFjaykgY2FsbGJhY2soYW5ub3RhdGlvbiwgb2xkSUQpO1xuICAgICAgICAgICAgfSkuZmFpbCgocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0dXJuZWRfcmVzcG9uc2UgPSBcInVuZGVmaW5lZCBmYWlsdXJlIHdoaWxlIGRlbGV0aW5nIHRoZSBhbm5vdGF0aW9uXCI7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnJlc3BvbnNlSlNPTikge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5yZXNwb25zZUpTT04uZXJyb3IuY29kZVswXS52YWx1ZSArIFwiIDogXCIgKyByZXNwb25zZS5yZXNwb25zZUpTT04uZXJyb3IubWVzc2FnZVswXS52YWx1ZSA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYENvdWxkIG5vdCBkZWxldGUgdGhlIGFubm90YXRpb24uIE1lc3NhZ2U6XFxuICR7cmV0dXJuZWRfcmVzcG9uc2V9YCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hbm5vdGF0b3IubWVzc2FnZU92ZXJsYXkuU2hvd0Vycm9yKGBDb3VsZCBub3QgZGVsZXRlIHRoZSBhbm5vdGF0aW9uITxicj4oJHtyZXR1cm5lZF9yZXNwb25zZX0pYCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHsgLy8gVmVyc2lvbiAyXG4gICAgICAgICAgICBhbm5vdGF0aW9uW1wic2VydmljZVwiXVswXVtcIml0ZW1zXCJdW1wiYWN0aW9uXCJdID0gXCJkZWxldGVcIjtcbiAgICAgICAgICAgIGRlbGV0ZSBhbm5vdGF0aW9uW1widGFyZ2V0XCJdO1xuICAgICAgICAgICAgZGVsZXRlIGFubm90YXRpb25bXCJib2R5XCJdO1xuICAgICAgICAgICAgZGVsZXRlIGFubm90YXRpb25bXCJhbm5vdGF0aW9uX3ZlcnNpb25cIl07XG4gICAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgICAgIHVybDogdGhpcy5iYXNlVVJMICsgXCJhcGkvZGVsZXRlXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5KGFubm90YXRpb24pLFxuICAgICAgICAgICAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMsXG4gICAgICAgICAgICAgICAgYmVmb3JlU2VuZDogZnVuY3Rpb24gKHhocikge1xuICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQXV0aG9yaXphdGlvbicsIHRoaXMubWFrZV93cml0ZV9hdXRoKGtleSkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3VjY2VzczogKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbm5vdGF0b3IubWVzc2FnZU92ZXJsYXkuU2hvd01lc3NhZ2UoXCJTdWNjZXNzZnVsbHkgZGVsZXRlZCB0aGUgYW5vdGF0aW9uLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYoY2FsbGJhY2spIGNhbGxiYWNrKGFubm90YXRpb24sIG9sZElEKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldHVybmVkX3Jlc3BvbnNlID0gXCJ1bmRlZmluZWQgZXJyb3Igd2hpbGUgZGVsZXRpbmcgdGhlIGFubm90YXRpb25cIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnJlc3BvbnNlSlNPTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuZWRfcmVzcG9uc2UgPSByZXNwb25zZS5yZXNwb25zZUpTT04uZXJyb3IuY29kZVswXS52YWx1ZSArIFwiIDogXCIgKyByZXNwb25zZS5yZXNwb25zZUpTT04uZXJyb3IubWVzc2FnZVswXS52YWx1ZSA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQ291bGQgbm90IGRlbGV0ZSB0aGUgYW5ub3RhdGlvbiEgTWVzc2FnZTpcXG4gJHtyZXR1cm5lZF9yZXNwb25zZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbm5vdGF0b3IubWVzc2FnZU92ZXJsYXkuU2hvd0Vycm9yKGBDb3VsZCBub3QgZGVsZXRlIHRoZSBhbm5vdGF0aW9uITxicj4oJHtyZXR1cm5lZF9yZXNwb25zZX0pYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gXG5cbiAgICB9XG5cbn1cblxuXG5leHBvcnQgeyBTZXJ2ZXJJbnRlcmZhY2UgfTsiLCJsZXQgc2hhMSA9IHJlcXVpcmUoJ3NoYTEnKTtcblxuLyoqXG4gKiBNYW5hZ2VzIHRoZSB1c2VyIHNlc3Npb24gZm9yIGNvbW11bmljYXRpbmcgd2l0aCB0aGUgYmFja2VuZC5cbiAqL1xuY2xhc3MgU2Vzc2lvbk1hbmFnZXIge1xuXG4gICAgY29uc3RydWN0b3IoYW5ub3RhdG9yKXtcbiAgICAgICAgY29uc29sZS5sb2coXCJbU2Vzc2lvbiBNYW5hZ2VyXSBDcmVhdGluZyBTZXNzaW9uTWFuYWdlci4uLlwiKTtcbiAgICAgICAgdGhpcy5hbm5vdGF0b3IgPSBhbm5vdGF0b3I7XG4gICAgICAgIHRoaXMubW9kYWxPcGVuID0gZmFsc2U7XG5cbiAgICAgICAgLy8gSW5qZWN0IHRoZSBidXR0b24gZm9yIGxvZ2dpbmcgaW4vb3V0IGludG8gdGhlIHRvb2xiYXJcbiAgICAgICAgaWYoIWFubm90YXRvci5raW9za01vZGUgJiYgYW5ub3RhdG9yLmNtc0VtYWlsID09ICcnKXtcbiAgICAgICAgICAgIHRoaXMuJHVzZXJCdXR0b24gPSAkKFwiPGJ1dHRvbj5TZXNzaW9uPC9idXR0b24+XCIpLmJ1dHRvbih7XG4gICAgICAgICAgICAgICAgaWNvbjogXCJmYSBmYS11c2VyXCIsXG4gICAgICAgICAgICAgICAgc2hvd0xhYmVsOiBmYWxzZVxuICAgICAgICAgICAgfSkuY2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuUHJlc2VudE1vZGFsKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuYW5ub3RhdG9yLnBsYXllci5jb250cm9sQmFyLlJlZ2lzdGVyRWxlbWVudCh0aGlzLiR1c2VyQnV0dG9uLCAxLCAnZmxleC1lbmQnKTtcbiAgICAgICAgfVxuICAgICAgICAvL3RoaXMuJGRpYWxvZy5kaWFsb2coXCJvcGVuXCIpO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKFwiW1Nlc3Npb24gTWFuYWdlcl0gU2Vzc2lvbk1hbmFnZXIgY3JlYXRlZC5cIik7XG5cbiAgICB9XG5cbiAgICBTaG93TG9naW5Nb2RhbCgpe1xuXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgZGlhbG9nXG4gICAgICAgIGxldCAkY29udGFpbmVyID0gJChcIjxkaXYgY2xhc3M9J3dhbGRvcmYtc2Vzc2lvbi1tb2RhbCcgdGl0bGU9J0xvZyBJbic+PC9kaXY+XCIpOyAvLyBPdXRlcm1vc3QgSFRNTFxuICAgICAgICBsZXQgJGhlYWRUZXh0ID0gJChcIjxwIGNsYXNzPSd2YWxpZGF0ZVRpcHMnPkFsbCBmaWVsZHMgYXJlIHJlcXVpcmVkLjwvcD5cIikuYXBwZW5kVG8oJGNvbnRhaW5lcik7XG4gICAgICAgIGxldCAkZm9ybSA9ICQoXCI8Zm9ybT48L2Zvcm0+XCIpLmFwcGVuZFRvKCRjb250YWluZXIpO1xuXG4gICAgICAgIGxldCAkbmlja25hbWVGaWVsZDtcbiAgICAgICAgbGV0ICR1c2VybmFtZUZpZWxkO1xuICAgICAgICBsZXQgJHBhc3N3b3JkRmllbGQ7XG5cbiAgICAgICAgaWYgKHRoaXMuYW5ub3RhdG9yLmFwaUtleSl7XG4gICAgICAgICAgICAkKFwiPGxhYmVsIGZvcj0ndXNlcm5hbWUnPk5hbWU8L2xhYmVsPlwiKS5hcHBlbmRUbygkZm9ybSk7XG4gICAgICAgICAgICAkbmlja25hbWVGaWVsZCA9ICQoXCI8aW5wdXQgdHlwZT0ndGV4dCcgbmFtZT0ndXNlcm5hbWUnIHZhbHVlPScnIGNsYXNzPSd0ZXh0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGwnPlwiKS5hcHBlbmRUbygkZm9ybSk7XG4gICAgICAgICAgICAkKFwiPGxhYmVsIGZvcj0ndXNlcm5hbWUnPkVtYWlsIEFkZHJlc3M8L2xhYmVsPlwiKS5hcHBlbmRUbygkZm9ybSk7XG4gICAgICAgICAgICAkdXNlcm5hbWVGaWVsZCA9ICQoXCI8aW5wdXQgdHlwZT0ndGV4dCcgbmFtZT0nZW1haWwnIHZhbHVlPScnIGNsYXNzPSd0ZXh0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGwnPlwiKS5hcHBlbmRUbygkZm9ybSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAkKFwiPGxhYmVsIGZvcj0ndXNlcm5hbWUnPlVzZXJuYW1lPC9sYWJlbD5cIikuYXBwZW5kVG8oJGZvcm0pO1xuICAgICAgICAgICAgJHVzZXJuYW1lRmllbGQgPSAkKFwiPGlucHV0IHR5cGU9J3RleHQnIG5hbWU9J3VzZXJuYW1lJyB2YWx1ZT0nJyBjbGFzcz0ndGV4dCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYWxsJz5cIikuYXBwZW5kVG8oJGZvcm0pO1xuICAgICAgICAgICAgJChcIjxsYWJlbCBmb3I9J3Bhc3N3b3JkJz5QYXNzd29yZDwvbGFiZWw+XCIpLmFwcGVuZFRvKCRmb3JtKTtcbiAgICAgICAgICAgICRwYXNzd29yZEZpZWxkID0gJChcIjxpbnB1dCB0eXBlPSdwYXNzd29yZCcgbmFtZT0ncGFzc3dvcmQnIHZhbHVlPScnIGNsYXNzPSd0ZXh0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGwnPlwiKS5hcHBlbmRUbygkZm9ybSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgICRmb3JtLndyYXBJbm5lcihcIjxmaWVsZHNldCAvPlwiKTtcblxuICAgICAgICBsZXQgbG9naW4gPSAoKSA9PiB7XG4gICAgICAgICAgICBpZih0aGlzLmFubm90YXRvci5hcGlLZXkpe1xuICAgICAgICAgICAgICAgIGxldCBuaWNrTmFtZSA9ICRuaWNrbmFtZUZpZWxkLnZhbCgpO1xuICAgICAgICAgICAgICAgIGxldCB1c2VyTmFtZSA9IHNoYTEoJHVzZXJuYW1lRmllbGQudmFsKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuYW5ub3RhdG9yLnNlcnZlci5Mb2dJbihuaWNrTmFtZSwgdXNlck5hbWUpLmRvbmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkFQSSBrZXkgbG9naW4gc3VjY2Vzc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgJGRpYWxvZy5kaWFsb2coXCJjbG9zZVwiKTtcbiAgICAgICAgICAgICAgICB9KS5mYWlsKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgJGhlYWRUZXh0Lmh0bWwoXCI8cD5JbnZhbGlkIGVtYWlsIGFkZHJlc3MuPC9wPlwiKTtcbiAgICAgICAgICAgICAgICAgICAgJGhlYWRUZXh0LmNzcyhcImNvbG9yXCIsIFwicmVkXCIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHVzZXJQYXNzID0gc2hhMSgkcGFzc3dvcmRGaWVsZC52YWwoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hbm5vdGF0b3Iuc2VydmVyLkxvZ0luKCR1c2VybmFtZUZpZWxkLnZhbCgpLCB1c2VyUGFzcykuZG9uZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICRkaWFsb2cuZGlhbG9nKFwiY2xvc2VcIik7XG4gICAgICAgICAgICAgICAgfSkuZmFpbCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICRoZWFkVGV4dC5odG1sKFwiPHA+SW52YWxpZCB1c2VybmFtZSBvciBwYXNzd29yZC48L3A+XCIpO1xuICAgICAgICAgICAgICAgICAgICAkaGVhZFRleHQuY3NzKFwiY29sb3JcIiwgXCJyZWRcIik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCAkZGlhbG9nID0gJGNvbnRhaW5lci5kaWFsb2coe1xuICAgICAgICAgICAgYXV0b09wZW46IHRydWUsXG4gICAgICAgICAgICBkcmFnZ2FibGU6IGZhbHNlLFxuICAgICAgICAgICAgbW9kYWw6IHRydWUsXG4gICAgICAgICAgICBidXR0b25zOiB7XG4gICAgICAgICAgICAgICAgXCJMb2cgSW5cIjogbG9naW4sXG4gICAgICAgICAgICAgICAgQ2FuY2VsOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICRkaWFsb2cuZGlhbG9nKFwiY2xvc2VcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgJGRpYWxvZy5maW5kKFwiZm9ybVwiKVsgMCBdLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgJGRpYWxvZy5maW5kKFwiaW5wdXRcIikucmVtb3ZlQ2xhc3MoIFwidWktc3RhdGUtZXJyb3JcIiApO1xuICAgICAgICAgICAgICAgIHRoaXMuT25Nb2RhbENsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIFNob3dMb2dvdXRNb2RhbCgpe1xuICAgICAgICBsZXQgJGNvbnRhaW5lciA9ICQoXCI8ZGl2IHRpdGxlPSdMb2cgT3V0Jz48L2Rpdj5cIik7XG4gICAgICAgIGxldCAkaGVhZFRleHQgPSAkY29udGFpbmVyLmh0bWwoXCI8cCBjbGFzcz0ndmFsaWRhdGVUaXBzJz5BcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gbG9nIG91dD88L3A+XCIpO1xuICAgICAgICBsZXQgJGRpYWxvZyA9ICRjb250YWluZXIuZGlhbG9nKHtcbiAgICAgICAgICAgIGF1dG9PcGVuOiB0cnVlLFxuICAgICAgICAgICAgZHJhZ2dhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIG1vZGFsOiB0cnVlLFxuICAgICAgICAgICAgYnV0dG9uczoge1xuICAgICAgICAgICAgICAgIFwiTG9nIE91dFwiOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5ub3RhdG9yLnNlcnZlci5Mb2dPdXQoKS5kb25lKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRkaWFsb2cuZGlhbG9nKFwiY2xvc2VcIik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgQ2FuY2VsOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICRkaWFsb2cuZGlhbG9nKFwiY2xvc2VcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5Pbk1vZGFsQ2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgUHJlc2VudE1vZGFsKCl7XG4gICAgICAgIC8vIEVhcmx5IG91dCBpZiB0aGUgbW9kYWwgaXMgYWxyZWFkeSBvcGVuXG4gICAgICAgIGlmKHRoaXMubW9kYWxPcGVuKSByZXR1cm47XG5cbiAgICAgICAgLy8gVHVybiBvZmYgZnVsbHNjcmVlbiBpZiBpdCdzIG9uXG4gICAgICAgIHRoaXMuYW5ub3RhdG9yLnBsYXllci5TZXRGdWxsc2NyZWVuKGZhbHNlKTtcblxuICAgICAgICBpZih0aGlzLmFubm90YXRvci5zZXJ2ZXIuTG9nZ2VkSW4oKSl7XG4gICAgICAgICAgICB0aGlzLlNob3dMb2dvdXRNb2RhbCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5TaG93TG9naW5Nb2RhbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5Pbk1vZGFsT3BlbigpO1xuICAgIH1cblxuICAgIE9uTW9kYWxPcGVuKCl7XG4gICAgICAgIHRoaXMuJHVzZXJCdXR0b24uYnV0dG9uKFwiZGlzYWJsZVwiKTtcbiAgICAgICAgdGhpcy5tb2RhbE9wZW4gPSB0cnVlO1xuICAgIH1cblxuICAgIE9uTW9kYWxDbG9zZSgpe1xuICAgICAgICB0aGlzLiR1c2VyQnV0dG9uLmJ1dHRvbihcImVuYWJsZVwiKTtcbiAgICAgICAgdGhpcy5tb2RhbE9wZW4gPSBmYWxzZTtcbiAgICB9XG5cbn1cblxuZXhwb3J0IHsgU2Vzc2lvbk1hbmFnZXIgfTsiLCJtb2R1bGUuZXhwb3J0cz17XG4gICAgXCJjb25maWdGaWxlXCI6IFwiYW5ub3RhdG9yLWNvbmZpZy5qc29uXCJcbn0iLCIvKlxuRW50cnkgcG9pbnQgZm9yIHRoZSB3aG9sZSBwcm9qZWN0LiBBbnkgalF1ZXJ5IGV4dGVuc2lvbnMgc2hvdWxkXG5iZSByZWdpc3RlcmVkIGhlcmUuXG4qL1xuXG4vLyBJbXBvcnQgbnBtIG1vZHVsZSBkZXBlbmRlbmNpZXNcbmltcG9ydCBcIi4vdmVuZG9yLmpzXCI7XG5cbmltcG9ydCBcIi4vdXRpbHMvYXJyYXktZXh0ZW5zaW9ucy5qc1wiO1xuaW1wb3J0IFwiLi91dGlscy9qcXVlcnktZXh0ZW5zaW9ucy5qc1wiO1xuaW1wb3J0IFwiLi91dGlscy9zdHJpbmctZXh0ZW5zaW9ucy5qc1wiO1xuXG5pbXBvcnQgeyBwcmVmZXJlbmNlcyB9IGZyb20gXCIuL3V0aWxzL3ByZWZlcmVuY2UtbWFuYWdlci5qc1wiO1xuaW1wb3J0IHsgVmVyaWZ5UmVxdWlyZW1lbnRzIH0gZnJvbSBcIi4vdXRpbHMvcmVxdWlyZW1lbnRzLmpzXCI7XG5pbXBvcnQgeyBBbm5vdGF0b3JWaWRlb1BsYXllciB9IGZyb20gXCIuL3ZpZGVvLXBsYXllci92aWRlby1wbGF5ZXIuanNcIjtcblxuXG4kLmZuLmFubm90YXRlID0gZnVuY3Rpb24oYXJncyl7IFxuXG4gICAgLy8gbGV0IHNlcnZlclVSTCA9IGFyZ3Muc2VydmVyVVJMIHx8ICcnO1xuICAgIC8vIGxldCB0YWdzVVJMID0gYXJncy50YWdzVVJMIHx8ICcnO1xuICAgIC8vIGxldCBhcGlLZXkgPSBhcmdzLmFwaUtleSB8fCAnJztcbiAgICAvLyBsZXQga2lvc2tNb2RlID0gYXJncy5raW9za01vZGUgfHwgZmFsc2U7XG4gICAgLy8gbGV0IGxvY2FsVVJMID0gYXJncy5sb2NhbFVSTCB8fCAnJztcbiAgICAvLyBsZXQgcmVuZGVyZXIgPSBmdW5jdGlvbiguLi4pIHx8IGZhbHNlO1xuXG4gICAgLy8gRXJyb3Igb3V0IGVhcmx5IGlmIFwidGhpc1wiIGlzIG5vdCBhIHZpZGVvXG4gICAgaWYoJCh0aGlzKS5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKSAhPSBcInZpZGVvXCIpe1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiQ2Fubm90IHdyYXAgYSBub24tdmlkZW8gZWxlbWVudCFcIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZighVmVyaWZ5UmVxdWlyZW1lbnRzKCkpe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gcHJlZmVyZW5jZXMuR2V0SlNPTigoZGF0YSkgPT4ge1xuICAgIC8vICAgICAvL2NvbnNvbGUubG9nKGRhdGEpO1xuICAgIC8vIH0pO1xuICAgIFxuICAgIG5ldyBBbm5vdGF0b3JWaWRlb1BsYXllcigkKHRoaXMpLCBhcmdzKTtcblxufTsiLCIvLyBGcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE0ODUzOTc0LzcxMzg3OTJcblxuLy8gV2FybiBpZiBvdmVycmlkaW5nIGV4aXN0aW5nIG1ldGhvZFxuaWYoQXJyYXkucHJvdG90eXBlLmVxdWFscylcbiAgICBjb25zb2xlLndhcm4oXCJPdmVycmlkaW5nIGV4aXN0aW5nIEFycmF5LnByb3RvdHlwZS5lcXVhbHMuIFBvc3NpYmxlIGNhdXNlczogTmV3IEFQSSBkZWZpbmVzIHRoZSBtZXRob2QsIFxcXG4gICAgdGhlcmUncyBhIGZyYW1ld29yayBjb25mbGljdCBvciB5b3UndmUgZ290IGRvdWJsZSBpbmNsdXNpb25zIGluIHlvdXIgY29kZS5cIik7XG4gICAgXG4vLyBhdHRhY2ggdGhlIC5lcXVhbHMgbWV0aG9kIHRvIEFycmF5J3MgcHJvdG90eXBlIHRvIGNhbGwgaXQgb24gYW55IGFycmF5XG5BcnJheS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgLy8gaWYgdGhlIG90aGVyIGFycmF5IGlzIGEgZmFsc3kgdmFsdWUsIHJldHVyblxuICAgIGlmICghYXJyYXkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIC8vIGNvbXBhcmUgbGVuZ3RocyAtIGNhbiBzYXZlIGEgbG90IG9mIHRpbWUgXG4gICAgaWYgKHRoaXMubGVuZ3RoICE9IGFycmF5Lmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGw9dGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBuZXN0ZWQgYXJyYXlzXG4gICAgICAgIGlmICh0aGlzW2ldIGluc3RhbmNlb2YgQXJyYXkgJiYgYXJyYXlbaV0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgLy8gcmVjdXJzZSBpbnRvIHRoZSBuZXN0ZWQgYXJyYXlzXG4gICAgICAgICAgICBpZiAoIXRoaXNbaV0uZXF1YWxzKGFycmF5W2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7ICAgICAgIFxuICAgICAgICB9ICAgICAgICAgICBcbiAgICAgICAgZWxzZSBpZiAodGhpc1tpXSAhPSBhcnJheVtpXSkgeyBcbiAgICAgICAgICAgIC8vIFdhcm5pbmcgLSB0d28gZGlmZmVyZW50IG9iamVjdCBpbnN0YW5jZXMgd2lsbCBuZXZlciBiZSBlcXVhbDoge3g6MjB9ICE9IHt4OjIwfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAgIFxuICAgICAgICB9ICAgICAgICAgICBcbiAgICB9ICAgICAgIFxuICAgIHJldHVybiB0cnVlO1xufVxuLy8gSGlkZSBtZXRob2QgZnJvbSBmb3ItaW4gbG9vcHNcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcnJheS5wcm90b3R5cGUsIFwiZXF1YWxzXCIsIHtlbnVtZXJhYmxlOiBmYWxzZX0pOyIsIi8qIVxyXG4gKiBqUXVlcnkgY2xpcC1wYXRoLXBvbHlnb24gUGx1Z2luIHYwLjEuMTUgKDIwMjAtMDYtMjQpXHJcbiAqIGpRdWVyeSBwbHVnaW4gdGhhdCBtYWtlcyBlYXN5IHRvIHVzZSBjbGlwLXBhdGggb24gd2hhdGV2ZXIgdGFnIHVuZGVyIGRpZmZlcmVudCBicm93c2Vyc1xyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYW5kcnVzaWVjemtvL2NsaXAtcGF0aC1wb2x5Z29uXHJcbiAqIFxyXG4gKiBDb3B5cmlnaHQgMjAyMCBLYXJvbCBBbmRydXNpZWN6a29cclxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2VcclxuICovXHJcblxyXG52YXIgZ2xvYmFsVmFyaWFibGUgPSB3aW5kb3cgfHwgcm9vdDtcclxudmFyIGpRdWVyeSA9IGpRdWVyeSB8fCBnbG9iYWxWYXJpYWJsZS5qUXVlcnkgfHwgcmVxdWlyZShcImpxdWVyeVwiKTtcclxuXHJcbihmdW5jdGlvbigkKSB7XHJcbiAgdmFyIGlkID0gMDtcclxuXHJcbiAgdmFyIENsaXBQYXRoID0gZnVuY3Rpb24oalF1ZXJ5LCAkZWwsIHBvaW50cywgb3B0aW9ucykge1xyXG4gICAgdGhpcy4kID0galF1ZXJ5O1xyXG4gICAgdGhpcy4kZWwgPSAkZWw7XHJcbiAgICB0aGlzLnBvaW50cyA9IHBvaW50cztcclxuICAgIHRoaXMuc3ZnRGVmSWQgPSAnY2xpcFBhdGhQb2x5Z29uR2VuSWQnICsgaWQrKztcclxuXHJcbiAgICB0aGlzLnByb2Nlc3NPcHRpb25zKG9wdGlvbnMpO1xyXG4gIH07XHJcblxyXG4gIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xyXG4gICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBDbGlwUGF0aDtcclxuICAgIH1cclxuICAgIGV4cG9ydHMuQ2xpcFBhdGggPSBDbGlwUGF0aDtcclxuICB9IGVsc2Uge1xyXG4gICAgZ2xvYmFsVmFyaWFibGUuQ2xpcFBhdGggPSBDbGlwUGF0aDtcclxuICB9XHJcblxyXG4gIENsaXBQYXRoLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICAkOiBudWxsLFxyXG4gICAgJGVsOiBudWxsLFxyXG4gICAgcG9pbnRzOiBudWxsLFxyXG5cclxuICAgIGlzRm9yV2Via2l0OiB0cnVlLFxyXG4gICAgaXNGb3JTdmc6IHRydWUsXHJcbiAgICBzdmdEZWZJZDogbnVsbCxcclxuICAgIGlzUGVyY2VudGFnZTogZmFsc2UsXHJcblxyXG4gICAgY3JlYXRlOiBmdW5jdGlvbigpIHtcclxuICAgICAgdGhpcy5fY3JlYXRlQ2xpcFBhdGgodGhpcy5wb2ludHMpO1xyXG4gICAgfSxcclxuXHJcbiAgICBfY3JlYXRlQ2xpcFBhdGg6IGZ1bmN0aW9uKHBvaW50cykge1xyXG4gICAgICB0aGlzLl9jcmVhdGVTdmdEZWZzKCk7XHJcbiAgICAgIGlmICh0aGlzLmlzRm9yU3ZnKSB7XHJcbiAgICAgICAgdGhpcy5fY3JlYXRlU3ZnQmFzZWRDbGlwUGF0aChwb2ludHMpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLmlzRm9yV2Via2l0KSB7XHJcbiAgICAgICAgdGhpcy5fY3JlYXRlV2Via2l0Q2xpcFBhdGgocG9pbnRzKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBfY3JlYXRlV2Via2l0Q2xpcFBhdGg6IGZ1bmN0aW9uKHBvaW50cykge1xyXG4gICAgICB2YXIgY2xpcFBhdGggPSBcInBvbHlnb24oXCIgKyB0aGlzLl90cmFuc2xhdGVQb2ludHMocG9pbnRzLCB0cnVlLCB0aGlzLmlzUGVyY2VudGFnZSkgKyBcIilcIjtcclxuICAgICAgdGhpcy4kZWwuY3NzKCctd2Via2l0LWNsaXAtcGF0aCcsIGNsaXBQYXRoKTtcclxuICAgIH0sXHJcblxyXG4gICAgX2NyZWF0ZVN2Z0Jhc2VkQ2xpcFBhdGg6IGZ1bmN0aW9uKHBvaW50cykge1xyXG4gICAgICB2YXIgY2xpcFBhdGggPSBcInBvbHlnb24oXCIgKyB0aGlzLl90cmFuc2xhdGVQb2ludHMocG9pbnRzLCB0cnVlLCB0aGlzLmlzUGVyY2VudGFnZSkgKyBcIilcIjtcclxuICAgICAgdGhpcy4kZWwuY3NzKCdjbGlwLXBhdGgnLCBjbGlwUGF0aCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIEZpcmVmb3ggbm8gbG9uZ2VyIHNlZW1zIHRvIHdvcmsgd2l0aCB0aGlzIGJ1dCBkb2VzIHdpdGggdGhlIHdlYmtpdCB2ZXJzaW9uLCBzbyBJIGNvcGllZCBpdCBhYm92ZS5cclxuICAgIC8vIF9jcmVhdGVTdmdCYXNlZENsaXBQYXRoOiBmdW5jdGlvbihwb2ludHMpIHtcclxuICAgIC8vICAgdGhpcy4kKCcjJyArIHRoaXMuc3ZnRGVmSWQgKyAnJykuZmluZCgncG9seWdvbicpLmF0dHIoJ3BvaW50cycsIHRoaXMuX3RyYW5zbGF0ZVBvaW50cyhwb2ludHMsIGZhbHNlLCB0aGlzLmlzUGVyY2VudGFnZSkpO1xyXG4gICAgLy8gICB0aGlzLiRlbC5jc3MoJ2NsaXAtcGF0aCcsICd1cmwoIycgKyB0aGlzLnN2Z0RlZklkICsgJyknKTtcclxuICAgIC8vIH0sXHJcblxyXG5cclxuICAgIF90cmFuc2xhdGVQb2ludHM6IGZ1bmN0aW9uKHBvaW50cywgd2l0aFVuaXQsIGlzUGVyY2VudGFnZSkge1xyXG4gICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgIGZvciAodmFyIGkgaW4gcG9pbnRzKSB7XHJcbiAgICAgICAgdmFyIHggPSB0aGlzLl9oYW5kbGVQeHMocG9pbnRzW2ldWzBdLCB3aXRoVW5pdCwgaXNQZXJjZW50YWdlKTtcclxuICAgICAgICB2YXIgeSA9IHRoaXMuX2hhbmRsZVB4cyhwb2ludHNbaV1bMV0sIHdpdGhVbml0LCBpc1BlcmNlbnRhZ2UpO1xyXG4gICAgICAgIHJlc3VsdC5wdXNoKHggKyAnICcgKyB5KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmVzdWx0LmpvaW4oJywgJyk7XHJcbiAgICB9LFxyXG5cclxuICAgIF9oYW5kbGVQeHM6IGZ1bmN0aW9uKG51bWJlciwgd2l0aFVuaXQsIGlzUGVyY2VudGFnZSkge1xyXG4gICAgICBpZiAobnVtYmVyID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bWJlcjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIXdpdGhVbml0KSB7XHJcbiAgICAgICAgaWYgKGlzUGVyY2VudGFnZSkge1xyXG4gICAgICAgICAgcmV0dXJuIG51bWJlciAvIDEwMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bWJlcjtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG51bWJlciArIChpc1BlcmNlbnRhZ2UgPyBcIiVcIiA6IFwicHhcIik7XHJcbiAgICB9LFxyXG5cclxuICAgIF9jcmVhdGVTdmdFbGVtZW50OiBmdW5jdGlvbihlbGVtZW50TmFtZSkge1xyXG4gICAgICByZXR1cm4gdGhpcy4kKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCBlbGVtZW50TmFtZSkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBfY3JlYXRlU3ZnRGVmczogZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmICh0aGlzLiQoJyMnICsgdGhpcy5zdmdEZWZJZCArICcnKS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICB2YXIgJHN2ZyA9IHRoaXMuX2NyZWF0ZVN2Z0VsZW1lbnQoJ3N2ZycpLmF0dHIoJ3dpZHRoJywgMCkuYXR0cignaGVpZ2h0JywgMCkuY3NzKHtcclxuICAgICAgICAgICdwb3NpdGlvbic6ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgICAndmlzaWJpbGl0eSc6ICdoaWRkZW4nLFxyXG4gICAgICAgICAgJ3dpZHRoJzogMCxcclxuICAgICAgICAgICdoZWlnaHQnOiAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyICRkZWZzID0gdGhpcy5fY3JlYXRlU3ZnRWxlbWVudCgnZGVmcycpO1xyXG4gICAgICAgICRzdmcuYXBwZW5kKCRkZWZzKTtcclxuICAgICAgICB2YXIgJGNsaXBwYXRoID0gdGhpcy5fY3JlYXRlU3ZnRWxlbWVudCgnY2xpcFBhdGgnKS5hdHRyKCdpZCcsIHRoaXMuc3ZnRGVmSWQpO1xyXG4gICAgICAgIGlmICh0aGlzLmlzUGVyY2VudGFnZSkge1xyXG4gICAgICAgICAgJGNsaXBwYXRoLmdldCgwKS5zZXRBdHRyaWJ1dGUoJ2NsaXBQYXRoVW5pdHMnLCAnb2JqZWN0Qm91bmRpbmdCb3gnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgJGRlZnMuYXBwZW5kKCRjbGlwcGF0aCk7XHJcbiAgICAgICAgdmFyICRwb2x5Z29uID0gdGhpcy5fY3JlYXRlU3ZnRWxlbWVudCgncG9seWdvbicpO1xyXG4gICAgICAgICRjbGlwcGF0aC5hcHBlbmQoJHBvbHlnb24pO1xyXG4gICAgICAgIHRoaXMuJCgnYm9keScpLmFwcGVuZCgkc3ZnKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBwcm9jZXNzT3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICB0aGlzLmlzRm9yV2Via2l0ID0gKG9wdGlvbnMgJiYgdHlwZW9mKG9wdGlvbnMuaXNGb3JXZWJraXQpICE9PSBcInVuZGVmaW5lZFwiKSA/IG9wdGlvbnMuaXNGb3JXZWJraXQgOiB0aGlzLmlzRm9yV2Via2l0O1xyXG4gICAgICB0aGlzLmlzRm9yU3ZnID0gKG9wdGlvbnMgJiYgdHlwZW9mKG9wdGlvbnMuaXNGb3JTdmcpICE9PSBcInVuZGVmaW5lZFwiKSA/IG9wdGlvbnMuaXNGb3JTdmcgOiB0aGlzLmlzRm9yU3ZnO1xyXG4gICAgICB0aGlzLmlzUGVyY2VudGFnZSA9IChvcHRpb25zICYmIG9wdGlvbnMuaXNQZXJjZW50YWdlIHx8IHRoaXMuaXNQZXJjZW50YWdlKTtcclxuICAgICAgdGhpcy5zdmdEZWZJZCA9IChvcHRpb25zICYmIG9wdGlvbnMuc3ZnRGVmSWQpIHx8IHRoaXMuc3ZnRGVmSWQ7XHJcbiAgICB9XHJcbiAgfTtcclxuICBcclxuICAkLmZuLmNsaXBQYXRoID0gZnVuY3Rpb24ocG9pbnRzLCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgJGVsID0gJCh0aGlzKTtcclxuICAgICAgdmFyIGNsaXBQYXRoID0gbmV3IENsaXBQYXRoKCQsICRlbCwgcG9pbnRzLCBvcHRpb25zKTtcclxuICAgICAgY2xpcFBhdGguY3JlYXRlKCk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxufSkuY2FsbCh0aGlzLCBqUXVlcnkpOyIsIi8qKlxuICogU2V0cyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZWxlbWVudCB3aGlsZSBkaXNhYmxpbmcgaW50ZXJhY3Rpb24uXG4gKiBEb2Vzbid0IG1lc3Mgd2l0aCBqUXVlcnkncyBwb3NpdGlvbmluZyBjYWxjdWxhdGlvbnMgbGlrZSBzaG93KClcbiAqIGFuZCBoaWRlKCkuXG4gKi9cbiQuZm4ubWFrZVZpc2libGUgPSBmdW5jdGlvbihzaG93KSB7XG4gICAgaWYoc2hvdyl7XG4gICAgICAgICQodGhpcykuY3NzKHtcbiAgICAgICAgICAgIFwidmlzaWJpbGl0eVwiOiBcInZpc2libGVcIixcbiAgICAgICAgICAgIFwicG9pbnRlci1ldmVudHNcIjogXCJcIlxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAkKHRoaXMpLmNzcyh7XG4gICAgICAgICAgICBcInZpc2liaWxpdHlcIjogXCJoaWRkZW5cIixcbiAgICAgICAgICAgIFwicG9pbnRlci1ldmVudHNcIjogXCJub25lXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFxufVxuXG4vKlxuQ29weXJpZ2h0IDIwMTQgTWlrZSBEdW5uXG5odHRwOi8vdXBzaG90cy5vcmcvXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbmEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG53aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG5kaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbnBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xudGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbmluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbkVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbk5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkVcbkxJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT05cbk9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmh0dHBzOi8vZ2l0aHViLmNvbS9tb2Fncml1cy9jb3B5Y3NzXG5cbiovXG5cdFxuJC5mbi5nZXRTdHlsZXMgPSBmdW5jdGlvbihvbmx5LCBleGNlcHQpIHtcbiAgICBcbiAgICAvLyB0aGUgbWFwIHRvIHJldHVybiB3aXRoIHJlcXVlc3RlZCBzdHlsZXMgYW5kIHZhbHVlcyBhcyBLVlBcbiAgICB2YXIgcHJvZHVjdCA9IHt9O1xuICAgIFxuICAgIC8vIHRoZSBzdHlsZSBvYmplY3QgZnJvbSB0aGUgRE9NIGVsZW1lbnQgd2UgbmVlZCB0byBpdGVyYXRlIHRocm91Z2hcbiAgICB2YXIgc3R5bGU7XG4gICAgXG4gICAgLy8gcmVjeWNsZSB0aGUgbmFtZSBvZiB0aGUgc3R5bGUgYXR0cmlidXRlXG4gICAgdmFyIG5hbWU7XG4gICAgXG4gICAgLy8gaWYgaXQncyBhIGxpbWl0ZWQgbGlzdCwgbm8gbmVlZCB0byBydW4gdGhyb3VnaCB0aGUgZW50aXJlIHN0eWxlIG9iamVjdFxuICAgIGlmIChvbmx5ICYmIG9ubHkgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvbmx5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgLy8gc2luY2Ugd2UgaGF2ZSB0aGUgbmFtZSBhbHJlYWR5LCBqdXN0IHJldHVybiB2aWEgYnVpbHQtaW4gLmNzcyBtZXRob2RcbiAgICAgICAgICAgIG5hbWUgPSBvbmx5W2ldO1xuICAgICAgICAgICAgcHJvZHVjdFtuYW1lXSA9IHRoaXMuY3NzKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgIH0gZWxzZSB7XG4gICAgXG4gICAgICAgIC8vIHByZXZlbnQgZnJvbSBlbXB0eSBzZWxlY3RvclxuICAgICAgICBpZiAodGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlLCB3ZSBuZWVkIHRvIGdldCBldmVyeXRoaW5nXG4gICAgICAgICAgICB2YXIgZG9tID0gdGhpcy5nZXQoMCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIHN0YW5kYXJkc1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gY29udmVuaWVuY2UgbWV0aG9kcyB0byB0dXJuIGNzcyBjYXNlICgnYmFja2dyb3VuZC1pbWFnZScpIHRvIGNhbWVsICgnYmFja2dyb3VuZEltYWdlJylcbiAgICAgICAgICAgICAgICB2YXIgcGF0dGVybiA9IC9cXC0oW2Etel0pL2c7XG4gICAgICAgICAgICAgICAgdmFyIHVjID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgfTtcdFx0XHRcbiAgICAgICAgICAgICAgICB2YXIgY2FtZWxpemUgPSBmdW5jdGlvbihzdHJpbmcpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UocGF0dGVybiwgdWMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHdlJ3JlIGdldHRpbmcgYSBnb29kIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgIGlmIChzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvbSwgbnVsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhbWVsLCB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gb3BlcmEgZG9lc24ndCBnaXZlIGJhY2sgc3R5bGUubGVuZ3RoIC0gdXNlIHRydXRoeSBzaW5jZSBhIDAgbGVuZ3RoIG1heSBhcyB3ZWxsIGJlIHNraXBwZWQgYW55d2F5c1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN0eWxlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBzdHlsZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW1lbCA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9kdWN0W2NhbWVsXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3BlcmFcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobmFtZSBpbiBzdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbWVsID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpIHx8IHN0eWxlW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RbY2FtZWxdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJRSAtIGZpcnN0IHRyeSBjdXJyZW50U3R5bGUsIHRoZW4gbm9ybWFsIHN0eWxlIG9iamVjdCAtIGRvbid0IGJvdGhlciB3aXRoIHJ1bnRpbWVTdHlsZVxuICAgICAgICAgICAgZWxzZSBpZiAoc3R5bGUgPSBkb20uY3VycmVudFN0eWxlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChuYW1lIGluIHN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2R1Y3RbbmFtZV0gPSBzdHlsZVtuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdHlsZSA9IGRvbS5zdHlsZSkge1xuICAgICAgICAgICAgICAgIGZvciAobmFtZSBpbiBzdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN0eWxlW25hbWVdICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2R1Y3RbbmFtZV0gPSBzdHlsZVtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyByZW1vdmUgYW55IHN0eWxlcyBzcGVjaWZpZWQuLi5cbiAgICAvLyBiZSBjYXJlZnVsIG9uIGJsYWNrbGlzdCAtIHNvbWV0aW1lcyB2ZW5kb3Itc3BlY2lmaWMgdmFsdWVzIGFyZW4ndCBvYnZpb3VzIGJ1dCB3aWxsIGJlIHZpc2libGUuLi4gIGUuZy4sIGV4Y2VwdGluZyAnY29sb3InIHdpbGwgc3RpbGwgbGV0ICctd2Via2l0LXRleHQtZmlsbC1jb2xvcicgdGhyb3VnaCwgd2hpY2ggd2lsbCBpbiBmYWN0IGNvbG9yIHRoZSB0ZXh0XG4gICAgaWYgKGV4Y2VwdCAmJiBleGNlcHQgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGV4Y2VwdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIG5hbWUgPSBleGNlcHRbaV07XG4gICAgICAgICAgICBkZWxldGUgcHJvZHVjdFtuYW1lXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBvbmUgd2F5IG91dCBzbyB3ZSBjYW4gcHJvY2VzcyBibGFja2xpc3QgaW4gb25lIHNwb3RcbiAgICByZXR1cm4gcHJvZHVjdDtcblxufTtcblxuLy8gc3VnYXIgLSBzb3VyY2UgaXMgdGhlIHNlbGVjdG9yLCBkb20gZWxlbWVudCBvciBqUXVlcnkgaW5zdGFuY2UgdG8gY29weSBmcm9tIC0gb25seSBhbmQgZXhjZXB0IGFyZSBvcHRpb25hbFxuJC5mbi5jb3B5Q1NTID0gZnVuY3Rpb24oc291cmNlLCBvbmx5LCBleGNlcHQpIHtcbiAgICB2YXIgc3R5bGVzID0gc291cmNlLmdldFN0eWxlcyhvbmx5LCBleGNlcHQpO1xuICAgIHRoaXMuY3NzKHN0eWxlcyk7XG4gICAgXG4gICAgcmV0dXJuIHRoaXM7XG59OyIsIi8vIEJyaW5nIGluIGJ1aWxkIGNvbmZpZyBvcHRpb25zXG5sZXQgbWV0YWNvbmZpZyA9IHJlcXVpcmUoXCIuLi9jb25maWcuanNvblwiKTtcblxuY2xhc3MgUHJlZmVyZW5jZU1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgfVxuXG4gICAgR2V0SlNPTihjYWxsYmFjayl7XG5cbiAgICAgICAgLy9sZXQgbG9jID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lO1xuICAgICAgICAvL2xldCBkaXIgPSBsb2Muc3Vic3RyaW5nKDAsIGxvYy5sYXN0SW5kZXhPZignLycpKTtcbiAgICAgICAgXG4gICAgICAgIGxldCBkaXIgPSBcIi4vZGlzdC9cIjtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhkaXIgKyBtZXRhY29uZmlnLmNvbmZpZ0ZpbGUpO1xuXG4gICAgICAgIGlmKHRoaXMuY2FjaGVkSlNPTiAhPSBudWxsKXtcbiAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMuY2FjaGVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNle1xuICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogXCJqc29uXCIsXG4gICAgICAgICAgICAgICAgdXJsOiBkaXIgKyBtZXRhY29uZmlnLmNvbmZpZ0ZpbGUsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogKGRhdGEpPT57XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVkSlNPTiA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMuY2FjaGVkSlNPTik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgIH1cblxufVxuXG5leHBvcnQgbGV0IHByZWZlcmVuY2VzID0gbmV3IFByZWZlcmVuY2VNYW5hZ2VyKCk7IiwiLyoqXG4gKiBSZXR1cm5zIGZhbHNlIGlmIHJ1bm5pbmcgb24gYW4gdW5zdXBwb3J0ZWQgcGxhdGZvcm0gb3IgbWlzc2luZyBqUXVlcnksIG90aGVyd2lzZSB0cnVlLlxuICogXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBWZXJpZnlSZXF1aXJlbWVudHMoKSB7XG4gICAgXG4gICAgLy8gU3RvcCBydW5uaW5nIGlmIHdlJ3JlIG9uIGFuIHVuc3VwcG9ydGVkIHBsYXRmb3JtIChtb2JpbGUgZm9yIG5vdylcbiAgICAvLyBpZiggL0FuZHJvaWR8d2ViT1N8aVBob25lfGlQYWR8aVBvZHxCbGFja0JlcnJ5fElFTW9iaWxlfE9wZXJhIE1pbmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICkge1xuICAgIC8vICAgICBjb25zb2xlLmVycm9yKFwiUGxhdGZvcm0gaXMgdW5zdXBwb3J0ZWQhXCIpO1xuICAgIC8vICAgICAvL2xldCB1bnN1cHBvcnRlZERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgLy8gICAgIC8vdW5zdXBwb3J0ZWREaXYuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJZb3VyIHBsYXRmb3JtIGlzIHVuc3VwcG9ydGVkIVwiKSk7XG4gICAgLy8gICAgIC8vZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh1bnN1cHBvcnRlZERpdik7XG4gICAgLy8gICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyB9XG5cbiAgICAvLyBDaGVjayBpZiB3ZSBkb24ndCBoYXZlIGpRdWVyeSBsb2FkZWRcbiAgICBpZighd2luZG93LmpRdWVyeSl7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJKUXVlcnkgbXVzdCBiZSBwcmVzZW50IVwiKTtcbiAgICAgICAgLy9sZXQgdW5zdXBwb3J0ZWREaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAvL3Vuc3VwcG9ydGVkRGl2LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiWW91ciBwbGF0Zm9ybSBpcyB1bnN1cHBvcnRlZCFcIikpO1xuICAgICAgICAvL2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodW5zdXBwb3J0ZWREaXYpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gICAgXG59IiwiXG4vKipcbiAqIEVzY2FwZXMgdGhlIHN0cmluZyBzbyBpdCBjYW4gZW1iZWQgZGlyZWN0bHkgaW4gYW4gSFRNTCBkb2N1bWVudC5cbiAqL1xuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTIwMzQzMzRcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHJpbmcucHJvdG90eXBlLCAnZXNjYXBlSFRNTCcsIHtcbiAgICB2YWx1ZSgpIHtcbiAgICAgICAgdmFyIGVudGl0eU1hcCA9IHtcbiAgICAgICAgICAgICcmJzogJyZhbXA7JywgJzwnOiAnJmx0OycsICc+JzogJyZndDsnLCAnXCInOiAnJnF1b3Q7JyxcbiAgICAgICAgICAgIFwiJ1wiOiAnJiMzOTsnLCAnLyc6ICcmI3gyRjsnLCAnYCc6ICcmI3g2MDsnLCAnPSc6ICcmI3gzRDsnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBTdHJpbmcodGhpcykucmVwbGFjZSgvWyY8PlwiJ2A9XFwvXS9nLCBmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgcmV0dXJuIGVudGl0eU1hcFtzXTtcbiAgICAgICAgfSk7XG4gICAgfVxufSk7IiwiLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzQ4NDEwMjZcbmZ1bmN0aW9uIEdldEZvcm1hdHRlZFRpbWUodGltZUluU2Vjb25kcyl7XG4gICAgaWYoaXNOYU4odGltZUluU2Vjb25kcykpIHJldHVybiAwO1xuICAgIGxldCB0aW1lID0gdGltZUluU2Vjb25kcyB8IDA7IC8vVHJ1bmNhdGUgdG8gaW50ZWdlclxuICAgIGxldCBob3VycyAgID0gTWF0aC5mbG9vcih0aW1lIC8gMzYwMCkgJSAyNFxuICAgIGxldCBtaW51dGVzID0gTWF0aC5mbG9vcih0aW1lIC8gNjApICUgNjBcbiAgICBsZXQgc2Vjb25kcyA9IHRpbWUgJSA2MFxuICAgIGxldCBmb3JtYXR0ZWQgPSBbaG91cnMsbWludXRlcyxzZWNvbmRzXVxuICAgICAgICAubWFwKHYgPT4gdiA8IDEwID8gXCIwXCIgKyB2IDogdilcbiAgICAgICAgLmZpbHRlcigodixpKSA9PiB2ICE9PSBcIjAwXCIgfHwgaSA+IDApXG4gICAgICAgIC5qb2luKFwiOlwiKVxuXG4gICAgaWYgKGZvcm1hdHRlZC5jaGFyQXQoMCkgPT0gXCIwXCIpIHtcbiAgICAgICAgZm9ybWF0dGVkID0gZm9ybWF0dGVkLnN1YnN0cigxKTtcbiAgICB9XG5cbiAgICBsZXQgbXMgPSAodGltZUluU2Vjb25kcyAlIDEpLnRvRml4ZWQoMik7XG4gICAgZm9ybWF0dGVkICs9IG1zLnRvU3RyaW5nKCkuc3Vic3RyKDEpO1xuXG4gICAgcmV0dXJuIGZvcm1hdHRlZDtcbn1cblxuLy8gRnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS85NjQwNDE3LzcxMzg3OTJcbmZ1bmN0aW9uIEdldFNlY29uZHNGcm9tSE1TKGhtcyl7XG4gICAgbGV0IHBhcnRzID0gaG1zLnNwbGl0KCcuJyk7XG4gICAgbGV0IG1zID0gXCIwXCI7XG4gICAgaWYocGFydHMubGVuZ3RoID4gMSkgbXMgPSAnLicrcGFydHNbMV07XG5cbiAgICBsZXQgcCA9IHBhcnRzWzBdLnNwbGl0KCc6JyksXG4gICAgICAgIHMgPSAwLCBtID0gMTtcblxuICAgIHdoaWxlIChwLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcyArPSBtICogcGFyc2VJbnQocC5wb3AoKSwgMTApO1xuICAgICAgICBtICo9IDYwO1xuICAgIH1cblxuICAgIHMgKz0gcGFyc2VGbG9hdChtcyk7XG4gICAgcmV0dXJuIHM7XG59XG5cbmV4cG9ydCB7IEdldEZvcm1hdHRlZFRpbWUsIEdldFNlY29uZHNGcm9tSE1TIH07IiwiLyoqXG4gKiBVc2UgdGhpcyBmaWxlIHRvIGltcG9ydCB3aGF0IHlvdSBuZWVkIGZyb20gdGhlIGJ1bmRsZWQgbnBtIG1vZHVsZXMuXG4gKi9cblxuLy8gTXVzdCBpbXBvcnQgZnJvbSBub2RlX21vZHVsZXMgZm9sZGVyIG9yIGl0IHdvbid0IHNlZSB0aGUgc2hpbW1lZCBqcXVlcnkgaW5zdGFuY2Vcbi8vIFJlbW92ZWQgZnJvbSBoZXJlIGJlY2F1c2UgdGhleSB3ZXJlbid0IGJlaW5nIGxvYWRlZCBpbiB0aGUgcmlnaHQgb3JkZXIgLSBKUEJcbi8vIGltcG9ydCAnLi4vbm9kZV9tb2R1bGVzL3NlbGVjdDIvZGlzdC9qcy9zZWxlY3QyLmpzJztcbi8vIGltcG9ydCBcIi4uL25vZGVfbW9kdWxlcy9zZWxlY3QyL2Rpc3QvY3NzL3NlbGVjdDIuY3NzXCI7XG5cbmltcG9ydCBcInF0aXAyXCI7XG4vL3JlcXVpcmUoXCIuLi9ub2RlX21vZHVsZXMvcXRpcDIvZGlzdC9qcXVlcnkucXRpcC5taW4uanNcIik7XG4vL2ltcG9ydCBcIi4uL25vZGVfbW9kdWxlcy9xdGlwMi9kaXN0L2pxdWVyeS5xdGlwLm1pbi5jc3NcIjtcblxucmVxdWlyZShcIi4vdXRpbHMvY2xpcC1wYXRoLXBvbHlnb24tMS4wLjE1LmpzXCIpO1xuXG4vL2xldCBzY3JlZW5mdWxsID0gcmVxdWlyZSgnc2NyZWVuZnVsbCcpO1xuLy9pbXBvcnQgc2NyZWVuZnVsbCBmcm9tIFwic2NyZWVuZnVsbFwiO1xuXG4vLyBDRE4gcmVzb3VyY2VzXG4vLyBGb250LUF3ZXNvbWVcbi8vJChcImhlYWRcIikuYXBwZW5kKCQoXCI8c2NyaXB0IHNyYz0naHR0cHM6Ly91c2UuZm9udGF3ZXNvbWUuY29tL2E3MDNlMmU1YmYuanMnPjwvc2NyaXB0PlwiKSk7IiwiaW1wb3J0IHsgR2V0Rm9ybWF0dGVkVGltZSB9IGZyb20gXCIuLi91dGlscy90aW1lLmpzXCI7XG5cbmNsYXNzIFNlZWtiYXJUb29sdGlwIHtcbiAgICBjb25zdHJ1Y3RvcigkcGFyZW50LCBwbGF5ZXIpe1xuICAgICAgICB0aGlzLiRwYXJlbnQgPSAkcGFyZW50O1xuICAgICAgICB0aGlzLnBsYXllciA9IHBsYXllcjtcblxuICAgICAgICB0aGlzLiR0b29sdGlwID0gJChcIjxkaXYgY2xhc3M9J3dhbGRvcmYtc2Vla2Jhci10b29sdGlwJz48L2Rpdj5cIikuYXBwZW5kVG8oJHBhcmVudCk7XG4gICAgICAgIHRoaXMudGV4dCA9IFwiVGVzdFwiO1xuICAgICAgICB0aGlzLiRjb250ZW50ID0gJChcIjxwPlwiICsgdGhpcy50ZXh0ICsgXCI8L3A+XCIpLmFwcGVuZFRvKHRoaXMuJHRvb2x0aXApO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5ob3Zlck9mZnNldCA9IC0xMDtcbiAgICAgICAgdGhpcy5wYWRkaW5nID0gNTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuSGlkZSgpO1xuXG4gICAgICAgIHRoaXMuJHBhcmVudC5tb3VzZW1vdmUoKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLlNob3coKTtcblxuICAgICAgICAgICAgLy9BZGQgYW5kIHVwZGF0ZSB0b29sdGlwIG9uIG1vdXNlIG1vdmVtZW50IHRvIHNob3cgd2hlcmUgdGhlIG1vdXNlIGlzIGhvdmVyaW5nLlxuICAgICAgICAgICAgbGV0IG1vdXNlWCA9IGV2ZW50LnBhZ2VYIC0gcGxheWVyLiRjb250YWluZXIub2Zmc2V0KCkubGVmdDtcbiAgICAgICAgICAgIGxldCBwZXJjZW50ID0gbW91c2VYIC8gdGhpcy4kcGFyZW50LndpZHRoKCk7XG4gICAgICAgICAgICBsZXQgdGltZUF0Q3Vyc29yID0gcGVyY2VudCAqIHBsYXllci52aWRlb0VsZW1lbnQuZHVyYXRpb247XG4gICAgICAgICAgICB0aGlzLk1vdmUobW91c2VYLCAwKTtcbiAgICAgICAgICAgIHRoaXMuU2V0Q29udGVudChHZXRGb3JtYXR0ZWRUaW1lKHRpbWVBdEN1cnNvcikpO1xuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuJHBhcmVudC5tb3VzZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLkhpZGUoKTtcbiAgICAgICAgfSk7XG5cbiAgICB9XG5cbiAgICBNb3ZlKHgsIHkpIHtcblxuICAgICAgICAvLyBHZXQgaW5pdGlhbCBwb3NpdGlvbnNcbiAgICAgICAgbGV0IGxlZnQgPSB4IC0gKHRoaXMuR2V0V2lkdGgoKSAvIDIpO1xuICAgICAgICBsZXQgdG9wID0geSAtICh0aGlzLkdldEhlaWdodCgpKSArIHRoaXMuaG92ZXJPZmZzZXQ7XG4gICAgICAgIFxuICAgICAgICAvLyBPZmZzZXQgaWYgbmVjZXNzYXJ5IChrZWVwIG9uLXNjcmVlbilcbiAgICAgICAgaWYgKGxlZnQgLSB0aGlzLnBhZGRpbmcgPCAwKSB7XG4gICAgICAgICAgICBsZWZ0ID0gdGhpcy5wYWRkaW5nO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoIChsZWZ0ICsgdGhpcy5wYWRkaW5nICsgdGhpcy5HZXRXaWR0aCgpKSA+IHRoaXMuJHBhcmVudC53aWR0aCgpICkge1xuICAgICAgICAgICAgbGVmdCA9IHRoaXMuJHBhcmVudC53aWR0aCgpIC0gdGhpcy5HZXRXaWR0aCgpIC0gdGhpcy5wYWRkaW5nO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBBcHBseSBwb3NpdGlvbnNcbiAgICAgICAgdGhpcy4kdG9vbHRpcC5jc3Moe1xuICAgICAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgICAgICBsZWZ0OiBsZWZ0XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIEdldFdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kdG9vbHRpcC53aWR0aCgpO1xuICAgIH1cblxuICAgIEdldEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHRvb2x0aXAuaGVpZ2h0KCk7XG4gICAgfVxuXG4gICAgU2hvdygpIHtcbiAgICAgICAgdGhpcy4kdG9vbHRpcC5tYWtlVmlzaWJsZSh0cnVlKTtcbiAgICB9XG5cbiAgICBIaWRlKCkge1xuICAgICAgICB0aGlzLiR0b29sdGlwLm1ha2VWaXNpYmxlKGZhbHNlKTtcbiAgICB9XG5cbiAgICBTZXRDb250ZW50KHRleHQpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyh0ZXh0KTtcbiAgICAgICAgdGhpcy4kY29udGVudC50ZXh0KHRleHQpO1xuICAgIH1cblxuXG5cbn1cblxuZXhwb3J0IHsgU2Vla2JhclRvb2x0aXAgfTsiLCJpbXBvcnQgeyBHZXRGb3JtYXR0ZWRUaW1lIH0gZnJvbSBcIi4uL3V0aWxzL3RpbWUuanNcIjtcbmltcG9ydCB7IFNlZWtiYXJUb29sdGlwIH0gZnJvbSBcIi4vc2Vla2Jhci10b29sdGlwLmpzXCI7XG5cbmNsYXNzIFZpZGVvUGxheWVyQmFyIHtcblxuICAgIGNvbnN0cnVjdG9yKHBsYXllcil7XG4gICAgICAgIHRoaXMucGxheWVyID0gcGxheWVyOyBcbiAgICAgICAgdGhpcy4kY29udGFpbmVyID0gJChcIjxkaXYgY2xhc3M9J3dhbGRvcmYtcGxheWVyLXRvb2xiYXIgZmxleC10b29sYmFyJz48L2Rpdj5cIikuYXBwZW5kVG8ocGxheWVyLiRjb250YWluZXIpO1xuXG4gICAgICAgIHRoaXMuUG9wdWxhdGVFbGVtZW50cygpO1xuXG4gICAgICAgIHRoaXMuc2NydWJiaW5nVGltZVNsaWRlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLnZpZGVvUGxheWluZ0JlZm9yZVRpbWVTY3J1YiA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEhvb2sgdXAgdG8gZXZlbnRzIGZyb20gdmlkZW8gcGxheWVyXG4gICAgICAgIHRoaXMucGxheWVyLiRjb250YWluZXIub24oXCJPblZpc2liaWxpdHlDaGFuZ2VcIiwgXG4gICAgICAgICAgICAoZXZlbnQsIGlzVmlzaWJsZSwgZHVyYXRpb24pID0+IHRoaXMuU2V0VmlzaWJsZShpc1Zpc2libGUsIGR1cmF0aW9uKVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMucGxheWVyLiRjb250YWluZXIub24oXCJPblBsYXlTdGF0ZUNoYW5nZVwiLCBcbiAgICAgICAgICAgIChldmVudCwgcGxheWluZykgPT4gdGhpcy5PblBsYXlTdGF0ZUNoYW5nZShwbGF5aW5nKVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMucGxheWVyLiRjb250YWluZXIub24oXCJPblRpbWVVcGRhdGVcIiwgXG4gICAgICAgICAgICAoZXZlbnQsIHRpbWUpID0+IHRoaXMuT25UaW1lVXBkYXRlKHRpbWUpXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5wbGF5ZXIuJGNvbnRhaW5lci5vbihcIk9uTXV0ZVN0YXRlQ2hhbmdlXCIsIFxuICAgICAgICAgICAgKGV2ZW50LCBtdXRlZCkgPT4gdGhpcy5Pbk11dGVTdGF0ZUNoYW5nZShtdXRlZClcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLnBsYXllci4kY29udGFpbmVyLm9uKFwiT25Wb2x1bWVDaGFuZ2VcIiwgXG4gICAgICAgICAgICAoZXZlbnQsIHZvbHVtZSkgPT4gdGhpcy5PblZvbHVtZUNoYW5nZSh2b2x1bWUpXG4gICAgICAgICk7XG4gICAgICAgIFxuICAgIH1cblxuICAgIFBvcHVsYXRlRWxlbWVudHMoKXtcblxuICAgICAgICB0aGlzLiRzZWVrQmFyID0gJChcIjxkaXYgaWQ9J3NlZWstYmFyJz48ZGl2IGlkPSdzZWVrLWhhbmRsZScgY2xhc3M9J3VpLXNsaWRlci1oYW5kbGUnPjwvZGl2PjwvZGl2PlwiKTtcbiAgICAgICAgbGV0ICRzZWVrU2xpZGVyID0gdGhpcy4kc2Vla0Jhci5zbGlkZXIoe1xuICAgICAgICAgICAgbWluOiAwLjAsXG4gICAgICAgICAgICBtYXg6IDEuMCxcbiAgICAgICAgICAgIHN0ZXA6IDAuMDAxXG4gICAgICAgIH0pO1xuICAgICAgICAkc2Vla1NsaWRlci5vbihcInNsaWRlXCIsICgpID0+IHRoaXMuVXBkYXRlVmlkZW9UaW1lKCkpO1xuICAgICAgICAkc2Vla1NsaWRlci5vbihcInNsaWRlc3RhcnRcIiwgKCkgPT4gdGhpcy5UaW1lRHJhZ1N0YXJ0ZWQoKSk7XG4gICAgICAgICRzZWVrU2xpZGVyLm9uKFwic2xpZGVzdG9wXCIsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuVGltZURyYWdGaW5pc2hlZCgpO1xuICAgICAgICAgICAgdGhpcy5VcGRhdGVWaWRlb1RpbWUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuJGNvbnRhaW5lci5hcHBlbmQodGhpcy4kc2Vla0Jhcik7XG4gICAgICAgIHRoaXMuc2Vla2JhclRvb2x0aXAgPSBuZXcgU2Vla2JhclRvb2x0aXAodGhpcy4kc2Vla0JhciwgdGhpcy5wbGF5ZXIpO1xuXG4gICAgICAgIHRoaXMuJHNlZWtQcm9ncmVzcyA9ICQoXCI8ZGl2IGlkPSdzZWVrLWZpbGwnPjwvZGl2PlwiKTtcbiAgICAgICAgdGhpcy4kY29udGFpbmVyLmFwcGVuZCh0aGlzLiRzZWVrUHJvZ3Jlc3MpO1xuXG4gICAgICAgIC8vSnVtcCBCYWNrIGJ1dHRvblxuICAgICAgICB0aGlzLiRqdW1wQmFja0J1dHRvbiA9ICQoXCI8YnV0dG9uPkp1bXAgQmFjazwvYnV0dG9uPlwiKS5idXR0b24oe1xuICAgICAgICAgICAgaWNvbjogXCJmYSBmYS1mYXN0LWJhY2t3YXJkXCIsXG4gICAgICAgICAgICBzaG93TGFiZWw6IGZhbHNlXG4gICAgICAgIH0pLmNsaWNrKCgpID0+IHRoaXMucGxheWVyLkp1bXBCYWNrd2FyZCgpKTtcbiAgICAgICAgdGhpcy5SZWdpc3RlckVsZW1lbnQodGhpcy4kanVtcEJhY2tCdXR0b24sIC04KTsgICBcbiAgICAgICAgXG4gICAgICAgIC8vTnVkZ2UgQmFjayBidXR0b25cbiAgICAgICAgdGhpcy4kbnVkZ2VCYWNrQnV0dG9uID0gJChcIjxidXR0b24+TnVkZ2UgQmFjazwvYnV0dG9uPlwiKS5idXR0b24oe1xuICAgICAgICAgICAgaWNvbjogXCJmYSBmYS1zdGVwLWJhY2t3YXJkXCIsXG4gICAgICAgICAgICBzaG93TGFiZWw6IGZhbHNlXG4gICAgICAgIH0pLmNsaWNrKCgpID0+IHRoaXMucGxheWVyLlN0ZXBCYWNrd2FyZCgpKTtcbiAgICAgICAgdGhpcy5SZWdpc3RlckVsZW1lbnQodGhpcy4kbnVkZ2VCYWNrQnV0dG9uLCAtNyk7XG5cbiAgICAgICAgLy8gUGxheSBidXR0b25cbiAgICAgICAgdGhpcy4kcGxheUJ1dHRvbiA9ICQoXCI8YnV0dG9uPlBsYXk8L2J1dHRvbj5cIikuYnV0dG9uKHtcbiAgICAgICAgICAgIGljb246IFwiZmEgZmEtcGxheVwiLFxuICAgICAgICAgICAgc2hvd0xhYmVsOiBmYWxzZVxuICAgICAgICB9KS5jbGljaygoKSA9PiB0aGlzLnBsYXllci5Ub2dnbGVQbGF5U3RhdGUoKSk7XG4gICAgICAgIHRoaXMuUmVnaXN0ZXJFbGVtZW50KHRoaXMuJHBsYXlCdXR0b24sIC02KTtcblxuICAgICAgICAvL051ZGdlIGJ1dHRvblxuICAgICAgICB0aGlzLiRudWRnZUJ1dHRvbiA9ICQoXCI8YnV0dG9uPk51ZGdlPC9idXR0b24+XCIpLmJ1dHRvbih7XG4gICAgICAgICAgICBpY29uOiBcImZhIGZhLXN0ZXAtZm9yd2FyZFwiLFxuICAgICAgICAgICAgc2hvd0xhYmVsOiBmYWxzZVxuICAgICAgICB9KS5jbGljaygoKSA9PiB0aGlzLnBsYXllci5TdGVwRm9yd2FyZCgpKTtcbiAgICAgICAgdGhpcy5SZWdpc3RlckVsZW1lbnQodGhpcy4kbnVkZ2VCdXR0b24sIC01KTsgICBcbiAgICAgICAgXG4gICAgICAgIC8vSnVtcCBidXR0b25cbiAgICAgICAgdGhpcy4kanVtcEJ1dHRvbiA9ICQoXCI8YnV0dG9uPk51ZGdlPC9idXR0b24+XCIpLmJ1dHRvbih7XG4gICAgICAgICAgICBpY29uOiBcImZhIGZhLWZhc3QtZm9yd2FyZFwiLFxuICAgICAgICAgICAgc2hvd0xhYmVsOiBmYWxzZVxuICAgICAgICB9KS5jbGljaygoKSA9PiB0aGlzLnBsYXllci5KdW1wRm9yd2FyZCgpKTtcbiAgICAgICAgdGhpcy5SZWdpc3RlckVsZW1lbnQodGhpcy4kanVtcEJ1dHRvbiwgLTQpOyAgICAgICAgICBcblxuICAgICAgICAvLyBUaW1lIHRleHRcbiAgICAgICAgbGV0IHplcm8gPSBHZXRGb3JtYXR0ZWRUaW1lKDAuMDAwKTtcbiAgICAgICAgdGhpcy4kdGltZVRleHQgPSAkKFwiPHA+JHt6ZXJvfS8ke3plcm99PC9wPlwiKTtcbiAgICAgICAgdGhpcy5SZWdpc3RlckVsZW1lbnQodGhpcy4kdGltZVRleHQsIC0zKTtcblxuICAgICAgICAvLyBNdXRlIGJ1dHRvblxuICAgICAgICB0aGlzLiRtdXRlQnV0dG9uID0gJChcIjxidXR0b24+TXV0ZTwvYnV0dG9uPlwiKS5idXR0b24oe1xuICAgICAgICAgICAgaWNvbjogXCJmYSBmYS12b2x1bWUtdXBcIixcbiAgICAgICAgICAgIHNob3dMYWJlbDogZmFsc2UsXG4gICAgICAgIH0pLmNsaWNrKCgpID0+IHRoaXMucGxheWVyLlRvZ2dsZU11dGVTdGF0ZSgpKTtcbiAgICAgICAgdGhpcy5SZWdpc3RlckVsZW1lbnQodGhpcy4kbXV0ZUJ1dHRvbiwgLTIpO1xuXG4gICAgICAgIC8vIFZvbHVtZSBiYXJcbiAgICAgICAgdGhpcy4kdm9sdW1lQmFyID0gJChcIjxkaXYgaWQ9J3ZvbHVtZS1iYXInPjxkaXYgaWQ9J3ZvbHVtZS1oYW5kbGUnIGNsYXNzPSd1aS1zbGlkZXItaGFuZGxlJz48L2Rpdj48L2Rpdj5cIik7XG4gICAgICAgIHRoaXMuJHZvbHVtZUJhci5zbGlkZXIoe1xuICAgICAgICAgICAgcmFuZ2U6IFwibWluXCIsXG4gICAgICAgICAgICBtYXg6IDEuMCxcbiAgICAgICAgICAgIHZhbHVlOiAxLjAsXG4gICAgICAgICAgICBzdGVwOiAwLjA1XG4gICAgICAgIH0pLm9uKFwic2xpZGVcIiwgKGV2ZW50LCB1aSkgPT4gdGhpcy5wbGF5ZXIuU2V0Vm9sdW1lKHVpLnZhbHVlKSk7XG4gICAgICAgIHRoaXMuUmVnaXN0ZXJFbGVtZW50KHRoaXMuJHZvbHVtZUJhciwgLTEpO1xuXG4gICAgICAgIC8vIEZ1bGxzY3JlZW4gYnV0dG9uXG4gICAgICAgIHRoaXMuJGZ1bGxTY3JlZW5CdXR0b24gPSAkKFwiPGJ1dHRvbj5GdWxsc2NyZWVuPC9idXR0b24+XCIpLmJ1dHRvbih7XG4gICAgICAgICAgICBpY29uOiBcImZhIGZhLWFycm93cy1hbHRcIixcbiAgICAgICAgICAgIHNob3dMYWJlbDogZmFsc2VcbiAgICAgICAgfSkuY2xpY2soKCkgPT4gdGhpcy5wbGF5ZXIuVG9nZ2xlRnVsbHNjcmVlbigpKTtcbiAgICAgICAgdGhpcy5SZWdpc3RlckVsZW1lbnQodGhpcy4kZnVsbFNjcmVlbkJ1dHRvbiwgOTk5LCAnZmxleC1lbmQnKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBlbXB0eSBlbGVtZW50IGJldHdlZW4gbGVmdCBmbG9hdGluZyBhbmQgcmlnaHQgZmxvYXRpbmcgdG9vbGJhciBpdGVtcyB0byBzcGFjZSB0aGVtIG91dCBwcm9wZXJseVxuICAgICAgICB0aGlzLiRjb250YWluZXIuYXBwZW5kKCQoXCI8ZGl2PjwvZGl2PlwiKS5jc3MoXCJmbGV4LWdyb3dcIiwgMSkuY3NzKFwib3JkZXJcIiwgMCkpO1xuXG4gICAgICAgIC8vSW5pdGlhbGl6ZSBjb250cm9sc1xuICAgICAgICB0aGlzLk9uVGltZVVwZGF0ZSgpO1xuICAgICAgICB0aGlzLiR2b2x1bWVCYXIuc2xpZGVyKFwidmFsdWVcIiwgdGhpcy5wbGF5ZXIudmlkZW9FbGVtZW50LnZvbHVtZSk7XG4gICAgfVxuXG4gICAgUmVnaXN0ZXJFbGVtZW50KCRlbGVtZW50LCBvcmRlciwganVzdGlmaWNhdGlvbiA9ICdmbGV4LXN0YXJ0Jyl7XG4gICAgICAgICRlbGVtZW50LmNzcygnb3JkZXInLCBvcmRlcik7XG4gICAgICAgICRlbGVtZW50LmNzcygnYWxpZ24tc2VsZicsIGp1c3RpZmljYXRpb24pO1xuICAgICAgICAvLyBTZXRzIGdyb3cgW3Nocmlua10gW2Jhc2lzXVxuICAgICAgICAvLyRlbGVtZW50LmNzcygnZmxleCcsICcwIDAgYXV0bycpO1xuICAgICAgICB0aGlzLiRjb250YWluZXIuYXBwZW5kKCRlbGVtZW50KTtcbiAgICB9XG5cbiAgICBTZXRWaXNpYmxlKGlzVmlzaWJsZSwgZHVyYXRpb24pe1xuICAgICAgICAvL2NvbnNvbGUubG9nKGlzVmlzaWJsZSArIFwiIFwiICsgZHVyYXRpb24pO1xuICAgICAgICB0aGlzLiRjb250YWluZXIuc3RvcCh0cnVlLCB0cnVlKTtcbiAgICAgICAgaWYoaXNWaXNpYmxlKXtcbiAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci5mYWRlVG8oZHVyYXRpb24sIDEuMCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci5tYWtlVmlzaWJsZSh0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyLmZhZGVUbyhkdXJhdGlvbiwgMC4wLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyLm1ha2VWaXNpYmxlKGZhbHNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgVXBkYXRlVmlkZW9UaW1lKCl7XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbmV3IHRpbWVcbiAgICAgICAgbGV0IHRpbWUgPSB0aGlzLnBsYXllci52aWRlb0VsZW1lbnQuZHVyYXRpb24gKiB0aGlzLiRzZWVrQmFyLnNsaWRlcihcInZhbHVlXCIpO1xuICAgICAgICB0aGlzLnBsYXllci5lbmRUaW1lID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGxheWVyLnZpZGVvRWxlbWVudC5jdXJyZW50VGltZSA9IHRpbWU7XG4gICAgfVxuXG4gICAgVGltZURyYWdTdGFydGVkKCl7XG4gICAgICAgIHRoaXMudmlkZW9QbGF5aW5nQmVmb3JlVGltZVNjcnViID0gIXRoaXMucGxheWVyLnZpZGVvRWxlbWVudC5wYXVzZWQ7XG4gICAgICAgIHRoaXMucGxheWVyLnZpZGVvRWxlbWVudC5wYXVzZSgpO1xuICAgIH1cblxuICAgIFRpbWVEcmFnRmluaXNoZWQoKXtcbiAgICAgICAgLy8gU3RhcnQgcGxheWluZyB0aGUgdmlkZW8gYWdhaW4gaWYgaXQgd2FzIHBsYXlpbmcgYmVmb3JlIHRoZSBzY3J1YiBzdGFydGVkXG4gICAgICAgIGlmICh0aGlzLnZpZGVvUGxheWluZ0JlZm9yZVRpbWVTY3J1Yil7XG4gICAgICAgICAgICB0aGlzLnBsYXllci52aWRlb0VsZW1lbnQucGxheSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8vXG4gICAgLy8vIC0tLS0tIEV2ZW50IExpc3RlbmVycyAtLS0tLVxuICAgIC8vLyBUaGUgZm9sbG93aW5nIHVwZGF0ZSB0aGUgdmlzdWFsIHN0YXRlIG9mIHRoZSBiYXJcbiAgICAvLy8gdXBvbiBjaGFuZ2VzIHRvIHRoZSB2aWRlbyBwbGF5ZXIuIFRoZXNlIGFyZSBob29rZWRcbiAgICAvLy8gdXAgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgIC8vL1xuXG4gICAgT25QbGF5U3RhdGVDaGFuZ2UocGxheWluZyl7XG4gICAgICAgIHRoaXMuJHBsYXlCdXR0b24uYnV0dG9uKFwib3B0aW9uXCIsIHtcbiAgICAgICAgICAgIGljb246IHBsYXlpbmcgPyBcImZhIGZhLXBhdXNlXCIgOiBcImZhIGZhLXBsYXlcIlxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBPblRpbWVVcGRhdGUodGltZSl7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJ2aWRlby1wbGF5ZXItYmFyLmpzOjE4NSBPblRpbWVVcGRhdGUgaXMgY2FsbGVkXCIpO1xuICAgICAgICBsZXQgZHVyYXRpb24gPSB0aGlzLnBsYXllci52aWRlb0VsZW1lbnQuZHVyYXRpb247XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSB0aW1lIHRleHRcbiAgICAgICAgdGhpcy4kdGltZVRleHQudGV4dChHZXRGb3JtYXR0ZWRUaW1lKHRpbWUpICsgXCIvXCIgKyBHZXRGb3JtYXR0ZWRUaW1lKGR1cmF0aW9uKSk7XG5cbiAgICAgICAgbGV0IHByb2dyZXNzID0gdGltZSAvIGR1cmF0aW9uO1xuICAgICAgICB0aGlzLiRzZWVrUHJvZ3Jlc3Mud2lkdGgoKHByb2dyZXNzICogMTAwKS50b1N0cmluZygpICsgXCIlXCIpO1xuICAgIH1cblxuICAgIE9uVm9sdW1lQ2hhbmdlKHZvbHVtZSl7XG4gICAgICAgIHRoaXMuJHZvbHVtZUJhci5zbGlkZXIoXCJ2YWx1ZVwiLCB2b2x1bWUpO1xuICAgIH1cblxuICAgIE9uTXV0ZVN0YXRlQ2hhbmdlKG11dGVkKXtcbiAgICAgICAgdGhpcy4kbXV0ZUJ1dHRvbi5idXR0b24oXCJvcHRpb25cIiwge1xuICAgICAgICAgICAgaWNvbjogbXV0ZWQgPyBcImZhIGZhLXZvbHVtZS11cFwiIDogXCJmYSBmYS12b2x1bWUtb2ZmXCJcbiAgICAgICAgfSk7XG4gICAgfVxuXG59XG5cbmV4cG9ydCB7IFZpZGVvUGxheWVyQmFyIH0iLCJpbXBvcnQgeyBWaWRlb1BsYXllckJhciB9IGZyb20gXCIuL3ZpZGVvLXBsYXllci1iYXIuanNcIjtcbmltcG9ydCB7IFZpZGVvQW5ub3RhdG9yIH0gZnJvbSBcIi4uL2Fubm90YXRvci9hbm5vdGF0b3IuanNcIjtcbi8vaW1wb3J0ICogYXMgc2NyZWVuZnVsbCBmcm9tIFwic2NyZWVuZnVsbFwiO1xuXG4vL2ltcG9ydCAnanF1ZXJ5LXVpL2Rpc3QvanF1ZXJ5LXVpLmpzJztcbmxldCBzY3JlZW5mdWxsID0gcmVxdWlyZSgnc2NyZWVuZnVsbCcpO1xuXG5jbGFzcyBBbm5vdGF0b3JWaWRlb1BsYXllciB7XG4gICAgY29uc3RydWN0b3IoJHZpZGVvLCBhbm5vdGF0b3JBcmdzKXtcbiAgICAgICAgY29uc29sZS5sb2coXCJbQW5ub3RhdG9yVmlkZW9QbGF5ZXJdIENyZWF0aW5nIEFubm90YXRvclZpZGVvUGxheWVyIGZvciB2aWRlby4uLlwiKTtcbiAgICAgICAgdGhpcy4kdmlkZW8gPSAkdmlkZW87XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50ID0gdGhpcy4kdmlkZW8uZ2V0KDApO1xuXG4gICAgICAgIC8vIFN0b3JlIHRoZSBvcmlnaW5hbCBzdHlsaW5nIG9mIHRoZSB2aWRlbyBlbGVtZW50IGJlZm9yZSB3ZSBhbHRlciBpdFxuICAgICAgICB0aGlzLm9yaWdpbmFsU3R5bGVzID0gdGhpcy4kdmlkZW8uZ2V0U3R5bGVzKG51bGwsIFtcImhlaWdodFwiLCBcIldlYmtpdFRleHRGaWxsQ29sb3JcIiwgXCJjb2xvclwiXSk7IC8vW1wid2lkdGhcIiwgXCJ0b3BcIiwgXCJsZWZ0XCIsIFwibWFyZ2luXCIsIFwicGFkZGluZ1wiXVxuXG4gICAgICAgIHRoaXMuV3JhcCgpO1xuICAgICAgICB0aGlzLlBvcHVsYXRlQ29udHJvbHMoKTtcbiAgICAgICAgdGhpcy5TZXRWaXNpYmxlKHRydWUpO1xuXG4gICAgICAgIC8vIEhvb2sgdXAgZXZlbnRzXG4gICAgICAgIHRoaXMuSG9va1VwRXZlbnRzKCk7XG5cbiAgICAgICAgLy8gUGxheSAvIHBhdXNlIHRoZSB2aWRlbyB3aGVuIGNsaWNrZWQuXG4gICAgICAgIHRoaXMuJHZpZGVvLm9uKFwiY2xpY2tcIiwgKCkgPT4gdGhpcy5Ub2dnbGVQbGF5U3RhdGUoKSk7XG5cbiAgICAgICAgdGhpcy5hbGxvd0F1dG9GYWRlID0gdHJ1ZTtcbiAgICAgICAgLy8vIEluYWN0aXZpdHkgdGltZXIgZm9yIHRoZSBtb3VzZS5cbiAgICAgICAgdGhpcy5tb3VzZVRpbWVyID0gbnVsbDtcbiAgICAgICAgLy8vIFNldCB0byB0cnVlIGlmIHRoZSB0aW1lIHNsaWRlciBpcyBjdXJyZW50bHkgYmVpbmcgZHJhZ2dlZCBieSB0aGUgdXNlci5cbiAgICAgICAgdGhpcy5kcmFnZ2luZ1RpbWVTbGlkZXIgPSBmYWxzZTtcbiAgICAgICAgLy8vIFNlY29uZHMgYmVmb3JlIHRoZSBVSSBmYWRlcyBkdWUgdG8gbW91c2UgaW5hY3Rpdml0eS5cbiAgICAgICAgdGhpcy5pZGxlU2Vjb25kc0JlZm9yZUZhZGUgPSAzO1xuICAgICAgICB0aGlzLmZhZGVEdXJhdGlvbiA9IDMwMDtcbiAgICAgICAgdGhpcy5lbmRUaW1lID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy4kY29udGFpbmVyLm1vdXNlbW92ZSgoKSA9PiB0aGlzLk9uTW91c2VNb3ZlKCkpO1xuICAgICAgICB0aGlzLlNldEF1dG9GYWRlKHRydWUpO1xuXG4gICAgICAgIC8vIElmIHNjcmVlbmZ1bGwgaXMgZW5hYmxlZCwgY3JlYXRlIHRoZSBldmVudCB0byBoYW5kbGUgaXQuXG4gICAgICAgIGlmKHNjcmVlbmZ1bGwgIT09ICd1bmRlZmluZWQnKXtcbiAgICAgICAgICAgIHNjcmVlbmZ1bGwub25jaGFuZ2UoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuT25GdWxsc2NyZWVuQ2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kY29udGFpbmVyLnRyaWdnZXIoXCJPbkZ1bGxzY3JlZW5DaGFuZ2VcIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50Lm9udGltZXVwZGF0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuT25UaW1lVXBkYXRlKHRoaXMudmlkZW9FbGVtZW50LmN1cnJlbnRUaW1lKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLiRjb250YWluZXIub24oXCJPblZpZGVvUmVhZHlcIiwgKCkgPT4ge1xuICAgICAgICAgICAgaWYoYW5ub3RhdG9yQXJncy5hbm5vdGF0b3I9PW51bGwpe1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW0Fubm90YXRvclZpZGVvUGxheWVyXSBQbGF5ZXIgc2VudCBPblZpZGVvUmVhZHksIGF0dGVtcHRpbmcgdG8gd3JhcCB3aXRoIGFubm90YXRvci4uLlwiKTtcbiAgICAgICAgICAgICAgICAvLyBBZGQgYW5ub3RhdG9yIG9uY2UgdmlkZW8gaGFzIGxvYWRlZFxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW0Fubm90YXRvclZpZGVvUGxheWVyXSBXcmFwcGluZyB2aWRlbyB3aXRoIGFubm90YXRvci4uLlwiKTtcbiAgICAgICAgICAgICAgICBhbm5vdGF0b3JBcmdzLnBsYXllciA9IHRoaXM7XG4gICAgICAgICAgICAgICAgYW5ub3RhdG9yQXJncy5hbm5vdGF0b3IgPSBuZXcgVmlkZW9Bbm5vdGF0b3IoYW5ub3RhdG9yQXJncyk7XG4gICAgICAgICAgICAgICAgaWYodHlwZW9mIGFubm90YXRvckFyZ3MuY2FsbGJhY2sgPT0gXCJmdW5jdGlvblwiKSBhbm5vdGF0b3JBcmdzLmNhbGxiYWNrKGFubm90YXRvckFyZ3MuYW5ub3RhdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnQub25sb2FkZWRtZXRhZGF0YSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci50cmlnZ2VyKFwiT25WaWRlb1JlYWR5XCIpO1xuICAgICAgICB9O1xuICAgICAgICBpZih0aGlzLnZpZGVvRWxlbWVudC5kdXJhdGlvbiAhPSBudWxsKXtcbiAgICAgICAgICAgIC8vIElmIHRoZSBtZXRhZGF0YSBpcyBhbHJlYWR5IHByZXBhcmVkLCB0aHJvdyB0aGUgZXZlbnQgc2luY2VcbiAgICAgICAgICAgIC8vIG9ubG9hZGVkbWV0YWRhdGEgd29uJ3QgYmUgZmlyZWRcbiAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci50cmlnZ2VyKFwiT25WaWRlb1JlYWR5XCIpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhcIltBbm5vdGF0b3JWaWRlb1BsYXllcl0gQW5ub3RhdG9yVmlkZW9QbGF5ZXIgY3JlYXRlZCBmb3IgdmlkZW8uXCIpO1xuICAgICAgICBcbiAgICB9XG5cbiAgICBXcmFwKCl7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgZGVmYXVsdCBjb250cm9scyBmcm9tIHRoZSB2aWRlb1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJjb250cm9sc1wiKTtcblxuICAgICAgICAvLyBXcmFwIHRoZSB2aWRlbyBlbGVtZW50IHdpdGggdGhlIGNvbnRhaW5lclxuICAgICAgICB0aGlzLiRjb250YWluZXIgPSB0aGlzLiR2aWRlby53cmFwKFwiPGRpdiBjbGFzcz0nd2FsZG9yZi12aWRlby1wbGF5ZXInPjwvZGl2PlwiKS5wYXJlbnQoKTtcbiAgICAgICAgLy8gUmVzaXplIGNvbnRhaW5lciB0byBmaXQgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIHZpZGVvXG4gICAgICAgIHRoaXMuJGNvbnRhaW5lci53aWR0aCh0aGlzLiR2aWRlby53aWR0aCgpKTtcbiAgICAgICAgdGhpcy4kY29udGFpbmVyLmhlaWdodCh0aGlzLiR2aWRlby5oZWlnaHQoKSk7XG4gICAgfVxuXG4gICAgUG9wdWxhdGVDb250cm9scygpe1xuICAgICAgICB0aGlzLmNvbnRyb2xCYXIgPSBuZXcgVmlkZW9QbGF5ZXJCYXIodGhpcyk7XG4gICAgfVxuXG4gICAgU2V0VmlzaWJsZShpc1Zpc2libGUsIGR1cmF0aW9uID0gMCl7XG4gICAgICAgIHRoaXMuJGNvbnRhaW5lci50cmlnZ2VyKFwiT25WaXNpYmlsaXR5Q2hhbmdlXCIsIFtpc1Zpc2libGUsIGR1cmF0aW9uXSk7XG4gICAgfVxuXG4gICAgSG9va1VwRXZlbnRzKCl7XG4gICAgICAgIFxuICAgIH1cblxuICAgIFRvZ2dsZVBsYXlTdGF0ZSgpe1xuICAgICAgICBpZih0aGlzLnZpZGVvRWxlbWVudC5wYXVzZWQpe1xuICAgICAgICAgICAgdGhpcy5QbGF5KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLlBhdXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBTdGVwRm9yd2FyZCgpe1xuICAgICAgICB2YXIgbmV3VGltZSA9IHRoaXMudmlkZW9FbGVtZW50LmN1cnJlbnRUaW1lICsgMC4xO1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudC5jdXJyZW50VGltZSA9IG5ld1RpbWUgPiB0aGlzLnZpZGVvRWxlbWVudC5kdXJhdGlvbiA/IHRoaXMudmlkZW9FbGVtZW50LmR1cmF0aW9uIDogbmV3VGltZTtcbiAgICB9XG5cbiAgICBKdW1wRm9yd2FyZCgpe1xuICAgICAgICB2YXIgbmV3VGltZSA9IHRoaXMudmlkZW9FbGVtZW50LmN1cnJlbnRUaW1lICsgMTtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnQuY3VycmVudFRpbWUgPSBuZXdUaW1lID4gdGhpcy52aWRlb0VsZW1lbnQuZHVyYXRpb24gPyB0aGlzLnZpZGVvRWxlbWVudC5kdXJhdGlvbiA6IG5ld1RpbWU7XG4gICAgfSAgXG4gICAgXG4gICAgU3RlcEJhY2t3YXJkKCl7XG4gICAgICAgIHZhciBuZXdUaW1lID0gdGhpcy52aWRlb0VsZW1lbnQuY3VycmVudFRpbWUgLSAwLjE7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50LmN1cnJlbnRUaW1lID0gbmV3VGltZSA8IDAgPyAwIDogbmV3VGltZTtcbiAgICB9XG5cbiAgICBKdW1wQmFja3dhcmQoKXtcbiAgICAgICAgdmFyIG5ld1RpbWUgPSB0aGlzLnZpZGVvRWxlbWVudC5jdXJyZW50VGltZSAtIDE7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50LmN1cnJlbnRUaW1lID0gbmV3VGltZSA8IDAgPyAwIDogbmV3VGltZTtcbiAgICB9ICAgICBcblxuICAgIFBsYXkoKXtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnQucGxheSgpO1xuICAgICAgICBpZih0aGlzLmVuZFRpbWUpIHRoaXMuZW5kVGltZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLlNldEF1dG9GYWRlKHRydWUpO1xuICAgICAgICB0aGlzLiRjb250YWluZXIudHJpZ2dlcihcIk9uUGxheVN0YXRlQ2hhbmdlXCIsICF0aGlzLnZpZGVvRWxlbWVudC5wYXVzZWQpO1xuICAgIH1cblxuICAgIFBhdXNlKCl7XG4gICAgICAgIGlmKHRoaXMuZW5kVGltZSkgdGhpcy5lbmRUaW1lID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50LnBhdXNlKCk7XG4gICAgICAgIHRoaXMuU2V0QXV0b0ZhZGUoZmFsc2UpO1xuICAgICAgICB0aGlzLiRjb250YWluZXIudHJpZ2dlcihcIk9uUGxheVN0YXRlQ2hhbmdlXCIsICF0aGlzLnZpZGVvRWxlbWVudC5wYXVzZWQpO1xuICAgIH1cblxuICAgIFRvZ2dsZU11dGVTdGF0ZSgpe1xuICAgICAgICBsZXQgbXV0ZWQgPSB0aGlzLnZpZGVvRWxlbWVudC5tdXRlZDtcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnQubXV0ZWQgPSAhbXV0ZWQ7XG4gICAgICAgIHRoaXMuJGNvbnRhaW5lci50cmlnZ2VyKFwiT25NdXRlU3RhdGVDaGFuZ2VcIiwgbXV0ZWQpO1xuICAgIH1cblxuICAgIFNldFZvbHVtZSh2b2x1bWUpe1xuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudC52b2x1bWUgPSB2b2x1bWU7XG4gICAgICAgIHRoaXMuJGNvbnRhaW5lci50cmlnZ2VyKFwiT25Wb2x1bWVDaGFuZ2VcIiwgdm9sdW1lKTtcbiAgICB9XG5cbiAgICBUb2dnbGVGdWxsc2NyZWVuKCl7XG4gICAgICAgIGlmIChzY3JlZW5mdWxsID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgICAgICBzY3JlZW5mdWxsLnRvZ2dsZSh0aGlzLiRjb250YWluZXJbMF0pO1xuICAgIH1cblxuICAgIE9uRnVsbHNjcmVlbkNoYW5nZSgpe1xuICAgICAgICBpZihzY3JlZW5mdWxsLmlzRnVsbHNjcmVlbil7XG4gICAgICAgICAgICB0aGlzLiRjb250YWluZXIuYWRkQ2xhc3MoXCJ3YWxkb3JmLWZ1bGxzY3JlZW5cIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci5yZW1vdmVDbGFzcyhcIndhbGRvcmYtZnVsbHNjcmVlblwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIFNldEZ1bGxzY3JlZW4oZnVsbHNjcmVlbil7XG4gICAgICAgIGlmIChzY3JlZW5mdWxsID09PSAndW5kZWZpbmVkJyB8fCAhc2NyZWVuZnVsbC5lbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZihmdWxsc2NyZWVuKXtcbiAgICAgICAgICAgIHNjcmVlbmZ1bGwucmVxdWVzdCh0aGlzLiRjb250YWluZXJbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2NyZWVuZnVsbC5leGl0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgbW91c2UgbW92ZXMgaW4gdGhlIHZpZGVvIGNvbnRhaW5lci5cbiAgICAgKi9cbiAgICBPbk1vdXNlTW92ZSgpe1xuICAgICAgICAvLyBSZXNldCB0aGUgdGltZXJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubW91c2VUaW1lcik7XG4gICAgICAgIHRoaXMubW91c2VUaW1lciA9IDA7XG5cbiAgICAgICAgLy8gUmVzdGFydCBmYWRpbmcgaWYgYWxsb3dlZCB0b1xuICAgICAgICBpZih0aGlzLmFsbG93QXV0b0ZhZGUpe1xuICAgICAgICAgICAgIHRoaXMuUmVzdGFydEZhZGluZygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgT25UaW1lVXBkYXRlKHRpbWUpe1xuICAgICAgICBpZih0aGlzLmVuZFRpbWUgJiYgdGhpcy5lbmRUaW1lIDw9IHRoaXMudmlkZW9FbGVtZW50LmN1cnJlbnRUaW1lKXtcbiAgICAgICAgICAgIHRoaXMuUGF1c2UoKTsgICBcbiAgICAgICAgICAgIHRoaXMuZW5kVGltZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGNvbnRhaW5lci50cmlnZ2VyKFwiT25UaW1lVXBkYXRlXCIsIHRpbWUpO1xuICAgIH1cblxuICAgIFJlc3RhcnRGYWRpbmcoKXtcbiAgICAgICAgLy8gUmVzdG9yZSB2aXNpYmlsaXR5XG4gICAgICAgIHRoaXMuU2V0VmlzaWJsZSh0cnVlLCB0aGlzLmZhZGVEdXJhdGlvbik7XG5cbiAgICAgICAgLy8gU3RhcnQgdGhlIHRpbWVyIG92ZXIgYWdhaW5cbiAgICAgICAgdGhpcy5tb3VzZVRpbWVyID0gc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgdGhpcy5TZXRWaXNpYmxlKGZhbHNlLCB0aGlzLmZhZGVEdXJhdGlvbik7XG4gICAgICAgIH0sIHRoaXMuaWRsZVNlY29uZHNCZWZvcmVGYWRlICogMTAwMCk7XG4gICAgfVxuXG4gICAgU2V0QXV0b0ZhZGUoYWxsb3cpIHtcbiAgICAgICAgdGhpcy5hbGxvd0F1dG9GYWRlID0gYWxsb3c7XG4gICAgICAgIFxuICAgICAgICAvLyBSZXNldCB0aGUgbW91c2UgdGltZXJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubW91c2VUaW1lcik7XG4gICAgICAgIHRoaXMubW91c2VUaW1lciA9IDA7XG5cbiAgICAgICAgLy8gTWFrZSBlbGVtZW50cyB2aXNpYmxlXG4gICAgICAgIHRoaXMuU2V0VmlzaWJsZSh0cnVlKTtcblxuICAgICAgICAvLyBSZXN0YXJ0IHRoZSBmYWRpbmcgYmVoYXZpb3IgaWYgZGVzaXJlZFxuICAgICAgICBpZihhbGxvdyl7XG4gICAgICAgICAgICB0aGlzLlJlc3RhcnRGYWRpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICB9XG5cbiAgICAvLyBJc1BsYXlpbmcoKXtcbiAgICAvLyAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzExMzM0MDFcbiAgICAvLyAgICAgcmV0dXJuICEhKHRoaXMudmlkZW9FbGVtZW50LmN1cnJlbnRUaW1lID4gMCAmJiAhdGhpcy52aWRlb0VsZW1lbnQucGF1c2VkICYmIFxuICAgIC8vICAgICAgICAgICAgICAgIXRoaXMudmlkZW9FbGVtZW50LmVuZGVkICYmIHRoaXMudmlkZW9FbGVtZW50LnJlYWR5U3RhdGUgPiAyKTtcbiAgICAvLyB9XG5cbiAgICAvLyBGcm9tIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL05hdGVvd2FtaS83YTk0N2U5M2YwOWM0NWExMDk3ZTc4M2RjMDA1NjBlMVxuICAgIEdldFZpZGVvRGltZW5zaW9ucygpIHtcbiAgICAgICAgbGV0IHZpZGVvID0gdGhpcy52aWRlb0VsZW1lbnQ7XG4gICAgICAgIC8vIFJhdGlvIG9mIHRoZSB2aWRlbydzIGludHJpc2ljIGRpbWVuc2lvbnNcbiAgICAgICAgbGV0IHZpZGVvUmF0aW8gPSB2aWRlby52aWRlb1dpZHRoIC8gdmlkZW8udmlkZW9IZWlnaHQ7XG4gICAgICAgIC8vIFRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSB2aWRlbyBlbGVtZW50XG4gICAgICAgIGxldCB3aWR0aCA9IHZpZGVvLm9mZnNldFdpZHRoO1xuICAgICAgICBsZXQgaGVpZ2h0ID0gdmlkZW8ub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAvLyBUaGUgcmF0aW8gb2YgdGhlIGVsZW1lbnQncyB3aWR0aCB0byBpdHMgaGVpZ2h0XG4gICAgICAgIGxldCBlbGVtZW50UmF0aW8gPSB3aWR0aCAvIGhlaWdodDtcbiAgICAgICAgLy8gSWYgdGhlIHZpZGVvIGVsZW1lbnQgaXMgc2hvcnQgYW5kIHdpZGVcbiAgICAgICAgaWYoZWxlbWVudFJhdGlvID4gdmlkZW9SYXRpbykgd2lkdGggPSBoZWlnaHQgKiB2aWRlb1JhdGlvO1xuICAgICAgICAvLyBJdCBtdXN0IGJlIHRhbGwgYW5kIHRoaW4sIG9yIGV4YWN0bHkgZXF1YWwgdG8gdGhlIG9yaWdpbmFsIHJhdGlvXG4gICAgICAgIGVsc2UgaGVpZ2h0ID0gd2lkdGggLyB2aWRlb1JhdGlvO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICB9O1xuICAgIH1cblxufVxuXG5leHBvcnQgeyBBbm5vdGF0b3JWaWRlb1BsYXllciB9OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5pc0lkZW50aWZpZXJTdGFydCA9IGlzSWRlbnRpZmllclN0YXJ0O1xuZXhwb3J0cy5pc0lkZW50aWZpZXJDaGFyID0gaXNJZGVudGlmaWVyQ2hhcjtcbmV4cG9ydHMuaXNJZGVudGlmaWVyTmFtZSA9IGlzSWRlbnRpZmllck5hbWU7XG5sZXQgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IFwiXFx4YWFcXHhiNVxceGJhXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAyYzFcXHUwMmM2LVxcdTAyZDFcXHUwMmUwLVxcdTAyZTRcXHUwMmVjXFx1MDJlZVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3YS1cXHUwMzdkXFx1MDM3ZlxcdTAzODZcXHUwMzg4LVxcdTAzOGFcXHUwMzhjXFx1MDM4ZS1cXHUwM2ExXFx1MDNhMy1cXHUwM2Y1XFx1MDNmNy1cXHUwNDgxXFx1MDQ4YS1cXHUwNTJmXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjAtXFx1MDU4OFxcdTA1ZDAtXFx1MDVlYVxcdTA1ZWYtXFx1MDVmMlxcdTA2MjAtXFx1MDY0YVxcdTA2NmVcXHUwNjZmXFx1MDY3MS1cXHUwNmQzXFx1MDZkNVxcdTA2ZTVcXHUwNmU2XFx1MDZlZVxcdTA2ZWZcXHUwNmZhLVxcdTA2ZmNcXHUwNmZmXFx1MDcxMFxcdTA3MTItXFx1MDcyZlxcdTA3NGQtXFx1MDdhNVxcdTA3YjFcXHUwN2NhLVxcdTA3ZWFcXHUwN2Y0XFx1MDdmNVxcdTA3ZmFcXHUwODAwLVxcdTA4MTVcXHUwODFhXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwODYwLVxcdTA4NmFcXHUwOGEwLVxcdTA4YjRcXHUwOGI2LVxcdTA4YzdcXHUwOTA0LVxcdTA5MzlcXHUwOTNkXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk4MFxcdTA5ODUtXFx1MDk4Y1xcdTA5OGZcXHUwOTkwXFx1MDk5My1cXHUwOWE4XFx1MDlhYS1cXHUwOWIwXFx1MDliMlxcdTA5YjYtXFx1MDliOVxcdTA5YmRcXHUwOWNlXFx1MDlkY1xcdTA5ZGRcXHUwOWRmLVxcdTA5ZTFcXHUwOWYwXFx1MDlmMVxcdTA5ZmNcXHUwYTA1LVxcdTBhMGFcXHUwYTBmXFx1MGExMFxcdTBhMTMtXFx1MGEyOFxcdTBhMmEtXFx1MGEzMFxcdTBhMzJcXHUwYTMzXFx1MGEzNVxcdTBhMzZcXHUwYTM4XFx1MGEzOVxcdTBhNTktXFx1MGE1Y1xcdTBhNWVcXHUwYTcyLVxcdTBhNzRcXHUwYTg1LVxcdTBhOGRcXHUwYThmLVxcdTBhOTFcXHUwYTkzLVxcdTBhYThcXHUwYWFhLVxcdTBhYjBcXHUwYWIyXFx1MGFiM1xcdTBhYjUtXFx1MGFiOVxcdTBhYmRcXHUwYWQwXFx1MGFlMFxcdTBhZTFcXHUwYWY5XFx1MGIwNS1cXHUwYjBjXFx1MGIwZlxcdTBiMTBcXHUwYjEzLVxcdTBiMjhcXHUwYjJhLVxcdTBiMzBcXHUwYjMyXFx1MGIzM1xcdTBiMzUtXFx1MGIzOVxcdTBiM2RcXHUwYjVjXFx1MGI1ZFxcdTBiNWYtXFx1MGI2MVxcdTBiNzFcXHUwYjgzXFx1MGI4NS1cXHUwYjhhXFx1MGI4ZS1cXHUwYjkwXFx1MGI5Mi1cXHUwYjk1XFx1MGI5OVxcdTBiOWFcXHUwYjljXFx1MGI5ZVxcdTBiOWZcXHUwYmEzXFx1MGJhNFxcdTBiYTgtXFx1MGJhYVxcdTBiYWUtXFx1MGJiOVxcdTBiZDBcXHUwYzA1LVxcdTBjMGNcXHUwYzBlLVxcdTBjMTBcXHUwYzEyLVxcdTBjMjhcXHUwYzJhLVxcdTBjMzlcXHUwYzNkXFx1MGM1OC1cXHUwYzVhXFx1MGM2MFxcdTBjNjFcXHUwYzgwXFx1MGM4NS1cXHUwYzhjXFx1MGM4ZS1cXHUwYzkwXFx1MGM5Mi1cXHUwY2E4XFx1MGNhYS1cXHUwY2IzXFx1MGNiNS1cXHUwY2I5XFx1MGNiZFxcdTBjZGVcXHUwY2UwXFx1MGNlMVxcdTBjZjFcXHUwY2YyXFx1MGQwNC1cXHUwZDBjXFx1MGQwZS1cXHUwZDEwXFx1MGQxMi1cXHUwZDNhXFx1MGQzZFxcdTBkNGVcXHUwZDU0LVxcdTBkNTZcXHUwZDVmLVxcdTBkNjFcXHUwZDdhLVxcdTBkN2ZcXHUwZDg1LVxcdTBkOTZcXHUwZDlhLVxcdTBkYjFcXHUwZGIzLVxcdTBkYmJcXHUwZGJkXFx1MGRjMC1cXHUwZGM2XFx1MGUwMS1cXHUwZTMwXFx1MGUzMlxcdTBlMzNcXHUwZTQwLVxcdTBlNDZcXHUwZTgxXFx1MGU4MlxcdTBlODRcXHUwZTg2LVxcdTBlOGFcXHUwZThjLVxcdTBlYTNcXHUwZWE1XFx1MGVhNy1cXHUwZWIwXFx1MGViMlxcdTBlYjNcXHUwZWJkXFx1MGVjMC1cXHUwZWM0XFx1MGVjNlxcdTBlZGMtXFx1MGVkZlxcdTBmMDBcXHUwZjQwLVxcdTBmNDdcXHUwZjQ5LVxcdTBmNmNcXHUwZjg4LVxcdTBmOGNcXHUxMDAwLVxcdTEwMmFcXHUxMDNmXFx1MTA1MC1cXHUxMDU1XFx1MTA1YS1cXHUxMDVkXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2ZS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4ZVxcdTEwYTAtXFx1MTBjNVxcdTEwYzdcXHUxMGNkXFx1MTBkMC1cXHUxMGZhXFx1MTBmYy1cXHUxMjQ4XFx1MTI0YS1cXHUxMjRkXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNWEtXFx1MTI1ZFxcdTEyNjAtXFx1MTI4OFxcdTEyOGEtXFx1MTI4ZFxcdTEyOTAtXFx1MTJiMFxcdTEyYjItXFx1MTJiNVxcdTEyYjgtXFx1MTJiZVxcdTEyYzBcXHUxMmMyLVxcdTEyYzVcXHUxMmM4LVxcdTEyZDZcXHUxMmQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNWFcXHUxMzgwLVxcdTEzOGZcXHUxM2EwLVxcdTEzZjVcXHUxM2Y4LVxcdTEzZmRcXHUxNDAxLVxcdTE2NmNcXHUxNjZmLVxcdTE2N2ZcXHUxNjgxLVxcdTE2OWFcXHUxNmEwLVxcdTE2ZWFcXHUxNmVlLVxcdTE2ZjhcXHUxNzAwLVxcdTE3MGNcXHUxNzBlLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NmNcXHUxNzZlLVxcdTE3NzBcXHUxNzgwLVxcdTE3YjNcXHUxN2Q3XFx1MTdkY1xcdTE4MjAtXFx1MTg3OFxcdTE4ODAtXFx1MThhOFxcdTE4YWFcXHUxOGIwLVxcdTE4ZjVcXHUxOTAwLVxcdTE5MWVcXHUxOTUwLVxcdTE5NmRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5YWJcXHUxOWIwLVxcdTE5YzlcXHUxYTAwLVxcdTFhMTZcXHUxYTIwLVxcdTFhNTRcXHUxYWE3XFx1MWIwNS1cXHUxYjMzXFx1MWI0NS1cXHUxYjRiXFx1MWI4My1cXHUxYmEwXFx1MWJhZVxcdTFiYWZcXHUxYmJhLVxcdTFiZTVcXHUxYzAwLVxcdTFjMjNcXHUxYzRkLVxcdTFjNGZcXHUxYzVhLVxcdTFjN2RcXHUxYzgwLVxcdTFjODhcXHUxYzkwLVxcdTFjYmFcXHUxY2JkLVxcdTFjYmZcXHUxY2U5LVxcdTFjZWNcXHUxY2VlLVxcdTFjZjNcXHUxY2Y1XFx1MWNmNlxcdTFjZmFcXHUxZDAwLVxcdTFkYmZcXHUxZTAwLVxcdTFmMTVcXHUxZjE4LVxcdTFmMWRcXHUxZjIwLVxcdTFmNDVcXHUxZjQ4LVxcdTFmNGRcXHUxZjUwLVxcdTFmNTdcXHUxZjU5XFx1MWY1YlxcdTFmNWRcXHUxZjVmLVxcdTFmN2RcXHUxZjgwLVxcdTFmYjRcXHUxZmI2LVxcdTFmYmNcXHUxZmJlXFx1MWZjMi1cXHUxZmM0XFx1MWZjNi1cXHUxZmNjXFx1MWZkMC1cXHUxZmQzXFx1MWZkNi1cXHUxZmRiXFx1MWZlMC1cXHUxZmVjXFx1MWZmMi1cXHUxZmY0XFx1MWZmNi1cXHUxZmZjXFx1MjA3MVxcdTIwN2ZcXHUyMDkwLVxcdTIwOWNcXHUyMTAyXFx1MjEwN1xcdTIxMGEtXFx1MjExM1xcdTIxMTVcXHUyMTE4LVxcdTIxMWRcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJhLVxcdTIxMzlcXHUyMTNjLVxcdTIxM2ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRlXFx1MjE2MC1cXHUyMTg4XFx1MmMwMC1cXHUyYzJlXFx1MmMzMC1cXHUyYzVlXFx1MmM2MC1cXHUyY2U0XFx1MmNlYi1cXHUyY2VlXFx1MmNmMlxcdTJjZjNcXHUyZDAwLVxcdTJkMjVcXHUyZDI3XFx1MmQyZFxcdTJkMzAtXFx1MmQ2N1xcdTJkNmZcXHUyZDgwLVxcdTJkOTZcXHUyZGEwLVxcdTJkYTZcXHUyZGE4LVxcdTJkYWVcXHUyZGIwLVxcdTJkYjZcXHUyZGI4LVxcdTJkYmVcXHUyZGMwLVxcdTJkYzZcXHUyZGM4LVxcdTJkY2VcXHUyZGQwLVxcdTJkZDZcXHUyZGQ4LVxcdTJkZGVcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM2NcXHUzMDQxLVxcdTMwOTZcXHUzMDliLVxcdTMwOWZcXHUzMGExLVxcdTMwZmFcXHUzMGZjLVxcdTMwZmZcXHUzMTA1LVxcdTMxMmZcXHUzMTMxLVxcdTMxOGVcXHUzMWEwLVxcdTMxYmZcXHUzMWYwLVxcdTMxZmZcXHUzNDAwLVxcdTRkYmZcXHU0ZTAwLVxcdTlmZmNcXHVhMDAwLVxcdWE0OGNcXHVhNGQwLVxcdWE0ZmRcXHVhNTAwLVxcdWE2MGNcXHVhNjEwLVxcdWE2MWZcXHVhNjJhXFx1YTYyYlxcdWE2NDAtXFx1YTY2ZVxcdWE2N2YtXFx1YTY5ZFxcdWE2YTAtXFx1YTZlZlxcdWE3MTctXFx1YTcxZlxcdWE3MjItXFx1YTc4OFxcdWE3OGItXFx1YTdiZlxcdWE3YzItXFx1YTdjYVxcdWE3ZjUtXFx1YTgwMVxcdWE4MDMtXFx1YTgwNVxcdWE4MDctXFx1YTgwYVxcdWE4MGMtXFx1YTgyMlxcdWE4NDAtXFx1YTg3M1xcdWE4ODItXFx1YThiM1xcdWE4ZjItXFx1YThmN1xcdWE4ZmJcXHVhOGZkXFx1YThmZVxcdWE5MGEtXFx1YTkyNVxcdWE5MzAtXFx1YTk0NlxcdWE5NjAtXFx1YTk3Y1xcdWE5ODQtXFx1YTliMlxcdWE5Y2ZcXHVhOWUwLVxcdWE5ZTRcXHVhOWU2LVxcdWE5ZWZcXHVhOWZhLVxcdWE5ZmVcXHVhYTAwLVxcdWFhMjhcXHVhYTQwLVxcdWFhNDJcXHVhYTQ0LVxcdWFhNGJcXHVhYTYwLVxcdWFhNzZcXHVhYTdhXFx1YWE3ZS1cXHVhYWFmXFx1YWFiMVxcdWFhYjVcXHVhYWI2XFx1YWFiOS1cXHVhYWJkXFx1YWFjMFxcdWFhYzJcXHVhYWRiLVxcdWFhZGRcXHVhYWUwLVxcdWFhZWFcXHVhYWYyLVxcdWFhZjRcXHVhYjAxLVxcdWFiMDZcXHVhYjA5LVxcdWFiMGVcXHVhYjExLVxcdWFiMTZcXHVhYjIwLVxcdWFiMjZcXHVhYjI4LVxcdWFiMmVcXHVhYjMwLVxcdWFiNWFcXHVhYjVjLVxcdWFiNjlcXHVhYjcwLVxcdWFiZTJcXHVhYzAwLVxcdWQ3YTNcXHVkN2IwLVxcdWQ3YzZcXHVkN2NiLVxcdWQ3ZmJcXHVmOTAwLVxcdWZhNmRcXHVmYTcwLVxcdWZhZDlcXHVmYjAwLVxcdWZiMDZcXHVmYjEzLVxcdWZiMTdcXHVmYjFkXFx1ZmIxZi1cXHVmYjI4XFx1ZmIyYS1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDBcXHVmYjQxXFx1ZmI0M1xcdWZiNDRcXHVmYjQ2LVxcdWZiYjFcXHVmYmQzLVxcdWZkM2RcXHVmZDUwLVxcdWZkOGZcXHVmZDkyLVxcdWZkYzdcXHVmZGYwLVxcdWZkZmJcXHVmZTcwLVxcdWZlNzRcXHVmZTc2LVxcdWZlZmNcXHVmZjIxLVxcdWZmM2FcXHVmZjQxLVxcdWZmNWFcXHVmZjY2LVxcdWZmYmVcXHVmZmMyLVxcdWZmYzdcXHVmZmNhLVxcdWZmY2ZcXHVmZmQyLVxcdWZmZDdcXHVmZmRhLVxcdWZmZGNcIjtcbmxldCBub25BU0NJSWlkZW50aWZpZXJDaGFycyA9IFwiXFx1MjAwY1xcdTIwMGRcXHhiN1xcdTAzMDAtXFx1MDM2ZlxcdTAzODdcXHUwNDgzLVxcdTA0ODdcXHUwNTkxLVxcdTA1YmRcXHUwNWJmXFx1MDVjMVxcdTA1YzJcXHUwNWM0XFx1MDVjNVxcdTA1YzdcXHUwNjEwLVxcdTA2MWFcXHUwNjRiLVxcdTA2NjlcXHUwNjcwXFx1MDZkNi1cXHUwNmRjXFx1MDZkZi1cXHUwNmU0XFx1MDZlN1xcdTA2ZThcXHUwNmVhLVxcdTA2ZWRcXHUwNmYwLVxcdTA2ZjlcXHUwNzExXFx1MDczMC1cXHUwNzRhXFx1MDdhNi1cXHUwN2IwXFx1MDdjMC1cXHUwN2M5XFx1MDdlYi1cXHUwN2YzXFx1MDdmZFxcdTA4MTYtXFx1MDgxOVxcdTA4MWItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyZFxcdTA4NTktXFx1MDg1YlxcdTA4ZDMtXFx1MDhlMVxcdTA4ZTMtXFx1MDkwM1xcdTA5M2EtXFx1MDkzY1xcdTA5M2UtXFx1MDk0ZlxcdTA5NTEtXFx1MDk1N1xcdTA5NjJcXHUwOTYzXFx1MDk2Ni1cXHUwOTZmXFx1MDk4MS1cXHUwOTgzXFx1MDliY1xcdTA5YmUtXFx1MDljNFxcdTA5YzdcXHUwOWM4XFx1MDljYi1cXHUwOWNkXFx1MDlkN1xcdTA5ZTJcXHUwOWUzXFx1MDllNi1cXHUwOWVmXFx1MDlmZVxcdTBhMDEtXFx1MGEwM1xcdTBhM2NcXHUwYTNlLVxcdTBhNDJcXHUwYTQ3XFx1MGE0OFxcdTBhNGItXFx1MGE0ZFxcdTBhNTFcXHUwYTY2LVxcdTBhNzFcXHUwYTc1XFx1MGE4MS1cXHUwYTgzXFx1MGFiY1xcdTBhYmUtXFx1MGFjNVxcdTBhYzctXFx1MGFjOVxcdTBhY2ItXFx1MGFjZFxcdTBhZTJcXHUwYWUzXFx1MGFlNi1cXHUwYWVmXFx1MGFmYS1cXHUwYWZmXFx1MGIwMS1cXHUwYjAzXFx1MGIzY1xcdTBiM2UtXFx1MGI0NFxcdTBiNDdcXHUwYjQ4XFx1MGI0Yi1cXHUwYjRkXFx1MGI1NS1cXHUwYjU3XFx1MGI2MlxcdTBiNjNcXHUwYjY2LVxcdTBiNmZcXHUwYjgyXFx1MGJiZS1cXHUwYmMyXFx1MGJjNi1cXHUwYmM4XFx1MGJjYS1cXHUwYmNkXFx1MGJkN1xcdTBiZTYtXFx1MGJlZlxcdTBjMDAtXFx1MGMwNFxcdTBjM2UtXFx1MGM0NFxcdTBjNDYtXFx1MGM0OFxcdTBjNGEtXFx1MGM0ZFxcdTBjNTVcXHUwYzU2XFx1MGM2MlxcdTBjNjNcXHUwYzY2LVxcdTBjNmZcXHUwYzgxLVxcdTBjODNcXHUwY2JjXFx1MGNiZS1cXHUwY2M0XFx1MGNjNi1cXHUwY2M4XFx1MGNjYS1cXHUwY2NkXFx1MGNkNVxcdTBjZDZcXHUwY2UyXFx1MGNlM1xcdTBjZTYtXFx1MGNlZlxcdTBkMDAtXFx1MGQwM1xcdTBkM2JcXHUwZDNjXFx1MGQzZS1cXHUwZDQ0XFx1MGQ0Ni1cXHUwZDQ4XFx1MGQ0YS1cXHUwZDRkXFx1MGQ1N1xcdTBkNjJcXHUwZDYzXFx1MGQ2Ni1cXHUwZDZmXFx1MGQ4MS1cXHUwZDgzXFx1MGRjYVxcdTBkY2YtXFx1MGRkNFxcdTBkZDZcXHUwZGQ4LVxcdTBkZGZcXHUwZGU2LVxcdTBkZWZcXHUwZGYyXFx1MGRmM1xcdTBlMzFcXHUwZTM0LVxcdTBlM2FcXHUwZTQ3LVxcdTBlNGVcXHUwZTUwLVxcdTBlNTlcXHUwZWIxXFx1MGViNC1cXHUwZWJjXFx1MGVjOC1cXHUwZWNkXFx1MGVkMC1cXHUwZWQ5XFx1MGYxOFxcdTBmMTlcXHUwZjIwLVxcdTBmMjlcXHUwZjM1XFx1MGYzN1xcdTBmMzlcXHUwZjNlXFx1MGYzZlxcdTBmNzEtXFx1MGY4NFxcdTBmODZcXHUwZjg3XFx1MGY4ZC1cXHUwZjk3XFx1MGY5OS1cXHUwZmJjXFx1MGZjNlxcdTEwMmItXFx1MTAzZVxcdTEwNDAtXFx1MTA0OVxcdTEwNTYtXFx1MTA1OVxcdTEwNWUtXFx1MTA2MFxcdTEwNjItXFx1MTA2NFxcdTEwNjctXFx1MTA2ZFxcdTEwNzEtXFx1MTA3NFxcdTEwODItXFx1MTA4ZFxcdTEwOGYtXFx1MTA5ZFxcdTEzNWQtXFx1MTM1ZlxcdTEzNjktXFx1MTM3MVxcdTE3MTItXFx1MTcxNFxcdTE3MzItXFx1MTczNFxcdTE3NTJcXHUxNzUzXFx1MTc3MlxcdTE3NzNcXHUxN2I0LVxcdTE3ZDNcXHUxN2RkXFx1MTdlMC1cXHUxN2U5XFx1MTgwYi1cXHUxODBkXFx1MTgxMC1cXHUxODE5XFx1MThhOVxcdTE5MjAtXFx1MTkyYlxcdTE5MzAtXFx1MTkzYlxcdTE5NDYtXFx1MTk0ZlxcdTE5ZDAtXFx1MTlkYVxcdTFhMTctXFx1MWExYlxcdTFhNTUtXFx1MWE1ZVxcdTFhNjAtXFx1MWE3Y1xcdTFhN2YtXFx1MWE4OVxcdTFhOTAtXFx1MWE5OVxcdTFhYjAtXFx1MWFiZFxcdTFhYmZcXHUxYWMwXFx1MWIwMC1cXHUxYjA0XFx1MWIzNC1cXHUxYjQ0XFx1MWI1MC1cXHUxYjU5XFx1MWI2Yi1cXHUxYjczXFx1MWI4MC1cXHUxYjgyXFx1MWJhMS1cXHUxYmFkXFx1MWJiMC1cXHUxYmI5XFx1MWJlNi1cXHUxYmYzXFx1MWMyNC1cXHUxYzM3XFx1MWM0MC1cXHUxYzQ5XFx1MWM1MC1cXHUxYzU5XFx1MWNkMC1cXHUxY2QyXFx1MWNkNC1cXHUxY2U4XFx1MWNlZFxcdTFjZjRcXHUxY2Y3LVxcdTFjZjlcXHUxZGMwLVxcdTFkZjlcXHUxZGZiLVxcdTFkZmZcXHUyMDNmXFx1MjA0MFxcdTIwNTRcXHUyMGQwLVxcdTIwZGNcXHUyMGUxXFx1MjBlNS1cXHUyMGYwXFx1MmNlZi1cXHUyY2YxXFx1MmQ3ZlxcdTJkZTAtXFx1MmRmZlxcdTMwMmEtXFx1MzAyZlxcdTMwOTlcXHUzMDlhXFx1YTYyMC1cXHVhNjI5XFx1YTY2ZlxcdWE2NzQtXFx1YTY3ZFxcdWE2OWVcXHVhNjlmXFx1YTZmMFxcdWE2ZjFcXHVhODAyXFx1YTgwNlxcdWE4MGJcXHVhODIzLVxcdWE4MjdcXHVhODJjXFx1YTg4MFxcdWE4ODFcXHVhOGI0LVxcdWE4YzVcXHVhOGQwLVxcdWE4ZDlcXHVhOGUwLVxcdWE4ZjFcXHVhOGZmLVxcdWE5MDlcXHVhOTI2LVxcdWE5MmRcXHVhOTQ3LVxcdWE5NTNcXHVhOTgwLVxcdWE5ODNcXHVhOWIzLVxcdWE5YzBcXHVhOWQwLVxcdWE5ZDlcXHVhOWU1XFx1YTlmMC1cXHVhOWY5XFx1YWEyOS1cXHVhYTM2XFx1YWE0M1xcdWFhNGNcXHVhYTRkXFx1YWE1MC1cXHVhYTU5XFx1YWE3Yi1cXHVhYTdkXFx1YWFiMFxcdWFhYjItXFx1YWFiNFxcdWFhYjdcXHVhYWI4XFx1YWFiZVxcdWFhYmZcXHVhYWMxXFx1YWFlYi1cXHVhYWVmXFx1YWFmNVxcdWFhZjZcXHVhYmUzLVxcdWFiZWFcXHVhYmVjXFx1YWJlZFxcdWFiZjAtXFx1YWJmOVxcdWZiMWVcXHVmZTAwLVxcdWZlMGZcXHVmZTIwLVxcdWZlMmZcXHVmZTMzXFx1ZmUzNFxcdWZlNGQtXFx1ZmU0ZlxcdWZmMTAtXFx1ZmYxOVxcdWZmM2ZcIjtcbmNvbnN0IG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0ID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBcIl1cIik7XG5jb25zdCBub25BU0NJSWlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzICsgXCJdXCIpO1xubm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzID0gbnVsbDtcbmNvbnN0IGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzID0gWzAsIDExLCAyLCAyNSwgMiwgMTgsIDIsIDEsIDIsIDE0LCAzLCAxMywgMzUsIDEyMiwgNzAsIDUyLCAyNjgsIDI4LCA0LCA0OCwgNDgsIDMxLCAxNCwgMjksIDYsIDM3LCAxMSwgMjksIDMsIDM1LCA1LCA3LCAyLCA0LCA0MywgMTU3LCAxOSwgMzUsIDUsIDM1LCA1LCAzOSwgOSwgNTEsIDE1NywgMzEwLCAxMCwgMjEsIDExLCA3LCAxNTMsIDUsIDMsIDAsIDIsIDQzLCAyLCAxLCA0LCAwLCAzLCAyMiwgMTEsIDIyLCAxMCwgMzAsIDY2LCAxOCwgMiwgMSwgMTEsIDIxLCAxMSwgMjUsIDcxLCA1NSwgNywgMSwgNjUsIDAsIDE2LCAzLCAyLCAyLCAyLCAyOCwgNDMsIDI4LCA0LCAyOCwgMzYsIDcsIDIsIDI3LCAyOCwgNTMsIDExLCAyMSwgMTEsIDE4LCAxNCwgMTcsIDExMSwgNzIsIDU2LCA1MCwgMTQsIDUwLCAxNCwgMzUsIDM0OSwgNDEsIDcsIDEsIDc5LCAyOCwgMTEsIDAsIDksIDIxLCAxMDcsIDIwLCAyOCwgMjIsIDEzLCA1MiwgNzYsIDQ0LCAzMywgMjQsIDI3LCAzNSwgMzAsIDAsIDMsIDAsIDksIDM0LCA0LCAwLCAxMywgNDcsIDE1LCAzLCAyMiwgMCwgMiwgMCwgMzYsIDE3LCAyLCAyNCwgODUsIDYsIDIsIDAsIDIsIDMsIDIsIDE0LCAyLCA5LCA4LCA0NiwgMzksIDcsIDMsIDEsIDMsIDIxLCAyLCA2LCAyLCAxLCAyLCA0LCA0LCAwLCAxOSwgMCwgMTMsIDQsIDE1OSwgNTIsIDE5LCAzLCAyMSwgMiwgMzEsIDQ3LCAyMSwgMSwgMiwgMCwgMTg1LCA0NiwgNDIsIDMsIDM3LCA0NywgMjEsIDAsIDYwLCA0MiwgMTQsIDAsIDcyLCAyNiwgMjMwLCA0MywgMTE3LCA2MywgMzIsIDcsIDMsIDAsIDMsIDcsIDIsIDEsIDIsIDIzLCAxNiwgMCwgMiwgMCwgOTUsIDcsIDMsIDM4LCAxNywgMCwgMiwgMCwgMjksIDAsIDExLCAzOSwgOCwgMCwgMjIsIDAsIDEyLCA0NSwgMjAsIDAsIDM1LCA1NiwgMjY0LCA4LCAyLCAzNiwgMTgsIDAsIDUwLCAyOSwgMTEzLCA2LCAyLCAxLCAyLCAzNywgMjIsIDAsIDI2LCA1LCAyLCAxLCAyLCAzMSwgMTUsIDAsIDMyOCwgMTgsIDE5MCwgMCwgODAsIDkyMSwgMTAzLCAxMTAsIDE4LCAxOTUsIDI3NDksIDEwNzAsIDQwNTAsIDU4MiwgODYzNCwgNTY4LCA4LCAzMCwgMTE0LCAyOSwgMTksIDQ3LCAxNywgMywgMzIsIDIwLCA2LCAxOCwgNjg5LCA2MywgMTI5LCA3NCwgNiwgMCwgNjcsIDEyLCA2NSwgMSwgMiwgMCwgMjksIDYxMzUsIDksIDEyMzcsIDQzLCA4LCA4OTUyLCAyODYsIDUwLCAyLCAxOCwgMywgOSwgMzk1LCAyMzA5LCAxMDYsIDYsIDEyLCA0LCA4LCA4LCA5LCA1OTkxLCA4NCwgMiwgNzAsIDIsIDEsIDMsIDAsIDMsIDEsIDMsIDMsIDIsIDExLCAyLCAwLCAyLCA2LCAyLCA2NCwgMiwgMywgMywgNywgMiwgNiwgMiwgMjcsIDIsIDMsIDIsIDQsIDIsIDAsIDQsIDYsIDIsIDMzOSwgMywgMjQsIDIsIDI0LCAyLCAzMCwgMiwgMjQsIDIsIDMwLCAyLCAyNCwgMiwgMzAsIDIsIDI0LCAyLCAzMCwgMiwgMjQsIDIsIDcsIDIzNTcsIDQ0LCAxMSwgNiwgMTcsIDAsIDM3MCwgNDMsIDEzMDEsIDE5NiwgNjAsIDY3LCA4LCAwLCAxMjA1LCAzLCAyLCAyNiwgMiwgMSwgMiwgMCwgMywgMCwgMiwgOSwgMiwgMywgMiwgMCwgMiwgMCwgNywgMCwgNSwgMCwgMiwgMCwgMiwgMCwgMiwgMiwgMiwgMSwgMiwgMCwgMywgMCwgMiwgMCwgMiwgMCwgMiwgMCwgMiwgMCwgMiwgMSwgMiwgMCwgMywgMywgMiwgNiwgMiwgMywgMiwgMywgMiwgMCwgMiwgOSwgMiwgMTYsIDYsIDIsIDIsIDQsIDIsIDE2LCA0NDIxLCA0MjcxNywgMzUsIDQxNDgsIDEyLCAyMjEsIDMsIDU3NjEsIDE1LCA3NDcyLCAzMTA0LCA1NDEsIDE1MDcsIDQ5MzhdO1xuY29uc3QgYXN0cmFsSWRlbnRpZmllckNvZGVzID0gWzUwOSwgMCwgMjI3LCAwLCAxNTAsIDQsIDI5NCwgOSwgMTM2OCwgMiwgMiwgMSwgNiwgMywgNDEsIDIsIDUsIDAsIDE2NiwgMSwgNTc0LCAzLCA5LCA5LCAzNzAsIDEsIDE1NCwgMTAsIDE3NiwgMiwgNTQsIDE0LCAzMiwgOSwgMTYsIDMsIDQ2LCAxMCwgNTQsIDksIDcsIDIsIDM3LCAxMywgMiwgOSwgNiwgMSwgNDUsIDAsIDEzLCAyLCA0OSwgMTMsIDksIDMsIDIsIDExLCA4MywgMTEsIDcsIDAsIDE2MSwgMTEsIDYsIDksIDcsIDMsIDU2LCAxLCAyLCA2LCAzLCAxLCAzLCAyLCAxMCwgMCwgMTEsIDEsIDMsIDYsIDQsIDQsIDE5MywgMTcsIDEwLCA5LCA1LCAwLCA4MiwgMTksIDEzLCA5LCAyMTQsIDYsIDMsIDgsIDI4LCAxLCA4MywgMTYsIDE2LCA5LCA4MiwgMTIsIDksIDksIDg0LCAxNCwgNSwgOSwgMjQzLCAxNCwgMTY2LCA5LCA3MSwgNSwgMiwgMSwgMywgMywgMiwgMCwgMiwgMSwgMTMsIDksIDEyMCwgNiwgMywgNiwgNCwgMCwgMjksIDksIDQxLCA2LCAyLCAzLCA5LCAwLCAxMCwgMTAsIDQ3LCAxNSwgNDA2LCA3LCAyLCA3LCAxNywgOSwgNTcsIDIxLCAyLCAxMywgMTIzLCA1LCA0LCAwLCAyLCAxLCAyLCA2LCAyLCAwLCA5LCA5LCA0OSwgNCwgMiwgMSwgMiwgNCwgOSwgOSwgMzMwLCAzLCAxOTMwNiwgOSwgMTM1LCA0LCA2MCwgNiwgMjYsIDksIDEwMTQsIDAsIDIsIDU0LCA4LCAzLCA4MiwgMCwgMTIsIDEsIDE5NjI4LCAxLCA1MzE5LCA0LCA0LCA1LCA5LCA3LCAzLCA2LCAzMSwgMywgMTQ5LCAyLCAxNDE4LCA0OSwgNTEzLCA1NCwgNSwgNDksIDksIDAsIDE1LCAwLCAyMywgNCwgMiwgMTQsIDEzNjEsIDYsIDIsIDE2LCAzLCA2LCAyLCAxLCAyLCA0LCAyNjIsIDYsIDEwLCA5LCA0MTksIDEzLCAxNDk1LCA2LCAxMTAsIDYsIDYsIDksIDQ3NTksIDksIDc4NzcxOSwgMjM5XTtcblxuZnVuY3Rpb24gaXNJbkFzdHJhbFNldChjb2RlLCBzZXQpIHtcbiAgbGV0IHBvcyA9IDB4MTAwMDA7XG5cbiAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IHNldC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMikge1xuICAgIHBvcyArPSBzZXRbaV07XG4gICAgaWYgKHBvcyA+IGNvZGUpIHJldHVybiBmYWxzZTtcbiAgICBwb3MgKz0gc2V0W2kgKyAxXTtcbiAgICBpZiAocG9zID49IGNvZGUpIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0lkZW50aWZpZXJTdGFydChjb2RlKSB7XG4gIGlmIChjb2RlIDwgNjUpIHJldHVybiBjb2RlID09PSAzNjtcbiAgaWYgKGNvZGUgPD0gOTApIHJldHVybiB0cnVlO1xuICBpZiAoY29kZSA8IDk3KSByZXR1cm4gY29kZSA9PT0gOTU7XG4gIGlmIChjb2RlIDw9IDEyMikgcmV0dXJuIHRydWU7XG5cbiAgaWYgKGNvZGUgPD0gMHhmZmZmKSB7XG4gICAgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXJTdGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpO1xuICB9XG5cbiAgcmV0dXJuIGlzSW5Bc3RyYWxTZXQoY29kZSwgYXN0cmFsSWRlbnRpZmllclN0YXJ0Q29kZXMpO1xufVxuXG5mdW5jdGlvbiBpc0lkZW50aWZpZXJDaGFyKGNvZGUpIHtcbiAgaWYgKGNvZGUgPCA0OCkgcmV0dXJuIGNvZGUgPT09IDM2O1xuICBpZiAoY29kZSA8IDU4KSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGNvZGUgPCA2NSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoY29kZSA8PSA5MCkgcmV0dXJuIHRydWU7XG4gIGlmIChjb2RlIDwgOTcpIHJldHVybiBjb2RlID09PSA5NTtcbiAgaWYgKGNvZGUgPD0gMTIyKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAoY29kZSA8PSAweGZmZmYpIHtcbiAgICByZXR1cm4gY29kZSA+PSAweGFhICYmIG5vbkFTQ0lJaWRlbnRpZmllci50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpO1xuICB9XG5cbiAgcmV0dXJuIGlzSW5Bc3RyYWxTZXQoY29kZSwgYXN0cmFsSWRlbnRpZmllclN0YXJ0Q29kZXMpIHx8IGlzSW5Bc3RyYWxTZXQoY29kZSwgYXN0cmFsSWRlbnRpZmllckNvZGVzKTtcbn1cblxuZnVuY3Rpb24gaXNJZGVudGlmaWVyTmFtZShuYW1lKSB7XG4gIGxldCBpc0ZpcnN0ID0gdHJ1ZTtcblxuICBmb3IgKGxldCBfaSA9IDAsIF9BcnJheSRmcm9tID0gQXJyYXkuZnJvbShuYW1lKTsgX2kgPCBfQXJyYXkkZnJvbS5sZW5ndGg7IF9pKyspIHtcbiAgICBjb25zdCBjaGFyID0gX0FycmF5JGZyb21bX2ldO1xuICAgIGNvbnN0IGNwID0gY2hhci5jb2RlUG9pbnRBdCgwKTtcblxuICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICBpZiAoIWlzSWRlbnRpZmllclN0YXJ0KGNwKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlzRmlyc3QgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKCFpc0lkZW50aWZpZXJDaGFyKGNwKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAhaXNGaXJzdDtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzSWRlbnRpZmllck5hbWVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2lkZW50aWZpZXIuaXNJZGVudGlmaWVyTmFtZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0lkZW50aWZpZXJDaGFyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pZGVudGlmaWVyLmlzSWRlbnRpZmllckNoYXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNJZGVudGlmaWVyU3RhcnRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2lkZW50aWZpZXIuaXNJZGVudGlmaWVyU3RhcnQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNSZXNlcnZlZFdvcmRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2tleXdvcmQuaXNSZXNlcnZlZFdvcmQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNTdHJpY3RCaW5kT25seVJlc2VydmVkV29yZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfa2V5d29yZC5pc1N0cmljdEJpbmRPbmx5UmVzZXJ2ZWRXb3JkO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzU3RyaWN0QmluZFJlc2VydmVkV29yZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfa2V5d29yZC5pc1N0cmljdEJpbmRSZXNlcnZlZFdvcmQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNTdHJpY3RSZXNlcnZlZFdvcmRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2tleXdvcmQuaXNTdHJpY3RSZXNlcnZlZFdvcmQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNLZXl3b3JkXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9rZXl3b3JkLmlzS2V5d29yZDtcbiAgfVxufSk7XG5cbnZhciBfaWRlbnRpZmllciA9IHJlcXVpcmUoXCIuL2lkZW50aWZpZXJcIik7XG5cbnZhciBfa2V5d29yZCA9IHJlcXVpcmUoXCIuL2tleXdvcmRcIik7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmlzUmVzZXJ2ZWRXb3JkID0gaXNSZXNlcnZlZFdvcmQ7XG5leHBvcnRzLmlzU3RyaWN0UmVzZXJ2ZWRXb3JkID0gaXNTdHJpY3RSZXNlcnZlZFdvcmQ7XG5leHBvcnRzLmlzU3RyaWN0QmluZE9ubHlSZXNlcnZlZFdvcmQgPSBpc1N0cmljdEJpbmRPbmx5UmVzZXJ2ZWRXb3JkO1xuZXhwb3J0cy5pc1N0cmljdEJpbmRSZXNlcnZlZFdvcmQgPSBpc1N0cmljdEJpbmRSZXNlcnZlZFdvcmQ7XG5leHBvcnRzLmlzS2V5d29yZCA9IGlzS2V5d29yZDtcbmNvbnN0IHJlc2VydmVkV29yZHMgPSB7XG4gIGtleXdvcmQ6IFtcImJyZWFrXCIsIFwiY2FzZVwiLCBcImNhdGNoXCIsIFwiY29udGludWVcIiwgXCJkZWJ1Z2dlclwiLCBcImRlZmF1bHRcIiwgXCJkb1wiLCBcImVsc2VcIiwgXCJmaW5hbGx5XCIsIFwiZm9yXCIsIFwiZnVuY3Rpb25cIiwgXCJpZlwiLCBcInJldHVyblwiLCBcInN3aXRjaFwiLCBcInRocm93XCIsIFwidHJ5XCIsIFwidmFyXCIsIFwiY29uc3RcIiwgXCJ3aGlsZVwiLCBcIndpdGhcIiwgXCJuZXdcIiwgXCJ0aGlzXCIsIFwic3VwZXJcIiwgXCJjbGFzc1wiLCBcImV4dGVuZHNcIiwgXCJleHBvcnRcIiwgXCJpbXBvcnRcIiwgXCJudWxsXCIsIFwidHJ1ZVwiLCBcImZhbHNlXCIsIFwiaW5cIiwgXCJpbnN0YW5jZW9mXCIsIFwidHlwZW9mXCIsIFwidm9pZFwiLCBcImRlbGV0ZVwiXSxcbiAgc3RyaWN0OiBbXCJpbXBsZW1lbnRzXCIsIFwiaW50ZXJmYWNlXCIsIFwibGV0XCIsIFwicGFja2FnZVwiLCBcInByaXZhdGVcIiwgXCJwcm90ZWN0ZWRcIiwgXCJwdWJsaWNcIiwgXCJzdGF0aWNcIiwgXCJ5aWVsZFwiXSxcbiAgc3RyaWN0QmluZDogW1wiZXZhbFwiLCBcImFyZ3VtZW50c1wiXVxufTtcbmNvbnN0IGtleXdvcmRzID0gbmV3IFNldChyZXNlcnZlZFdvcmRzLmtleXdvcmQpO1xuY29uc3QgcmVzZXJ2ZWRXb3Jkc1N0cmljdFNldCA9IG5ldyBTZXQocmVzZXJ2ZWRXb3Jkcy5zdHJpY3QpO1xuY29uc3QgcmVzZXJ2ZWRXb3Jkc1N0cmljdEJpbmRTZXQgPSBuZXcgU2V0KHJlc2VydmVkV29yZHMuc3RyaWN0QmluZCk7XG5cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWRXb3JkKHdvcmQsIGluTW9kdWxlKSB7XG4gIHJldHVybiBpbk1vZHVsZSAmJiB3b3JkID09PSBcImF3YWl0XCIgfHwgd29yZCA9PT0gXCJlbnVtXCI7XG59XG5cbmZ1bmN0aW9uIGlzU3RyaWN0UmVzZXJ2ZWRXb3JkKHdvcmQsIGluTW9kdWxlKSB7XG4gIHJldHVybiBpc1Jlc2VydmVkV29yZCh3b3JkLCBpbk1vZHVsZSkgfHwgcmVzZXJ2ZWRXb3Jkc1N0cmljdFNldC5oYXMod29yZCk7XG59XG5cbmZ1bmN0aW9uIGlzU3RyaWN0QmluZE9ubHlSZXNlcnZlZFdvcmQod29yZCkge1xuICByZXR1cm4gcmVzZXJ2ZWRXb3Jkc1N0cmljdEJpbmRTZXQuaGFzKHdvcmQpO1xufVxuXG5mdW5jdGlvbiBpc1N0cmljdEJpbmRSZXNlcnZlZFdvcmQod29yZCwgaW5Nb2R1bGUpIHtcbiAgcmV0dXJuIGlzU3RyaWN0UmVzZXJ2ZWRXb3JkKHdvcmQsIGluTW9kdWxlKSB8fCBpc1N0cmljdEJpbmRPbmx5UmVzZXJ2ZWRXb3JkKHdvcmQpO1xufVxuXG5mdW5jdGlvbiBpc0tleXdvcmQod29yZCkge1xuICByZXR1cm4ga2V5d29yZHMuaGFzKHdvcmQpO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gYXNzZXJ0Tm9kZTtcblxudmFyIF9pc05vZGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi92YWxpZGF0b3JzL2lzTm9kZVwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGFzc2VydE5vZGUobm9kZSkge1xuICBpZiAoISgwLCBfaXNOb2RlLmRlZmF1bHQpKG5vZGUpKSB7XG4gICAgdmFyIF9ub2RlJHR5cGU7XG5cbiAgICBjb25zdCB0eXBlID0gKF9ub2RlJHR5cGUgPSBub2RlID09IG51bGwgPyB2b2lkIDAgOiBub2RlLnR5cGUpICE9IG51bGwgPyBfbm9kZSR0eXBlIDogSlNPTi5zdHJpbmdpZnkobm9kZSk7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm90IGEgdmFsaWQgbm9kZSBvZiB0eXBlIFwiJHt0eXBlfVwiYCk7XG4gIH1cbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuYXNzZXJ0QXJyYXlFeHByZXNzaW9uID0gYXNzZXJ0QXJyYXlFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRBc3NpZ25tZW50RXhwcmVzc2lvbiA9IGFzc2VydEFzc2lnbm1lbnRFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRCaW5hcnlFeHByZXNzaW9uID0gYXNzZXJ0QmluYXJ5RXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0SW50ZXJwcmV0ZXJEaXJlY3RpdmUgPSBhc3NlcnRJbnRlcnByZXRlckRpcmVjdGl2ZTtcbmV4cG9ydHMuYXNzZXJ0RGlyZWN0aXZlID0gYXNzZXJ0RGlyZWN0aXZlO1xuZXhwb3J0cy5hc3NlcnREaXJlY3RpdmVMaXRlcmFsID0gYXNzZXJ0RGlyZWN0aXZlTGl0ZXJhbDtcbmV4cG9ydHMuYXNzZXJ0QmxvY2tTdGF0ZW1lbnQgPSBhc3NlcnRCbG9ja1N0YXRlbWVudDtcbmV4cG9ydHMuYXNzZXJ0QnJlYWtTdGF0ZW1lbnQgPSBhc3NlcnRCcmVha1N0YXRlbWVudDtcbmV4cG9ydHMuYXNzZXJ0Q2FsbEV4cHJlc3Npb24gPSBhc3NlcnRDYWxsRXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0Q2F0Y2hDbGF1c2UgPSBhc3NlcnRDYXRjaENsYXVzZTtcbmV4cG9ydHMuYXNzZXJ0Q29uZGl0aW9uYWxFeHByZXNzaW9uID0gYXNzZXJ0Q29uZGl0aW9uYWxFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRDb250aW51ZVN0YXRlbWVudCA9IGFzc2VydENvbnRpbnVlU3RhdGVtZW50O1xuZXhwb3J0cy5hc3NlcnREZWJ1Z2dlclN0YXRlbWVudCA9IGFzc2VydERlYnVnZ2VyU3RhdGVtZW50O1xuZXhwb3J0cy5hc3NlcnREb1doaWxlU3RhdGVtZW50ID0gYXNzZXJ0RG9XaGlsZVN0YXRlbWVudDtcbmV4cG9ydHMuYXNzZXJ0RW1wdHlTdGF0ZW1lbnQgPSBhc3NlcnRFbXB0eVN0YXRlbWVudDtcbmV4cG9ydHMuYXNzZXJ0RXhwcmVzc2lvblN0YXRlbWVudCA9IGFzc2VydEV4cHJlc3Npb25TdGF0ZW1lbnQ7XG5leHBvcnRzLmFzc2VydEZpbGUgPSBhc3NlcnRGaWxlO1xuZXhwb3J0cy5hc3NlcnRGb3JJblN0YXRlbWVudCA9IGFzc2VydEZvckluU3RhdGVtZW50O1xuZXhwb3J0cy5hc3NlcnRGb3JTdGF0ZW1lbnQgPSBhc3NlcnRGb3JTdGF0ZW1lbnQ7XG5leHBvcnRzLmFzc2VydEZ1bmN0aW9uRGVjbGFyYXRpb24gPSBhc3NlcnRGdW5jdGlvbkRlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnRGdW5jdGlvbkV4cHJlc3Npb24gPSBhc3NlcnRGdW5jdGlvbkV4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydElkZW50aWZpZXIgPSBhc3NlcnRJZGVudGlmaWVyO1xuZXhwb3J0cy5hc3NlcnRJZlN0YXRlbWVudCA9IGFzc2VydElmU3RhdGVtZW50O1xuZXhwb3J0cy5hc3NlcnRMYWJlbGVkU3RhdGVtZW50ID0gYXNzZXJ0TGFiZWxlZFN0YXRlbWVudDtcbmV4cG9ydHMuYXNzZXJ0U3RyaW5nTGl0ZXJhbCA9IGFzc2VydFN0cmluZ0xpdGVyYWw7XG5leHBvcnRzLmFzc2VydE51bWVyaWNMaXRlcmFsID0gYXNzZXJ0TnVtZXJpY0xpdGVyYWw7XG5leHBvcnRzLmFzc2VydE51bGxMaXRlcmFsID0gYXNzZXJ0TnVsbExpdGVyYWw7XG5leHBvcnRzLmFzc2VydEJvb2xlYW5MaXRlcmFsID0gYXNzZXJ0Qm9vbGVhbkxpdGVyYWw7XG5leHBvcnRzLmFzc2VydFJlZ0V4cExpdGVyYWwgPSBhc3NlcnRSZWdFeHBMaXRlcmFsO1xuZXhwb3J0cy5hc3NlcnRMb2dpY2FsRXhwcmVzc2lvbiA9IGFzc2VydExvZ2ljYWxFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRNZW1iZXJFeHByZXNzaW9uID0gYXNzZXJ0TWVtYmVyRXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0TmV3RXhwcmVzc2lvbiA9IGFzc2VydE5ld0V4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydFByb2dyYW0gPSBhc3NlcnRQcm9ncmFtO1xuZXhwb3J0cy5hc3NlcnRPYmplY3RFeHByZXNzaW9uID0gYXNzZXJ0T2JqZWN0RXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0T2JqZWN0TWV0aG9kID0gYXNzZXJ0T2JqZWN0TWV0aG9kO1xuZXhwb3J0cy5hc3NlcnRPYmplY3RQcm9wZXJ0eSA9IGFzc2VydE9iamVjdFByb3BlcnR5O1xuZXhwb3J0cy5hc3NlcnRSZXN0RWxlbWVudCA9IGFzc2VydFJlc3RFbGVtZW50O1xuZXhwb3J0cy5hc3NlcnRSZXR1cm5TdGF0ZW1lbnQgPSBhc3NlcnRSZXR1cm5TdGF0ZW1lbnQ7XG5leHBvcnRzLmFzc2VydFNlcXVlbmNlRXhwcmVzc2lvbiA9IGFzc2VydFNlcXVlbmNlRXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0UGFyZW50aGVzaXplZEV4cHJlc3Npb24gPSBhc3NlcnRQYXJlbnRoZXNpemVkRXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0U3dpdGNoQ2FzZSA9IGFzc2VydFN3aXRjaENhc2U7XG5leHBvcnRzLmFzc2VydFN3aXRjaFN0YXRlbWVudCA9IGFzc2VydFN3aXRjaFN0YXRlbWVudDtcbmV4cG9ydHMuYXNzZXJ0VGhpc0V4cHJlc3Npb24gPSBhc3NlcnRUaGlzRXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0VGhyb3dTdGF0ZW1lbnQgPSBhc3NlcnRUaHJvd1N0YXRlbWVudDtcbmV4cG9ydHMuYXNzZXJ0VHJ5U3RhdGVtZW50ID0gYXNzZXJ0VHJ5U3RhdGVtZW50O1xuZXhwb3J0cy5hc3NlcnRVbmFyeUV4cHJlc3Npb24gPSBhc3NlcnRVbmFyeUV4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydFVwZGF0ZUV4cHJlc3Npb24gPSBhc3NlcnRVcGRhdGVFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRWYXJpYWJsZURlY2xhcmF0aW9uID0gYXNzZXJ0VmFyaWFibGVEZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0VmFyaWFibGVEZWNsYXJhdG9yID0gYXNzZXJ0VmFyaWFibGVEZWNsYXJhdG9yO1xuZXhwb3J0cy5hc3NlcnRXaGlsZVN0YXRlbWVudCA9IGFzc2VydFdoaWxlU3RhdGVtZW50O1xuZXhwb3J0cy5hc3NlcnRXaXRoU3RhdGVtZW50ID0gYXNzZXJ0V2l0aFN0YXRlbWVudDtcbmV4cG9ydHMuYXNzZXJ0QXNzaWdubWVudFBhdHRlcm4gPSBhc3NlcnRBc3NpZ25tZW50UGF0dGVybjtcbmV4cG9ydHMuYXNzZXJ0QXJyYXlQYXR0ZXJuID0gYXNzZXJ0QXJyYXlQYXR0ZXJuO1xuZXhwb3J0cy5hc3NlcnRBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGFzc2VydEFycm93RnVuY3Rpb25FeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRDbGFzc0JvZHkgPSBhc3NlcnRDbGFzc0JvZHk7XG5leHBvcnRzLmFzc2VydENsYXNzRXhwcmVzc2lvbiA9IGFzc2VydENsYXNzRXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0Q2xhc3NEZWNsYXJhdGlvbiA9IGFzc2VydENsYXNzRGVjbGFyYXRpb247XG5leHBvcnRzLmFzc2VydEV4cG9ydEFsbERlY2xhcmF0aW9uID0gYXNzZXJ0RXhwb3J0QWxsRGVjbGFyYXRpb247XG5leHBvcnRzLmFzc2VydEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbiA9IGFzc2VydEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0RXhwb3J0TmFtZWREZWNsYXJhdGlvbiA9IGFzc2VydEV4cG9ydE5hbWVkRGVjbGFyYXRpb247XG5leHBvcnRzLmFzc2VydEV4cG9ydFNwZWNpZmllciA9IGFzc2VydEV4cG9ydFNwZWNpZmllcjtcbmV4cG9ydHMuYXNzZXJ0Rm9yT2ZTdGF0ZW1lbnQgPSBhc3NlcnRGb3JPZlN0YXRlbWVudDtcbmV4cG9ydHMuYXNzZXJ0SW1wb3J0RGVjbGFyYXRpb24gPSBhc3NlcnRJbXBvcnREZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0SW1wb3J0RGVmYXVsdFNwZWNpZmllciA9IGFzc2VydEltcG9ydERlZmF1bHRTcGVjaWZpZXI7XG5leHBvcnRzLmFzc2VydEltcG9ydE5hbWVzcGFjZVNwZWNpZmllciA9IGFzc2VydEltcG9ydE5hbWVzcGFjZVNwZWNpZmllcjtcbmV4cG9ydHMuYXNzZXJ0SW1wb3J0U3BlY2lmaWVyID0gYXNzZXJ0SW1wb3J0U3BlY2lmaWVyO1xuZXhwb3J0cy5hc3NlcnRNZXRhUHJvcGVydHkgPSBhc3NlcnRNZXRhUHJvcGVydHk7XG5leHBvcnRzLmFzc2VydENsYXNzTWV0aG9kID0gYXNzZXJ0Q2xhc3NNZXRob2Q7XG5leHBvcnRzLmFzc2VydE9iamVjdFBhdHRlcm4gPSBhc3NlcnRPYmplY3RQYXR0ZXJuO1xuZXhwb3J0cy5hc3NlcnRTcHJlYWRFbGVtZW50ID0gYXNzZXJ0U3ByZWFkRWxlbWVudDtcbmV4cG9ydHMuYXNzZXJ0U3VwZXIgPSBhc3NlcnRTdXBlcjtcbmV4cG9ydHMuYXNzZXJ0VGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uID0gYXNzZXJ0VGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRUZW1wbGF0ZUVsZW1lbnQgPSBhc3NlcnRUZW1wbGF0ZUVsZW1lbnQ7XG5leHBvcnRzLmFzc2VydFRlbXBsYXRlTGl0ZXJhbCA9IGFzc2VydFRlbXBsYXRlTGl0ZXJhbDtcbmV4cG9ydHMuYXNzZXJ0WWllbGRFeHByZXNzaW9uID0gYXNzZXJ0WWllbGRFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRBd2FpdEV4cHJlc3Npb24gPSBhc3NlcnRBd2FpdEV4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydEltcG9ydCA9IGFzc2VydEltcG9ydDtcbmV4cG9ydHMuYXNzZXJ0QmlnSW50TGl0ZXJhbCA9IGFzc2VydEJpZ0ludExpdGVyYWw7XG5leHBvcnRzLmFzc2VydEV4cG9ydE5hbWVzcGFjZVNwZWNpZmllciA9IGFzc2VydEV4cG9ydE5hbWVzcGFjZVNwZWNpZmllcjtcbmV4cG9ydHMuYXNzZXJ0T3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uID0gYXNzZXJ0T3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRPcHRpb25hbENhbGxFeHByZXNzaW9uID0gYXNzZXJ0T3B0aW9uYWxDYWxsRXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0QW55VHlwZUFubm90YXRpb24gPSBhc3NlcnRBbnlUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0QXJyYXlUeXBlQW5ub3RhdGlvbiA9IGFzc2VydEFycmF5VHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydEJvb2xlYW5UeXBlQW5ub3RhdGlvbiA9IGFzc2VydEJvb2xlYW5UeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0Qm9vbGVhbkxpdGVyYWxUeXBlQW5ub3RhdGlvbiA9IGFzc2VydEJvb2xlYW5MaXRlcmFsVHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydE51bGxMaXRlcmFsVHlwZUFubm90YXRpb24gPSBhc3NlcnROdWxsTGl0ZXJhbFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnRDbGFzc0ltcGxlbWVudHMgPSBhc3NlcnRDbGFzc0ltcGxlbWVudHM7XG5leHBvcnRzLmFzc2VydERlY2xhcmVDbGFzcyA9IGFzc2VydERlY2xhcmVDbGFzcztcbmV4cG9ydHMuYXNzZXJ0RGVjbGFyZUZ1bmN0aW9uID0gYXNzZXJ0RGVjbGFyZUZ1bmN0aW9uO1xuZXhwb3J0cy5hc3NlcnREZWNsYXJlSW50ZXJmYWNlID0gYXNzZXJ0RGVjbGFyZUludGVyZmFjZTtcbmV4cG9ydHMuYXNzZXJ0RGVjbGFyZU1vZHVsZSA9IGFzc2VydERlY2xhcmVNb2R1bGU7XG5leHBvcnRzLmFzc2VydERlY2xhcmVNb2R1bGVFeHBvcnRzID0gYXNzZXJ0RGVjbGFyZU1vZHVsZUV4cG9ydHM7XG5leHBvcnRzLmFzc2VydERlY2xhcmVUeXBlQWxpYXMgPSBhc3NlcnREZWNsYXJlVHlwZUFsaWFzO1xuZXhwb3J0cy5hc3NlcnREZWNsYXJlT3BhcXVlVHlwZSA9IGFzc2VydERlY2xhcmVPcGFxdWVUeXBlO1xuZXhwb3J0cy5hc3NlcnREZWNsYXJlVmFyaWFibGUgPSBhc3NlcnREZWNsYXJlVmFyaWFibGU7XG5leHBvcnRzLmFzc2VydERlY2xhcmVFeHBvcnREZWNsYXJhdGlvbiA9IGFzc2VydERlY2xhcmVFeHBvcnREZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0RGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uID0gYXNzZXJ0RGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnREZWNsYXJlZFByZWRpY2F0ZSA9IGFzc2VydERlY2xhcmVkUHJlZGljYXRlO1xuZXhwb3J0cy5hc3NlcnRFeGlzdHNUeXBlQW5ub3RhdGlvbiA9IGFzc2VydEV4aXN0c1R5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnRGdW5jdGlvblR5cGVBbm5vdGF0aW9uID0gYXNzZXJ0RnVuY3Rpb25UeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0RnVuY3Rpb25UeXBlUGFyYW0gPSBhc3NlcnRGdW5jdGlvblR5cGVQYXJhbTtcbmV4cG9ydHMuYXNzZXJ0R2VuZXJpY1R5cGVBbm5vdGF0aW9uID0gYXNzZXJ0R2VuZXJpY1R5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnRJbmZlcnJlZFByZWRpY2F0ZSA9IGFzc2VydEluZmVycmVkUHJlZGljYXRlO1xuZXhwb3J0cy5hc3NlcnRJbnRlcmZhY2VFeHRlbmRzID0gYXNzZXJ0SW50ZXJmYWNlRXh0ZW5kcztcbmV4cG9ydHMuYXNzZXJ0SW50ZXJmYWNlRGVjbGFyYXRpb24gPSBhc3NlcnRJbnRlcmZhY2VEZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0SW50ZXJmYWNlVHlwZUFubm90YXRpb24gPSBhc3NlcnRJbnRlcmZhY2VUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0SW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb24gPSBhc3NlcnRJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0TWl4ZWRUeXBlQW5ub3RhdGlvbiA9IGFzc2VydE1peGVkVHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydEVtcHR5VHlwZUFubm90YXRpb24gPSBhc3NlcnRFbXB0eVR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnROdWxsYWJsZVR5cGVBbm5vdGF0aW9uID0gYXNzZXJ0TnVsbGFibGVUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0TnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uID0gYXNzZXJ0TnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnROdW1iZXJUeXBlQW5ub3RhdGlvbiA9IGFzc2VydE51bWJlclR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnRPYmplY3RUeXBlQW5ub3RhdGlvbiA9IGFzc2VydE9iamVjdFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnRPYmplY3RUeXBlSW50ZXJuYWxTbG90ID0gYXNzZXJ0T2JqZWN0VHlwZUludGVybmFsU2xvdDtcbmV4cG9ydHMuYXNzZXJ0T2JqZWN0VHlwZUNhbGxQcm9wZXJ0eSA9IGFzc2VydE9iamVjdFR5cGVDYWxsUHJvcGVydHk7XG5leHBvcnRzLmFzc2VydE9iamVjdFR5cGVJbmRleGVyID0gYXNzZXJ0T2JqZWN0VHlwZUluZGV4ZXI7XG5leHBvcnRzLmFzc2VydE9iamVjdFR5cGVQcm9wZXJ0eSA9IGFzc2VydE9iamVjdFR5cGVQcm9wZXJ0eTtcbmV4cG9ydHMuYXNzZXJ0T2JqZWN0VHlwZVNwcmVhZFByb3BlcnR5ID0gYXNzZXJ0T2JqZWN0VHlwZVNwcmVhZFByb3BlcnR5O1xuZXhwb3J0cy5hc3NlcnRPcGFxdWVUeXBlID0gYXNzZXJ0T3BhcXVlVHlwZTtcbmV4cG9ydHMuYXNzZXJ0UXVhbGlmaWVkVHlwZUlkZW50aWZpZXIgPSBhc3NlcnRRdWFsaWZpZWRUeXBlSWRlbnRpZmllcjtcbmV4cG9ydHMuYXNzZXJ0U3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uID0gYXNzZXJ0U3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnRTdHJpbmdUeXBlQW5ub3RhdGlvbiA9IGFzc2VydFN0cmluZ1R5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnRTeW1ib2xUeXBlQW5ub3RhdGlvbiA9IGFzc2VydFN5bWJvbFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnRUaGlzVHlwZUFubm90YXRpb24gPSBhc3NlcnRUaGlzVHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydFR1cGxlVHlwZUFubm90YXRpb24gPSBhc3NlcnRUdXBsZVR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnRUeXBlb2ZUeXBlQW5ub3RhdGlvbiA9IGFzc2VydFR5cGVvZlR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnRUeXBlQWxpYXMgPSBhc3NlcnRUeXBlQWxpYXM7XG5leHBvcnRzLmFzc2VydFR5cGVBbm5vdGF0aW9uID0gYXNzZXJ0VHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydFR5cGVDYXN0RXhwcmVzc2lvbiA9IGFzc2VydFR5cGVDYXN0RXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0VHlwZVBhcmFtZXRlciA9IGFzc2VydFR5cGVQYXJhbWV0ZXI7XG5leHBvcnRzLmFzc2VydFR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbiA9IGFzc2VydFR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0VHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24gPSBhc3NlcnRUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0VW5pb25UeXBlQW5ub3RhdGlvbiA9IGFzc2VydFVuaW9uVHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydFZhcmlhbmNlID0gYXNzZXJ0VmFyaWFuY2U7XG5leHBvcnRzLmFzc2VydFZvaWRUeXBlQW5ub3RhdGlvbiA9IGFzc2VydFZvaWRUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0RW51bURlY2xhcmF0aW9uID0gYXNzZXJ0RW51bURlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnRFbnVtQm9vbGVhbkJvZHkgPSBhc3NlcnRFbnVtQm9vbGVhbkJvZHk7XG5leHBvcnRzLmFzc2VydEVudW1OdW1iZXJCb2R5ID0gYXNzZXJ0RW51bU51bWJlckJvZHk7XG5leHBvcnRzLmFzc2VydEVudW1TdHJpbmdCb2R5ID0gYXNzZXJ0RW51bVN0cmluZ0JvZHk7XG5leHBvcnRzLmFzc2VydEVudW1TeW1ib2xCb2R5ID0gYXNzZXJ0RW51bVN5bWJvbEJvZHk7XG5leHBvcnRzLmFzc2VydEVudW1Cb29sZWFuTWVtYmVyID0gYXNzZXJ0RW51bUJvb2xlYW5NZW1iZXI7XG5leHBvcnRzLmFzc2VydEVudW1OdW1iZXJNZW1iZXIgPSBhc3NlcnRFbnVtTnVtYmVyTWVtYmVyO1xuZXhwb3J0cy5hc3NlcnRFbnVtU3RyaW5nTWVtYmVyID0gYXNzZXJ0RW51bVN0cmluZ01lbWJlcjtcbmV4cG9ydHMuYXNzZXJ0RW51bURlZmF1bHRlZE1lbWJlciA9IGFzc2VydEVudW1EZWZhdWx0ZWRNZW1iZXI7XG5leHBvcnRzLmFzc2VydEpTWEF0dHJpYnV0ZSA9IGFzc2VydEpTWEF0dHJpYnV0ZTtcbmV4cG9ydHMuYXNzZXJ0SlNYQ2xvc2luZ0VsZW1lbnQgPSBhc3NlcnRKU1hDbG9zaW5nRWxlbWVudDtcbmV4cG9ydHMuYXNzZXJ0SlNYRWxlbWVudCA9IGFzc2VydEpTWEVsZW1lbnQ7XG5leHBvcnRzLmFzc2VydEpTWEVtcHR5RXhwcmVzc2lvbiA9IGFzc2VydEpTWEVtcHR5RXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0SlNYRXhwcmVzc2lvbkNvbnRhaW5lciA9IGFzc2VydEpTWEV4cHJlc3Npb25Db250YWluZXI7XG5leHBvcnRzLmFzc2VydEpTWFNwcmVhZENoaWxkID0gYXNzZXJ0SlNYU3ByZWFkQ2hpbGQ7XG5leHBvcnRzLmFzc2VydEpTWElkZW50aWZpZXIgPSBhc3NlcnRKU1hJZGVudGlmaWVyO1xuZXhwb3J0cy5hc3NlcnRKU1hNZW1iZXJFeHByZXNzaW9uID0gYXNzZXJ0SlNYTWVtYmVyRXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0SlNYTmFtZXNwYWNlZE5hbWUgPSBhc3NlcnRKU1hOYW1lc3BhY2VkTmFtZTtcbmV4cG9ydHMuYXNzZXJ0SlNYT3BlbmluZ0VsZW1lbnQgPSBhc3NlcnRKU1hPcGVuaW5nRWxlbWVudDtcbmV4cG9ydHMuYXNzZXJ0SlNYU3ByZWFkQXR0cmlidXRlID0gYXNzZXJ0SlNYU3ByZWFkQXR0cmlidXRlO1xuZXhwb3J0cy5hc3NlcnRKU1hUZXh0ID0gYXNzZXJ0SlNYVGV4dDtcbmV4cG9ydHMuYXNzZXJ0SlNYRnJhZ21lbnQgPSBhc3NlcnRKU1hGcmFnbWVudDtcbmV4cG9ydHMuYXNzZXJ0SlNYT3BlbmluZ0ZyYWdtZW50ID0gYXNzZXJ0SlNYT3BlbmluZ0ZyYWdtZW50O1xuZXhwb3J0cy5hc3NlcnRKU1hDbG9zaW5nRnJhZ21lbnQgPSBhc3NlcnRKU1hDbG9zaW5nRnJhZ21lbnQ7XG5leHBvcnRzLmFzc2VydE5vb3AgPSBhc3NlcnROb29wO1xuZXhwb3J0cy5hc3NlcnRQbGFjZWhvbGRlciA9IGFzc2VydFBsYWNlaG9sZGVyO1xuZXhwb3J0cy5hc3NlcnRWOEludHJpbnNpY0lkZW50aWZpZXIgPSBhc3NlcnRWOEludHJpbnNpY0lkZW50aWZpZXI7XG5leHBvcnRzLmFzc2VydEFyZ3VtZW50UGxhY2Vob2xkZXIgPSBhc3NlcnRBcmd1bWVudFBsYWNlaG9sZGVyO1xuZXhwb3J0cy5hc3NlcnRCaW5kRXhwcmVzc2lvbiA9IGFzc2VydEJpbmRFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRDbGFzc1Byb3BlcnR5ID0gYXNzZXJ0Q2xhc3NQcm9wZXJ0eTtcbmV4cG9ydHMuYXNzZXJ0UGlwZWxpbmVUb3BpY0V4cHJlc3Npb24gPSBhc3NlcnRQaXBlbGluZVRvcGljRXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0UGlwZWxpbmVCYXJlRnVuY3Rpb24gPSBhc3NlcnRQaXBlbGluZUJhcmVGdW5jdGlvbjtcbmV4cG9ydHMuYXNzZXJ0UGlwZWxpbmVQcmltYXJ5VG9waWNSZWZlcmVuY2UgPSBhc3NlcnRQaXBlbGluZVByaW1hcnlUb3BpY1JlZmVyZW5jZTtcbmV4cG9ydHMuYXNzZXJ0Q2xhc3NQcml2YXRlUHJvcGVydHkgPSBhc3NlcnRDbGFzc1ByaXZhdGVQcm9wZXJ0eTtcbmV4cG9ydHMuYXNzZXJ0Q2xhc3NQcml2YXRlTWV0aG9kID0gYXNzZXJ0Q2xhc3NQcml2YXRlTWV0aG9kO1xuZXhwb3J0cy5hc3NlcnRJbXBvcnRBdHRyaWJ1dGUgPSBhc3NlcnRJbXBvcnRBdHRyaWJ1dGU7XG5leHBvcnRzLmFzc2VydERlY29yYXRvciA9IGFzc2VydERlY29yYXRvcjtcbmV4cG9ydHMuYXNzZXJ0RG9FeHByZXNzaW9uID0gYXNzZXJ0RG9FeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRFeHBvcnREZWZhdWx0U3BlY2lmaWVyID0gYXNzZXJ0RXhwb3J0RGVmYXVsdFNwZWNpZmllcjtcbmV4cG9ydHMuYXNzZXJ0UHJpdmF0ZU5hbWUgPSBhc3NlcnRQcml2YXRlTmFtZTtcbmV4cG9ydHMuYXNzZXJ0UmVjb3JkRXhwcmVzc2lvbiA9IGFzc2VydFJlY29yZEV4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydFR1cGxlRXhwcmVzc2lvbiA9IGFzc2VydFR1cGxlRXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0RGVjaW1hbExpdGVyYWwgPSBhc3NlcnREZWNpbWFsTGl0ZXJhbDtcbmV4cG9ydHMuYXNzZXJ0VFNQYXJhbWV0ZXJQcm9wZXJ0eSA9IGFzc2VydFRTUGFyYW1ldGVyUHJvcGVydHk7XG5leHBvcnRzLmFzc2VydFRTRGVjbGFyZUZ1bmN0aW9uID0gYXNzZXJ0VFNEZWNsYXJlRnVuY3Rpb247XG5leHBvcnRzLmFzc2VydFRTRGVjbGFyZU1ldGhvZCA9IGFzc2VydFRTRGVjbGFyZU1ldGhvZDtcbmV4cG9ydHMuYXNzZXJ0VFNRdWFsaWZpZWROYW1lID0gYXNzZXJ0VFNRdWFsaWZpZWROYW1lO1xuZXhwb3J0cy5hc3NlcnRUU0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvbiA9IGFzc2VydFRTQ2FsbFNpZ25hdHVyZURlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnRUU0NvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uID0gYXNzZXJ0VFNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0VFNQcm9wZXJ0eVNpZ25hdHVyZSA9IGFzc2VydFRTUHJvcGVydHlTaWduYXR1cmU7XG5leHBvcnRzLmFzc2VydFRTTWV0aG9kU2lnbmF0dXJlID0gYXNzZXJ0VFNNZXRob2RTaWduYXR1cmU7XG5leHBvcnRzLmFzc2VydFRTSW5kZXhTaWduYXR1cmUgPSBhc3NlcnRUU0luZGV4U2lnbmF0dXJlO1xuZXhwb3J0cy5hc3NlcnRUU0FueUtleXdvcmQgPSBhc3NlcnRUU0FueUtleXdvcmQ7XG5leHBvcnRzLmFzc2VydFRTQm9vbGVhbktleXdvcmQgPSBhc3NlcnRUU0Jvb2xlYW5LZXl3b3JkO1xuZXhwb3J0cy5hc3NlcnRUU0JpZ0ludEtleXdvcmQgPSBhc3NlcnRUU0JpZ0ludEtleXdvcmQ7XG5leHBvcnRzLmFzc2VydFRTTmV2ZXJLZXl3b3JkID0gYXNzZXJ0VFNOZXZlcktleXdvcmQ7XG5leHBvcnRzLmFzc2VydFRTTnVsbEtleXdvcmQgPSBhc3NlcnRUU051bGxLZXl3b3JkO1xuZXhwb3J0cy5hc3NlcnRUU051bWJlcktleXdvcmQgPSBhc3NlcnRUU051bWJlcktleXdvcmQ7XG5leHBvcnRzLmFzc2VydFRTT2JqZWN0S2V5d29yZCA9IGFzc2VydFRTT2JqZWN0S2V5d29yZDtcbmV4cG9ydHMuYXNzZXJ0VFNTdHJpbmdLZXl3b3JkID0gYXNzZXJ0VFNTdHJpbmdLZXl3b3JkO1xuZXhwb3J0cy5hc3NlcnRUU1N5bWJvbEtleXdvcmQgPSBhc3NlcnRUU1N5bWJvbEtleXdvcmQ7XG5leHBvcnRzLmFzc2VydFRTVW5kZWZpbmVkS2V5d29yZCA9IGFzc2VydFRTVW5kZWZpbmVkS2V5d29yZDtcbmV4cG9ydHMuYXNzZXJ0VFNVbmtub3duS2V5d29yZCA9IGFzc2VydFRTVW5rbm93bktleXdvcmQ7XG5leHBvcnRzLmFzc2VydFRTVm9pZEtleXdvcmQgPSBhc3NlcnRUU1ZvaWRLZXl3b3JkO1xuZXhwb3J0cy5hc3NlcnRUU1RoaXNUeXBlID0gYXNzZXJ0VFNUaGlzVHlwZTtcbmV4cG9ydHMuYXNzZXJ0VFNGdW5jdGlvblR5cGUgPSBhc3NlcnRUU0Z1bmN0aW9uVHlwZTtcbmV4cG9ydHMuYXNzZXJ0VFNDb25zdHJ1Y3RvclR5cGUgPSBhc3NlcnRUU0NvbnN0cnVjdG9yVHlwZTtcbmV4cG9ydHMuYXNzZXJ0VFNUeXBlUmVmZXJlbmNlID0gYXNzZXJ0VFNUeXBlUmVmZXJlbmNlO1xuZXhwb3J0cy5hc3NlcnRUU1R5cGVQcmVkaWNhdGUgPSBhc3NlcnRUU1R5cGVQcmVkaWNhdGU7XG5leHBvcnRzLmFzc2VydFRTVHlwZVF1ZXJ5ID0gYXNzZXJ0VFNUeXBlUXVlcnk7XG5leHBvcnRzLmFzc2VydFRTVHlwZUxpdGVyYWwgPSBhc3NlcnRUU1R5cGVMaXRlcmFsO1xuZXhwb3J0cy5hc3NlcnRUU0FycmF5VHlwZSA9IGFzc2VydFRTQXJyYXlUeXBlO1xuZXhwb3J0cy5hc3NlcnRUU1R1cGxlVHlwZSA9IGFzc2VydFRTVHVwbGVUeXBlO1xuZXhwb3J0cy5hc3NlcnRUU09wdGlvbmFsVHlwZSA9IGFzc2VydFRTT3B0aW9uYWxUeXBlO1xuZXhwb3J0cy5hc3NlcnRUU1Jlc3RUeXBlID0gYXNzZXJ0VFNSZXN0VHlwZTtcbmV4cG9ydHMuYXNzZXJ0VFNOYW1lZFR1cGxlTWVtYmVyID0gYXNzZXJ0VFNOYW1lZFR1cGxlTWVtYmVyO1xuZXhwb3J0cy5hc3NlcnRUU1VuaW9uVHlwZSA9IGFzc2VydFRTVW5pb25UeXBlO1xuZXhwb3J0cy5hc3NlcnRUU0ludGVyc2VjdGlvblR5cGUgPSBhc3NlcnRUU0ludGVyc2VjdGlvblR5cGU7XG5leHBvcnRzLmFzc2VydFRTQ29uZGl0aW9uYWxUeXBlID0gYXNzZXJ0VFNDb25kaXRpb25hbFR5cGU7XG5leHBvcnRzLmFzc2VydFRTSW5mZXJUeXBlID0gYXNzZXJ0VFNJbmZlclR5cGU7XG5leHBvcnRzLmFzc2VydFRTUGFyZW50aGVzaXplZFR5cGUgPSBhc3NlcnRUU1BhcmVudGhlc2l6ZWRUeXBlO1xuZXhwb3J0cy5hc3NlcnRUU1R5cGVPcGVyYXRvciA9IGFzc2VydFRTVHlwZU9wZXJhdG9yO1xuZXhwb3J0cy5hc3NlcnRUU0luZGV4ZWRBY2Nlc3NUeXBlID0gYXNzZXJ0VFNJbmRleGVkQWNjZXNzVHlwZTtcbmV4cG9ydHMuYXNzZXJ0VFNNYXBwZWRUeXBlID0gYXNzZXJ0VFNNYXBwZWRUeXBlO1xuZXhwb3J0cy5hc3NlcnRUU0xpdGVyYWxUeXBlID0gYXNzZXJ0VFNMaXRlcmFsVHlwZTtcbmV4cG9ydHMuYXNzZXJ0VFNFeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHMgPSBhc3NlcnRUU0V4cHJlc3Npb25XaXRoVHlwZUFyZ3VtZW50cztcbmV4cG9ydHMuYXNzZXJ0VFNJbnRlcmZhY2VEZWNsYXJhdGlvbiA9IGFzc2VydFRTSW50ZXJmYWNlRGVjbGFyYXRpb247XG5leHBvcnRzLmFzc2VydFRTSW50ZXJmYWNlQm9keSA9IGFzc2VydFRTSW50ZXJmYWNlQm9keTtcbmV4cG9ydHMuYXNzZXJ0VFNUeXBlQWxpYXNEZWNsYXJhdGlvbiA9IGFzc2VydFRTVHlwZUFsaWFzRGVjbGFyYXRpb247XG5leHBvcnRzLmFzc2VydFRTQXNFeHByZXNzaW9uID0gYXNzZXJ0VFNBc0V4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydFRTVHlwZUFzc2VydGlvbiA9IGFzc2VydFRTVHlwZUFzc2VydGlvbjtcbmV4cG9ydHMuYXNzZXJ0VFNFbnVtRGVjbGFyYXRpb24gPSBhc3NlcnRUU0VudW1EZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0VFNFbnVtTWVtYmVyID0gYXNzZXJ0VFNFbnVtTWVtYmVyO1xuZXhwb3J0cy5hc3NlcnRUU01vZHVsZURlY2xhcmF0aW9uID0gYXNzZXJ0VFNNb2R1bGVEZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0VFNNb2R1bGVCbG9jayA9IGFzc2VydFRTTW9kdWxlQmxvY2s7XG5leHBvcnRzLmFzc2VydFRTSW1wb3J0VHlwZSA9IGFzc2VydFRTSW1wb3J0VHlwZTtcbmV4cG9ydHMuYXNzZXJ0VFNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvbiA9IGFzc2VydFRTSW1wb3J0RXF1YWxzRGVjbGFyYXRpb247XG5leHBvcnRzLmFzc2VydFRTRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2UgPSBhc3NlcnRUU0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlO1xuZXhwb3J0cy5hc3NlcnRUU05vbk51bGxFeHByZXNzaW9uID0gYXNzZXJ0VFNOb25OdWxsRXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0VFNFeHBvcnRBc3NpZ25tZW50ID0gYXNzZXJ0VFNFeHBvcnRBc3NpZ25tZW50O1xuZXhwb3J0cy5hc3NlcnRUU05hbWVzcGFjZUV4cG9ydERlY2xhcmF0aW9uID0gYXNzZXJ0VFNOYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0VFNUeXBlQW5ub3RhdGlvbiA9IGFzc2VydFRTVHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydFRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24gPSBhc3NlcnRUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uO1xuZXhwb3J0cy5hc3NlcnRUU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbiA9IGFzc2VydFRTVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnRUU1R5cGVQYXJhbWV0ZXIgPSBhc3NlcnRUU1R5cGVQYXJhbWV0ZXI7XG5leHBvcnRzLmFzc2VydEV4cHJlc3Npb24gPSBhc3NlcnRFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRCaW5hcnkgPSBhc3NlcnRCaW5hcnk7XG5leHBvcnRzLmFzc2VydFNjb3BhYmxlID0gYXNzZXJ0U2NvcGFibGU7XG5leHBvcnRzLmFzc2VydEJsb2NrUGFyZW50ID0gYXNzZXJ0QmxvY2tQYXJlbnQ7XG5leHBvcnRzLmFzc2VydEJsb2NrID0gYXNzZXJ0QmxvY2s7XG5leHBvcnRzLmFzc2VydFN0YXRlbWVudCA9IGFzc2VydFN0YXRlbWVudDtcbmV4cG9ydHMuYXNzZXJ0VGVybWluYXRvcmxlc3MgPSBhc3NlcnRUZXJtaW5hdG9ybGVzcztcbmV4cG9ydHMuYXNzZXJ0Q29tcGxldGlvblN0YXRlbWVudCA9IGFzc2VydENvbXBsZXRpb25TdGF0ZW1lbnQ7XG5leHBvcnRzLmFzc2VydENvbmRpdGlvbmFsID0gYXNzZXJ0Q29uZGl0aW9uYWw7XG5leHBvcnRzLmFzc2VydExvb3AgPSBhc3NlcnRMb29wO1xuZXhwb3J0cy5hc3NlcnRXaGlsZSA9IGFzc2VydFdoaWxlO1xuZXhwb3J0cy5hc3NlcnRFeHByZXNzaW9uV3JhcHBlciA9IGFzc2VydEV4cHJlc3Npb25XcmFwcGVyO1xuZXhwb3J0cy5hc3NlcnRGb3IgPSBhc3NlcnRGb3I7XG5leHBvcnRzLmFzc2VydEZvclhTdGF0ZW1lbnQgPSBhc3NlcnRGb3JYU3RhdGVtZW50O1xuZXhwb3J0cy5hc3NlcnRGdW5jdGlvbiA9IGFzc2VydEZ1bmN0aW9uO1xuZXhwb3J0cy5hc3NlcnRGdW5jdGlvblBhcmVudCA9IGFzc2VydEZ1bmN0aW9uUGFyZW50O1xuZXhwb3J0cy5hc3NlcnRQdXJlaXNoID0gYXNzZXJ0UHVyZWlzaDtcbmV4cG9ydHMuYXNzZXJ0RGVjbGFyYXRpb24gPSBhc3NlcnREZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0UGF0dGVybkxpa2UgPSBhc3NlcnRQYXR0ZXJuTGlrZTtcbmV4cG9ydHMuYXNzZXJ0TFZhbCA9IGFzc2VydExWYWw7XG5leHBvcnRzLmFzc2VydFRTRW50aXR5TmFtZSA9IGFzc2VydFRTRW50aXR5TmFtZTtcbmV4cG9ydHMuYXNzZXJ0TGl0ZXJhbCA9IGFzc2VydExpdGVyYWw7XG5leHBvcnRzLmFzc2VydEltbXV0YWJsZSA9IGFzc2VydEltbXV0YWJsZTtcbmV4cG9ydHMuYXNzZXJ0VXNlcldoaXRlc3BhY2FibGUgPSBhc3NlcnRVc2VyV2hpdGVzcGFjYWJsZTtcbmV4cG9ydHMuYXNzZXJ0TWV0aG9kID0gYXNzZXJ0TWV0aG9kO1xuZXhwb3J0cy5hc3NlcnRPYmplY3RNZW1iZXIgPSBhc3NlcnRPYmplY3RNZW1iZXI7XG5leHBvcnRzLmFzc2VydFByb3BlcnR5ID0gYXNzZXJ0UHJvcGVydHk7XG5leHBvcnRzLmFzc2VydFVuYXJ5TGlrZSA9IGFzc2VydFVuYXJ5TGlrZTtcbmV4cG9ydHMuYXNzZXJ0UGF0dGVybiA9IGFzc2VydFBhdHRlcm47XG5leHBvcnRzLmFzc2VydENsYXNzID0gYXNzZXJ0Q2xhc3M7XG5leHBvcnRzLmFzc2VydE1vZHVsZURlY2xhcmF0aW9uID0gYXNzZXJ0TW9kdWxlRGVjbGFyYXRpb247XG5leHBvcnRzLmFzc2VydEV4cG9ydERlY2xhcmF0aW9uID0gYXNzZXJ0RXhwb3J0RGVjbGFyYXRpb247XG5leHBvcnRzLmFzc2VydE1vZHVsZVNwZWNpZmllciA9IGFzc2VydE1vZHVsZVNwZWNpZmllcjtcbmV4cG9ydHMuYXNzZXJ0RmxvdyA9IGFzc2VydEZsb3c7XG5leHBvcnRzLmFzc2VydEZsb3dUeXBlID0gYXNzZXJ0Rmxvd1R5cGU7XG5leHBvcnRzLmFzc2VydEZsb3dCYXNlQW5ub3RhdGlvbiA9IGFzc2VydEZsb3dCYXNlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0Rmxvd0RlY2xhcmF0aW9uID0gYXNzZXJ0Rmxvd0RlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnRGbG93UHJlZGljYXRlID0gYXNzZXJ0Rmxvd1ByZWRpY2F0ZTtcbmV4cG9ydHMuYXNzZXJ0RW51bUJvZHkgPSBhc3NlcnRFbnVtQm9keTtcbmV4cG9ydHMuYXNzZXJ0RW51bU1lbWJlciA9IGFzc2VydEVudW1NZW1iZXI7XG5leHBvcnRzLmFzc2VydEpTWCA9IGFzc2VydEpTWDtcbmV4cG9ydHMuYXNzZXJ0UHJpdmF0ZSA9IGFzc2VydFByaXZhdGU7XG5leHBvcnRzLmFzc2VydFRTVHlwZUVsZW1lbnQgPSBhc3NlcnRUU1R5cGVFbGVtZW50O1xuZXhwb3J0cy5hc3NlcnRUU1R5cGUgPSBhc3NlcnRUU1R5cGU7XG5leHBvcnRzLmFzc2VydFRTQmFzZVR5cGUgPSBhc3NlcnRUU0Jhc2VUeXBlO1xuZXhwb3J0cy5hc3NlcnROdW1iZXJMaXRlcmFsID0gYXNzZXJ0TnVtYmVyTGl0ZXJhbDtcbmV4cG9ydHMuYXNzZXJ0UmVnZXhMaXRlcmFsID0gYXNzZXJ0UmVnZXhMaXRlcmFsO1xuZXhwb3J0cy5hc3NlcnRSZXN0UHJvcGVydHkgPSBhc3NlcnRSZXN0UHJvcGVydHk7XG5leHBvcnRzLmFzc2VydFNwcmVhZFByb3BlcnR5ID0gYXNzZXJ0U3ByZWFkUHJvcGVydHk7XG5cbnZhciBfaXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi92YWxpZGF0b3JzL2lzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gYXNzZXJ0KHR5cGUsIG5vZGUsIG9wdHMpIHtcbiAgaWYgKCEoMCwgX2lzLmRlZmF1bHQpKHR5cGUsIG5vZGUsIG9wdHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCB0eXBlIFwiJHt0eXBlfVwiIHdpdGggb3B0aW9uICR7SlNPTi5zdHJpbmdpZnkob3B0cyl9LCBgICsgYGJ1dCBpbnN0ZWFkIGdvdCBcIiR7bm9kZS50eXBlfVwiLmApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydEFycmF5RXhwcmVzc2lvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiQXJyYXlFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRBc3NpZ25tZW50RXhwcmVzc2lvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiQXNzaWdubWVudEV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEJpbmFyeUV4cHJlc3Npb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkJpbmFyeUV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEludGVycHJldGVyRGlyZWN0aXZlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJJbnRlcnByZXRlckRpcmVjdGl2ZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RGlyZWN0aXZlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJEaXJlY3RpdmVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydERpcmVjdGl2ZUxpdGVyYWwobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkRpcmVjdGl2ZUxpdGVyYWxcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEJsb2NrU3RhdGVtZW50KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJCbG9ja1N0YXRlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0QnJlYWtTdGF0ZW1lbnQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkJyZWFrU3RhdGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRDYWxsRXhwcmVzc2lvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiQ2FsbEV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydENhdGNoQ2xhdXNlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJDYXRjaENsYXVzZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Q29uZGl0aW9uYWxFeHByZXNzaW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydENvbnRpbnVlU3RhdGVtZW50KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJDb250aW51ZVN0YXRlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RGVidWdnZXJTdGF0ZW1lbnQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkRlYnVnZ2VyU3RhdGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnREb1doaWxlU3RhdGVtZW50KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJEb1doaWxlU3RhdGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRFbXB0eVN0YXRlbWVudChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRW1wdHlTdGF0ZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEZpbGUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkZpbGVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEZvckluU3RhdGVtZW50KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJGb3JJblN0YXRlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Rm9yU3RhdGVtZW50KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJGb3JTdGF0ZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEZ1bmN0aW9uRGVjbGFyYXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEZ1bmN0aW9uRXhwcmVzc2lvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRnVuY3Rpb25FeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRJZGVudGlmaWVyKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJJZGVudGlmaWVyXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRJZlN0YXRlbWVudChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiSWZTdGF0ZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydExhYmVsZWRTdGF0ZW1lbnQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkxhYmVsZWRTdGF0ZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFN0cmluZ0xpdGVyYWwobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlN0cmluZ0xpdGVyYWxcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE51bWVyaWNMaXRlcmFsKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJOdW1lcmljTGl0ZXJhbFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0TnVsbExpdGVyYWwobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIk51bGxMaXRlcmFsXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRCb29sZWFuTGl0ZXJhbChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiQm9vbGVhbkxpdGVyYWxcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFJlZ0V4cExpdGVyYWwobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlJlZ0V4cExpdGVyYWxcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydExvZ2ljYWxFeHByZXNzaW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJMb2dpY2FsRXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0TWVtYmVyRXhwcmVzc2lvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiTWVtYmVyRXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0TmV3RXhwcmVzc2lvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiTmV3RXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0UHJvZ3JhbShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiUHJvZ3JhbVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0RXhwcmVzc2lvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiT2JqZWN0RXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0TWV0aG9kKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJPYmplY3RNZXRob2RcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE9iamVjdFByb3BlcnR5KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJPYmplY3RQcm9wZXJ0eVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0UmVzdEVsZW1lbnQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlJlc3RFbGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRSZXR1cm5TdGF0ZW1lbnQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlJldHVyblN0YXRlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2VxdWVuY2VFeHByZXNzaW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJTZXF1ZW5jZUV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0U3dpdGNoQ2FzZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiU3dpdGNoQ2FzZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0U3dpdGNoU3RhdGVtZW50KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJTd2l0Y2hTdGF0ZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRoaXNFeHByZXNzaW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUaGlzRXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VGhyb3dTdGF0ZW1lbnQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRocm93U3RhdGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUcnlTdGF0ZW1lbnQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRyeVN0YXRlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VW5hcnlFeHByZXNzaW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJVbmFyeUV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFVwZGF0ZUV4cHJlc3Npb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlVwZGF0ZUV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFZhcmlhYmxlRGVjbGFyYXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlZhcmlhYmxlRGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFZhcmlhYmxlRGVjbGFyYXRvcihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVmFyaWFibGVEZWNsYXJhdG9yXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRXaGlsZVN0YXRlbWVudChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiV2hpbGVTdGF0ZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFdpdGhTdGF0ZW1lbnQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIldpdGhTdGF0ZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEFzc2lnbm1lbnRQYXR0ZXJuKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJBc3NpZ25tZW50UGF0dGVyblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0QXJyYXlQYXR0ZXJuKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJBcnJheVBhdHRlcm5cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEFycm93RnVuY3Rpb25FeHByZXNzaW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Q2xhc3NCb2R5KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJDbGFzc0JvZHlcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydENsYXNzRXhwcmVzc2lvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiQ2xhc3NFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRDbGFzc0RlY2xhcmF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJDbGFzc0RlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRFeHBvcnRBbGxEZWNsYXJhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRFeHBvcnROYW1lZERlY2xhcmF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRFeHBvcnRTcGVjaWZpZXIobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkV4cG9ydFNwZWNpZmllclwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Rm9yT2ZTdGF0ZW1lbnQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkZvck9mU3RhdGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRJbXBvcnREZWNsYXJhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiSW1wb3J0RGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEltcG9ydERlZmF1bHRTcGVjaWZpZXIobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEltcG9ydE5hbWVzcGFjZVNwZWNpZmllcihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRJbXBvcnRTcGVjaWZpZXIobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkltcG9ydFNwZWNpZmllclwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0TWV0YVByb3BlcnR5KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJNZXRhUHJvcGVydHlcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydENsYXNzTWV0aG9kKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJDbGFzc01ldGhvZFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0UGF0dGVybihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiT2JqZWN0UGF0dGVyblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0U3ByZWFkRWxlbWVudChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiU3ByZWFkRWxlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0U3VwZXIobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlN1cGVyXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VGVtcGxhdGVFbGVtZW50KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUZW1wbGF0ZUVsZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRlbXBsYXRlTGl0ZXJhbChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVGVtcGxhdGVMaXRlcmFsXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRZaWVsZEV4cHJlc3Npb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIllpZWxkRXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0QXdhaXRFeHByZXNzaW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJBd2FpdEV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEltcG9ydChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiSW1wb3J0XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRCaWdJbnRMaXRlcmFsKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJCaWdJbnRMaXRlcmFsXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXIobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkV4cG9ydE5hbWVzcGFjZVNwZWNpZmllclwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0T3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE9wdGlvbmFsQ2FsbEV4cHJlc3Npb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEFueVR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJBbnlUeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0QXJyYXlUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiQXJyYXlUeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Qm9vbGVhblR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJCb29sZWFuVHlwZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEJvb2xlYW5MaXRlcmFsVHlwZUFubm90YXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkJvb2xlYW5MaXRlcmFsVHlwZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE51bGxMaXRlcmFsVHlwZUFubm90YXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIk51bGxMaXRlcmFsVHlwZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydENsYXNzSW1wbGVtZW50cyhub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiQ2xhc3NJbXBsZW1lbnRzXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnREZWNsYXJlQ2xhc3Mobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkRlY2xhcmVDbGFzc1wiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RGVjbGFyZUZ1bmN0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJEZWNsYXJlRnVuY3Rpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydERlY2xhcmVJbnRlcmZhY2Uobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkRlY2xhcmVJbnRlcmZhY2VcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydERlY2xhcmVNb2R1bGUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkRlY2xhcmVNb2R1bGVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydERlY2xhcmVNb2R1bGVFeHBvcnRzKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJEZWNsYXJlTW9kdWxlRXhwb3J0c1wiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RGVjbGFyZVR5cGVBbGlhcyhub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRGVjbGFyZVR5cGVBbGlhc1wiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RGVjbGFyZU9wYXF1ZVR5cGUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkRlY2xhcmVPcGFxdWVUeXBlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnREZWNsYXJlVmFyaWFibGUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkRlY2xhcmVWYXJpYWJsZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydERlY2xhcmVFeHBvcnRBbGxEZWNsYXJhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnREZWNsYXJlZFByZWRpY2F0ZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRGVjbGFyZWRQcmVkaWNhdGVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEV4aXN0c1R5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJFeGlzdHNUeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RnVuY3Rpb25UeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RnVuY3Rpb25UeXBlUGFyYW0obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkZ1bmN0aW9uVHlwZVBhcmFtXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRHZW5lcmljVHlwZUFubm90YXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkdlbmVyaWNUeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SW5mZXJyZWRQcmVkaWNhdGUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkluZmVycmVkUHJlZGljYXRlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRJbnRlcmZhY2VFeHRlbmRzKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJJbnRlcmZhY2VFeHRlbmRzXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRJbnRlcmZhY2VEZWNsYXJhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiSW50ZXJmYWNlRGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEludGVyZmFjZVR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJJbnRlcmZhY2VUeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkludGVyc2VjdGlvblR5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRNaXhlZFR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJNaXhlZFR5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRFbXB0eVR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJFbXB0eVR5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnROdWxsYWJsZVR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJOdWxsYWJsZVR5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnROdW1iZXJMaXRlcmFsVHlwZUFubm90YXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIk51bWJlckxpdGVyYWxUeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0TnVtYmVyVHlwZUFubm90YXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIk51bWJlclR5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRPYmplY3RUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiT2JqZWN0VHlwZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE9iamVjdFR5cGVJbnRlcm5hbFNsb3Qobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIk9iamVjdFR5cGVJbnRlcm5hbFNsb3RcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE9iamVjdFR5cGVDYWxsUHJvcGVydHkobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIk9iamVjdFR5cGVDYWxsUHJvcGVydHlcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE9iamVjdFR5cGVJbmRleGVyKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJPYmplY3RUeXBlSW5kZXhlclwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0VHlwZVByb3BlcnR5KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJPYmplY3RUeXBlUHJvcGVydHlcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiT2JqZWN0VHlwZVNwcmVhZFByb3BlcnR5XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRPcGFxdWVUeXBlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJPcGFxdWVUeXBlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRRdWFsaWZpZWRUeXBlSWRlbnRpZmllcihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiUXVhbGlmaWVkVHlwZUlkZW50aWZpZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFN0cmluZ0xpdGVyYWxUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiU3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRTdHJpbmdUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiU3RyaW5nVHlwZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFN5bWJvbFR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJTeW1ib2xUeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VGhpc1R5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUaGlzVHlwZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFR1cGxlVHlwZUFubm90YXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlR1cGxlVHlwZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFR5cGVvZlR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUeXBlb2ZUeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VHlwZUFsaWFzKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUeXBlQWxpYXNcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VHlwZUNhc3RFeHByZXNzaW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUeXBlQ2FzdEV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFR5cGVQYXJhbWV0ZXIobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlR5cGVQYXJhbWV0ZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFVuaW9uVHlwZUFubm90YXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlVuaW9uVHlwZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFZhcmlhbmNlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJWYXJpYW5jZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Vm9pZFR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJWb2lkVHlwZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEVudW1EZWNsYXJhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRW51bURlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRFbnVtQm9vbGVhbkJvZHkobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkVudW1Cb29sZWFuQm9keVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RW51bU51bWJlckJvZHkobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkVudW1OdW1iZXJCb2R5XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRFbnVtU3RyaW5nQm9keShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRW51bVN0cmluZ0JvZHlcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEVudW1TeW1ib2xCb2R5KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJFbnVtU3ltYm9sQm9keVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RW51bUJvb2xlYW5NZW1iZXIobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkVudW1Cb29sZWFuTWVtYmVyXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRFbnVtTnVtYmVyTWVtYmVyKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJFbnVtTnVtYmVyTWVtYmVyXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRFbnVtU3RyaW5nTWVtYmVyKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJFbnVtU3RyaW5nTWVtYmVyXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRFbnVtRGVmYXVsdGVkTWVtYmVyKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJFbnVtRGVmYXVsdGVkTWVtYmVyXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRKU1hBdHRyaWJ1dGUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkpTWEF0dHJpYnV0ZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SlNYQ2xvc2luZ0VsZW1lbnQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkpTWENsb3NpbmdFbGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRKU1hFbGVtZW50KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJKU1hFbGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRKU1hFbXB0eUV4cHJlc3Npb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkpTWEVtcHR5RXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SlNYRXhwcmVzc2lvbkNvbnRhaW5lcihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SlNYU3ByZWFkQ2hpbGQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkpTWFNwcmVhZENoaWxkXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRKU1hJZGVudGlmaWVyKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJKU1hJZGVudGlmaWVyXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRKU1hNZW1iZXJFeHByZXNzaW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJKU1hNZW1iZXJFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRKU1hOYW1lc3BhY2VkTmFtZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiSlNYTmFtZXNwYWNlZE5hbWVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEpTWE9wZW5pbmdFbGVtZW50KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJKU1hPcGVuaW5nRWxlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SlNYU3ByZWFkQXR0cmlidXRlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJKU1hTcHJlYWRBdHRyaWJ1dGVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEpTWFRleHQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkpTWFRleHRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEpTWEZyYWdtZW50KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJKU1hGcmFnbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SlNYT3BlbmluZ0ZyYWdtZW50KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJKU1hPcGVuaW5nRnJhZ21lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEpTWENsb3NpbmdGcmFnbWVudChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiSlNYQ2xvc2luZ0ZyYWdtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnROb29wKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJOb29wXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRQbGFjZWhvbGRlcihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiUGxhY2Vob2xkZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFY4SW50cmluc2ljSWRlbnRpZmllcihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVjhJbnRyaW5zaWNJZGVudGlmaWVyXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRBcmd1bWVudFBsYWNlaG9sZGVyKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJBcmd1bWVudFBsYWNlaG9sZGVyXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRCaW5kRXhwcmVzc2lvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiQmluZEV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydENsYXNzUHJvcGVydHkobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkNsYXNzUHJvcGVydHlcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFBpcGVsaW5lVG9waWNFeHByZXNzaW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJQaXBlbGluZVRvcGljRXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0UGlwZWxpbmVCYXJlRnVuY3Rpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlBpcGVsaW5lQmFyZUZ1bmN0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRQaXBlbGluZVByaW1hcnlUb3BpY1JlZmVyZW5jZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiUGlwZWxpbmVQcmltYXJ5VG9waWNSZWZlcmVuY2VcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydENsYXNzUHJpdmF0ZVByb3BlcnR5KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJDbGFzc1ByaXZhdGVQcm9wZXJ0eVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Q2xhc3NQcml2YXRlTWV0aG9kKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJDbGFzc1ByaXZhdGVNZXRob2RcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEltcG9ydEF0dHJpYnV0ZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiSW1wb3J0QXR0cmlidXRlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnREZWNvcmF0b3Iobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkRlY29yYXRvclwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RG9FeHByZXNzaW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJEb0V4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEV4cG9ydERlZmF1bHRTcGVjaWZpZXIobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkV4cG9ydERlZmF1bHRTcGVjaWZpZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFByaXZhdGVOYW1lKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJQcml2YXRlTmFtZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0UmVjb3JkRXhwcmVzc2lvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiUmVjb3JkRXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VHVwbGVFeHByZXNzaW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUdXBsZUV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydERlY2ltYWxMaXRlcmFsKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJEZWNpbWFsTGl0ZXJhbFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNQYXJhbWV0ZXJQcm9wZXJ0eShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNQYXJhbWV0ZXJQcm9wZXJ0eVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNEZWNsYXJlRnVuY3Rpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTRGVjbGFyZUZ1bmN0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU0RlY2xhcmVNZXRob2Qobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTRGVjbGFyZU1ldGhvZFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNRdWFsaWZpZWROYW1lKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU1F1YWxpZmllZE5hbWVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTQ2FsbFNpZ25hdHVyZURlY2xhcmF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNQcm9wZXJ0eVNpZ25hdHVyZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNQcm9wZXJ0eVNpZ25hdHVyZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNNZXRob2RTaWduYXR1cmUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTTWV0aG9kU2lnbmF0dXJlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU0luZGV4U2lnbmF0dXJlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU0luZGV4U2lnbmF0dXJlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU0FueUtleXdvcmQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTQW55S2V5d29yZFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNCb29sZWFuS2V5d29yZChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNCb29sZWFuS2V5d29yZFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNCaWdJbnRLZXl3b3JkKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU0JpZ0ludEtleXdvcmRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTTmV2ZXJLZXl3b3JkKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU05ldmVyS2V5d29yZFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNOdWxsS2V5d29yZChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNOdWxsS2V5d29yZFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNOdW1iZXJLZXl3b3JkKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU051bWJlcktleXdvcmRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTT2JqZWN0S2V5d29yZChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNPYmplY3RLZXl3b3JkXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU1N0cmluZ0tleXdvcmQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTU3RyaW5nS2V5d29yZFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNTeW1ib2xLZXl3b3JkKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU1N5bWJvbEtleXdvcmRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTVW5kZWZpbmVkS2V5d29yZChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNVbmRlZmluZWRLZXl3b3JkXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU1Vua25vd25LZXl3b3JkKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU1Vua25vd25LZXl3b3JkXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU1ZvaWRLZXl3b3JkKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU1ZvaWRLZXl3b3JkXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU1RoaXNUeXBlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU1RoaXNUeXBlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU0Z1bmN0aW9uVHlwZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNGdW5jdGlvblR5cGVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTQ29uc3RydWN0b3JUeXBlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU0NvbnN0cnVjdG9yVHlwZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNUeXBlUmVmZXJlbmNlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU1R5cGVSZWZlcmVuY2VcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTVHlwZVByZWRpY2F0ZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNUeXBlUHJlZGljYXRlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU1R5cGVRdWVyeShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNUeXBlUXVlcnlcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTVHlwZUxpdGVyYWwobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTVHlwZUxpdGVyYWxcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTQXJyYXlUeXBlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU0FycmF5VHlwZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNUdXBsZVR5cGUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTVHVwbGVUeXBlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU09wdGlvbmFsVHlwZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNPcHRpb25hbFR5cGVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTUmVzdFR5cGUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTUmVzdFR5cGVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTTmFtZWRUdXBsZU1lbWJlcihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNOYW1lZFR1cGxlTWVtYmVyXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU1VuaW9uVHlwZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNVbmlvblR5cGVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTSW50ZXJzZWN0aW9uVHlwZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNJbnRlcnNlY3Rpb25UeXBlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU0NvbmRpdGlvbmFsVHlwZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNDb25kaXRpb25hbFR5cGVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTSW5mZXJUeXBlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU0luZmVyVHlwZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNQYXJlbnRoZXNpemVkVHlwZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNQYXJlbnRoZXNpemVkVHlwZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNUeXBlT3BlcmF0b3Iobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTVHlwZU9wZXJhdG9yXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU0luZGV4ZWRBY2Nlc3NUeXBlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU0luZGV4ZWRBY2Nlc3NUeXBlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU01hcHBlZFR5cGUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTTWFwcGVkVHlwZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNMaXRlcmFsVHlwZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNMaXRlcmFsVHlwZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNFeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHMobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU0ludGVyZmFjZURlY2xhcmF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU0ludGVyZmFjZURlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU0ludGVyZmFjZUJvZHkobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTSW50ZXJmYWNlQm9keVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNUeXBlQWxpYXNEZWNsYXJhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNUeXBlQWxpYXNEZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNBc0V4cHJlc3Npb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTQXNFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU1R5cGVBc3NlcnRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTVHlwZUFzc2VydGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNFbnVtRGVjbGFyYXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTRW51bURlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU0VudW1NZW1iZXIobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTRW51bU1lbWJlclwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNNb2R1bGVEZWNsYXJhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNNb2R1bGVEZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNNb2R1bGVCbG9jayhub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNNb2R1bGVCbG9ja1wiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNJbXBvcnRUeXBlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU0ltcG9ydFR5cGVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTSW1wb3J0RXF1YWxzRGVjbGFyYXRpb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTSW1wb3J0RXF1YWxzRGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2Uobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2VcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTTm9uTnVsbEV4cHJlc3Npb24obm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTTm9uTnVsbEV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTRXhwb3J0QXNzaWdubWVudChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNFeHBvcnRBc3NpZ25tZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU05hbWVzcGFjZUV4cG9ydERlY2xhcmF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU05hbWVzcGFjZUV4cG9ydERlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU1R5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU1R5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRTVHlwZVBhcmFtZXRlcihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNUeXBlUGFyYW1ldGVyXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRFeHByZXNzaW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRCaW5hcnkobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkJpbmFyeVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2NvcGFibGUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlNjb3BhYmxlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRCbG9ja1BhcmVudChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiQmxvY2tQYXJlbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEJsb2NrKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJCbG9ja1wiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0U3RhdGVtZW50KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJTdGF0ZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFRlcm1pbmF0b3JsZXNzKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUZXJtaW5hdG9ybGVzc1wiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Q29tcGxldGlvblN0YXRlbWVudChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiQ29tcGxldGlvblN0YXRlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Q29uZGl0aW9uYWwobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkNvbmRpdGlvbmFsXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRMb29wKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJMb29wXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRXaGlsZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiV2hpbGVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEV4cHJlc3Npb25XcmFwcGVyKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJFeHByZXNzaW9uV3JhcHBlclwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Rm9yKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJGb3JcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEZvclhTdGF0ZW1lbnQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkZvclhTdGF0ZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEZ1bmN0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJGdW5jdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0RnVuY3Rpb25QYXJlbnQobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkZ1bmN0aW9uUGFyZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRQdXJlaXNoKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJQdXJlaXNoXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnREZWNsYXJhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFBhdHRlcm5MaWtlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJQYXR0ZXJuTGlrZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0TFZhbChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiTFZhbFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNFbnRpdHlOYW1lKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU0VudGl0eU5hbWVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydExpdGVyYWwobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkxpdGVyYWxcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEltbXV0YWJsZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiSW1tdXRhYmxlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRVc2VyV2hpdGVzcGFjYWJsZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVXNlcldoaXRlc3BhY2FibGVcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydE1ldGhvZChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiTWV0aG9kXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRPYmplY3RNZW1iZXIobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIk9iamVjdE1lbWJlclwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0UHJvcGVydHkobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlByb3BlcnR5XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRVbmFyeUxpa2Uobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlVuYXJ5TGlrZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0UGF0dGVybihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiUGF0dGVyblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Q2xhc3Mobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkNsYXNzXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRNb2R1bGVEZWNsYXJhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiTW9kdWxlRGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEV4cG9ydERlY2xhcmF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJFeHBvcnREZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0TW9kdWxlU3BlY2lmaWVyKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJNb2R1bGVTcGVjaWZpZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEZsb3cobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkZsb3dcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEZsb3dUeXBlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJGbG93VHlwZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Rmxvd0Jhc2VBbm5vdGF0aW9uKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJGbG93QmFzZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEZsb3dEZWNsYXJhdGlvbihub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRmxvd0RlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRGbG93UHJlZGljYXRlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJGbG93UHJlZGljYXRlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRFbnVtQm9keShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiRW51bUJvZHlcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEVudW1NZW1iZXIobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIkVudW1NZW1iZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydEpTWChub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiSlNYXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRQcml2YXRlKG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJQcml2YXRlXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU1R5cGVFbGVtZW50KG5vZGUsIG9wdHMgPSB7fSkge1xuICBhc3NlcnQoXCJUU1R5cGVFbGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRUU1R5cGUobm9kZSwgb3B0cyA9IHt9KSB7XG4gIGFzc2VydChcIlRTVHlwZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VFNCYXNlVHlwZShub2RlLCBvcHRzID0ge30pIHtcbiAgYXNzZXJ0KFwiVFNCYXNlVHlwZVwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0TnVtYmVyTGl0ZXJhbChub2RlLCBvcHRzKSB7XG4gIGNvbnNvbGUudHJhY2UoXCJUaGUgbm9kZSB0eXBlIE51bWJlckxpdGVyYWwgaGFzIGJlZW4gcmVuYW1lZCB0byBOdW1lcmljTGl0ZXJhbFwiKTtcbiAgYXNzZXJ0KFwiTnVtYmVyTGl0ZXJhbFwiLCBub2RlLCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0UmVnZXhMaXRlcmFsKG5vZGUsIG9wdHMpIHtcbiAgY29uc29sZS50cmFjZShcIlRoZSBub2RlIHR5cGUgUmVnZXhMaXRlcmFsIGhhcyBiZWVuIHJlbmFtZWQgdG8gUmVnRXhwTGl0ZXJhbFwiKTtcbiAgYXNzZXJ0KFwiUmVnZXhMaXRlcmFsXCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRSZXN0UHJvcGVydHkobm9kZSwgb3B0cykge1xuICBjb25zb2xlLnRyYWNlKFwiVGhlIG5vZGUgdHlwZSBSZXN0UHJvcGVydHkgaGFzIGJlZW4gcmVuYW1lZCB0byBSZXN0RWxlbWVudFwiKTtcbiAgYXNzZXJ0KFwiUmVzdFByb3BlcnR5XCIsIG5vZGUsIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRTcHJlYWRQcm9wZXJ0eShub2RlLCBvcHRzKSB7XG4gIGNvbnNvbGUudHJhY2UoXCJUaGUgbm9kZSB0eXBlIFNwcmVhZFByb3BlcnR5IGhhcyBiZWVuIHJlbmFtZWQgdG8gU3ByZWFkRWxlbWVudFwiKTtcbiAgYXNzZXJ0KFwiU3ByZWFkUHJvcGVydHlcIiwgbm9kZSwgb3B0cyk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBidWlsZGVyO1xuXG52YXIgX2Nsb25lID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2Nsb25lXCIpKTtcblxudmFyIF9kZWZpbml0aW9ucyA9IHJlcXVpcmUoXCIuLi9kZWZpbml0aW9uc1wiKTtcblxudmFyIF92YWxpZGF0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3ZhbGlkYXRvcnMvdmFsaWRhdGVcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBidWlsZGVyKHR5cGUsIC4uLmFyZ3MpIHtcbiAgY29uc3Qga2V5cyA9IF9kZWZpbml0aW9ucy5CVUlMREVSX0tFWVNbdHlwZV07XG4gIGNvbnN0IGNvdW50QXJncyA9IGFyZ3MubGVuZ3RoO1xuXG4gIGlmIChjb3VudEFyZ3MgPiBrZXlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHt0eXBlfTogVG9vIG1hbnkgYXJndW1lbnRzIHBhc3NlZC4gUmVjZWl2ZWQgJHtjb3VudEFyZ3N9IGJ1dCBjYW4gcmVjZWl2ZSBubyBtb3JlIHRoYW4gJHtrZXlzLmxlbmd0aH1gKTtcbiAgfVxuXG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZVxuICB9O1xuICBsZXQgaSA9IDA7XG4gIGtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgIGNvbnN0IGZpZWxkID0gX2RlZmluaXRpb25zLk5PREVfRklFTERTW3R5cGVdW2tleV07XG4gICAgbGV0IGFyZztcbiAgICBpZiAoaSA8IGNvdW50QXJncykgYXJnID0gYXJnc1tpXTtcbiAgICBpZiAoYXJnID09PSB1bmRlZmluZWQpIGFyZyA9ICgwLCBfY2xvbmUuZGVmYXVsdCkoZmllbGQuZGVmYXVsdCk7XG4gICAgbm9kZVtrZXldID0gYXJnO1xuICAgIGkrKztcbiAgfSk7XG5cbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMobm9kZSkpIHtcbiAgICAoMCwgX3ZhbGlkYXRlLmRlZmF1bHQpKG5vZGUsIGtleSwgbm9kZVtrZXldKTtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlRmxvd1VuaW9uVHlwZTtcblxudmFyIF9nZW5lcmF0ZWQgPSByZXF1aXJlKFwiLi4vZ2VuZXJhdGVkXCIpO1xuXG52YXIgX3JlbW92ZVR5cGVEdXBsaWNhdGVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vbW9kaWZpY2F0aW9ucy9mbG93L3JlbW92ZVR5cGVEdXBsaWNhdGVzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gY3JlYXRlRmxvd1VuaW9uVHlwZSh0eXBlcykge1xuICBjb25zdCBmbGF0dGVuZWQgPSAoMCwgX3JlbW92ZVR5cGVEdXBsaWNhdGVzLmRlZmF1bHQpKHR5cGVzKTtcblxuICBpZiAoZmxhdHRlbmVkLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBmbGF0dGVuZWRbMF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICgwLCBfZ2VuZXJhdGVkLnVuaW9uVHlwZUFubm90YXRpb24pKGZsYXR0ZW5lZCk7XG4gIH1cbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZVR5cGVBbm5vdGF0aW9uQmFzZWRPblR5cGVvZjtcblxudmFyIF9nZW5lcmF0ZWQgPSByZXF1aXJlKFwiLi4vZ2VuZXJhdGVkXCIpO1xuXG5mdW5jdGlvbiBjcmVhdGVUeXBlQW5ub3RhdGlvbkJhc2VkT25UeXBlb2YodHlwZSkge1xuICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiAoMCwgX2dlbmVyYXRlZC5zdHJpbmdUeXBlQW5ub3RhdGlvbikoKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuICgwLCBfZ2VuZXJhdGVkLm51bWJlclR5cGVBbm5vdGF0aW9uKSgpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gKDAsIF9nZW5lcmF0ZWQudm9pZFR5cGVBbm5vdGF0aW9uKSgpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuICgwLCBfZ2VuZXJhdGVkLmJvb2xlYW5UeXBlQW5ub3RhdGlvbikoKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gKDAsIF9nZW5lcmF0ZWQuZ2VuZXJpY1R5cGVBbm5vdGF0aW9uKSgoMCwgX2dlbmVyYXRlZC5pZGVudGlmaWVyKShcIkZ1bmN0aW9uXCIpKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuICgwLCBfZ2VuZXJhdGVkLmdlbmVyaWNUeXBlQW5ub3RhdGlvbikoKDAsIF9nZW5lcmF0ZWQuaWRlbnRpZmllcikoXCJPYmplY3RcIikpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFwic3ltYm9sXCIpIHtcbiAgICByZXR1cm4gKDAsIF9nZW5lcmF0ZWQuZ2VuZXJpY1R5cGVBbm5vdGF0aW9uKSgoMCwgX2dlbmVyYXRlZC5pZGVudGlmaWVyKShcIlN5bWJvbFwiKSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0eXBlb2YgdmFsdWVcIik7XG4gIH1cbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQXJyYXlFeHByZXNzaW9uID0gZXhwb3J0cy5hcnJheUV4cHJlc3Npb24gPSBhcnJheUV4cHJlc3Npb247XG5leHBvcnRzLkFzc2lnbm1lbnRFeHByZXNzaW9uID0gZXhwb3J0cy5hc3NpZ25tZW50RXhwcmVzc2lvbiA9IGFzc2lnbm1lbnRFeHByZXNzaW9uO1xuZXhwb3J0cy5CaW5hcnlFeHByZXNzaW9uID0gZXhwb3J0cy5iaW5hcnlFeHByZXNzaW9uID0gYmluYXJ5RXhwcmVzc2lvbjtcbmV4cG9ydHMuSW50ZXJwcmV0ZXJEaXJlY3RpdmUgPSBleHBvcnRzLmludGVycHJldGVyRGlyZWN0aXZlID0gaW50ZXJwcmV0ZXJEaXJlY3RpdmU7XG5leHBvcnRzLkRpcmVjdGl2ZSA9IGV4cG9ydHMuZGlyZWN0aXZlID0gZGlyZWN0aXZlO1xuZXhwb3J0cy5EaXJlY3RpdmVMaXRlcmFsID0gZXhwb3J0cy5kaXJlY3RpdmVMaXRlcmFsID0gZGlyZWN0aXZlTGl0ZXJhbDtcbmV4cG9ydHMuQmxvY2tTdGF0ZW1lbnQgPSBleHBvcnRzLmJsb2NrU3RhdGVtZW50ID0gYmxvY2tTdGF0ZW1lbnQ7XG5leHBvcnRzLkJyZWFrU3RhdGVtZW50ID0gZXhwb3J0cy5icmVha1N0YXRlbWVudCA9IGJyZWFrU3RhdGVtZW50O1xuZXhwb3J0cy5DYWxsRXhwcmVzc2lvbiA9IGV4cG9ydHMuY2FsbEV4cHJlc3Npb24gPSBjYWxsRXhwcmVzc2lvbjtcbmV4cG9ydHMuQ2F0Y2hDbGF1c2UgPSBleHBvcnRzLmNhdGNoQ2xhdXNlID0gY2F0Y2hDbGF1c2U7XG5leHBvcnRzLkNvbmRpdGlvbmFsRXhwcmVzc2lvbiA9IGV4cG9ydHMuY29uZGl0aW9uYWxFeHByZXNzaW9uID0gY29uZGl0aW9uYWxFeHByZXNzaW9uO1xuZXhwb3J0cy5Db250aW51ZVN0YXRlbWVudCA9IGV4cG9ydHMuY29udGludWVTdGF0ZW1lbnQgPSBjb250aW51ZVN0YXRlbWVudDtcbmV4cG9ydHMuRGVidWdnZXJTdGF0ZW1lbnQgPSBleHBvcnRzLmRlYnVnZ2VyU3RhdGVtZW50ID0gZGVidWdnZXJTdGF0ZW1lbnQ7XG5leHBvcnRzLkRvV2hpbGVTdGF0ZW1lbnQgPSBleHBvcnRzLmRvV2hpbGVTdGF0ZW1lbnQgPSBkb1doaWxlU3RhdGVtZW50O1xuZXhwb3J0cy5FbXB0eVN0YXRlbWVudCA9IGV4cG9ydHMuZW1wdHlTdGF0ZW1lbnQgPSBlbXB0eVN0YXRlbWVudDtcbmV4cG9ydHMuRXhwcmVzc2lvblN0YXRlbWVudCA9IGV4cG9ydHMuZXhwcmVzc2lvblN0YXRlbWVudCA9IGV4cHJlc3Npb25TdGF0ZW1lbnQ7XG5leHBvcnRzLkZpbGUgPSBleHBvcnRzLmZpbGUgPSBmaWxlO1xuZXhwb3J0cy5Gb3JJblN0YXRlbWVudCA9IGV4cG9ydHMuZm9ySW5TdGF0ZW1lbnQgPSBmb3JJblN0YXRlbWVudDtcbmV4cG9ydHMuRm9yU3RhdGVtZW50ID0gZXhwb3J0cy5mb3JTdGF0ZW1lbnQgPSBmb3JTdGF0ZW1lbnQ7XG5leHBvcnRzLkZ1bmN0aW9uRGVjbGFyYXRpb24gPSBleHBvcnRzLmZ1bmN0aW9uRGVjbGFyYXRpb24gPSBmdW5jdGlvbkRlY2xhcmF0aW9uO1xuZXhwb3J0cy5GdW5jdGlvbkV4cHJlc3Npb24gPSBleHBvcnRzLmZ1bmN0aW9uRXhwcmVzc2lvbiA9IGZ1bmN0aW9uRXhwcmVzc2lvbjtcbmV4cG9ydHMuSWRlbnRpZmllciA9IGV4cG9ydHMuaWRlbnRpZmllciA9IGlkZW50aWZpZXI7XG5leHBvcnRzLklmU3RhdGVtZW50ID0gZXhwb3J0cy5pZlN0YXRlbWVudCA9IGlmU3RhdGVtZW50O1xuZXhwb3J0cy5MYWJlbGVkU3RhdGVtZW50ID0gZXhwb3J0cy5sYWJlbGVkU3RhdGVtZW50ID0gbGFiZWxlZFN0YXRlbWVudDtcbmV4cG9ydHMuU3RyaW5nTGl0ZXJhbCA9IGV4cG9ydHMuc3RyaW5nTGl0ZXJhbCA9IHN0cmluZ0xpdGVyYWw7XG5leHBvcnRzLk51bWVyaWNMaXRlcmFsID0gZXhwb3J0cy5udW1lcmljTGl0ZXJhbCA9IG51bWVyaWNMaXRlcmFsO1xuZXhwb3J0cy5OdWxsTGl0ZXJhbCA9IGV4cG9ydHMubnVsbExpdGVyYWwgPSBudWxsTGl0ZXJhbDtcbmV4cG9ydHMuQm9vbGVhbkxpdGVyYWwgPSBleHBvcnRzLmJvb2xlYW5MaXRlcmFsID0gYm9vbGVhbkxpdGVyYWw7XG5leHBvcnRzLlJlZ0V4cExpdGVyYWwgPSBleHBvcnRzLnJlZ0V4cExpdGVyYWwgPSByZWdFeHBMaXRlcmFsO1xuZXhwb3J0cy5Mb2dpY2FsRXhwcmVzc2lvbiA9IGV4cG9ydHMubG9naWNhbEV4cHJlc3Npb24gPSBsb2dpY2FsRXhwcmVzc2lvbjtcbmV4cG9ydHMuTWVtYmVyRXhwcmVzc2lvbiA9IGV4cG9ydHMubWVtYmVyRXhwcmVzc2lvbiA9IG1lbWJlckV4cHJlc3Npb247XG5leHBvcnRzLk5ld0V4cHJlc3Npb24gPSBleHBvcnRzLm5ld0V4cHJlc3Npb24gPSBuZXdFeHByZXNzaW9uO1xuZXhwb3J0cy5Qcm9ncmFtID0gZXhwb3J0cy5wcm9ncmFtID0gcHJvZ3JhbTtcbmV4cG9ydHMuT2JqZWN0RXhwcmVzc2lvbiA9IGV4cG9ydHMub2JqZWN0RXhwcmVzc2lvbiA9IG9iamVjdEV4cHJlc3Npb247XG5leHBvcnRzLk9iamVjdE1ldGhvZCA9IGV4cG9ydHMub2JqZWN0TWV0aG9kID0gb2JqZWN0TWV0aG9kO1xuZXhwb3J0cy5PYmplY3RQcm9wZXJ0eSA9IGV4cG9ydHMub2JqZWN0UHJvcGVydHkgPSBvYmplY3RQcm9wZXJ0eTtcbmV4cG9ydHMuUmVzdEVsZW1lbnQgPSBleHBvcnRzLnJlc3RFbGVtZW50ID0gcmVzdEVsZW1lbnQ7XG5leHBvcnRzLlJldHVyblN0YXRlbWVudCA9IGV4cG9ydHMucmV0dXJuU3RhdGVtZW50ID0gcmV0dXJuU3RhdGVtZW50O1xuZXhwb3J0cy5TZXF1ZW5jZUV4cHJlc3Npb24gPSBleHBvcnRzLnNlcXVlbmNlRXhwcmVzc2lvbiA9IHNlcXVlbmNlRXhwcmVzc2lvbjtcbmV4cG9ydHMuUGFyZW50aGVzaXplZEV4cHJlc3Npb24gPSBleHBvcnRzLnBhcmVudGhlc2l6ZWRFeHByZXNzaW9uID0gcGFyZW50aGVzaXplZEV4cHJlc3Npb247XG5leHBvcnRzLlN3aXRjaENhc2UgPSBleHBvcnRzLnN3aXRjaENhc2UgPSBzd2l0Y2hDYXNlO1xuZXhwb3J0cy5Td2l0Y2hTdGF0ZW1lbnQgPSBleHBvcnRzLnN3aXRjaFN0YXRlbWVudCA9IHN3aXRjaFN0YXRlbWVudDtcbmV4cG9ydHMuVGhpc0V4cHJlc3Npb24gPSBleHBvcnRzLnRoaXNFeHByZXNzaW9uID0gdGhpc0V4cHJlc3Npb247XG5leHBvcnRzLlRocm93U3RhdGVtZW50ID0gZXhwb3J0cy50aHJvd1N0YXRlbWVudCA9IHRocm93U3RhdGVtZW50O1xuZXhwb3J0cy5UcnlTdGF0ZW1lbnQgPSBleHBvcnRzLnRyeVN0YXRlbWVudCA9IHRyeVN0YXRlbWVudDtcbmV4cG9ydHMuVW5hcnlFeHByZXNzaW9uID0gZXhwb3J0cy51bmFyeUV4cHJlc3Npb24gPSB1bmFyeUV4cHJlc3Npb247XG5leHBvcnRzLlVwZGF0ZUV4cHJlc3Npb24gPSBleHBvcnRzLnVwZGF0ZUV4cHJlc3Npb24gPSB1cGRhdGVFeHByZXNzaW9uO1xuZXhwb3J0cy5WYXJpYWJsZURlY2xhcmF0aW9uID0gZXhwb3J0cy52YXJpYWJsZURlY2xhcmF0aW9uID0gdmFyaWFibGVEZWNsYXJhdGlvbjtcbmV4cG9ydHMuVmFyaWFibGVEZWNsYXJhdG9yID0gZXhwb3J0cy52YXJpYWJsZURlY2xhcmF0b3IgPSB2YXJpYWJsZURlY2xhcmF0b3I7XG5leHBvcnRzLldoaWxlU3RhdGVtZW50ID0gZXhwb3J0cy53aGlsZVN0YXRlbWVudCA9IHdoaWxlU3RhdGVtZW50O1xuZXhwb3J0cy5XaXRoU3RhdGVtZW50ID0gZXhwb3J0cy53aXRoU3RhdGVtZW50ID0gd2l0aFN0YXRlbWVudDtcbmV4cG9ydHMuQXNzaWdubWVudFBhdHRlcm4gPSBleHBvcnRzLmFzc2lnbm1lbnRQYXR0ZXJuID0gYXNzaWdubWVudFBhdHRlcm47XG5leHBvcnRzLkFycmF5UGF0dGVybiA9IGV4cG9ydHMuYXJyYXlQYXR0ZXJuID0gYXJyYXlQYXR0ZXJuO1xuZXhwb3J0cy5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGV4cG9ydHMuYXJyb3dGdW5jdGlvbkV4cHJlc3Npb24gPSBhcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjtcbmV4cG9ydHMuQ2xhc3NCb2R5ID0gZXhwb3J0cy5jbGFzc0JvZHkgPSBjbGFzc0JvZHk7XG5leHBvcnRzLkNsYXNzRXhwcmVzc2lvbiA9IGV4cG9ydHMuY2xhc3NFeHByZXNzaW9uID0gY2xhc3NFeHByZXNzaW9uO1xuZXhwb3J0cy5DbGFzc0RlY2xhcmF0aW9uID0gZXhwb3J0cy5jbGFzc0RlY2xhcmF0aW9uID0gY2xhc3NEZWNsYXJhdGlvbjtcbmV4cG9ydHMuRXhwb3J0QWxsRGVjbGFyYXRpb24gPSBleHBvcnRzLmV4cG9ydEFsbERlY2xhcmF0aW9uID0gZXhwb3J0QWxsRGVjbGFyYXRpb247XG5leHBvcnRzLkV4cG9ydERlZmF1bHREZWNsYXJhdGlvbiA9IGV4cG9ydHMuZXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uID0gZXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uO1xuZXhwb3J0cy5FeHBvcnROYW1lZERlY2xhcmF0aW9uID0gZXhwb3J0cy5leHBvcnROYW1lZERlY2xhcmF0aW9uID0gZXhwb3J0TmFtZWREZWNsYXJhdGlvbjtcbmV4cG9ydHMuRXhwb3J0U3BlY2lmaWVyID0gZXhwb3J0cy5leHBvcnRTcGVjaWZpZXIgPSBleHBvcnRTcGVjaWZpZXI7XG5leHBvcnRzLkZvck9mU3RhdGVtZW50ID0gZXhwb3J0cy5mb3JPZlN0YXRlbWVudCA9IGZvck9mU3RhdGVtZW50O1xuZXhwb3J0cy5JbXBvcnREZWNsYXJhdGlvbiA9IGV4cG9ydHMuaW1wb3J0RGVjbGFyYXRpb24gPSBpbXBvcnREZWNsYXJhdGlvbjtcbmV4cG9ydHMuSW1wb3J0RGVmYXVsdFNwZWNpZmllciA9IGV4cG9ydHMuaW1wb3J0RGVmYXVsdFNwZWNpZmllciA9IGltcG9ydERlZmF1bHRTcGVjaWZpZXI7XG5leHBvcnRzLkltcG9ydE5hbWVzcGFjZVNwZWNpZmllciA9IGV4cG9ydHMuaW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyID0gaW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyO1xuZXhwb3J0cy5JbXBvcnRTcGVjaWZpZXIgPSBleHBvcnRzLmltcG9ydFNwZWNpZmllciA9IGltcG9ydFNwZWNpZmllcjtcbmV4cG9ydHMuTWV0YVByb3BlcnR5ID0gZXhwb3J0cy5tZXRhUHJvcGVydHkgPSBtZXRhUHJvcGVydHk7XG5leHBvcnRzLkNsYXNzTWV0aG9kID0gZXhwb3J0cy5jbGFzc01ldGhvZCA9IGNsYXNzTWV0aG9kO1xuZXhwb3J0cy5PYmplY3RQYXR0ZXJuID0gZXhwb3J0cy5vYmplY3RQYXR0ZXJuID0gb2JqZWN0UGF0dGVybjtcbmV4cG9ydHMuU3ByZWFkRWxlbWVudCA9IGV4cG9ydHMuc3ByZWFkRWxlbWVudCA9IHNwcmVhZEVsZW1lbnQ7XG5leHBvcnRzLnN1cGVyID0gZXhwb3J0cy5TdXBlciA9IF9zdXBlcjtcbmV4cG9ydHMuVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uID0gZXhwb3J0cy50YWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24gPSB0YWdnZWRUZW1wbGF0ZUV4cHJlc3Npb247XG5leHBvcnRzLlRlbXBsYXRlRWxlbWVudCA9IGV4cG9ydHMudGVtcGxhdGVFbGVtZW50ID0gdGVtcGxhdGVFbGVtZW50O1xuZXhwb3J0cy5UZW1wbGF0ZUxpdGVyYWwgPSBleHBvcnRzLnRlbXBsYXRlTGl0ZXJhbCA9IHRlbXBsYXRlTGl0ZXJhbDtcbmV4cG9ydHMuWWllbGRFeHByZXNzaW9uID0gZXhwb3J0cy55aWVsZEV4cHJlc3Npb24gPSB5aWVsZEV4cHJlc3Npb247XG5leHBvcnRzLkF3YWl0RXhwcmVzc2lvbiA9IGV4cG9ydHMuYXdhaXRFeHByZXNzaW9uID0gYXdhaXRFeHByZXNzaW9uO1xuZXhwb3J0cy5pbXBvcnQgPSBleHBvcnRzLkltcG9ydCA9IF9pbXBvcnQ7XG5leHBvcnRzLkJpZ0ludExpdGVyYWwgPSBleHBvcnRzLmJpZ0ludExpdGVyYWwgPSBiaWdJbnRMaXRlcmFsO1xuZXhwb3J0cy5FeHBvcnROYW1lc3BhY2VTcGVjaWZpZXIgPSBleHBvcnRzLmV4cG9ydE5hbWVzcGFjZVNwZWNpZmllciA9IGV4cG9ydE5hbWVzcGFjZVNwZWNpZmllcjtcbmV4cG9ydHMuT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uID0gZXhwb3J0cy5vcHRpb25hbE1lbWJlckV4cHJlc3Npb24gPSBvcHRpb25hbE1lbWJlckV4cHJlc3Npb247XG5leHBvcnRzLk9wdGlvbmFsQ2FsbEV4cHJlc3Npb24gPSBleHBvcnRzLm9wdGlvbmFsQ2FsbEV4cHJlc3Npb24gPSBvcHRpb25hbENhbGxFeHByZXNzaW9uO1xuZXhwb3J0cy5BbnlUeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMuYW55VHlwZUFubm90YXRpb24gPSBhbnlUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuQXJyYXlUeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMuYXJyYXlUeXBlQW5ub3RhdGlvbiA9IGFycmF5VHlwZUFubm90YXRpb247XG5leHBvcnRzLkJvb2xlYW5UeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMuYm9vbGVhblR5cGVBbm5vdGF0aW9uID0gYm9vbGVhblR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5Cb29sZWFuTGl0ZXJhbFR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5ib29sZWFuTGl0ZXJhbFR5cGVBbm5vdGF0aW9uID0gYm9vbGVhbkxpdGVyYWxUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuTnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMubnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvbiA9IG51bGxMaXRlcmFsVHlwZUFubm90YXRpb247XG5leHBvcnRzLkNsYXNzSW1wbGVtZW50cyA9IGV4cG9ydHMuY2xhc3NJbXBsZW1lbnRzID0gY2xhc3NJbXBsZW1lbnRzO1xuZXhwb3J0cy5EZWNsYXJlQ2xhc3MgPSBleHBvcnRzLmRlY2xhcmVDbGFzcyA9IGRlY2xhcmVDbGFzcztcbmV4cG9ydHMuRGVjbGFyZUZ1bmN0aW9uID0gZXhwb3J0cy5kZWNsYXJlRnVuY3Rpb24gPSBkZWNsYXJlRnVuY3Rpb247XG5leHBvcnRzLkRlY2xhcmVJbnRlcmZhY2UgPSBleHBvcnRzLmRlY2xhcmVJbnRlcmZhY2UgPSBkZWNsYXJlSW50ZXJmYWNlO1xuZXhwb3J0cy5EZWNsYXJlTW9kdWxlID0gZXhwb3J0cy5kZWNsYXJlTW9kdWxlID0gZGVjbGFyZU1vZHVsZTtcbmV4cG9ydHMuRGVjbGFyZU1vZHVsZUV4cG9ydHMgPSBleHBvcnRzLmRlY2xhcmVNb2R1bGVFeHBvcnRzID0gZGVjbGFyZU1vZHVsZUV4cG9ydHM7XG5leHBvcnRzLkRlY2xhcmVUeXBlQWxpYXMgPSBleHBvcnRzLmRlY2xhcmVUeXBlQWxpYXMgPSBkZWNsYXJlVHlwZUFsaWFzO1xuZXhwb3J0cy5EZWNsYXJlT3BhcXVlVHlwZSA9IGV4cG9ydHMuZGVjbGFyZU9wYXF1ZVR5cGUgPSBkZWNsYXJlT3BhcXVlVHlwZTtcbmV4cG9ydHMuRGVjbGFyZVZhcmlhYmxlID0gZXhwb3J0cy5kZWNsYXJlVmFyaWFibGUgPSBkZWNsYXJlVmFyaWFibGU7XG5leHBvcnRzLkRlY2xhcmVFeHBvcnREZWNsYXJhdGlvbiA9IGV4cG9ydHMuZGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uID0gZGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uO1xuZXhwb3J0cy5EZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb24gPSBleHBvcnRzLmRlY2xhcmVFeHBvcnRBbGxEZWNsYXJhdGlvbiA9IGRlY2xhcmVFeHBvcnRBbGxEZWNsYXJhdGlvbjtcbmV4cG9ydHMuRGVjbGFyZWRQcmVkaWNhdGUgPSBleHBvcnRzLmRlY2xhcmVkUHJlZGljYXRlID0gZGVjbGFyZWRQcmVkaWNhdGU7XG5leHBvcnRzLkV4aXN0c1R5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5leGlzdHNUeXBlQW5ub3RhdGlvbiA9IGV4aXN0c1R5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5GdW5jdGlvblR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5mdW5jdGlvblR5cGVBbm5vdGF0aW9uID0gZnVuY3Rpb25UeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuRnVuY3Rpb25UeXBlUGFyYW0gPSBleHBvcnRzLmZ1bmN0aW9uVHlwZVBhcmFtID0gZnVuY3Rpb25UeXBlUGFyYW07XG5leHBvcnRzLkdlbmVyaWNUeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMuZ2VuZXJpY1R5cGVBbm5vdGF0aW9uID0gZ2VuZXJpY1R5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5JbmZlcnJlZFByZWRpY2F0ZSA9IGV4cG9ydHMuaW5mZXJyZWRQcmVkaWNhdGUgPSBpbmZlcnJlZFByZWRpY2F0ZTtcbmV4cG9ydHMuSW50ZXJmYWNlRXh0ZW5kcyA9IGV4cG9ydHMuaW50ZXJmYWNlRXh0ZW5kcyA9IGludGVyZmFjZUV4dGVuZHM7XG5leHBvcnRzLkludGVyZmFjZURlY2xhcmF0aW9uID0gZXhwb3J0cy5pbnRlcmZhY2VEZWNsYXJhdGlvbiA9IGludGVyZmFjZURlY2xhcmF0aW9uO1xuZXhwb3J0cy5JbnRlcmZhY2VUeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMuaW50ZXJmYWNlVHlwZUFubm90YXRpb24gPSBpbnRlcmZhY2VUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuSW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb24gPSBleHBvcnRzLmludGVyc2VjdGlvblR5cGVBbm5vdGF0aW9uID0gaW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb247XG5leHBvcnRzLk1peGVkVHlwZUFubm90YXRpb24gPSBleHBvcnRzLm1peGVkVHlwZUFubm90YXRpb24gPSBtaXhlZFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5FbXB0eVR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5lbXB0eVR5cGVBbm5vdGF0aW9uID0gZW1wdHlUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuTnVsbGFibGVUeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMubnVsbGFibGVUeXBlQW5ub3RhdGlvbiA9IG51bGxhYmxlVHlwZUFubm90YXRpb247XG5leHBvcnRzLk51bWJlckxpdGVyYWxUeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMubnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uID0gbnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5OdW1iZXJUeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMubnVtYmVyVHlwZUFubm90YXRpb24gPSBudW1iZXJUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuT2JqZWN0VHlwZUFubm90YXRpb24gPSBleHBvcnRzLm9iamVjdFR5cGVBbm5vdGF0aW9uID0gb2JqZWN0VHlwZUFubm90YXRpb247XG5leHBvcnRzLk9iamVjdFR5cGVJbnRlcm5hbFNsb3QgPSBleHBvcnRzLm9iamVjdFR5cGVJbnRlcm5hbFNsb3QgPSBvYmplY3RUeXBlSW50ZXJuYWxTbG90O1xuZXhwb3J0cy5PYmplY3RUeXBlQ2FsbFByb3BlcnR5ID0gZXhwb3J0cy5vYmplY3RUeXBlQ2FsbFByb3BlcnR5ID0gb2JqZWN0VHlwZUNhbGxQcm9wZXJ0eTtcbmV4cG9ydHMuT2JqZWN0VHlwZUluZGV4ZXIgPSBleHBvcnRzLm9iamVjdFR5cGVJbmRleGVyID0gb2JqZWN0VHlwZUluZGV4ZXI7XG5leHBvcnRzLk9iamVjdFR5cGVQcm9wZXJ0eSA9IGV4cG9ydHMub2JqZWN0VHlwZVByb3BlcnR5ID0gb2JqZWN0VHlwZVByb3BlcnR5O1xuZXhwb3J0cy5PYmplY3RUeXBlU3ByZWFkUHJvcGVydHkgPSBleHBvcnRzLm9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eSA9IG9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eTtcbmV4cG9ydHMuT3BhcXVlVHlwZSA9IGV4cG9ydHMub3BhcXVlVHlwZSA9IG9wYXF1ZVR5cGU7XG5leHBvcnRzLlF1YWxpZmllZFR5cGVJZGVudGlmaWVyID0gZXhwb3J0cy5xdWFsaWZpZWRUeXBlSWRlbnRpZmllciA9IHF1YWxpZmllZFR5cGVJZGVudGlmaWVyO1xuZXhwb3J0cy5TdHJpbmdMaXRlcmFsVHlwZUFubm90YXRpb24gPSBleHBvcnRzLnN0cmluZ0xpdGVyYWxUeXBlQW5ub3RhdGlvbiA9IHN0cmluZ0xpdGVyYWxUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuU3RyaW5nVHlwZUFubm90YXRpb24gPSBleHBvcnRzLnN0cmluZ1R5cGVBbm5vdGF0aW9uID0gc3RyaW5nVHlwZUFubm90YXRpb247XG5leHBvcnRzLlN5bWJvbFR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5zeW1ib2xUeXBlQW5ub3RhdGlvbiA9IHN5bWJvbFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5UaGlzVHlwZUFubm90YXRpb24gPSBleHBvcnRzLnRoaXNUeXBlQW5ub3RhdGlvbiA9IHRoaXNUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuVHVwbGVUeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMudHVwbGVUeXBlQW5ub3RhdGlvbiA9IHR1cGxlVHlwZUFubm90YXRpb247XG5leHBvcnRzLlR5cGVvZlR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy50eXBlb2ZUeXBlQW5ub3RhdGlvbiA9IHR5cGVvZlR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5UeXBlQWxpYXMgPSBleHBvcnRzLnR5cGVBbGlhcyA9IHR5cGVBbGlhcztcbmV4cG9ydHMuVHlwZUFubm90YXRpb24gPSBleHBvcnRzLnR5cGVBbm5vdGF0aW9uID0gdHlwZUFubm90YXRpb247XG5leHBvcnRzLlR5cGVDYXN0RXhwcmVzc2lvbiA9IGV4cG9ydHMudHlwZUNhc3RFeHByZXNzaW9uID0gdHlwZUNhc3RFeHByZXNzaW9uO1xuZXhwb3J0cy5UeXBlUGFyYW1ldGVyID0gZXhwb3J0cy50eXBlUGFyYW1ldGVyID0gdHlwZVBhcmFtZXRlcjtcbmV4cG9ydHMuVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uID0gZXhwb3J0cy50eXBlUGFyYW1ldGVyRGVjbGFyYXRpb24gPSB0eXBlUGFyYW1ldGVyRGVjbGFyYXRpb247XG5leHBvcnRzLlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uID0gZXhwb3J0cy50eXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbiA9IHR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uO1xuZXhwb3J0cy5VbmlvblR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy51bmlvblR5cGVBbm5vdGF0aW9uID0gdW5pb25UeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuVmFyaWFuY2UgPSBleHBvcnRzLnZhcmlhbmNlID0gdmFyaWFuY2U7XG5leHBvcnRzLlZvaWRUeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMudm9pZFR5cGVBbm5vdGF0aW9uID0gdm9pZFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5FbnVtRGVjbGFyYXRpb24gPSBleHBvcnRzLmVudW1EZWNsYXJhdGlvbiA9IGVudW1EZWNsYXJhdGlvbjtcbmV4cG9ydHMuRW51bUJvb2xlYW5Cb2R5ID0gZXhwb3J0cy5lbnVtQm9vbGVhbkJvZHkgPSBlbnVtQm9vbGVhbkJvZHk7XG5leHBvcnRzLkVudW1OdW1iZXJCb2R5ID0gZXhwb3J0cy5lbnVtTnVtYmVyQm9keSA9IGVudW1OdW1iZXJCb2R5O1xuZXhwb3J0cy5FbnVtU3RyaW5nQm9keSA9IGV4cG9ydHMuZW51bVN0cmluZ0JvZHkgPSBlbnVtU3RyaW5nQm9keTtcbmV4cG9ydHMuRW51bVN5bWJvbEJvZHkgPSBleHBvcnRzLmVudW1TeW1ib2xCb2R5ID0gZW51bVN5bWJvbEJvZHk7XG5leHBvcnRzLkVudW1Cb29sZWFuTWVtYmVyID0gZXhwb3J0cy5lbnVtQm9vbGVhbk1lbWJlciA9IGVudW1Cb29sZWFuTWVtYmVyO1xuZXhwb3J0cy5FbnVtTnVtYmVyTWVtYmVyID0gZXhwb3J0cy5lbnVtTnVtYmVyTWVtYmVyID0gZW51bU51bWJlck1lbWJlcjtcbmV4cG9ydHMuRW51bVN0cmluZ01lbWJlciA9IGV4cG9ydHMuZW51bVN0cmluZ01lbWJlciA9IGVudW1TdHJpbmdNZW1iZXI7XG5leHBvcnRzLkVudW1EZWZhdWx0ZWRNZW1iZXIgPSBleHBvcnRzLmVudW1EZWZhdWx0ZWRNZW1iZXIgPSBlbnVtRGVmYXVsdGVkTWVtYmVyO1xuZXhwb3J0cy5qU1hBdHRyaWJ1dGUgPSBleHBvcnRzLkpTWEF0dHJpYnV0ZSA9IGV4cG9ydHMuanN4QXR0cmlidXRlID0ganN4QXR0cmlidXRlO1xuZXhwb3J0cy5qU1hDbG9zaW5nRWxlbWVudCA9IGV4cG9ydHMuSlNYQ2xvc2luZ0VsZW1lbnQgPSBleHBvcnRzLmpzeENsb3NpbmdFbGVtZW50ID0ganN4Q2xvc2luZ0VsZW1lbnQ7XG5leHBvcnRzLmpTWEVsZW1lbnQgPSBleHBvcnRzLkpTWEVsZW1lbnQgPSBleHBvcnRzLmpzeEVsZW1lbnQgPSBqc3hFbGVtZW50O1xuZXhwb3J0cy5qU1hFbXB0eUV4cHJlc3Npb24gPSBleHBvcnRzLkpTWEVtcHR5RXhwcmVzc2lvbiA9IGV4cG9ydHMuanN4RW1wdHlFeHByZXNzaW9uID0ganN4RW1wdHlFeHByZXNzaW9uO1xuZXhwb3J0cy5qU1hFeHByZXNzaW9uQ29udGFpbmVyID0gZXhwb3J0cy5KU1hFeHByZXNzaW9uQ29udGFpbmVyID0gZXhwb3J0cy5qc3hFeHByZXNzaW9uQ29udGFpbmVyID0ganN4RXhwcmVzc2lvbkNvbnRhaW5lcjtcbmV4cG9ydHMualNYU3ByZWFkQ2hpbGQgPSBleHBvcnRzLkpTWFNwcmVhZENoaWxkID0gZXhwb3J0cy5qc3hTcHJlYWRDaGlsZCA9IGpzeFNwcmVhZENoaWxkO1xuZXhwb3J0cy5qU1hJZGVudGlmaWVyID0gZXhwb3J0cy5KU1hJZGVudGlmaWVyID0gZXhwb3J0cy5qc3hJZGVudGlmaWVyID0ganN4SWRlbnRpZmllcjtcbmV4cG9ydHMualNYTWVtYmVyRXhwcmVzc2lvbiA9IGV4cG9ydHMuSlNYTWVtYmVyRXhwcmVzc2lvbiA9IGV4cG9ydHMuanN4TWVtYmVyRXhwcmVzc2lvbiA9IGpzeE1lbWJlckV4cHJlc3Npb247XG5leHBvcnRzLmpTWE5hbWVzcGFjZWROYW1lID0gZXhwb3J0cy5KU1hOYW1lc3BhY2VkTmFtZSA9IGV4cG9ydHMuanN4TmFtZXNwYWNlZE5hbWUgPSBqc3hOYW1lc3BhY2VkTmFtZTtcbmV4cG9ydHMualNYT3BlbmluZ0VsZW1lbnQgPSBleHBvcnRzLkpTWE9wZW5pbmdFbGVtZW50ID0gZXhwb3J0cy5qc3hPcGVuaW5nRWxlbWVudCA9IGpzeE9wZW5pbmdFbGVtZW50O1xuZXhwb3J0cy5qU1hTcHJlYWRBdHRyaWJ1dGUgPSBleHBvcnRzLkpTWFNwcmVhZEF0dHJpYnV0ZSA9IGV4cG9ydHMuanN4U3ByZWFkQXR0cmlidXRlID0ganN4U3ByZWFkQXR0cmlidXRlO1xuZXhwb3J0cy5qU1hUZXh0ID0gZXhwb3J0cy5KU1hUZXh0ID0gZXhwb3J0cy5qc3hUZXh0ID0ganN4VGV4dDtcbmV4cG9ydHMualNYRnJhZ21lbnQgPSBleHBvcnRzLkpTWEZyYWdtZW50ID0gZXhwb3J0cy5qc3hGcmFnbWVudCA9IGpzeEZyYWdtZW50O1xuZXhwb3J0cy5qU1hPcGVuaW5nRnJhZ21lbnQgPSBleHBvcnRzLkpTWE9wZW5pbmdGcmFnbWVudCA9IGV4cG9ydHMuanN4T3BlbmluZ0ZyYWdtZW50ID0ganN4T3BlbmluZ0ZyYWdtZW50O1xuZXhwb3J0cy5qU1hDbG9zaW5nRnJhZ21lbnQgPSBleHBvcnRzLkpTWENsb3NpbmdGcmFnbWVudCA9IGV4cG9ydHMuanN4Q2xvc2luZ0ZyYWdtZW50ID0ganN4Q2xvc2luZ0ZyYWdtZW50O1xuZXhwb3J0cy5Ob29wID0gZXhwb3J0cy5ub29wID0gbm9vcDtcbmV4cG9ydHMuUGxhY2Vob2xkZXIgPSBleHBvcnRzLnBsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXI7XG5leHBvcnRzLlY4SW50cmluc2ljSWRlbnRpZmllciA9IGV4cG9ydHMudjhJbnRyaW5zaWNJZGVudGlmaWVyID0gdjhJbnRyaW5zaWNJZGVudGlmaWVyO1xuZXhwb3J0cy5Bcmd1bWVudFBsYWNlaG9sZGVyID0gZXhwb3J0cy5hcmd1bWVudFBsYWNlaG9sZGVyID0gYXJndW1lbnRQbGFjZWhvbGRlcjtcbmV4cG9ydHMuQmluZEV4cHJlc3Npb24gPSBleHBvcnRzLmJpbmRFeHByZXNzaW9uID0gYmluZEV4cHJlc3Npb247XG5leHBvcnRzLkNsYXNzUHJvcGVydHkgPSBleHBvcnRzLmNsYXNzUHJvcGVydHkgPSBjbGFzc1Byb3BlcnR5O1xuZXhwb3J0cy5QaXBlbGluZVRvcGljRXhwcmVzc2lvbiA9IGV4cG9ydHMucGlwZWxpbmVUb3BpY0V4cHJlc3Npb24gPSBwaXBlbGluZVRvcGljRXhwcmVzc2lvbjtcbmV4cG9ydHMuUGlwZWxpbmVCYXJlRnVuY3Rpb24gPSBleHBvcnRzLnBpcGVsaW5lQmFyZUZ1bmN0aW9uID0gcGlwZWxpbmVCYXJlRnVuY3Rpb247XG5leHBvcnRzLlBpcGVsaW5lUHJpbWFyeVRvcGljUmVmZXJlbmNlID0gZXhwb3J0cy5waXBlbGluZVByaW1hcnlUb3BpY1JlZmVyZW5jZSA9IHBpcGVsaW5lUHJpbWFyeVRvcGljUmVmZXJlbmNlO1xuZXhwb3J0cy5DbGFzc1ByaXZhdGVQcm9wZXJ0eSA9IGV4cG9ydHMuY2xhc3NQcml2YXRlUHJvcGVydHkgPSBjbGFzc1ByaXZhdGVQcm9wZXJ0eTtcbmV4cG9ydHMuQ2xhc3NQcml2YXRlTWV0aG9kID0gZXhwb3J0cy5jbGFzc1ByaXZhdGVNZXRob2QgPSBjbGFzc1ByaXZhdGVNZXRob2Q7XG5leHBvcnRzLkltcG9ydEF0dHJpYnV0ZSA9IGV4cG9ydHMuaW1wb3J0QXR0cmlidXRlID0gaW1wb3J0QXR0cmlidXRlO1xuZXhwb3J0cy5EZWNvcmF0b3IgPSBleHBvcnRzLmRlY29yYXRvciA9IGRlY29yYXRvcjtcbmV4cG9ydHMuRG9FeHByZXNzaW9uID0gZXhwb3J0cy5kb0V4cHJlc3Npb24gPSBkb0V4cHJlc3Npb247XG5leHBvcnRzLkV4cG9ydERlZmF1bHRTcGVjaWZpZXIgPSBleHBvcnRzLmV4cG9ydERlZmF1bHRTcGVjaWZpZXIgPSBleHBvcnREZWZhdWx0U3BlY2lmaWVyO1xuZXhwb3J0cy5Qcml2YXRlTmFtZSA9IGV4cG9ydHMucHJpdmF0ZU5hbWUgPSBwcml2YXRlTmFtZTtcbmV4cG9ydHMuUmVjb3JkRXhwcmVzc2lvbiA9IGV4cG9ydHMucmVjb3JkRXhwcmVzc2lvbiA9IHJlY29yZEV4cHJlc3Npb247XG5leHBvcnRzLlR1cGxlRXhwcmVzc2lvbiA9IGV4cG9ydHMudHVwbGVFeHByZXNzaW9uID0gdHVwbGVFeHByZXNzaW9uO1xuZXhwb3J0cy5EZWNpbWFsTGl0ZXJhbCA9IGV4cG9ydHMuZGVjaW1hbExpdGVyYWwgPSBkZWNpbWFsTGl0ZXJhbDtcbmV4cG9ydHMudFNQYXJhbWV0ZXJQcm9wZXJ0eSA9IGV4cG9ydHMuVFNQYXJhbWV0ZXJQcm9wZXJ0eSA9IGV4cG9ydHMudHNQYXJhbWV0ZXJQcm9wZXJ0eSA9IHRzUGFyYW1ldGVyUHJvcGVydHk7XG5leHBvcnRzLnRTRGVjbGFyZUZ1bmN0aW9uID0gZXhwb3J0cy5UU0RlY2xhcmVGdW5jdGlvbiA9IGV4cG9ydHMudHNEZWNsYXJlRnVuY3Rpb24gPSB0c0RlY2xhcmVGdW5jdGlvbjtcbmV4cG9ydHMudFNEZWNsYXJlTWV0aG9kID0gZXhwb3J0cy5UU0RlY2xhcmVNZXRob2QgPSBleHBvcnRzLnRzRGVjbGFyZU1ldGhvZCA9IHRzRGVjbGFyZU1ldGhvZDtcbmV4cG9ydHMudFNRdWFsaWZpZWROYW1lID0gZXhwb3J0cy5UU1F1YWxpZmllZE5hbWUgPSBleHBvcnRzLnRzUXVhbGlmaWVkTmFtZSA9IHRzUXVhbGlmaWVkTmFtZTtcbmV4cG9ydHMudFNDYWxsU2lnbmF0dXJlRGVjbGFyYXRpb24gPSBleHBvcnRzLlRTQ2FsbFNpZ25hdHVyZURlY2xhcmF0aW9uID0gZXhwb3J0cy50c0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvbiA9IHRzQ2FsbFNpZ25hdHVyZURlY2xhcmF0aW9uO1xuZXhwb3J0cy50U0NvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uID0gZXhwb3J0cy5UU0NvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uID0gZXhwb3J0cy50c0NvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uID0gdHNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvbjtcbmV4cG9ydHMudFNQcm9wZXJ0eVNpZ25hdHVyZSA9IGV4cG9ydHMuVFNQcm9wZXJ0eVNpZ25hdHVyZSA9IGV4cG9ydHMudHNQcm9wZXJ0eVNpZ25hdHVyZSA9IHRzUHJvcGVydHlTaWduYXR1cmU7XG5leHBvcnRzLnRTTWV0aG9kU2lnbmF0dXJlID0gZXhwb3J0cy5UU01ldGhvZFNpZ25hdHVyZSA9IGV4cG9ydHMudHNNZXRob2RTaWduYXR1cmUgPSB0c01ldGhvZFNpZ25hdHVyZTtcbmV4cG9ydHMudFNJbmRleFNpZ25hdHVyZSA9IGV4cG9ydHMuVFNJbmRleFNpZ25hdHVyZSA9IGV4cG9ydHMudHNJbmRleFNpZ25hdHVyZSA9IHRzSW5kZXhTaWduYXR1cmU7XG5leHBvcnRzLnRTQW55S2V5d29yZCA9IGV4cG9ydHMuVFNBbnlLZXl3b3JkID0gZXhwb3J0cy50c0FueUtleXdvcmQgPSB0c0FueUtleXdvcmQ7XG5leHBvcnRzLnRTQm9vbGVhbktleXdvcmQgPSBleHBvcnRzLlRTQm9vbGVhbktleXdvcmQgPSBleHBvcnRzLnRzQm9vbGVhbktleXdvcmQgPSB0c0Jvb2xlYW5LZXl3b3JkO1xuZXhwb3J0cy50U0JpZ0ludEtleXdvcmQgPSBleHBvcnRzLlRTQmlnSW50S2V5d29yZCA9IGV4cG9ydHMudHNCaWdJbnRLZXl3b3JkID0gdHNCaWdJbnRLZXl3b3JkO1xuZXhwb3J0cy50U05ldmVyS2V5d29yZCA9IGV4cG9ydHMuVFNOZXZlcktleXdvcmQgPSBleHBvcnRzLnRzTmV2ZXJLZXl3b3JkID0gdHNOZXZlcktleXdvcmQ7XG5leHBvcnRzLnRTTnVsbEtleXdvcmQgPSBleHBvcnRzLlRTTnVsbEtleXdvcmQgPSBleHBvcnRzLnRzTnVsbEtleXdvcmQgPSB0c051bGxLZXl3b3JkO1xuZXhwb3J0cy50U051bWJlcktleXdvcmQgPSBleHBvcnRzLlRTTnVtYmVyS2V5d29yZCA9IGV4cG9ydHMudHNOdW1iZXJLZXl3b3JkID0gdHNOdW1iZXJLZXl3b3JkO1xuZXhwb3J0cy50U09iamVjdEtleXdvcmQgPSBleHBvcnRzLlRTT2JqZWN0S2V5d29yZCA9IGV4cG9ydHMudHNPYmplY3RLZXl3b3JkID0gdHNPYmplY3RLZXl3b3JkO1xuZXhwb3J0cy50U1N0cmluZ0tleXdvcmQgPSBleHBvcnRzLlRTU3RyaW5nS2V5d29yZCA9IGV4cG9ydHMudHNTdHJpbmdLZXl3b3JkID0gdHNTdHJpbmdLZXl3b3JkO1xuZXhwb3J0cy50U1N5bWJvbEtleXdvcmQgPSBleHBvcnRzLlRTU3ltYm9sS2V5d29yZCA9IGV4cG9ydHMudHNTeW1ib2xLZXl3b3JkID0gdHNTeW1ib2xLZXl3b3JkO1xuZXhwb3J0cy50U1VuZGVmaW5lZEtleXdvcmQgPSBleHBvcnRzLlRTVW5kZWZpbmVkS2V5d29yZCA9IGV4cG9ydHMudHNVbmRlZmluZWRLZXl3b3JkID0gdHNVbmRlZmluZWRLZXl3b3JkO1xuZXhwb3J0cy50U1Vua25vd25LZXl3b3JkID0gZXhwb3J0cy5UU1Vua25vd25LZXl3b3JkID0gZXhwb3J0cy50c1Vua25vd25LZXl3b3JkID0gdHNVbmtub3duS2V5d29yZDtcbmV4cG9ydHMudFNWb2lkS2V5d29yZCA9IGV4cG9ydHMuVFNWb2lkS2V5d29yZCA9IGV4cG9ydHMudHNWb2lkS2V5d29yZCA9IHRzVm9pZEtleXdvcmQ7XG5leHBvcnRzLnRTVGhpc1R5cGUgPSBleHBvcnRzLlRTVGhpc1R5cGUgPSBleHBvcnRzLnRzVGhpc1R5cGUgPSB0c1RoaXNUeXBlO1xuZXhwb3J0cy50U0Z1bmN0aW9uVHlwZSA9IGV4cG9ydHMuVFNGdW5jdGlvblR5cGUgPSBleHBvcnRzLnRzRnVuY3Rpb25UeXBlID0gdHNGdW5jdGlvblR5cGU7XG5leHBvcnRzLnRTQ29uc3RydWN0b3JUeXBlID0gZXhwb3J0cy5UU0NvbnN0cnVjdG9yVHlwZSA9IGV4cG9ydHMudHNDb25zdHJ1Y3RvclR5cGUgPSB0c0NvbnN0cnVjdG9yVHlwZTtcbmV4cG9ydHMudFNUeXBlUmVmZXJlbmNlID0gZXhwb3J0cy5UU1R5cGVSZWZlcmVuY2UgPSBleHBvcnRzLnRzVHlwZVJlZmVyZW5jZSA9IHRzVHlwZVJlZmVyZW5jZTtcbmV4cG9ydHMudFNUeXBlUHJlZGljYXRlID0gZXhwb3J0cy5UU1R5cGVQcmVkaWNhdGUgPSBleHBvcnRzLnRzVHlwZVByZWRpY2F0ZSA9IHRzVHlwZVByZWRpY2F0ZTtcbmV4cG9ydHMudFNUeXBlUXVlcnkgPSBleHBvcnRzLlRTVHlwZVF1ZXJ5ID0gZXhwb3J0cy50c1R5cGVRdWVyeSA9IHRzVHlwZVF1ZXJ5O1xuZXhwb3J0cy50U1R5cGVMaXRlcmFsID0gZXhwb3J0cy5UU1R5cGVMaXRlcmFsID0gZXhwb3J0cy50c1R5cGVMaXRlcmFsID0gdHNUeXBlTGl0ZXJhbDtcbmV4cG9ydHMudFNBcnJheVR5cGUgPSBleHBvcnRzLlRTQXJyYXlUeXBlID0gZXhwb3J0cy50c0FycmF5VHlwZSA9IHRzQXJyYXlUeXBlO1xuZXhwb3J0cy50U1R1cGxlVHlwZSA9IGV4cG9ydHMuVFNUdXBsZVR5cGUgPSBleHBvcnRzLnRzVHVwbGVUeXBlID0gdHNUdXBsZVR5cGU7XG5leHBvcnRzLnRTT3B0aW9uYWxUeXBlID0gZXhwb3J0cy5UU09wdGlvbmFsVHlwZSA9IGV4cG9ydHMudHNPcHRpb25hbFR5cGUgPSB0c09wdGlvbmFsVHlwZTtcbmV4cG9ydHMudFNSZXN0VHlwZSA9IGV4cG9ydHMuVFNSZXN0VHlwZSA9IGV4cG9ydHMudHNSZXN0VHlwZSA9IHRzUmVzdFR5cGU7XG5leHBvcnRzLnRTTmFtZWRUdXBsZU1lbWJlciA9IGV4cG9ydHMuVFNOYW1lZFR1cGxlTWVtYmVyID0gZXhwb3J0cy50c05hbWVkVHVwbGVNZW1iZXIgPSB0c05hbWVkVHVwbGVNZW1iZXI7XG5leHBvcnRzLnRTVW5pb25UeXBlID0gZXhwb3J0cy5UU1VuaW9uVHlwZSA9IGV4cG9ydHMudHNVbmlvblR5cGUgPSB0c1VuaW9uVHlwZTtcbmV4cG9ydHMudFNJbnRlcnNlY3Rpb25UeXBlID0gZXhwb3J0cy5UU0ludGVyc2VjdGlvblR5cGUgPSBleHBvcnRzLnRzSW50ZXJzZWN0aW9uVHlwZSA9IHRzSW50ZXJzZWN0aW9uVHlwZTtcbmV4cG9ydHMudFNDb25kaXRpb25hbFR5cGUgPSBleHBvcnRzLlRTQ29uZGl0aW9uYWxUeXBlID0gZXhwb3J0cy50c0NvbmRpdGlvbmFsVHlwZSA9IHRzQ29uZGl0aW9uYWxUeXBlO1xuZXhwb3J0cy50U0luZmVyVHlwZSA9IGV4cG9ydHMuVFNJbmZlclR5cGUgPSBleHBvcnRzLnRzSW5mZXJUeXBlID0gdHNJbmZlclR5cGU7XG5leHBvcnRzLnRTUGFyZW50aGVzaXplZFR5cGUgPSBleHBvcnRzLlRTUGFyZW50aGVzaXplZFR5cGUgPSBleHBvcnRzLnRzUGFyZW50aGVzaXplZFR5cGUgPSB0c1BhcmVudGhlc2l6ZWRUeXBlO1xuZXhwb3J0cy50U1R5cGVPcGVyYXRvciA9IGV4cG9ydHMuVFNUeXBlT3BlcmF0b3IgPSBleHBvcnRzLnRzVHlwZU9wZXJhdG9yID0gdHNUeXBlT3BlcmF0b3I7XG5leHBvcnRzLnRTSW5kZXhlZEFjY2Vzc1R5cGUgPSBleHBvcnRzLlRTSW5kZXhlZEFjY2Vzc1R5cGUgPSBleHBvcnRzLnRzSW5kZXhlZEFjY2Vzc1R5cGUgPSB0c0luZGV4ZWRBY2Nlc3NUeXBlO1xuZXhwb3J0cy50U01hcHBlZFR5cGUgPSBleHBvcnRzLlRTTWFwcGVkVHlwZSA9IGV4cG9ydHMudHNNYXBwZWRUeXBlID0gdHNNYXBwZWRUeXBlO1xuZXhwb3J0cy50U0xpdGVyYWxUeXBlID0gZXhwb3J0cy5UU0xpdGVyYWxUeXBlID0gZXhwb3J0cy50c0xpdGVyYWxUeXBlID0gdHNMaXRlcmFsVHlwZTtcbmV4cG9ydHMudFNFeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHMgPSBleHBvcnRzLlRTRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzID0gZXhwb3J0cy50c0V4cHJlc3Npb25XaXRoVHlwZUFyZ3VtZW50cyA9IHRzRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzO1xuZXhwb3J0cy50U0ludGVyZmFjZURlY2xhcmF0aW9uID0gZXhwb3J0cy5UU0ludGVyZmFjZURlY2xhcmF0aW9uID0gZXhwb3J0cy50c0ludGVyZmFjZURlY2xhcmF0aW9uID0gdHNJbnRlcmZhY2VEZWNsYXJhdGlvbjtcbmV4cG9ydHMudFNJbnRlcmZhY2VCb2R5ID0gZXhwb3J0cy5UU0ludGVyZmFjZUJvZHkgPSBleHBvcnRzLnRzSW50ZXJmYWNlQm9keSA9IHRzSW50ZXJmYWNlQm9keTtcbmV4cG9ydHMudFNUeXBlQWxpYXNEZWNsYXJhdGlvbiA9IGV4cG9ydHMuVFNUeXBlQWxpYXNEZWNsYXJhdGlvbiA9IGV4cG9ydHMudHNUeXBlQWxpYXNEZWNsYXJhdGlvbiA9IHRzVHlwZUFsaWFzRGVjbGFyYXRpb247XG5leHBvcnRzLnRTQXNFeHByZXNzaW9uID0gZXhwb3J0cy5UU0FzRXhwcmVzc2lvbiA9IGV4cG9ydHMudHNBc0V4cHJlc3Npb24gPSB0c0FzRXhwcmVzc2lvbjtcbmV4cG9ydHMudFNUeXBlQXNzZXJ0aW9uID0gZXhwb3J0cy5UU1R5cGVBc3NlcnRpb24gPSBleHBvcnRzLnRzVHlwZUFzc2VydGlvbiA9IHRzVHlwZUFzc2VydGlvbjtcbmV4cG9ydHMudFNFbnVtRGVjbGFyYXRpb24gPSBleHBvcnRzLlRTRW51bURlY2xhcmF0aW9uID0gZXhwb3J0cy50c0VudW1EZWNsYXJhdGlvbiA9IHRzRW51bURlY2xhcmF0aW9uO1xuZXhwb3J0cy50U0VudW1NZW1iZXIgPSBleHBvcnRzLlRTRW51bU1lbWJlciA9IGV4cG9ydHMudHNFbnVtTWVtYmVyID0gdHNFbnVtTWVtYmVyO1xuZXhwb3J0cy50U01vZHVsZURlY2xhcmF0aW9uID0gZXhwb3J0cy5UU01vZHVsZURlY2xhcmF0aW9uID0gZXhwb3J0cy50c01vZHVsZURlY2xhcmF0aW9uID0gdHNNb2R1bGVEZWNsYXJhdGlvbjtcbmV4cG9ydHMudFNNb2R1bGVCbG9jayA9IGV4cG9ydHMuVFNNb2R1bGVCbG9jayA9IGV4cG9ydHMudHNNb2R1bGVCbG9jayA9IHRzTW9kdWxlQmxvY2s7XG5leHBvcnRzLnRTSW1wb3J0VHlwZSA9IGV4cG9ydHMuVFNJbXBvcnRUeXBlID0gZXhwb3J0cy50c0ltcG9ydFR5cGUgPSB0c0ltcG9ydFR5cGU7XG5leHBvcnRzLnRTSW1wb3J0RXF1YWxzRGVjbGFyYXRpb24gPSBleHBvcnRzLlRTSW1wb3J0RXF1YWxzRGVjbGFyYXRpb24gPSBleHBvcnRzLnRzSW1wb3J0RXF1YWxzRGVjbGFyYXRpb24gPSB0c0ltcG9ydEVxdWFsc0RlY2xhcmF0aW9uO1xuZXhwb3J0cy50U0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlID0gZXhwb3J0cy5UU0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlID0gZXhwb3J0cy50c0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlID0gdHNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZTtcbmV4cG9ydHMudFNOb25OdWxsRXhwcmVzc2lvbiA9IGV4cG9ydHMuVFNOb25OdWxsRXhwcmVzc2lvbiA9IGV4cG9ydHMudHNOb25OdWxsRXhwcmVzc2lvbiA9IHRzTm9uTnVsbEV4cHJlc3Npb247XG5leHBvcnRzLnRTRXhwb3J0QXNzaWdubWVudCA9IGV4cG9ydHMuVFNFeHBvcnRBc3NpZ25tZW50ID0gZXhwb3J0cy50c0V4cG9ydEFzc2lnbm1lbnQgPSB0c0V4cG9ydEFzc2lnbm1lbnQ7XG5leHBvcnRzLnRTTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb24gPSBleHBvcnRzLlRTTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb24gPSBleHBvcnRzLnRzTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb24gPSB0c05hbWVzcGFjZUV4cG9ydERlY2xhcmF0aW9uO1xuZXhwb3J0cy50U1R5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5UU1R5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy50c1R5cGVBbm5vdGF0aW9uID0gdHNUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMudFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbiA9IGV4cG9ydHMuVFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbiA9IGV4cG9ydHMudHNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbiA9IHRzVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb247XG5leHBvcnRzLnRTVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uID0gZXhwb3J0cy5UU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbiA9IGV4cG9ydHMudHNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24gPSB0c1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbjtcbmV4cG9ydHMudFNUeXBlUGFyYW1ldGVyID0gZXhwb3J0cy5UU1R5cGVQYXJhbWV0ZXIgPSBleHBvcnRzLnRzVHlwZVBhcmFtZXRlciA9IHRzVHlwZVBhcmFtZXRlcjtcbmV4cG9ydHMubnVtYmVyTGl0ZXJhbCA9IGV4cG9ydHMuTnVtYmVyTGl0ZXJhbCA9IE51bWJlckxpdGVyYWw7XG5leHBvcnRzLnJlZ2V4TGl0ZXJhbCA9IGV4cG9ydHMuUmVnZXhMaXRlcmFsID0gUmVnZXhMaXRlcmFsO1xuZXhwb3J0cy5yZXN0UHJvcGVydHkgPSBleHBvcnRzLlJlc3RQcm9wZXJ0eSA9IFJlc3RQcm9wZXJ0eTtcbmV4cG9ydHMuc3ByZWFkUHJvcGVydHkgPSBleHBvcnRzLlNwcmVhZFByb3BlcnR5ID0gU3ByZWFkUHJvcGVydHk7XG5cbnZhciBfYnVpbGRlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2J1aWxkZXJcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBhcnJheUV4cHJlc3Npb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiQXJyYXlFeHByZXNzaW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBhc3NpZ25tZW50RXhwcmVzc2lvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gYmluYXJ5RXhwcmVzc2lvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJCaW5hcnlFeHByZXNzaW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBpbnRlcnByZXRlckRpcmVjdGl2ZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJJbnRlcnByZXRlckRpcmVjdGl2ZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZGlyZWN0aXZlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkRpcmVjdGl2ZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZGlyZWN0aXZlTGl0ZXJhbCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJEaXJlY3RpdmVMaXRlcmFsXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBibG9ja1N0YXRlbWVudCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJCbG9ja1N0YXRlbWVudFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gYnJlYWtTdGF0ZW1lbnQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiQnJlYWtTdGF0ZW1lbnRcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGNhbGxFeHByZXNzaW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkNhbGxFeHByZXNzaW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBjYXRjaENsYXVzZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJDYXRjaENsYXVzZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gY29uZGl0aW9uYWxFeHByZXNzaW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gY29udGludWVTdGF0ZW1lbnQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiQ29udGludWVTdGF0ZW1lbnRcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGRlYnVnZ2VyU3RhdGVtZW50KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkRlYnVnZ2VyU3RhdGVtZW50XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBkb1doaWxlU3RhdGVtZW50KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkRvV2hpbGVTdGF0ZW1lbnRcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGVtcHR5U3RhdGVtZW50KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkVtcHR5U3RhdGVtZW50XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBleHByZXNzaW9uU3RhdGVtZW50KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGZpbGUoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRmlsZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZm9ySW5TdGF0ZW1lbnQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRm9ySW5TdGF0ZW1lbnRcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGZvclN0YXRlbWVudCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJGb3JTdGF0ZW1lbnRcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGZ1bmN0aW9uRGVjbGFyYXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZnVuY3Rpb25FeHByZXNzaW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkZ1bmN0aW9uRXhwcmVzc2lvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gaWRlbnRpZmllciguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJJZGVudGlmaWVyXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBpZlN0YXRlbWVudCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJJZlN0YXRlbWVudFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gbGFiZWxlZFN0YXRlbWVudCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJMYWJlbGVkU3RhdGVtZW50XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdMaXRlcmFsKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlN0cmluZ0xpdGVyYWxcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIG51bWVyaWNMaXRlcmFsKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIk51bWVyaWNMaXRlcmFsXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBudWxsTGl0ZXJhbCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJOdWxsTGl0ZXJhbFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gYm9vbGVhbkxpdGVyYWwoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiQm9vbGVhbkxpdGVyYWxcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHJlZ0V4cExpdGVyYWwoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiUmVnRXhwTGl0ZXJhbFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gbG9naWNhbEV4cHJlc3Npb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiTG9naWNhbEV4cHJlc3Npb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIG1lbWJlckV4cHJlc3Npb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiTWVtYmVyRXhwcmVzc2lvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gbmV3RXhwcmVzc2lvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJOZXdFeHByZXNzaW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBwcm9ncmFtKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlByb2dyYW1cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIG9iamVjdEV4cHJlc3Npb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiT2JqZWN0RXhwcmVzc2lvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gb2JqZWN0TWV0aG9kKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIk9iamVjdE1ldGhvZFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gb2JqZWN0UHJvcGVydHkoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiT2JqZWN0UHJvcGVydHlcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHJlc3RFbGVtZW50KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlJlc3RFbGVtZW50XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiByZXR1cm5TdGF0ZW1lbnQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiUmV0dXJuU3RhdGVtZW50XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBzZXF1ZW5jZUV4cHJlc3Npb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiU2VxdWVuY2VFeHByZXNzaW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBwYXJlbnRoZXNpemVkRXhwcmVzc2lvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gc3dpdGNoQ2FzZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJTd2l0Y2hDYXNlXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBzd2l0Y2hTdGF0ZW1lbnQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiU3dpdGNoU3RhdGVtZW50XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0aGlzRXhwcmVzc2lvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUaGlzRXhwcmVzc2lvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdGhyb3dTdGF0ZW1lbnQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVGhyb3dTdGF0ZW1lbnRcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRyeVN0YXRlbWVudCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUcnlTdGF0ZW1lbnRcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHVuYXJ5RXhwcmVzc2lvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJVbmFyeUV4cHJlc3Npb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUV4cHJlc3Npb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVXBkYXRlRXhwcmVzc2lvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdmFyaWFibGVEZWNsYXJhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB2YXJpYWJsZURlY2xhcmF0b3IoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVmFyaWFibGVEZWNsYXJhdG9yXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB3aGlsZVN0YXRlbWVudCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJXaGlsZVN0YXRlbWVudFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gd2l0aFN0YXRlbWVudCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJXaXRoU3RhdGVtZW50XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBhc3NpZ25tZW50UGF0dGVybiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJBc3NpZ25tZW50UGF0dGVyblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gYXJyYXlQYXR0ZXJuKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkFycmF5UGF0dGVyblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gYXJyb3dGdW5jdGlvbkV4cHJlc3Npb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGNsYXNzQm9keSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJDbGFzc0JvZHlcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGNsYXNzRXhwcmVzc2lvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJDbGFzc0V4cHJlc3Npb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGNsYXNzRGVjbGFyYXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiQ2xhc3NEZWNsYXJhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZXhwb3J0QWxsRGVjbGFyYXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGV4cG9ydERlZmF1bHREZWNsYXJhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGV4cG9ydE5hbWVkRGVjbGFyYXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZXhwb3J0U3BlY2lmaWVyKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkV4cG9ydFNwZWNpZmllclwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZm9yT2ZTdGF0ZW1lbnQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRm9yT2ZTdGF0ZW1lbnRcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGltcG9ydERlY2xhcmF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkltcG9ydERlY2xhcmF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBpbXBvcnREZWZhdWx0U3BlY2lmaWVyKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGltcG9ydE5hbWVzcGFjZVNwZWNpZmllciguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGltcG9ydFNwZWNpZmllciguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJJbXBvcnRTcGVjaWZpZXJcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIG1ldGFQcm9wZXJ0eSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJNZXRhUHJvcGVydHlcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGNsYXNzTWV0aG9kKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkNsYXNzTWV0aG9kXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBvYmplY3RQYXR0ZXJuKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIk9iamVjdFBhdHRlcm5cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHNwcmVhZEVsZW1lbnQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiU3ByZWFkRWxlbWVudFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gX3N1cGVyKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlN1cGVyXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0YWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0ZW1wbGF0ZUVsZW1lbnQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVGVtcGxhdGVFbGVtZW50XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0ZW1wbGF0ZUxpdGVyYWwoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVGVtcGxhdGVMaXRlcmFsXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB5aWVsZEV4cHJlc3Npb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiWWllbGRFeHByZXNzaW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBhd2FpdEV4cHJlc3Npb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiQXdhaXRFeHByZXNzaW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBfaW1wb3J0KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkltcG9ydFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gYmlnSW50TGl0ZXJhbCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJCaWdJbnRMaXRlcmFsXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBleHBvcnROYW1lc3BhY2VTcGVjaWZpZXIoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBvcHRpb25hbE1lbWJlckV4cHJlc3Npb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBvcHRpb25hbENhbGxFeHByZXNzaW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGFueVR5cGVBbm5vdGF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkFueVR5cGVBbm5vdGF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBhcnJheVR5cGVBbm5vdGF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkFycmF5VHlwZUFubm90YXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGJvb2xlYW5UeXBlQW5ub3RhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJCb29sZWFuVHlwZUFubm90YXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGJvb2xlYW5MaXRlcmFsVHlwZUFubm90YXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiQm9vbGVhbkxpdGVyYWxUeXBlQW5ub3RhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gbnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJOdWxsTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBjbGFzc0ltcGxlbWVudHMoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiQ2xhc3NJbXBsZW1lbnRzXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBkZWNsYXJlQ2xhc3MoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRGVjbGFyZUNsYXNzXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBkZWNsYXJlRnVuY3Rpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRGVjbGFyZUZ1bmN0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBkZWNsYXJlSW50ZXJmYWNlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkRlY2xhcmVJbnRlcmZhY2VcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGRlY2xhcmVNb2R1bGUoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRGVjbGFyZU1vZHVsZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZGVjbGFyZU1vZHVsZUV4cG9ydHMoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRGVjbGFyZU1vZHVsZUV4cG9ydHNcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGRlY2xhcmVUeXBlQWxpYXMoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRGVjbGFyZVR5cGVBbGlhc1wiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZGVjbGFyZU9wYXF1ZVR5cGUoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRGVjbGFyZU9wYXF1ZVR5cGVcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGRlY2xhcmVWYXJpYWJsZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJEZWNsYXJlVmFyaWFibGVcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGRlY2xhcmVFeHBvcnREZWNsYXJhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGRlY2xhcmVFeHBvcnRBbGxEZWNsYXJhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJEZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGRlY2xhcmVkUHJlZGljYXRlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkRlY2xhcmVkUHJlZGljYXRlXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBleGlzdHNUeXBlQW5ub3RhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJFeGlzdHNUeXBlQW5ub3RhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZnVuY3Rpb25UeXBlQW5ub3RhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBmdW5jdGlvblR5cGVQYXJhbSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJGdW5jdGlvblR5cGVQYXJhbVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJpY1R5cGVBbm5vdGF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkdlbmVyaWNUeXBlQW5ub3RhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gaW5mZXJyZWRQcmVkaWNhdGUoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiSW5mZXJyZWRQcmVkaWNhdGVcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGludGVyZmFjZUV4dGVuZHMoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiSW50ZXJmYWNlRXh0ZW5kc1wiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJmYWNlRGVjbGFyYXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiSW50ZXJmYWNlRGVjbGFyYXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGludGVyZmFjZVR5cGVBbm5vdGF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkludGVyZmFjZVR5cGVBbm5vdGF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gbWl4ZWRUeXBlQW5ub3RhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJNaXhlZFR5cGVBbm5vdGF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBlbXB0eVR5cGVBbm5vdGF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkVtcHR5VHlwZUFubm90YXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIG51bGxhYmxlVHlwZUFubm90YXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiTnVsbGFibGVUeXBlQW5ub3RhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gbnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIk51bWJlckxpdGVyYWxUeXBlQW5ub3RhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gbnVtYmVyVHlwZUFubm90YXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiTnVtYmVyVHlwZUFubm90YXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIG9iamVjdFR5cGVBbm5vdGF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIk9iamVjdFR5cGVBbm5vdGF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBvYmplY3RUeXBlSW50ZXJuYWxTbG90KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIk9iamVjdFR5cGVJbnRlcm5hbFNsb3RcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIG9iamVjdFR5cGVDYWxsUHJvcGVydHkoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gb2JqZWN0VHlwZUluZGV4ZXIoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiT2JqZWN0VHlwZUluZGV4ZXJcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIG9iamVjdFR5cGVQcm9wZXJ0eSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJPYmplY3RUeXBlUHJvcGVydHlcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIG9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJPYmplY3RUeXBlU3ByZWFkUHJvcGVydHlcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIG9wYXF1ZVR5cGUoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiT3BhcXVlVHlwZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gcXVhbGlmaWVkVHlwZUlkZW50aWZpZXIoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiUXVhbGlmaWVkVHlwZUlkZW50aWZpZXJcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ0xpdGVyYWxUeXBlQW5ub3RhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJTdHJpbmdMaXRlcmFsVHlwZUFubm90YXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ1R5cGVBbm5vdGF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlN0cmluZ1R5cGVBbm5vdGF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBzeW1ib2xUeXBlQW5ub3RhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJTeW1ib2xUeXBlQW5ub3RhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdGhpc1R5cGVBbm5vdGF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRoaXNUeXBlQW5ub3RhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHVwbGVUeXBlQW5ub3RhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUdXBsZVR5cGVBbm5vdGF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0eXBlb2ZUeXBlQW5ub3RhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUeXBlb2ZUeXBlQW5ub3RhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHlwZUFsaWFzKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlR5cGVBbGlhc1wiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHlwZUFubm90YXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVHlwZUFubm90YXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHR5cGVDYXN0RXhwcmVzc2lvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUeXBlQ2FzdEV4cHJlc3Npb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHR5cGVQYXJhbWV0ZXIoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVHlwZVBhcmFtZXRlclwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHVuaW9uVHlwZUFubm90YXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVW5pb25UeXBlQW5ub3RhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdmFyaWFuY2UoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVmFyaWFuY2VcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHZvaWRUeXBlQW5ub3RhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJWb2lkVHlwZUFubm90YXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGVudW1EZWNsYXJhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJFbnVtRGVjbGFyYXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGVudW1Cb29sZWFuQm9keSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJFbnVtQm9vbGVhbkJvZHlcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGVudW1OdW1iZXJCb2R5KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkVudW1OdW1iZXJCb2R5XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBlbnVtU3RyaW5nQm9keSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJFbnVtU3RyaW5nQm9keVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZW51bVN5bWJvbEJvZHkoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRW51bVN5bWJvbEJvZHlcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGVudW1Cb29sZWFuTWVtYmVyKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkVudW1Cb29sZWFuTWVtYmVyXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBlbnVtTnVtYmVyTWVtYmVyKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkVudW1OdW1iZXJNZW1iZXJcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGVudW1TdHJpbmdNZW1iZXIoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRW51bVN0cmluZ01lbWJlclwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gZW51bURlZmF1bHRlZE1lbWJlciguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJFbnVtRGVmYXVsdGVkTWVtYmVyXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBqc3hBdHRyaWJ1dGUoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiSlNYQXR0cmlidXRlXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBqc3hDbG9zaW5nRWxlbWVudCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJKU1hDbG9zaW5nRWxlbWVudFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24ganN4RWxlbWVudCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJKU1hFbGVtZW50XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBqc3hFbXB0eUV4cHJlc3Npb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiSlNYRW1wdHlFeHByZXNzaW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBqc3hFeHByZXNzaW9uQ29udGFpbmVyKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkpTWEV4cHJlc3Npb25Db250YWluZXJcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGpzeFNwcmVhZENoaWxkKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkpTWFNwcmVhZENoaWxkXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBqc3hJZGVudGlmaWVyKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkpTWElkZW50aWZpZXJcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGpzeE1lbWJlckV4cHJlc3Npb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiSlNYTWVtYmVyRXhwcmVzc2lvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24ganN4TmFtZXNwYWNlZE5hbWUoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiSlNYTmFtZXNwYWNlZE5hbWVcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGpzeE9wZW5pbmdFbGVtZW50KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkpTWE9wZW5pbmdFbGVtZW50XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBqc3hTcHJlYWRBdHRyaWJ1dGUoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiSlNYU3ByZWFkQXR0cmlidXRlXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBqc3hUZXh0KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkpTWFRleHRcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGpzeEZyYWdtZW50KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkpTWEZyYWdtZW50XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBqc3hPcGVuaW5nRnJhZ21lbnQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiSlNYT3BlbmluZ0ZyYWdtZW50XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBqc3hDbG9zaW5nRnJhZ21lbnQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiSlNYQ2xvc2luZ0ZyYWdtZW50XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBub29wKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIk5vb3BcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlBsYWNlaG9sZGVyXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB2OEludHJpbnNpY0lkZW50aWZpZXIoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVjhJbnRyaW5zaWNJZGVudGlmaWVyXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBhcmd1bWVudFBsYWNlaG9sZGVyKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkFyZ3VtZW50UGxhY2Vob2xkZXJcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGJpbmRFeHByZXNzaW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkJpbmRFeHByZXNzaW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBjbGFzc1Byb3BlcnR5KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkNsYXNzUHJvcGVydHlcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHBpcGVsaW5lVG9waWNFeHByZXNzaW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlBpcGVsaW5lVG9waWNFeHByZXNzaW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBwaXBlbGluZUJhcmVGdW5jdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJQaXBlbGluZUJhcmVGdW5jdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gcGlwZWxpbmVQcmltYXJ5VG9waWNSZWZlcmVuY2UoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiUGlwZWxpbmVQcmltYXJ5VG9waWNSZWZlcmVuY2VcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGNsYXNzUHJpdmF0ZVByb3BlcnR5KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkNsYXNzUHJpdmF0ZVByb3BlcnR5XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBjbGFzc1ByaXZhdGVNZXRob2QoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiQ2xhc3NQcml2YXRlTWV0aG9kXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBpbXBvcnRBdHRyaWJ1dGUoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiSW1wb3J0QXR0cmlidXRlXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBkZWNvcmF0b3IoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRGVjb3JhdG9yXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBkb0V4cHJlc3Npb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiRG9FeHByZXNzaW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBleHBvcnREZWZhdWx0U3BlY2lmaWVyKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkV4cG9ydERlZmF1bHRTcGVjaWZpZXJcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHByaXZhdGVOYW1lKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlByaXZhdGVOYW1lXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiByZWNvcmRFeHByZXNzaW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlJlY29yZEV4cHJlc3Npb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHR1cGxlRXhwcmVzc2lvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUdXBsZUV4cHJlc3Npb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGRlY2ltYWxMaXRlcmFsKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIkRlY2ltYWxMaXRlcmFsXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c1BhcmFtZXRlclByb3BlcnR5KC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTUGFyYW1ldGVyUHJvcGVydHlcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzRGVjbGFyZUZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTRGVjbGFyZUZ1bmN0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c0RlY2xhcmVNZXRob2QoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNEZWNsYXJlTWV0aG9kXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c1F1YWxpZmllZE5hbWUoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNRdWFsaWZpZWROYW1lXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU0NvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c1Byb3BlcnR5U2lnbmF0dXJlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTUHJvcGVydHlTaWduYXR1cmVcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzTWV0aG9kU2lnbmF0dXJlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTTWV0aG9kU2lnbmF0dXJlXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c0luZGV4U2lnbmF0dXJlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTSW5kZXhTaWduYXR1cmVcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzQW55S2V5d29yZCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU0FueUtleXdvcmRcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzQm9vbGVhbktleXdvcmQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNCb29sZWFuS2V5d29yZFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNCaWdJbnRLZXl3b3JkKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTQmlnSW50S2V5d29yZFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNOZXZlcktleXdvcmQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNOZXZlcktleXdvcmRcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzTnVsbEtleXdvcmQoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNOdWxsS2V5d29yZFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNOdW1iZXJLZXl3b3JkKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTTnVtYmVyS2V5d29yZFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNPYmplY3RLZXl3b3JkKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTT2JqZWN0S2V5d29yZFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNTdHJpbmdLZXl3b3JkKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTU3RyaW5nS2V5d29yZFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNTeW1ib2xLZXl3b3JkKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTU3ltYm9sS2V5d29yZFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNVbmRlZmluZWRLZXl3b3JkKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTVW5kZWZpbmVkS2V5d29yZFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNVbmtub3duS2V5d29yZCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU1Vua25vd25LZXl3b3JkXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c1ZvaWRLZXl3b3JkKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTVm9pZEtleXdvcmRcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzVGhpc1R5cGUoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNUaGlzVHlwZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNGdW5jdGlvblR5cGUoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNGdW5jdGlvblR5cGVcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzQ29uc3RydWN0b3JUeXBlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTQ29uc3RydWN0b3JUeXBlXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c1R5cGVSZWZlcmVuY2UoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNUeXBlUmVmZXJlbmNlXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c1R5cGVQcmVkaWNhdGUoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNUeXBlUHJlZGljYXRlXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c1R5cGVRdWVyeSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU1R5cGVRdWVyeVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNUeXBlTGl0ZXJhbCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU1R5cGVMaXRlcmFsXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c0FycmF5VHlwZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU0FycmF5VHlwZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNUdXBsZVR5cGUoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNUdXBsZVR5cGVcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzT3B0aW9uYWxUeXBlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTT3B0aW9uYWxUeXBlXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c1Jlc3RUeXBlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTUmVzdFR5cGVcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzTmFtZWRUdXBsZU1lbWJlciguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU05hbWVkVHVwbGVNZW1iZXJcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzVW5pb25UeXBlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTVW5pb25UeXBlXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c0ludGVyc2VjdGlvblR5cGUoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNJbnRlcnNlY3Rpb25UeXBlXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c0NvbmRpdGlvbmFsVHlwZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU0NvbmRpdGlvbmFsVHlwZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNJbmZlclR5cGUoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNJbmZlclR5cGVcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzUGFyZW50aGVzaXplZFR5cGUoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNQYXJlbnRoZXNpemVkVHlwZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNUeXBlT3BlcmF0b3IoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNUeXBlT3BlcmF0b3JcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzSW5kZXhlZEFjY2Vzc1R5cGUoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNJbmRleGVkQWNjZXNzVHlwZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNNYXBwZWRUeXBlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTTWFwcGVkVHlwZVwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNMaXRlcmFsVHlwZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU0xpdGVyYWxUeXBlXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c0V4cHJlc3Npb25XaXRoVHlwZUFyZ3VtZW50cyguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU0V4cHJlc3Npb25XaXRoVHlwZUFyZ3VtZW50c1wiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNJbnRlcmZhY2VEZWNsYXJhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU0ludGVyZmFjZURlY2xhcmF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c0ludGVyZmFjZUJvZHkoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNJbnRlcmZhY2VCb2R5XCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c1R5cGVBbGlhc0RlY2xhcmF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTVHlwZUFsaWFzRGVjbGFyYXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzQXNFeHByZXNzaW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTQXNFeHByZXNzaW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c1R5cGVBc3NlcnRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNUeXBlQXNzZXJ0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c0VudW1EZWNsYXJhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU0VudW1EZWNsYXJhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNFbnVtTWVtYmVyKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTRW51bU1lbWJlclwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNNb2R1bGVEZWNsYXJhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU01vZHVsZURlY2xhcmF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c01vZHVsZUJsb2NrKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTTW9kdWxlQmxvY2tcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzSW1wb3J0VHlwZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU0ltcG9ydFR5cGVcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzSW1wb3J0RXF1YWxzRGVjbGFyYXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZSguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c05vbk51bGxFeHByZXNzaW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTTm9uTnVsbEV4cHJlc3Npb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzRXhwb3J0QXNzaWdubWVudCguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU0V4cG9ydEFzc2lnbm1lbnRcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb24oLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNOYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvblwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gdHNUeXBlQW5ub3RhdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJUU1R5cGVBbm5vdGF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIHRzVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKC4uLmFyZ3MpIHtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlRTVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiB0c1R5cGVQYXJhbWV0ZXIoLi4uYXJncykge1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiVFNUeXBlUGFyYW1ldGVyXCIsIC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBOdW1iZXJMaXRlcmFsKC4uLmFyZ3MpIHtcbiAgY29uc29sZS50cmFjZShcIlRoZSBub2RlIHR5cGUgTnVtYmVyTGl0ZXJhbCBoYXMgYmVlbiByZW5hbWVkIHRvIE51bWVyaWNMaXRlcmFsXCIpO1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiTnVtYmVyTGl0ZXJhbFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gUmVnZXhMaXRlcmFsKC4uLmFyZ3MpIHtcbiAgY29uc29sZS50cmFjZShcIlRoZSBub2RlIHR5cGUgUmVnZXhMaXRlcmFsIGhhcyBiZWVuIHJlbmFtZWQgdG8gUmVnRXhwTGl0ZXJhbFwiKTtcbiAgcmV0dXJuICgwLCBfYnVpbGRlci5kZWZhdWx0KShcIlJlZ2V4TGl0ZXJhbFwiLCAuLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gUmVzdFByb3BlcnR5KC4uLmFyZ3MpIHtcbiAgY29uc29sZS50cmFjZShcIlRoZSBub2RlIHR5cGUgUmVzdFByb3BlcnR5IGhhcyBiZWVuIHJlbmFtZWQgdG8gUmVzdEVsZW1lbnRcIik7XG4gIHJldHVybiAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoXCJSZXN0UHJvcGVydHlcIiwgLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIFNwcmVhZFByb3BlcnR5KC4uLmFyZ3MpIHtcbiAgY29uc29sZS50cmFjZShcIlRoZSBub2RlIHR5cGUgU3ByZWFkUHJvcGVydHkgaGFzIGJlZW4gcmVuYW1lZCB0byBTcHJlYWRFbGVtZW50XCIpO1xuICByZXR1cm4gKDAsIF9idWlsZGVyLmRlZmF1bHQpKFwiU3ByZWFkUHJvcGVydHlcIiwgLi4uYXJncyk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBidWlsZENoaWxkcmVuO1xuXG52YXIgX2dlbmVyYXRlZCA9IHJlcXVpcmUoXCIuLi8uLi92YWxpZGF0b3JzL2dlbmVyYXRlZFwiKTtcblxudmFyIF9jbGVhbkpTWEVsZW1lbnRMaXRlcmFsQ2hpbGQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi91dGlscy9yZWFjdC9jbGVhbkpTWEVsZW1lbnRMaXRlcmFsQ2hpbGRcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBidWlsZENoaWxkcmVuKG5vZGUpIHtcbiAgY29uc3QgZWxlbWVudHMgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuXG4gICAgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzSlNYVGV4dCkoY2hpbGQpKSB7XG4gICAgICAoMCwgX2NsZWFuSlNYRWxlbWVudExpdGVyYWxDaGlsZC5kZWZhdWx0KShjaGlsZCwgZWxlbWVudHMpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzSlNYRXhwcmVzc2lvbkNvbnRhaW5lcikoY2hpbGQpKSBjaGlsZCA9IGNoaWxkLmV4cHJlc3Npb247XG4gICAgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzSlNYRW1wdHlFeHByZXNzaW9uKShjaGlsZCkpIGNvbnRpbnVlO1xuICAgIGVsZW1lbnRzLnB1c2goY2hpbGQpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRzO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlVFNVbmlvblR5cGU7XG5cbnZhciBfZ2VuZXJhdGVkID0gcmVxdWlyZShcIi4uL2dlbmVyYXRlZFwiKTtcblxudmFyIF9yZW1vdmVUeXBlRHVwbGljYXRlcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uL21vZGlmaWNhdGlvbnMvdHlwZXNjcmlwdC9yZW1vdmVUeXBlRHVwbGljYXRlc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGNyZWF0ZVRTVW5pb25UeXBlKHR5cGVBbm5vdGF0aW9ucykge1xuICBjb25zdCB0eXBlcyA9IHR5cGVBbm5vdGF0aW9ucy5tYXAodHlwZSA9PiB0eXBlLnR5cGVBbm5vdGF0aW9ucyk7XG4gIGNvbnN0IGZsYXR0ZW5lZCA9ICgwLCBfcmVtb3ZlVHlwZUR1cGxpY2F0ZXMuZGVmYXVsdCkodHlwZXMpO1xuXG4gIGlmIChmbGF0dGVuZWQubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGZsYXR0ZW5lZFswXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKDAsIF9nZW5lcmF0ZWQudHNVbmlvblR5cGUpKGZsYXR0ZW5lZCk7XG4gIH1cbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNsb25lO1xuXG52YXIgX2Nsb25lTm9kZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY2xvbmVOb2RlXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gY2xvbmUobm9kZSkge1xuICByZXR1cm4gKDAsIF9jbG9uZU5vZGUuZGVmYXVsdCkobm9kZSwgZmFsc2UpO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gY2xvbmVEZWVwO1xuXG52YXIgX2Nsb25lTm9kZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY2xvbmVOb2RlXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gY2xvbmVEZWVwKG5vZGUpIHtcbiAgcmV0dXJuICgwLCBfY2xvbmVOb2RlLmRlZmF1bHQpKG5vZGUpO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gY2xvbmVEZWVwV2l0aG91dExvYztcblxudmFyIF9jbG9uZU5vZGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Nsb25lTm9kZVwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGNsb25lRGVlcFdpdGhvdXRMb2Mobm9kZSkge1xuICByZXR1cm4gKDAsIF9jbG9uZU5vZGUuZGVmYXVsdCkobm9kZSwgdHJ1ZSwgdHJ1ZSk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBjbG9uZU5vZGU7XG5cbnZhciBfZGVmaW5pdGlvbnMgPSByZXF1aXJlKFwiLi4vZGVmaW5pdGlvbnNcIik7XG5cbmNvbnN0IGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxuZnVuY3Rpb24gY2xvbmVJZk5vZGUob2JqLCBkZWVwLCB3aXRob3V0TG9jKSB7XG4gIGlmIChvYmogJiYgdHlwZW9mIG9iai50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGNsb25lTm9kZShvYmosIGRlZXAsIHdpdGhvdXRMb2MpO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gY2xvbmVJZk5vZGVPckFycmF5KG9iaiwgZGVlcCwgd2l0aG91dExvYykge1xuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG9iai5tYXAobm9kZSA9PiBjbG9uZUlmTm9kZShub2RlLCBkZWVwLCB3aXRob3V0TG9jKSk7XG4gIH1cblxuICByZXR1cm4gY2xvbmVJZk5vZGUob2JqLCBkZWVwLCB3aXRob3V0TG9jKTtcbn1cblxuZnVuY3Rpb24gY2xvbmVOb2RlKG5vZGUsIGRlZXAgPSB0cnVlLCB3aXRob3V0TG9jID0gZmFsc2UpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gbm9kZTtcbiAgY29uc3Qge1xuICAgIHR5cGVcbiAgfSA9IG5vZGU7XG4gIGNvbnN0IG5ld05vZGUgPSB7XG4gICAgdHlwZVxuICB9O1xuXG4gIGlmICh0eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgIG5ld05vZGUubmFtZSA9IG5vZGUubmFtZTtcblxuICAgIGlmIChoYXMobm9kZSwgXCJvcHRpb25hbFwiKSAmJiB0eXBlb2Ygbm9kZS5vcHRpb25hbCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIG5ld05vZGUub3B0aW9uYWwgPSBub2RlLm9wdGlvbmFsO1xuICAgIH1cblxuICAgIGlmIChoYXMobm9kZSwgXCJ0eXBlQW5ub3RhdGlvblwiKSkge1xuICAgICAgbmV3Tm9kZS50eXBlQW5ub3RhdGlvbiA9IGRlZXAgPyBjbG9uZUlmTm9kZU9yQXJyYXkobm9kZS50eXBlQW5ub3RhdGlvbiwgdHJ1ZSwgd2l0aG91dExvYykgOiBub2RlLnR5cGVBbm5vdGF0aW9uO1xuICAgIH1cbiAgfSBlbHNlIGlmICghaGFzKF9kZWZpbml0aW9ucy5OT0RFX0ZJRUxEUywgdHlwZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gbm9kZSB0eXBlOiBcIiR7dHlwZX1cImApO1xuICB9IGVsc2Uge1xuICAgIGZvciAoY29uc3QgZmllbGQgb2YgT2JqZWN0LmtleXMoX2RlZmluaXRpb25zLk5PREVfRklFTERTW3R5cGVdKSkge1xuICAgICAgaWYgKGhhcyhub2RlLCBmaWVsZCkpIHtcbiAgICAgICAgaWYgKGRlZXApIHtcbiAgICAgICAgICBuZXdOb2RlW2ZpZWxkXSA9IHR5cGUgPT09IFwiRmlsZVwiICYmIGZpZWxkID09PSBcImNvbW1lbnRzXCIgPyBtYXliZUNsb25lQ29tbWVudHMobm9kZS5jb21tZW50cywgZGVlcCwgd2l0aG91dExvYykgOiBjbG9uZUlmTm9kZU9yQXJyYXkobm9kZVtmaWVsZF0sIHRydWUsIHdpdGhvdXRMb2MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld05vZGVbZmllbGRdID0gbm9kZVtmaWVsZF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoaGFzKG5vZGUsIFwibG9jXCIpKSB7XG4gICAgaWYgKHdpdGhvdXRMb2MpIHtcbiAgICAgIG5ld05vZGUubG9jID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3Tm9kZS5sb2MgPSBub2RlLmxvYztcbiAgICB9XG4gIH1cblxuICBpZiAoaGFzKG5vZGUsIFwibGVhZGluZ0NvbW1lbnRzXCIpKSB7XG4gICAgbmV3Tm9kZS5sZWFkaW5nQ29tbWVudHMgPSBtYXliZUNsb25lQ29tbWVudHMobm9kZS5sZWFkaW5nQ29tbWVudHMsIGRlZXAsIHdpdGhvdXRMb2MpO1xuICB9XG5cbiAgaWYgKGhhcyhub2RlLCBcImlubmVyQ29tbWVudHNcIikpIHtcbiAgICBuZXdOb2RlLmlubmVyQ29tbWVudHMgPSBtYXliZUNsb25lQ29tbWVudHMobm9kZS5pbm5lckNvbW1lbnRzLCBkZWVwLCB3aXRob3V0TG9jKTtcbiAgfVxuXG4gIGlmIChoYXMobm9kZSwgXCJ0cmFpbGluZ0NvbW1lbnRzXCIpKSB7XG4gICAgbmV3Tm9kZS50cmFpbGluZ0NvbW1lbnRzID0gbWF5YmVDbG9uZUNvbW1lbnRzKG5vZGUudHJhaWxpbmdDb21tZW50cywgZGVlcCwgd2l0aG91dExvYyk7XG4gIH1cblxuICBpZiAoaGFzKG5vZGUsIFwiZXh0cmFcIikpIHtcbiAgICBuZXdOb2RlLmV4dHJhID0gT2JqZWN0LmFzc2lnbih7fSwgbm9kZS5leHRyYSk7XG4gIH1cblxuICByZXR1cm4gbmV3Tm9kZTtcbn1cblxuZnVuY3Rpb24gY2xvbmVDb21tZW50c1dpdGhvdXRMb2MoY29tbWVudHMpIHtcbiAgcmV0dXJuIGNvbW1lbnRzLm1hcCgoe1xuICAgIHR5cGUsXG4gICAgdmFsdWVcbiAgfSkgPT4gKHtcbiAgICB0eXBlLFxuICAgIHZhbHVlLFxuICAgIGxvYzogbnVsbFxuICB9KSk7XG59XG5cbmZ1bmN0aW9uIG1heWJlQ2xvbmVDb21tZW50cyhjb21tZW50cywgZGVlcCwgd2l0aG91dExvYykge1xuICByZXR1cm4gZGVlcCAmJiB3aXRob3V0TG9jID8gY2xvbmVDb21tZW50c1dpdGhvdXRMb2MoY29tbWVudHMpIDogY29tbWVudHM7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBjbG9uZVdpdGhvdXRMb2M7XG5cbnZhciBfY2xvbmVOb2RlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jbG9uZU5vZGVcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBjbG9uZVdpdGhvdXRMb2Mobm9kZSkge1xuICByZXR1cm4gKDAsIF9jbG9uZU5vZGUuZGVmYXVsdCkobm9kZSwgZmFsc2UsIHRydWUpO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gYWRkQ29tbWVudDtcblxudmFyIF9hZGRDb21tZW50cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vYWRkQ29tbWVudHNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBhZGRDb21tZW50KG5vZGUsIHR5cGUsIGNvbnRlbnQsIGxpbmUpIHtcbiAgcmV0dXJuICgwLCBfYWRkQ29tbWVudHMuZGVmYXVsdCkobm9kZSwgdHlwZSwgW3tcbiAgICB0eXBlOiBsaW5lID8gXCJDb21tZW50TGluZVwiIDogXCJDb21tZW50QmxvY2tcIixcbiAgICB2YWx1ZTogY29udGVudFxuICB9XSk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBhZGRDb21tZW50cztcblxuZnVuY3Rpb24gYWRkQ29tbWVudHMobm9kZSwgdHlwZSwgY29tbWVudHMpIHtcbiAgaWYgKCFjb21tZW50cyB8fCAhbm9kZSkgcmV0dXJuIG5vZGU7XG4gIGNvbnN0IGtleSA9IGAke3R5cGV9Q29tbWVudHNgO1xuXG4gIGlmIChub2RlW2tleV0pIHtcbiAgICBpZiAodHlwZSA9PT0gXCJsZWFkaW5nXCIpIHtcbiAgICAgIG5vZGVba2V5XSA9IGNvbW1lbnRzLmNvbmNhdChub2RlW2tleV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlW2tleV0gPSBub2RlW2tleV0uY29uY2F0KGNvbW1lbnRzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbm9kZVtrZXldID0gY29tbWVudHM7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGluaGVyaXRJbm5lckNvbW1lbnRzO1xuXG52YXIgX2luaGVyaXQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi91dGlscy9pbmhlcml0XCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gaW5oZXJpdElubmVyQ29tbWVudHMoY2hpbGQsIHBhcmVudCkge1xuICAoMCwgX2luaGVyaXQuZGVmYXVsdCkoXCJpbm5lckNvbW1lbnRzXCIsIGNoaWxkLCBwYXJlbnQpO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaW5oZXJpdExlYWRpbmdDb21tZW50cztcblxudmFyIF9pbmhlcml0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vdXRpbHMvaW5oZXJpdFwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGluaGVyaXRMZWFkaW5nQ29tbWVudHMoY2hpbGQsIHBhcmVudCkge1xuICAoMCwgX2luaGVyaXQuZGVmYXVsdCkoXCJsZWFkaW5nQ29tbWVudHNcIiwgY2hpbGQsIHBhcmVudCk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpbmhlcml0VHJhaWxpbmdDb21tZW50cztcblxudmFyIF9pbmhlcml0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vdXRpbHMvaW5oZXJpdFwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGluaGVyaXRUcmFpbGluZ0NvbW1lbnRzKGNoaWxkLCBwYXJlbnQpIHtcbiAgKDAsIF9pbmhlcml0LmRlZmF1bHQpKFwidHJhaWxpbmdDb21tZW50c1wiLCBjaGlsZCwgcGFyZW50KTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGluaGVyaXRzQ29tbWVudHM7XG5cbnZhciBfaW5oZXJpdFRyYWlsaW5nQ29tbWVudHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2luaGVyaXRUcmFpbGluZ0NvbW1lbnRzXCIpKTtcblxudmFyIF9pbmhlcml0TGVhZGluZ0NvbW1lbnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pbmhlcml0TGVhZGluZ0NvbW1lbnRzXCIpKTtcblxudmFyIF9pbmhlcml0SW5uZXJDb21tZW50cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaW5oZXJpdElubmVyQ29tbWVudHNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBpbmhlcml0c0NvbW1lbnRzKGNoaWxkLCBwYXJlbnQpIHtcbiAgKDAsIF9pbmhlcml0VHJhaWxpbmdDb21tZW50cy5kZWZhdWx0KShjaGlsZCwgcGFyZW50KTtcbiAgKDAsIF9pbmhlcml0TGVhZGluZ0NvbW1lbnRzLmRlZmF1bHQpKGNoaWxkLCBwYXJlbnQpO1xuICAoMCwgX2luaGVyaXRJbm5lckNvbW1lbnRzLmRlZmF1bHQpKGNoaWxkLCBwYXJlbnQpO1xuICByZXR1cm4gY2hpbGQ7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSByZW1vdmVDb21tZW50cztcblxudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xuXG5mdW5jdGlvbiByZW1vdmVDb21tZW50cyhub2RlKSB7XG4gIF9jb25zdGFudHMuQ09NTUVOVF9LRVlTLmZvckVhY2goa2V5ID0+IHtcbiAgICBub2RlW2tleV0gPSBudWxsO1xuICB9KTtcblxuICByZXR1cm4gbm9kZTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuVFNCQVNFVFlQRV9UWVBFUyA9IGV4cG9ydHMuVFNUWVBFX1RZUEVTID0gZXhwb3J0cy5UU1RZUEVFTEVNRU5UX1RZUEVTID0gZXhwb3J0cy5QUklWQVRFX1RZUEVTID0gZXhwb3J0cy5KU1hfVFlQRVMgPSBleHBvcnRzLkVOVU1NRU1CRVJfVFlQRVMgPSBleHBvcnRzLkVOVU1CT0RZX1RZUEVTID0gZXhwb3J0cy5GTE9XUFJFRElDQVRFX1RZUEVTID0gZXhwb3J0cy5GTE9XREVDTEFSQVRJT05fVFlQRVMgPSBleHBvcnRzLkZMT1dCQVNFQU5OT1RBVElPTl9UWVBFUyA9IGV4cG9ydHMuRkxPV1RZUEVfVFlQRVMgPSBleHBvcnRzLkZMT1dfVFlQRVMgPSBleHBvcnRzLk1PRFVMRVNQRUNJRklFUl9UWVBFUyA9IGV4cG9ydHMuRVhQT1JUREVDTEFSQVRJT05fVFlQRVMgPSBleHBvcnRzLk1PRFVMRURFQ0xBUkFUSU9OX1RZUEVTID0gZXhwb3J0cy5DTEFTU19UWVBFUyA9IGV4cG9ydHMuUEFUVEVSTl9UWVBFUyA9IGV4cG9ydHMuVU5BUllMSUtFX1RZUEVTID0gZXhwb3J0cy5QUk9QRVJUWV9UWVBFUyA9IGV4cG9ydHMuT0JKRUNUTUVNQkVSX1RZUEVTID0gZXhwb3J0cy5NRVRIT0RfVFlQRVMgPSBleHBvcnRzLlVTRVJXSElURVNQQUNBQkxFX1RZUEVTID0gZXhwb3J0cy5JTU1VVEFCTEVfVFlQRVMgPSBleHBvcnRzLkxJVEVSQUxfVFlQRVMgPSBleHBvcnRzLlRTRU5USVRZTkFNRV9UWVBFUyA9IGV4cG9ydHMuTFZBTF9UWVBFUyA9IGV4cG9ydHMuUEFUVEVSTkxJS0VfVFlQRVMgPSBleHBvcnRzLkRFQ0xBUkFUSU9OX1RZUEVTID0gZXhwb3J0cy5QVVJFSVNIX1RZUEVTID0gZXhwb3J0cy5GVU5DVElPTlBBUkVOVF9UWVBFUyA9IGV4cG9ydHMuRlVOQ1RJT05fVFlQRVMgPSBleHBvcnRzLkZPUlhTVEFURU1FTlRfVFlQRVMgPSBleHBvcnRzLkZPUl9UWVBFUyA9IGV4cG9ydHMuRVhQUkVTU0lPTldSQVBQRVJfVFlQRVMgPSBleHBvcnRzLldISUxFX1RZUEVTID0gZXhwb3J0cy5MT09QX1RZUEVTID0gZXhwb3J0cy5DT05ESVRJT05BTF9UWVBFUyA9IGV4cG9ydHMuQ09NUExFVElPTlNUQVRFTUVOVF9UWVBFUyA9IGV4cG9ydHMuVEVSTUlOQVRPUkxFU1NfVFlQRVMgPSBleHBvcnRzLlNUQVRFTUVOVF9UWVBFUyA9IGV4cG9ydHMuQkxPQ0tfVFlQRVMgPSBleHBvcnRzLkJMT0NLUEFSRU5UX1RZUEVTID0gZXhwb3J0cy5TQ09QQUJMRV9UWVBFUyA9IGV4cG9ydHMuQklOQVJZX1RZUEVTID0gZXhwb3J0cy5FWFBSRVNTSU9OX1RZUEVTID0gdm9pZCAwO1xuXG52YXIgX2RlZmluaXRpb25zID0gcmVxdWlyZShcIi4uLy4uL2RlZmluaXRpb25zXCIpO1xuXG5jb25zdCBFWFBSRVNTSU9OX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIkV4cHJlc3Npb25cIl07XG5leHBvcnRzLkVYUFJFU1NJT05fVFlQRVMgPSBFWFBSRVNTSU9OX1RZUEVTO1xuY29uc3QgQklOQVJZX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIkJpbmFyeVwiXTtcbmV4cG9ydHMuQklOQVJZX1RZUEVTID0gQklOQVJZX1RZUEVTO1xuY29uc3QgU0NPUEFCTEVfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiU2NvcGFibGVcIl07XG5leHBvcnRzLlNDT1BBQkxFX1RZUEVTID0gU0NPUEFCTEVfVFlQRVM7XG5jb25zdCBCTE9DS1BBUkVOVF9UWVBFUyA9IF9kZWZpbml0aW9ucy5GTElQUEVEX0FMSUFTX0tFWVNbXCJCbG9ja1BhcmVudFwiXTtcbmV4cG9ydHMuQkxPQ0tQQVJFTlRfVFlQRVMgPSBCTE9DS1BBUkVOVF9UWVBFUztcbmNvbnN0IEJMT0NLX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIkJsb2NrXCJdO1xuZXhwb3J0cy5CTE9DS19UWVBFUyA9IEJMT0NLX1RZUEVTO1xuY29uc3QgU1RBVEVNRU5UX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIlN0YXRlbWVudFwiXTtcbmV4cG9ydHMuU1RBVEVNRU5UX1RZUEVTID0gU1RBVEVNRU5UX1RZUEVTO1xuY29uc3QgVEVSTUlOQVRPUkxFU1NfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiVGVybWluYXRvcmxlc3NcIl07XG5leHBvcnRzLlRFUk1JTkFUT1JMRVNTX1RZUEVTID0gVEVSTUlOQVRPUkxFU1NfVFlQRVM7XG5jb25zdCBDT01QTEVUSU9OU1RBVEVNRU5UX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIkNvbXBsZXRpb25TdGF0ZW1lbnRcIl07XG5leHBvcnRzLkNPTVBMRVRJT05TVEFURU1FTlRfVFlQRVMgPSBDT01QTEVUSU9OU1RBVEVNRU5UX1RZUEVTO1xuY29uc3QgQ09ORElUSU9OQUxfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiQ29uZGl0aW9uYWxcIl07XG5leHBvcnRzLkNPTkRJVElPTkFMX1RZUEVTID0gQ09ORElUSU9OQUxfVFlQRVM7XG5jb25zdCBMT09QX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIkxvb3BcIl07XG5leHBvcnRzLkxPT1BfVFlQRVMgPSBMT09QX1RZUEVTO1xuY29uc3QgV0hJTEVfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiV2hpbGVcIl07XG5leHBvcnRzLldISUxFX1RZUEVTID0gV0hJTEVfVFlQRVM7XG5jb25zdCBFWFBSRVNTSU9OV1JBUFBFUl9UWVBFUyA9IF9kZWZpbml0aW9ucy5GTElQUEVEX0FMSUFTX0tFWVNbXCJFeHByZXNzaW9uV3JhcHBlclwiXTtcbmV4cG9ydHMuRVhQUkVTU0lPTldSQVBQRVJfVFlQRVMgPSBFWFBSRVNTSU9OV1JBUFBFUl9UWVBFUztcbmNvbnN0IEZPUl9UWVBFUyA9IF9kZWZpbml0aW9ucy5GTElQUEVEX0FMSUFTX0tFWVNbXCJGb3JcIl07XG5leHBvcnRzLkZPUl9UWVBFUyA9IEZPUl9UWVBFUztcbmNvbnN0IEZPUlhTVEFURU1FTlRfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiRm9yWFN0YXRlbWVudFwiXTtcbmV4cG9ydHMuRk9SWFNUQVRFTUVOVF9UWVBFUyA9IEZPUlhTVEFURU1FTlRfVFlQRVM7XG5jb25zdCBGVU5DVElPTl9UWVBFUyA9IF9kZWZpbml0aW9ucy5GTElQUEVEX0FMSUFTX0tFWVNbXCJGdW5jdGlvblwiXTtcbmV4cG9ydHMuRlVOQ1RJT05fVFlQRVMgPSBGVU5DVElPTl9UWVBFUztcbmNvbnN0IEZVTkNUSU9OUEFSRU5UX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIkZ1bmN0aW9uUGFyZW50XCJdO1xuZXhwb3J0cy5GVU5DVElPTlBBUkVOVF9UWVBFUyA9IEZVTkNUSU9OUEFSRU5UX1RZUEVTO1xuY29uc3QgUFVSRUlTSF9UWVBFUyA9IF9kZWZpbml0aW9ucy5GTElQUEVEX0FMSUFTX0tFWVNbXCJQdXJlaXNoXCJdO1xuZXhwb3J0cy5QVVJFSVNIX1RZUEVTID0gUFVSRUlTSF9UWVBFUztcbmNvbnN0IERFQ0xBUkFUSU9OX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIkRlY2xhcmF0aW9uXCJdO1xuZXhwb3J0cy5ERUNMQVJBVElPTl9UWVBFUyA9IERFQ0xBUkFUSU9OX1RZUEVTO1xuY29uc3QgUEFUVEVSTkxJS0VfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiUGF0dGVybkxpa2VcIl07XG5leHBvcnRzLlBBVFRFUk5MSUtFX1RZUEVTID0gUEFUVEVSTkxJS0VfVFlQRVM7XG5jb25zdCBMVkFMX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIkxWYWxcIl07XG5leHBvcnRzLkxWQUxfVFlQRVMgPSBMVkFMX1RZUEVTO1xuY29uc3QgVFNFTlRJVFlOQU1FX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIlRTRW50aXR5TmFtZVwiXTtcbmV4cG9ydHMuVFNFTlRJVFlOQU1FX1RZUEVTID0gVFNFTlRJVFlOQU1FX1RZUEVTO1xuY29uc3QgTElURVJBTF9UWVBFUyA9IF9kZWZpbml0aW9ucy5GTElQUEVEX0FMSUFTX0tFWVNbXCJMaXRlcmFsXCJdO1xuZXhwb3J0cy5MSVRFUkFMX1RZUEVTID0gTElURVJBTF9UWVBFUztcbmNvbnN0IElNTVVUQUJMRV9UWVBFUyA9IF9kZWZpbml0aW9ucy5GTElQUEVEX0FMSUFTX0tFWVNbXCJJbW11dGFibGVcIl07XG5leHBvcnRzLklNTVVUQUJMRV9UWVBFUyA9IElNTVVUQUJMRV9UWVBFUztcbmNvbnN0IFVTRVJXSElURVNQQUNBQkxFX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIlVzZXJXaGl0ZXNwYWNhYmxlXCJdO1xuZXhwb3J0cy5VU0VSV0hJVEVTUEFDQUJMRV9UWVBFUyA9IFVTRVJXSElURVNQQUNBQkxFX1RZUEVTO1xuY29uc3QgTUVUSE9EX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIk1ldGhvZFwiXTtcbmV4cG9ydHMuTUVUSE9EX1RZUEVTID0gTUVUSE9EX1RZUEVTO1xuY29uc3QgT0JKRUNUTUVNQkVSX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIk9iamVjdE1lbWJlclwiXTtcbmV4cG9ydHMuT0JKRUNUTUVNQkVSX1RZUEVTID0gT0JKRUNUTUVNQkVSX1RZUEVTO1xuY29uc3QgUFJPUEVSVFlfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiUHJvcGVydHlcIl07XG5leHBvcnRzLlBST1BFUlRZX1RZUEVTID0gUFJPUEVSVFlfVFlQRVM7XG5jb25zdCBVTkFSWUxJS0VfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiVW5hcnlMaWtlXCJdO1xuZXhwb3J0cy5VTkFSWUxJS0VfVFlQRVMgPSBVTkFSWUxJS0VfVFlQRVM7XG5jb25zdCBQQVRURVJOX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIlBhdHRlcm5cIl07XG5leHBvcnRzLlBBVFRFUk5fVFlQRVMgPSBQQVRURVJOX1RZUEVTO1xuY29uc3QgQ0xBU1NfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiQ2xhc3NcIl07XG5leHBvcnRzLkNMQVNTX1RZUEVTID0gQ0xBU1NfVFlQRVM7XG5jb25zdCBNT0RVTEVERUNMQVJBVElPTl9UWVBFUyA9IF9kZWZpbml0aW9ucy5GTElQUEVEX0FMSUFTX0tFWVNbXCJNb2R1bGVEZWNsYXJhdGlvblwiXTtcbmV4cG9ydHMuTU9EVUxFREVDTEFSQVRJT05fVFlQRVMgPSBNT0RVTEVERUNMQVJBVElPTl9UWVBFUztcbmNvbnN0IEVYUE9SVERFQ0xBUkFUSU9OX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIkV4cG9ydERlY2xhcmF0aW9uXCJdO1xuZXhwb3J0cy5FWFBPUlRERUNMQVJBVElPTl9UWVBFUyA9IEVYUE9SVERFQ0xBUkFUSU9OX1RZUEVTO1xuY29uc3QgTU9EVUxFU1BFQ0lGSUVSX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIk1vZHVsZVNwZWNpZmllclwiXTtcbmV4cG9ydHMuTU9EVUxFU1BFQ0lGSUVSX1RZUEVTID0gTU9EVUxFU1BFQ0lGSUVSX1RZUEVTO1xuY29uc3QgRkxPV19UWVBFUyA9IF9kZWZpbml0aW9ucy5GTElQUEVEX0FMSUFTX0tFWVNbXCJGbG93XCJdO1xuZXhwb3J0cy5GTE9XX1RZUEVTID0gRkxPV19UWVBFUztcbmNvbnN0IEZMT1dUWVBFX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIkZsb3dUeXBlXCJdO1xuZXhwb3J0cy5GTE9XVFlQRV9UWVBFUyA9IEZMT1dUWVBFX1RZUEVTO1xuY29uc3QgRkxPV0JBU0VBTk5PVEFUSU9OX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIkZsb3dCYXNlQW5ub3RhdGlvblwiXTtcbmV4cG9ydHMuRkxPV0JBU0VBTk5PVEFUSU9OX1RZUEVTID0gRkxPV0JBU0VBTk5PVEFUSU9OX1RZUEVTO1xuY29uc3QgRkxPV0RFQ0xBUkFUSU9OX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIkZsb3dEZWNsYXJhdGlvblwiXTtcbmV4cG9ydHMuRkxPV0RFQ0xBUkFUSU9OX1RZUEVTID0gRkxPV0RFQ0xBUkFUSU9OX1RZUEVTO1xuY29uc3QgRkxPV1BSRURJQ0FURV9UWVBFUyA9IF9kZWZpbml0aW9ucy5GTElQUEVEX0FMSUFTX0tFWVNbXCJGbG93UHJlZGljYXRlXCJdO1xuZXhwb3J0cy5GTE9XUFJFRElDQVRFX1RZUEVTID0gRkxPV1BSRURJQ0FURV9UWVBFUztcbmNvbnN0IEVOVU1CT0RZX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIkVudW1Cb2R5XCJdO1xuZXhwb3J0cy5FTlVNQk9EWV9UWVBFUyA9IEVOVU1CT0RZX1RZUEVTO1xuY29uc3QgRU5VTU1FTUJFUl9UWVBFUyA9IF9kZWZpbml0aW9ucy5GTElQUEVEX0FMSUFTX0tFWVNbXCJFbnVtTWVtYmVyXCJdO1xuZXhwb3J0cy5FTlVNTUVNQkVSX1RZUEVTID0gRU5VTU1FTUJFUl9UWVBFUztcbmNvbnN0IEpTWF9UWVBFUyA9IF9kZWZpbml0aW9ucy5GTElQUEVEX0FMSUFTX0tFWVNbXCJKU1hcIl07XG5leHBvcnRzLkpTWF9UWVBFUyA9IEpTWF9UWVBFUztcbmNvbnN0IFBSSVZBVEVfVFlQRVMgPSBfZGVmaW5pdGlvbnMuRkxJUFBFRF9BTElBU19LRVlTW1wiUHJpdmF0ZVwiXTtcbmV4cG9ydHMuUFJJVkFURV9UWVBFUyA9IFBSSVZBVEVfVFlQRVM7XG5jb25zdCBUU1RZUEVFTEVNRU5UX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIlRTVHlwZUVsZW1lbnRcIl07XG5leHBvcnRzLlRTVFlQRUVMRU1FTlRfVFlQRVMgPSBUU1RZUEVFTEVNRU5UX1RZUEVTO1xuY29uc3QgVFNUWVBFX1RZUEVTID0gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZU1tcIlRTVHlwZVwiXTtcbmV4cG9ydHMuVFNUWVBFX1RZUEVTID0gVFNUWVBFX1RZUEVTO1xuY29uc3QgVFNCQVNFVFlQRV9UWVBFUyA9IF9kZWZpbml0aW9ucy5GTElQUEVEX0FMSUFTX0tFWVNbXCJUU0Jhc2VUeXBlXCJdO1xuZXhwb3J0cy5UU0JBU0VUWVBFX1RZUEVTID0gVFNCQVNFVFlQRV9UWVBFUzsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuTk9UX0xPQ0FMX0JJTkRJTkcgPSBleHBvcnRzLkJMT0NLX1NDT1BFRF9TWU1CT0wgPSBleHBvcnRzLklOSEVSSVRfS0VZUyA9IGV4cG9ydHMuVU5BUllfT1BFUkFUT1JTID0gZXhwb3J0cy5TVFJJTkdfVU5BUllfT1BFUkFUT1JTID0gZXhwb3J0cy5OVU1CRVJfVU5BUllfT1BFUkFUT1JTID0gZXhwb3J0cy5CT09MRUFOX1VOQVJZX09QRVJBVE9SUyA9IGV4cG9ydHMuQVNTSUdOTUVOVF9PUEVSQVRPUlMgPSBleHBvcnRzLkJJTkFSWV9PUEVSQVRPUlMgPSBleHBvcnRzLk5VTUJFUl9CSU5BUllfT1BFUkFUT1JTID0gZXhwb3J0cy5CT09MRUFOX0JJTkFSWV9PUEVSQVRPUlMgPSBleHBvcnRzLkNPTVBBUklTT05fQklOQVJZX09QRVJBVE9SUyA9IGV4cG9ydHMuRVFVQUxJVFlfQklOQVJZX09QRVJBVE9SUyA9IGV4cG9ydHMuQk9PTEVBTl9OVU1CRVJfQklOQVJZX09QRVJBVE9SUyA9IGV4cG9ydHMuVVBEQVRFX09QRVJBVE9SUyA9IGV4cG9ydHMuTE9HSUNBTF9PUEVSQVRPUlMgPSBleHBvcnRzLkNPTU1FTlRfS0VZUyA9IGV4cG9ydHMuRk9SX0lOSVRfS0VZUyA9IGV4cG9ydHMuRkxBVFRFTkFCTEVfS0VZUyA9IGV4cG9ydHMuU1RBVEVNRU5UX09SX0JMT0NLX0tFWVMgPSB2b2lkIDA7XG5jb25zdCBTVEFURU1FTlRfT1JfQkxPQ0tfS0VZUyA9IFtcImNvbnNlcXVlbnRcIiwgXCJib2R5XCIsIFwiYWx0ZXJuYXRlXCJdO1xuZXhwb3J0cy5TVEFURU1FTlRfT1JfQkxPQ0tfS0VZUyA9IFNUQVRFTUVOVF9PUl9CTE9DS19LRVlTO1xuY29uc3QgRkxBVFRFTkFCTEVfS0VZUyA9IFtcImJvZHlcIiwgXCJleHByZXNzaW9uc1wiXTtcbmV4cG9ydHMuRkxBVFRFTkFCTEVfS0VZUyA9IEZMQVRURU5BQkxFX0tFWVM7XG5jb25zdCBGT1JfSU5JVF9LRVlTID0gW1wibGVmdFwiLCBcImluaXRcIl07XG5leHBvcnRzLkZPUl9JTklUX0tFWVMgPSBGT1JfSU5JVF9LRVlTO1xuY29uc3QgQ09NTUVOVF9LRVlTID0gW1wibGVhZGluZ0NvbW1lbnRzXCIsIFwidHJhaWxpbmdDb21tZW50c1wiLCBcImlubmVyQ29tbWVudHNcIl07XG5leHBvcnRzLkNPTU1FTlRfS0VZUyA9IENPTU1FTlRfS0VZUztcbmNvbnN0IExPR0lDQUxfT1BFUkFUT1JTID0gW1wifHxcIiwgXCImJlwiLCBcIj8/XCJdO1xuZXhwb3J0cy5MT0dJQ0FMX09QRVJBVE9SUyA9IExPR0lDQUxfT1BFUkFUT1JTO1xuY29uc3QgVVBEQVRFX09QRVJBVE9SUyA9IFtcIisrXCIsIFwiLS1cIl07XG5leHBvcnRzLlVQREFURV9PUEVSQVRPUlMgPSBVUERBVEVfT1BFUkFUT1JTO1xuY29uc3QgQk9PTEVBTl9OVU1CRVJfQklOQVJZX09QRVJBVE9SUyA9IFtcIj5cIiwgXCI8XCIsIFwiPj1cIiwgXCI8PVwiXTtcbmV4cG9ydHMuQk9PTEVBTl9OVU1CRVJfQklOQVJZX09QRVJBVE9SUyA9IEJPT0xFQU5fTlVNQkVSX0JJTkFSWV9PUEVSQVRPUlM7XG5jb25zdCBFUVVBTElUWV9CSU5BUllfT1BFUkFUT1JTID0gW1wiPT1cIiwgXCI9PT1cIiwgXCIhPVwiLCBcIiE9PVwiXTtcbmV4cG9ydHMuRVFVQUxJVFlfQklOQVJZX09QRVJBVE9SUyA9IEVRVUFMSVRZX0JJTkFSWV9PUEVSQVRPUlM7XG5jb25zdCBDT01QQVJJU09OX0JJTkFSWV9PUEVSQVRPUlMgPSBbLi4uRVFVQUxJVFlfQklOQVJZX09QRVJBVE9SUywgXCJpblwiLCBcImluc3RhbmNlb2ZcIl07XG5leHBvcnRzLkNPTVBBUklTT05fQklOQVJZX09QRVJBVE9SUyA9IENPTVBBUklTT05fQklOQVJZX09QRVJBVE9SUztcbmNvbnN0IEJPT0xFQU5fQklOQVJZX09QRVJBVE9SUyA9IFsuLi5DT01QQVJJU09OX0JJTkFSWV9PUEVSQVRPUlMsIC4uLkJPT0xFQU5fTlVNQkVSX0JJTkFSWV9PUEVSQVRPUlNdO1xuZXhwb3J0cy5CT09MRUFOX0JJTkFSWV9PUEVSQVRPUlMgPSBCT09MRUFOX0JJTkFSWV9PUEVSQVRPUlM7XG5jb25zdCBOVU1CRVJfQklOQVJZX09QRVJBVE9SUyA9IFtcIi1cIiwgXCIvXCIsIFwiJVwiLCBcIipcIiwgXCIqKlwiLCBcIiZcIiwgXCJ8XCIsIFwiPj5cIiwgXCI+Pj5cIiwgXCI8PFwiLCBcIl5cIl07XG5leHBvcnRzLk5VTUJFUl9CSU5BUllfT1BFUkFUT1JTID0gTlVNQkVSX0JJTkFSWV9PUEVSQVRPUlM7XG5jb25zdCBCSU5BUllfT1BFUkFUT1JTID0gW1wiK1wiLCAuLi5OVU1CRVJfQklOQVJZX09QRVJBVE9SUywgLi4uQk9PTEVBTl9CSU5BUllfT1BFUkFUT1JTXTtcbmV4cG9ydHMuQklOQVJZX09QRVJBVE9SUyA9IEJJTkFSWV9PUEVSQVRPUlM7XG5jb25zdCBBU1NJR05NRU5UX09QRVJBVE9SUyA9IFtcIj1cIiwgXCIrPVwiLCAuLi5OVU1CRVJfQklOQVJZX09QRVJBVE9SUy5tYXAob3AgPT4gb3AgKyBcIj1cIiksIC4uLkxPR0lDQUxfT1BFUkFUT1JTLm1hcChvcCA9PiBvcCArIFwiPVwiKV07XG5leHBvcnRzLkFTU0lHTk1FTlRfT1BFUkFUT1JTID0gQVNTSUdOTUVOVF9PUEVSQVRPUlM7XG5jb25zdCBCT09MRUFOX1VOQVJZX09QRVJBVE9SUyA9IFtcImRlbGV0ZVwiLCBcIiFcIl07XG5leHBvcnRzLkJPT0xFQU5fVU5BUllfT1BFUkFUT1JTID0gQk9PTEVBTl9VTkFSWV9PUEVSQVRPUlM7XG5jb25zdCBOVU1CRVJfVU5BUllfT1BFUkFUT1JTID0gW1wiK1wiLCBcIi1cIiwgXCJ+XCJdO1xuZXhwb3J0cy5OVU1CRVJfVU5BUllfT1BFUkFUT1JTID0gTlVNQkVSX1VOQVJZX09QRVJBVE9SUztcbmNvbnN0IFNUUklOR19VTkFSWV9PUEVSQVRPUlMgPSBbXCJ0eXBlb2ZcIl07XG5leHBvcnRzLlNUUklOR19VTkFSWV9PUEVSQVRPUlMgPSBTVFJJTkdfVU5BUllfT1BFUkFUT1JTO1xuY29uc3QgVU5BUllfT1BFUkFUT1JTID0gW1widm9pZFwiLCBcInRocm93XCIsIC4uLkJPT0xFQU5fVU5BUllfT1BFUkFUT1JTLCAuLi5OVU1CRVJfVU5BUllfT1BFUkFUT1JTLCAuLi5TVFJJTkdfVU5BUllfT1BFUkFUT1JTXTtcbmV4cG9ydHMuVU5BUllfT1BFUkFUT1JTID0gVU5BUllfT1BFUkFUT1JTO1xuY29uc3QgSU5IRVJJVF9LRVlTID0ge1xuICBvcHRpb25hbDogW1widHlwZUFubm90YXRpb25cIiwgXCJ0eXBlUGFyYW1ldGVyc1wiLCBcInJldHVyblR5cGVcIl0sXG4gIGZvcmNlOiBbXCJzdGFydFwiLCBcImxvY1wiLCBcImVuZFwiXVxufTtcbmV4cG9ydHMuSU5IRVJJVF9LRVlTID0gSU5IRVJJVF9LRVlTO1xuY29uc3QgQkxPQ0tfU0NPUEVEX1NZTUJPTCA9IFN5bWJvbC5mb3IoXCJ2YXIgdXNlZCB0byBiZSBibG9jayBzY29wZWRcIik7XG5leHBvcnRzLkJMT0NLX1NDT1BFRF9TWU1CT0wgPSBCTE9DS19TQ09QRURfU1lNQk9MO1xuY29uc3QgTk9UX0xPQ0FMX0JJTkRJTkcgPSBTeW1ib2wuZm9yKFwic2hvdWxkIG5vdCBiZSBjb25zaWRlcmVkIGEgbG9jYWwgYmluZGluZ1wiKTtcbmV4cG9ydHMuTk9UX0xPQ0FMX0JJTkRJTkcgPSBOT1RfTE9DQUxfQklORElORzsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGVuc3VyZUJsb2NrO1xuXG52YXIgX3RvQmxvY2sgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3RvQmxvY2tcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBlbnN1cmVCbG9jayhub2RlLCBrZXkgPSBcImJvZHlcIikge1xuICByZXR1cm4gbm9kZVtrZXldID0gKDAsIF90b0Jsb2NrLmRlZmF1bHQpKG5vZGVba2V5XSwgbm9kZSk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBnYXRoZXJTZXF1ZW5jZUV4cHJlc3Npb25zO1xuXG52YXIgX2dldEJpbmRpbmdJZGVudGlmaWVycyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3JldHJpZXZlcnMvZ2V0QmluZGluZ0lkZW50aWZpZXJzXCIpKTtcblxudmFyIF9nZW5lcmF0ZWQgPSByZXF1aXJlKFwiLi4vdmFsaWRhdG9ycy9nZW5lcmF0ZWRcIik7XG5cbnZhciBfZ2VuZXJhdGVkMiA9IHJlcXVpcmUoXCIuLi9idWlsZGVycy9nZW5lcmF0ZWRcIik7XG5cbnZhciBfY2xvbmVOb2RlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vY2xvbmUvY2xvbmVOb2RlXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gZ2F0aGVyU2VxdWVuY2VFeHByZXNzaW9ucyhub2Rlcywgc2NvcGUsIGRlY2xhcnMpIHtcbiAgY29uc3QgZXhwcnMgPSBbXTtcbiAgbGV0IGVuc3VyZUxhc3RVbmRlZmluZWQgPSB0cnVlO1xuXG4gIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgIGlmICghKDAsIF9nZW5lcmF0ZWQuaXNFbXB0eVN0YXRlbWVudCkobm9kZSkpIHtcbiAgICAgIGVuc3VyZUxhc3RVbmRlZmluZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNFeHByZXNzaW9uKShub2RlKSkge1xuICAgICAgZXhwcnMucHVzaChub2RlKTtcbiAgICB9IGVsc2UgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzRXhwcmVzc2lvblN0YXRlbWVudCkobm9kZSkpIHtcbiAgICAgIGV4cHJzLnB1c2gobm9kZS5leHByZXNzaW9uKTtcbiAgICB9IGVsc2UgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzVmFyaWFibGVEZWNsYXJhdGlvbikobm9kZSkpIHtcbiAgICAgIGlmIChub2RlLmtpbmQgIT09IFwidmFyXCIpIHJldHVybjtcblxuICAgICAgZm9yIChjb25zdCBkZWNsYXIgb2Ygbm9kZS5kZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYmluZGluZ3MgPSAoMCwgX2dldEJpbmRpbmdJZGVudGlmaWVycy5kZWZhdWx0KShkZWNsYXIpO1xuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGJpbmRpbmdzKSkge1xuICAgICAgICAgIGRlY2xhcnMucHVzaCh7XG4gICAgICAgICAgICBraW5kOiBub2RlLmtpbmQsXG4gICAgICAgICAgICBpZDogKDAsIF9jbG9uZU5vZGUuZGVmYXVsdCkoYmluZGluZ3Nba2V5XSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWNsYXIuaW5pdCkge1xuICAgICAgICAgIGV4cHJzLnB1c2goKDAsIF9nZW5lcmF0ZWQyLmFzc2lnbm1lbnRFeHByZXNzaW9uKShcIj1cIiwgZGVjbGFyLmlkLCBkZWNsYXIuaW5pdCkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVuc3VyZUxhc3RVbmRlZmluZWQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNJZlN0YXRlbWVudCkobm9kZSkpIHtcbiAgICAgIGNvbnN0IGNvbnNlcXVlbnQgPSBub2RlLmNvbnNlcXVlbnQgPyBnYXRoZXJTZXF1ZW5jZUV4cHJlc3Npb25zKFtub2RlLmNvbnNlcXVlbnRdLCBzY29wZSwgZGVjbGFycykgOiBzY29wZS5idWlsZFVuZGVmaW5lZE5vZGUoKTtcbiAgICAgIGNvbnN0IGFsdGVybmF0ZSA9IG5vZGUuYWx0ZXJuYXRlID8gZ2F0aGVyU2VxdWVuY2VFeHByZXNzaW9ucyhbbm9kZS5hbHRlcm5hdGVdLCBzY29wZSwgZGVjbGFycykgOiBzY29wZS5idWlsZFVuZGVmaW5lZE5vZGUoKTtcbiAgICAgIGlmICghY29uc2VxdWVudCB8fCAhYWx0ZXJuYXRlKSByZXR1cm47XG4gICAgICBleHBycy5wdXNoKCgwLCBfZ2VuZXJhdGVkMi5jb25kaXRpb25hbEV4cHJlc3Npb24pKG5vZGUudGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlKSk7XG4gICAgfSBlbHNlIGlmICgoMCwgX2dlbmVyYXRlZC5pc0Jsb2NrU3RhdGVtZW50KShub2RlKSkge1xuICAgICAgY29uc3QgYm9keSA9IGdhdGhlclNlcXVlbmNlRXhwcmVzc2lvbnMobm9kZS5ib2R5LCBzY29wZSwgZGVjbGFycyk7XG4gICAgICBpZiAoIWJvZHkpIHJldHVybjtcbiAgICAgIGV4cHJzLnB1c2goYm9keSk7XG4gICAgfSBlbHNlIGlmICgoMCwgX2dlbmVyYXRlZC5pc0VtcHR5U3RhdGVtZW50KShub2RlKSkge1xuICAgICAgaWYgKG5vZGVzLmluZGV4T2Yobm9kZSkgPT09IDApIHtcbiAgICAgICAgZW5zdXJlTGFzdFVuZGVmaW5lZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAoZW5zdXJlTGFzdFVuZGVmaW5lZCkge1xuICAgIGV4cHJzLnB1c2goc2NvcGUuYnVpbGRVbmRlZmluZWROb2RlKCkpO1xuICB9XG5cbiAgaWYgKGV4cHJzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBleHByc1swXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKDAsIF9nZW5lcmF0ZWQyLnNlcXVlbmNlRXhwcmVzc2lvbikoZXhwcnMpO1xuICB9XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB0b0JpbmRpbmdJZGVudGlmaWVyTmFtZTtcblxudmFyIF90b0lkZW50aWZpZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3RvSWRlbnRpZmllclwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHRvQmluZGluZ0lkZW50aWZpZXJOYW1lKG5hbWUpIHtcbiAgbmFtZSA9ICgwLCBfdG9JZGVudGlmaWVyLmRlZmF1bHQpKG5hbWUpO1xuICBpZiAobmFtZSA9PT0gXCJldmFsXCIgfHwgbmFtZSA9PT0gXCJhcmd1bWVudHNcIikgbmFtZSA9IFwiX1wiICsgbmFtZTtcbiAgcmV0dXJuIG5hbWU7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB0b0Jsb2NrO1xuXG52YXIgX2dlbmVyYXRlZCA9IHJlcXVpcmUoXCIuLi92YWxpZGF0b3JzL2dlbmVyYXRlZFwiKTtcblxudmFyIF9nZW5lcmF0ZWQyID0gcmVxdWlyZShcIi4uL2J1aWxkZXJzL2dlbmVyYXRlZFwiKTtcblxuZnVuY3Rpb24gdG9CbG9jayhub2RlLCBwYXJlbnQpIHtcbiAgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzQmxvY2tTdGF0ZW1lbnQpKG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBsZXQgYmxvY2tOb2RlcyA9IFtdO1xuXG4gIGlmICgoMCwgX2dlbmVyYXRlZC5pc0VtcHR5U3RhdGVtZW50KShub2RlKSkge1xuICAgIGJsb2NrTm9kZXMgPSBbXTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoISgwLCBfZ2VuZXJhdGVkLmlzU3RhdGVtZW50KShub2RlKSkge1xuICAgICAgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzRnVuY3Rpb24pKHBhcmVudCkpIHtcbiAgICAgICAgbm9kZSA9ICgwLCBfZ2VuZXJhdGVkMi5yZXR1cm5TdGF0ZW1lbnQpKG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZSA9ICgwLCBfZ2VuZXJhdGVkMi5leHByZXNzaW9uU3RhdGVtZW50KShub2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBibG9ja05vZGVzID0gW25vZGVdO1xuICB9XG5cbiAgcmV0dXJuICgwLCBfZ2VuZXJhdGVkMi5ibG9ja1N0YXRlbWVudCkoYmxvY2tOb2Rlcyk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB0b0NvbXB1dGVkS2V5O1xuXG52YXIgX2dlbmVyYXRlZCA9IHJlcXVpcmUoXCIuLi92YWxpZGF0b3JzL2dlbmVyYXRlZFwiKTtcblxudmFyIF9nZW5lcmF0ZWQyID0gcmVxdWlyZShcIi4uL2J1aWxkZXJzL2dlbmVyYXRlZFwiKTtcblxuZnVuY3Rpb24gdG9Db21wdXRlZEtleShub2RlLCBrZXkgPSBub2RlLmtleSB8fCBub2RlLnByb3BlcnR5KSB7XG4gIGlmICghbm9kZS5jb21wdXRlZCAmJiAoMCwgX2dlbmVyYXRlZC5pc0lkZW50aWZpZXIpKGtleSkpIGtleSA9ICgwLCBfZ2VuZXJhdGVkMi5zdHJpbmdMaXRlcmFsKShrZXkubmFtZSk7XG4gIHJldHVybiBrZXk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB0b0V4cHJlc3Npb247XG5cbnZhciBfZ2VuZXJhdGVkID0gcmVxdWlyZShcIi4uL3ZhbGlkYXRvcnMvZ2VuZXJhdGVkXCIpO1xuXG5mdW5jdGlvbiB0b0V4cHJlc3Npb24obm9kZSkge1xuICBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNFeHByZXNzaW9uU3RhdGVtZW50KShub2RlKSkge1xuICAgIG5vZGUgPSBub2RlLmV4cHJlc3Npb247XG4gIH1cblxuICBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNFeHByZXNzaW9uKShub2RlKSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzQ2xhc3MpKG5vZGUpKSB7XG4gICAgbm9kZS50eXBlID0gXCJDbGFzc0V4cHJlc3Npb25cIjtcbiAgfSBlbHNlIGlmICgoMCwgX2dlbmVyYXRlZC5pc0Z1bmN0aW9uKShub2RlKSkge1xuICAgIG5vZGUudHlwZSA9IFwiRnVuY3Rpb25FeHByZXNzaW9uXCI7XG4gIH1cblxuICBpZiAoISgwLCBfZ2VuZXJhdGVkLmlzRXhwcmVzc2lvbikobm9kZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCB0dXJuICR7bm9kZS50eXBlfSB0byBhbiBleHByZXNzaW9uYCk7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHRvSWRlbnRpZmllcjtcblxudmFyIF9pc1ZhbGlkSWRlbnRpZmllciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3ZhbGlkYXRvcnMvaXNWYWxpZElkZW50aWZpZXJcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiB0b0lkZW50aWZpZXIobmFtZSkge1xuICBuYW1lID0gbmFtZSArIFwiXCI7XG4gIG5hbWUgPSBuYW1lLnJlcGxhY2UoL1teYS16QS1aMC05JF9dL2csIFwiLVwiKTtcbiAgbmFtZSA9IG5hbWUucmVwbGFjZSgvXlstMC05XSsvLCBcIlwiKTtcbiAgbmFtZSA9IG5hbWUucmVwbGFjZSgvWy1cXHNdKyguKT8vZywgZnVuY3Rpb24gKG1hdGNoLCBjKSB7XG4gICAgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiBcIlwiO1xuICB9KTtcblxuICBpZiAoISgwLCBfaXNWYWxpZElkZW50aWZpZXIuZGVmYXVsdCkobmFtZSkpIHtcbiAgICBuYW1lID0gYF8ke25hbWV9YDtcbiAgfVxuXG4gIHJldHVybiBuYW1lIHx8IFwiX1wiO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdG9LZXlBbGlhcztcblxudmFyIF9nZW5lcmF0ZWQgPSByZXF1aXJlKFwiLi4vdmFsaWRhdG9ycy9nZW5lcmF0ZWRcIik7XG5cbnZhciBfY2xvbmVOb2RlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vY2xvbmUvY2xvbmVOb2RlXCIpKTtcblxudmFyIF9yZW1vdmVQcm9wZXJ0aWVzRGVlcCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL21vZGlmaWNhdGlvbnMvcmVtb3ZlUHJvcGVydGllc0RlZXBcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiB0b0tleUFsaWFzKG5vZGUsIGtleSA9IG5vZGUua2V5KSB7XG4gIGxldCBhbGlhcztcblxuICBpZiAobm9kZS5raW5kID09PSBcIm1ldGhvZFwiKSB7XG4gICAgcmV0dXJuIHRvS2V5QWxpYXMuaW5jcmVtZW50KCkgKyBcIlwiO1xuICB9IGVsc2UgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzSWRlbnRpZmllcikoa2V5KSkge1xuICAgIGFsaWFzID0ga2V5Lm5hbWU7XG4gIH0gZWxzZSBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNTdHJpbmdMaXRlcmFsKShrZXkpKSB7XG4gICAgYWxpYXMgPSBKU09OLnN0cmluZ2lmeShrZXkudmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGFsaWFzID0gSlNPTi5zdHJpbmdpZnkoKDAsIF9yZW1vdmVQcm9wZXJ0aWVzRGVlcC5kZWZhdWx0KSgoMCwgX2Nsb25lTm9kZS5kZWZhdWx0KShrZXkpKSk7XG4gIH1cblxuICBpZiAobm9kZS5jb21wdXRlZCkge1xuICAgIGFsaWFzID0gYFske2FsaWFzfV1gO1xuICB9XG5cbiAgaWYgKG5vZGUuc3RhdGljKSB7XG4gICAgYWxpYXMgPSBgc3RhdGljOiR7YWxpYXN9YDtcbiAgfVxuXG4gIHJldHVybiBhbGlhcztcbn1cblxudG9LZXlBbGlhcy51aWQgPSAwO1xuXG50b0tleUFsaWFzLmluY3JlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRvS2V5QWxpYXMudWlkID49IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgcmV0dXJuIHRvS2V5QWxpYXMudWlkID0gMDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdG9LZXlBbGlhcy51aWQrKztcbiAgfVxufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHRvU2VxdWVuY2VFeHByZXNzaW9uO1xuXG52YXIgX2dhdGhlclNlcXVlbmNlRXhwcmVzc2lvbnMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2dhdGhlclNlcXVlbmNlRXhwcmVzc2lvbnNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiB0b1NlcXVlbmNlRXhwcmVzc2lvbihub2Rlcywgc2NvcGUpIHtcbiAgaWYgKCEobm9kZXMgPT0gbnVsbCA/IHZvaWQgMCA6IG5vZGVzLmxlbmd0aCkpIHJldHVybjtcbiAgY29uc3QgZGVjbGFycyA9IFtdO1xuICBjb25zdCByZXN1bHQgPSAoMCwgX2dhdGhlclNlcXVlbmNlRXhwcmVzc2lvbnMuZGVmYXVsdCkobm9kZXMsIHNjb3BlLCBkZWNsYXJzKTtcbiAgaWYgKCFyZXN1bHQpIHJldHVybjtcblxuICBmb3IgKGNvbnN0IGRlY2xhciBvZiBkZWNsYXJzKSB7XG4gICAgc2NvcGUucHVzaChkZWNsYXIpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHRvU3RhdGVtZW50O1xuXG52YXIgX2dlbmVyYXRlZCA9IHJlcXVpcmUoXCIuLi92YWxpZGF0b3JzL2dlbmVyYXRlZFwiKTtcblxudmFyIF9nZW5lcmF0ZWQyID0gcmVxdWlyZShcIi4uL2J1aWxkZXJzL2dlbmVyYXRlZFwiKTtcblxuZnVuY3Rpb24gdG9TdGF0ZW1lbnQobm9kZSwgaWdub3JlKSB7XG4gIGlmICgoMCwgX2dlbmVyYXRlZC5pc1N0YXRlbWVudCkobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGxldCBtdXN0SGF2ZUlkID0gZmFsc2U7XG4gIGxldCBuZXdUeXBlO1xuXG4gIGlmICgoMCwgX2dlbmVyYXRlZC5pc0NsYXNzKShub2RlKSkge1xuICAgIG11c3RIYXZlSWQgPSB0cnVlO1xuICAgIG5ld1R5cGUgPSBcIkNsYXNzRGVjbGFyYXRpb25cIjtcbiAgfSBlbHNlIGlmICgoMCwgX2dlbmVyYXRlZC5pc0Z1bmN0aW9uKShub2RlKSkge1xuICAgIG11c3RIYXZlSWQgPSB0cnVlO1xuICAgIG5ld1R5cGUgPSBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIjtcbiAgfSBlbHNlIGlmICgoMCwgX2dlbmVyYXRlZC5pc0Fzc2lnbm1lbnRFeHByZXNzaW9uKShub2RlKSkge1xuICAgIHJldHVybiAoMCwgX2dlbmVyYXRlZDIuZXhwcmVzc2lvblN0YXRlbWVudCkobm9kZSk7XG4gIH1cblxuICBpZiAobXVzdEhhdmVJZCAmJiAhbm9kZS5pZCkge1xuICAgIG5ld1R5cGUgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICghbmV3VHlwZSkge1xuICAgIGlmIChpZ25vcmUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgdHVybiAke25vZGUudHlwZX0gdG8gYSBzdGF0ZW1lbnRgKTtcbiAgICB9XG4gIH1cblxuICBub2RlLnR5cGUgPSBuZXdUeXBlO1xuICByZXR1cm4gbm9kZTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZhbHVlVG9Ob2RlO1xuXG52YXIgX2lzUGxhaW5PYmplY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNQbGFpbk9iamVjdFwiKSk7XG5cbnZhciBfaXNSZWdFeHAgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNSZWdFeHBcIikpO1xuXG52YXIgX2lzVmFsaWRJZGVudGlmaWVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vdmFsaWRhdG9ycy9pc1ZhbGlkSWRlbnRpZmllclwiKSk7XG5cbnZhciBfZ2VuZXJhdGVkID0gcmVxdWlyZShcIi4uL2J1aWxkZXJzL2dlbmVyYXRlZFwiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gdmFsdWVUb05vZGUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gKDAsIF9nZW5lcmF0ZWQuaWRlbnRpZmllcikoXCJ1bmRlZmluZWRcIik7XG4gIH1cblxuICBpZiAodmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuICgwLCBfZ2VuZXJhdGVkLmJvb2xlYW5MaXRlcmFsKSh2YWx1ZSk7XG4gIH1cblxuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gKDAsIF9nZW5lcmF0ZWQubnVsbExpdGVyYWwpKCk7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuICgwLCBfZ2VuZXJhdGVkLnN0cmluZ0xpdGVyYWwpKHZhbHVlKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICBsZXQgcmVzdWx0O1xuXG4gICAgaWYgKE51bWJlci5pc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgIHJlc3VsdCA9ICgwLCBfZ2VuZXJhdGVkLm51bWVyaWNMaXRlcmFsKShNYXRoLmFicyh2YWx1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbnVtZXJhdG9yO1xuXG4gICAgICBpZiAoTnVtYmVyLmlzTmFOKHZhbHVlKSkge1xuICAgICAgICBudW1lcmF0b3IgPSAoMCwgX2dlbmVyYXRlZC5udW1lcmljTGl0ZXJhbCkoMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBudW1lcmF0b3IgPSAoMCwgX2dlbmVyYXRlZC5udW1lcmljTGl0ZXJhbCkoMSk7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCA9ICgwLCBfZ2VuZXJhdGVkLmJpbmFyeUV4cHJlc3Npb24pKFwiL1wiLCBudW1lcmF0b3IsICgwLCBfZ2VuZXJhdGVkLm51bWVyaWNMaXRlcmFsKSgwKSk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlIDwgMCB8fCBPYmplY3QuaXModmFsdWUsIC0wKSkge1xuICAgICAgcmVzdWx0ID0gKDAsIF9nZW5lcmF0ZWQudW5hcnlFeHByZXNzaW9uKShcIi1cIiwgcmVzdWx0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCgwLCBfaXNSZWdFeHAuZGVmYXVsdCkodmFsdWUpKSB7XG4gICAgY29uc3QgcGF0dGVybiA9IHZhbHVlLnNvdXJjZTtcbiAgICBjb25zdCBmbGFncyA9IHZhbHVlLnRvU3RyaW5nKCkubWF0Y2goL1xcLyhbYS16XSt8KSQvKVsxXTtcbiAgICByZXR1cm4gKDAsIF9nZW5lcmF0ZWQucmVnRXhwTGl0ZXJhbCkocGF0dGVybiwgZmxhZ3MpO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuICgwLCBfZ2VuZXJhdGVkLmFycmF5RXhwcmVzc2lvbikodmFsdWUubWFwKHZhbHVlVG9Ob2RlKSk7XG4gIH1cblxuICBpZiAoKDAsIF9pc1BsYWluT2JqZWN0LmRlZmF1bHQpKHZhbHVlKSkge1xuICAgIGNvbnN0IHByb3BzID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh2YWx1ZSkpIHtcbiAgICAgIGxldCBub2RlS2V5O1xuXG4gICAgICBpZiAoKDAsIF9pc1ZhbGlkSWRlbnRpZmllci5kZWZhdWx0KShrZXkpKSB7XG4gICAgICAgIG5vZGVLZXkgPSAoMCwgX2dlbmVyYXRlZC5pZGVudGlmaWVyKShrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZUtleSA9ICgwLCBfZ2VuZXJhdGVkLnN0cmluZ0xpdGVyYWwpKGtleSk7XG4gICAgICB9XG5cbiAgICAgIHByb3BzLnB1c2goKDAsIF9nZW5lcmF0ZWQub2JqZWN0UHJvcGVydHkpKG5vZGVLZXksIHZhbHVlVG9Ob2RlKHZhbHVlW2tleV0pKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICgwLCBfZ2VuZXJhdGVkLm9iamVjdEV4cHJlc3Npb24pKHByb3BzKTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihcImRvbid0IGtub3cgaG93IHRvIHR1cm4gdGhpcyB2YWx1ZSBpbnRvIGEgbm9kZVwiKTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY2xhc3NNZXRob2RPckRlY2xhcmVNZXRob2RDb21tb24gPSBleHBvcnRzLmNsYXNzTWV0aG9kT3JQcm9wZXJ0eUNvbW1vbiA9IGV4cG9ydHMucGF0dGVybkxpa2VDb21tb24gPSBleHBvcnRzLmZ1bmN0aW9uRGVjbGFyYXRpb25Db21tb24gPSBleHBvcnRzLmZ1bmN0aW9uVHlwZUFubm90YXRpb25Db21tb24gPSBleHBvcnRzLmZ1bmN0aW9uQ29tbW9uID0gdm9pZCAwO1xuXG52YXIgX2lzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vdmFsaWRhdG9ycy9pc1wiKSk7XG5cbnZhciBfaXNWYWxpZElkZW50aWZpZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi92YWxpZGF0b3JzL2lzVmFsaWRJZGVudGlmaWVyXCIpKTtcblxudmFyIF9oZWxwZXJWYWxpZGF0b3JJZGVudGlmaWVyID0gcmVxdWlyZShcIkBiYWJlbC9oZWxwZXItdmFsaWRhdG9yLWlkZW50aWZpZXJcIik7XG5cbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcblxudmFyIF91dGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3V0aWxzXCIpKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IGRlZmF1bHQ6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJBcnJheUV4cHJlc3Npb25cIiwge1xuICBmaWVsZHM6IHtcbiAgICBlbGVtZW50czoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZU9yVmFsdWVUeXBlKShcIm51bGxcIiwgXCJFeHByZXNzaW9uXCIsIFwiU3ByZWFkRWxlbWVudFwiKSkpLFxuICAgICAgZGVmYXVsdDogIXByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcgPyBbXSA6IHVuZGVmaW5lZFxuICAgIH1cbiAgfSxcbiAgdmlzaXRvcjogW1wiZWxlbWVudHNcIl0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIl1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIsIHtcbiAgZmllbGRzOiB7XG4gICAgb3BlcmF0b3I6IHtcbiAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORykge1xuICAgICAgICAgIHJldHVybiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gKDAsIF91dGlscy5hc3NlcnRPbmVPZikoLi4uX2NvbnN0YW50cy5BU1NJR05NRU5UX09QRVJBVE9SUyk7XG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSAoMCwgX3V0aWxzLmFzc2VydE9uZU9mKShcIj1cIik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSwga2V5LCB2YWwpIHtcbiAgICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSAoMCwgX2lzLmRlZmF1bHQpKFwiUGF0dGVyblwiLCBub2RlLmxlZnQpID8gcGF0dGVybiA6IGlkZW50aWZpZXI7XG4gICAgICAgICAgdmFsaWRhdG9yKG5vZGUsIGtleSwgdmFsKTtcbiAgICAgICAgfTtcbiAgICAgIH0oKVxuICAgIH0sXG4gICAgbGVmdDoge1xuICAgICAgdmFsaWRhdGU6ICFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HID8gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJMVmFsXCIpIDogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIsIFwiTWVtYmVyRXhwcmVzc2lvblwiLCBcIkFycmF5UGF0dGVyblwiLCBcIk9iamVjdFBhdHRlcm5cIilcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9LFxuICBidWlsZGVyOiBbXCJvcGVyYXRvclwiLCBcImxlZnRcIiwgXCJyaWdodFwiXSxcbiAgdmlzaXRvcjogW1wibGVmdFwiLCBcInJpZ2h0XCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJCaW5hcnlFeHByZXNzaW9uXCIsIHtcbiAgYnVpbGRlcjogW1wib3BlcmF0b3JcIiwgXCJsZWZ0XCIsIFwicmlnaHRcIl0sXG4gIGZpZWxkczoge1xuICAgIG9wZXJhdG9yOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRPbmVPZikoLi4uX2NvbnN0YW50cy5CSU5BUllfT1BFUkFUT1JTKVxuICAgIH0sXG4gICAgbGVmdDoge1xuICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKTtcbiAgICAgICAgY29uc3QgaW5PcCA9ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiLCBcIlByaXZhdGVOYW1lXCIpO1xuXG4gICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IGZ1bmN0aW9uIChub2RlLCBrZXksIHZhbCkge1xuICAgICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IG5vZGUub3BlcmF0b3IgPT09IFwiaW5cIiA/IGluT3AgOiBleHByZXNzaW9uO1xuICAgICAgICAgIHZhbGlkYXRvcihub2RlLCBrZXksIHZhbCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFsaWRhdG9yLm9uZU9mTm9kZVR5cGVzID0gW1wiRXhwcmVzc2lvblwiLCBcIlByaXZhdGVOYW1lXCJdO1xuICAgICAgICByZXR1cm4gdmFsaWRhdG9yO1xuICAgICAgfSgpXG4gICAgfSxcbiAgICByaWdodDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgfSxcbiAgdmlzaXRvcjogW1wibGVmdFwiLCBcInJpZ2h0XCJdLFxuICBhbGlhc2VzOiBbXCJCaW5hcnlcIiwgXCJFeHByZXNzaW9uXCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJJbnRlcnByZXRlckRpcmVjdGl2ZVwiLCB7XG4gIGJ1aWxkZXI6IFtcInZhbHVlXCJdLFxuICBmaWVsZHM6IHtcbiAgICB2YWx1ZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRGlyZWN0aXZlXCIsIHtcbiAgdmlzaXRvcjogW1widmFsdWVcIl0sXG4gIGZpZWxkczoge1xuICAgIHZhbHVlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJEaXJlY3RpdmVMaXRlcmFsXCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJEaXJlY3RpdmVMaXRlcmFsXCIsIHtcbiAgYnVpbGRlcjogW1widmFsdWVcIl0sXG4gIGZpZWxkczoge1xuICAgIHZhbHVlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwic3RyaW5nXCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJCbG9ja1N0YXRlbWVudFwiLCB7XG4gIGJ1aWxkZXI6IFtcImJvZHlcIiwgXCJkaXJlY3RpdmVzXCJdLFxuICB2aXNpdG9yOiBbXCJkaXJlY3RpdmVzXCIsIFwiYm9keVwiXSxcbiAgZmllbGRzOiB7XG4gICAgZGlyZWN0aXZlczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRGlyZWN0aXZlXCIpKSksXG4gICAgICBkZWZhdWx0OiBbXVxuICAgIH0sXG4gICAgYm9keToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiU3RhdGVtZW50XCIpKSlcbiAgICB9XG4gIH0sXG4gIGFsaWFzZXM6IFtcIlNjb3BhYmxlXCIsIFwiQmxvY2tQYXJlbnRcIiwgXCJCbG9ja1wiLCBcIlN0YXRlbWVudFwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiQnJlYWtTdGF0ZW1lbnRcIiwge1xuICB2aXNpdG9yOiBbXCJsYWJlbFwiXSxcbiAgZmllbGRzOiB7XG4gICAgbGFiZWw6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgYWxpYXNlczogW1wiU3RhdGVtZW50XCIsIFwiVGVybWluYXRvcmxlc3NcIiwgXCJDb21wbGV0aW9uU3RhdGVtZW50XCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJDYWxsRXhwcmVzc2lvblwiLCB7XG4gIHZpc2l0b3I6IFtcImNhbGxlZVwiLCBcImFyZ3VtZW50c1wiLCBcInR5cGVQYXJhbWV0ZXJzXCIsIFwidHlwZUFyZ3VtZW50c1wiXSxcbiAgYnVpbGRlcjogW1wiY2FsbGVlXCIsIFwiYXJndW1lbnRzXCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdLFxuICBmaWVsZHM6IE9iamVjdC5hc3NpZ24oe1xuICAgIGNhbGxlZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiLCBcIlY4SW50cmluc2ljSWRlbnRpZmllclwiKVxuICAgIH0sXG4gICAgYXJndW1lbnRzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIsIFwiU3ByZWFkRWxlbWVudFwiLCBcIkpTWE5hbWVzcGFjZWROYW1lXCIsIFwiQXJndW1lbnRQbGFjZWhvbGRlclwiKSkpXG4gICAgfVxuICB9LCAhcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORyA/IHtcbiAgICBvcHRpb25hbDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKHRydWUsIGZhbHNlKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9IDoge30sIHtcbiAgICB0eXBlQXJndW1lbnRzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICB0eXBlUGFyYW1ldGVyczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9KVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiQ2F0Y2hDbGF1c2VcIiwge1xuICB2aXNpdG9yOiBbXCJwYXJhbVwiLCBcImJvZHlcIl0sXG4gIGZpZWxkczoge1xuICAgIHBhcmFtOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIsIFwiQXJyYXlQYXR0ZXJuXCIsIFwiT2JqZWN0UGF0dGVyblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJCbG9ja1N0YXRlbWVudFwiKVxuICAgIH1cbiAgfSxcbiAgYWxpYXNlczogW1wiU2NvcGFibGVcIiwgXCJCbG9ja1BhcmVudFwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIsIHtcbiAgdmlzaXRvcjogW1widGVzdFwiLCBcImNvbnNlcXVlbnRcIiwgXCJhbHRlcm5hdGVcIl0sXG4gIGZpZWxkczoge1xuICAgIHRlc3Q6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIGNvbnNlcXVlbnQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIGFsdGVybmF0ZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgfSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiLCBcIkNvbmRpdGlvbmFsXCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJDb250aW51ZVN0YXRlbWVudFwiLCB7XG4gIHZpc2l0b3I6IFtcImxhYmVsXCJdLFxuICBmaWVsZHM6IHtcbiAgICBsYWJlbDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9LFxuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJUZXJtaW5hdG9ybGVzc1wiLCBcIkNvbXBsZXRpb25TdGF0ZW1lbnRcIl1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkRlYnVnZ2VyU3RhdGVtZW50XCIsIHtcbiAgYWxpYXNlczogW1wiU3RhdGVtZW50XCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJEb1doaWxlU3RhdGVtZW50XCIsIHtcbiAgdmlzaXRvcjogW1widGVzdFwiLCBcImJvZHlcIl0sXG4gIGZpZWxkczoge1xuICAgIHRlc3Q6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlN0YXRlbWVudFwiKVxuICAgIH1cbiAgfSxcbiAgYWxpYXNlczogW1wiU3RhdGVtZW50XCIsIFwiQmxvY2tQYXJlbnRcIiwgXCJMb29wXCIsIFwiV2hpbGVcIiwgXCJTY29wYWJsZVwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRW1wdHlTdGF0ZW1lbnRcIiwge1xuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIl1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIiwge1xuICB2aXNpdG9yOiBbXCJleHByZXNzaW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9LFxuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJFeHByZXNzaW9uV3JhcHBlclwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRmlsZVwiLCB7XG4gIGJ1aWxkZXI6IFtcInByb2dyYW1cIiwgXCJjb21tZW50c1wiLCBcInRva2Vuc1wiXSxcbiAgdmlzaXRvcjogW1wicHJvZ3JhbVwiXSxcbiAgZmllbGRzOiB7XG4gICAgcHJvZ3JhbToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiUHJvZ3JhbVwiKVxuICAgIH0sXG4gICAgY29tbWVudHM6IHtcbiAgICAgIHZhbGlkYXRlOiAhcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORyA/IE9iamVjdC5hc3NpZ24oKCkgPT4ge30sIHtcbiAgICAgICAgZWFjaDoge1xuICAgICAgICAgIG9uZU9mTm9kZVR5cGVzOiBbXCJDb21tZW50QmxvY2tcIiwgXCJDb21tZW50TGluZVwiXVxuICAgICAgICB9XG4gICAgICB9KSA6ICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJDb21tZW50QmxvY2tcIiwgXCJDb21tZW50TGluZVwiKSksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgdG9rZW5zOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRFYWNoKShPYmplY3QuYXNzaWduKCgpID0+IHt9LCB7XG4gICAgICAgIHR5cGU6IFwiYW55XCJcbiAgICAgIH0pKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJGb3JJblN0YXRlbWVudFwiLCB7XG4gIHZpc2l0b3I6IFtcImxlZnRcIiwgXCJyaWdodFwiLCBcImJvZHlcIl0sXG4gIGFsaWFzZXM6IFtcIlNjb3BhYmxlXCIsIFwiU3RhdGVtZW50XCIsIFwiRm9yXCIsIFwiQmxvY2tQYXJlbnRcIiwgXCJMb29wXCIsIFwiRm9yWFN0YXRlbWVudFwiXSxcbiAgZmllbGRzOiB7XG4gICAgbGVmdDoge1xuICAgICAgdmFsaWRhdGU6ICFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HID8gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsIFwiTFZhbFwiKSA6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVmFyaWFibGVEZWNsYXJhdGlvblwiLCBcIklkZW50aWZpZXJcIiwgXCJNZW1iZXJFeHByZXNzaW9uXCIsIFwiQXJyYXlQYXR0ZXJuXCIsIFwiT2JqZWN0UGF0dGVyblwiKVxuICAgIH0sXG4gICAgcmlnaHQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlN0YXRlbWVudFwiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRm9yU3RhdGVtZW50XCIsIHtcbiAgdmlzaXRvcjogW1wiaW5pdFwiLCBcInRlc3RcIiwgXCJ1cGRhdGVcIiwgXCJib2R5XCJdLFxuICBhbGlhc2VzOiBbXCJTY29wYWJsZVwiLCBcIlN0YXRlbWVudFwiLCBcIkZvclwiLCBcIkJsb2NrUGFyZW50XCIsIFwiTG9vcFwiXSxcbiAgZmllbGRzOiB7XG4gICAgaW5pdDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVmFyaWFibGVEZWNsYXJhdGlvblwiLCBcIkV4cHJlc3Npb25cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgdGVzdDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICB1cGRhdGU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgYm9keToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiU3RhdGVtZW50XCIpXG4gICAgfVxuICB9XG59KTtcbmNvbnN0IGZ1bmN0aW9uQ29tbW9uID0ge1xuICBwYXJhbXM6IHtcbiAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIsIFwiUGF0dGVyblwiLCBcIlJlc3RFbGVtZW50XCIsIFwiVFNQYXJhbWV0ZXJQcm9wZXJ0eVwiKSkpXG4gIH0sXG4gIGdlbmVyYXRvcjoge1xuICAgIGRlZmF1bHQ6IGZhbHNlXG4gIH0sXG4gIGFzeW5jOiB7XG4gICAgZGVmYXVsdDogZmFsc2VcbiAgfVxufTtcbmV4cG9ydHMuZnVuY3Rpb25Db21tb24gPSBmdW5jdGlvbkNvbW1vbjtcbmNvbnN0IGZ1bmN0aW9uVHlwZUFubm90YXRpb25Db21tb24gPSB7XG4gIHJldHVyblR5cGU6IHtcbiAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJUeXBlQW5ub3RhdGlvblwiLCBcIlRTVHlwZUFubm90YXRpb25cIiwgXCJOb29wXCIpLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0sXG4gIHR5cGVQYXJhbWV0ZXJzOiB7XG4gICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIsIFwiVFNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiwgXCJOb29wXCIpLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH1cbn07XG5leHBvcnRzLmZ1bmN0aW9uVHlwZUFubm90YXRpb25Db21tb24gPSBmdW5jdGlvblR5cGVBbm5vdGF0aW9uQ29tbW9uO1xuY29uc3QgZnVuY3Rpb25EZWNsYXJhdGlvbkNvbW1vbiA9IE9iamVjdC5hc3NpZ24oe30sIGZ1bmN0aW9uQ29tbW9uLCB7XG4gIGRlY2xhcmU6IHtcbiAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9LFxuICBpZDoge1xuICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIiksXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfVxufSk7XG5leHBvcnRzLmZ1bmN0aW9uRGVjbGFyYXRpb25Db21tb24gPSBmdW5jdGlvbkRlY2xhcmF0aW9uQ29tbW9uO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiwge1xuICBidWlsZGVyOiBbXCJpZFwiLCBcInBhcmFtc1wiLCBcImJvZHlcIiwgXCJnZW5lcmF0b3JcIiwgXCJhc3luY1wiXSxcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJwYXJhbXNcIiwgXCJib2R5XCIsIFwicmV0dXJuVHlwZVwiLCBcInR5cGVQYXJhbWV0ZXJzXCJdLFxuICBmaWVsZHM6IE9iamVjdC5hc3NpZ24oe30sIGZ1bmN0aW9uRGVjbGFyYXRpb25Db21tb24sIGZ1bmN0aW9uVHlwZUFubm90YXRpb25Db21tb24sIHtcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJCbG9ja1N0YXRlbWVudFwiKVxuICAgIH1cbiAgfSksXG4gIGFsaWFzZXM6IFtcIlNjb3BhYmxlXCIsIFwiRnVuY3Rpb25cIiwgXCJCbG9ja1BhcmVudFwiLCBcIkZ1bmN0aW9uUGFyZW50XCIsIFwiU3RhdGVtZW50XCIsIFwiUHVyZWlzaFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICB2YWxpZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIGlmICghcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORykgcmV0dXJuICgpID0+IHt9O1xuICAgIGNvbnN0IGlkZW50aWZpZXIgPSAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwYXJlbnQsIGtleSwgbm9kZSkge1xuICAgICAgaWYgKCEoMCwgX2lzLmRlZmF1bHQpKFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIsIHBhcmVudCkpIHtcbiAgICAgICAgaWRlbnRpZmllcihub2RlLCBcImlkXCIsIG5vZGUuaWQpO1xuICAgICAgfVxuICAgIH07XG4gIH0oKVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRnVuY3Rpb25FeHByZXNzaW9uXCIsIHtcbiAgaW5oZXJpdHM6IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiLFxuICBhbGlhc2VzOiBbXCJTY29wYWJsZVwiLCBcIkZ1bmN0aW9uXCIsIFwiQmxvY2tQYXJlbnRcIiwgXCJGdW5jdGlvblBhcmVudFwiLCBcIkV4cHJlc3Npb25cIiwgXCJQdXJlaXNoXCJdLFxuICBmaWVsZHM6IE9iamVjdC5hc3NpZ24oe30sIGZ1bmN0aW9uQ29tbW9uLCBmdW5jdGlvblR5cGVBbm5vdGF0aW9uQ29tbW9uLCB7XG4gICAgaWQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgYm9keToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiQmxvY2tTdGF0ZW1lbnRcIilcbiAgICB9XG4gIH0pXG59KTtcbmNvbnN0IHBhdHRlcm5MaWtlQ29tbW9uID0ge1xuICB0eXBlQW5ub3RhdGlvbjoge1xuICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlR5cGVBbm5vdGF0aW9uXCIsIFwiVFNUeXBlQW5ub3RhdGlvblwiLCBcIk5vb3BcIiksXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSxcbiAgZGVjb3JhdG9yczoge1xuICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJhcnJheVwiKSwgKDAsIF91dGlscy5hc3NlcnRFYWNoKSgoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkRlY29yYXRvclwiKSkpXG4gIH1cbn07XG5leHBvcnRzLnBhdHRlcm5MaWtlQ29tbW9uID0gcGF0dGVybkxpa2VDb21tb247XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiSWRlbnRpZmllclwiLCB7XG4gIGJ1aWxkZXI6IFtcIm5hbWVcIl0sXG4gIHZpc2l0b3I6IFtcInR5cGVBbm5vdGF0aW9uXCIsIFwiZGVjb3JhdG9yc1wiXSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiLCBcIlBhdHRlcm5MaWtlXCIsIFwiTFZhbFwiLCBcIlRTRW50aXR5TmFtZVwiXSxcbiAgZmllbGRzOiBPYmplY3QuYXNzaWduKHt9LCBwYXR0ZXJuTGlrZUNvbW1vbiwge1xuICAgIG5hbWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIiksIE9iamVjdC5hc3NpZ24oZnVuY3Rpb24gKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgICAgIGlmICghcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORykgcmV0dXJuO1xuXG4gICAgICAgIGlmICghKDAsIF9pc1ZhbGlkSWRlbnRpZmllci5kZWZhdWx0KSh2YWwsIGZhbHNlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFwiJHt2YWx9XCIgaXMgbm90IGEgdmFsaWQgaWRlbnRpZmllciBuYW1lYCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgICAgfSkpXG4gICAgfSxcbiAgICBvcHRpb25hbDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfSksXG5cbiAgdmFsaWRhdGUocGFyZW50LCBrZXksIG5vZGUpIHtcbiAgICBpZiAoIXByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcpIHJldHVybjtcbiAgICBjb25zdCBtYXRjaCA9IC9cXC4oXFx3KykkLy5leGVjKGtleSk7XG4gICAgaWYgKCFtYXRjaCkgcmV0dXJuO1xuICAgIGNvbnN0IFssIHBhcmVudEtleV0gPSBtYXRjaDtcbiAgICBjb25zdCBub25Db21wID0ge1xuICAgICAgY29tcHV0ZWQ6IGZhbHNlXG4gICAgfTtcblxuICAgIGlmIChwYXJlbnRLZXkgPT09IFwicHJvcGVydHlcIikge1xuICAgICAgaWYgKCgwLCBfaXMuZGVmYXVsdCkoXCJNZW1iZXJFeHByZXNzaW9uXCIsIHBhcmVudCwgbm9uQ29tcCkpIHJldHVybjtcbiAgICAgIGlmICgoMCwgX2lzLmRlZmF1bHQpKFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCIsIHBhcmVudCwgbm9uQ29tcCkpIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHBhcmVudEtleSA9PT0gXCJrZXlcIikge1xuICAgICAgaWYgKCgwLCBfaXMuZGVmYXVsdCkoXCJQcm9wZXJ0eVwiLCBwYXJlbnQsIG5vbkNvbXApKSByZXR1cm47XG4gICAgICBpZiAoKDAsIF9pcy5kZWZhdWx0KShcIk1ldGhvZFwiLCBwYXJlbnQsIG5vbkNvbXApKSByZXR1cm47XG4gICAgfSBlbHNlIGlmIChwYXJlbnRLZXkgPT09IFwiZXhwb3J0ZWRcIikge1xuICAgICAgaWYgKCgwLCBfaXMuZGVmYXVsdCkoXCJFeHBvcnRTcGVjaWZpZXJcIiwgcGFyZW50KSkgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAocGFyZW50S2V5ID09PSBcImltcG9ydGVkXCIpIHtcbiAgICAgIGlmICgoMCwgX2lzLmRlZmF1bHQpKFwiSW1wb3J0U3BlY2lmaWVyXCIsIHBhcmVudCwge1xuICAgICAgICBpbXBvcnRlZDogbm9kZVxuICAgICAgfSkpIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHBhcmVudEtleSA9PT0gXCJtZXRhXCIpIHtcbiAgICAgIGlmICgoMCwgX2lzLmRlZmF1bHQpKFwiTWV0YVByb3BlcnR5XCIsIHBhcmVudCwge1xuICAgICAgICBtZXRhOiBub2RlXG4gICAgICB9KSkgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICgoKDAsIF9oZWxwZXJWYWxpZGF0b3JJZGVudGlmaWVyLmlzS2V5d29yZCkobm9kZS5uYW1lKSB8fCAoMCwgX2hlbHBlclZhbGlkYXRvcklkZW50aWZpZXIuaXNSZXNlcnZlZFdvcmQpKG5vZGUubmFtZSkpICYmIG5vZGUubmFtZSAhPT0gXCJ0aGlzXCIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFwiJHtub2RlLm5hbWV9XCIgaXMgbm90IGEgdmFsaWQgaWRlbnRpZmllcmApO1xuICAgIH1cbiAgfVxuXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJJZlN0YXRlbWVudFwiLCB7XG4gIHZpc2l0b3I6IFtcInRlc3RcIiwgXCJjb25zZXF1ZW50XCIsIFwiYWx0ZXJuYXRlXCJdLFxuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJDb25kaXRpb25hbFwiXSxcbiAgZmllbGRzOiB7XG4gICAgdGVzdDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgY29uc2VxdWVudDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiU3RhdGVtZW50XCIpXG4gICAgfSxcbiAgICBhbHRlcm5hdGU6IHtcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiU3RhdGVtZW50XCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJMYWJlbGVkU3RhdGVtZW50XCIsIHtcbiAgdmlzaXRvcjogW1wibGFiZWxcIiwgXCJib2R5XCJdLFxuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIl0sXG4gIGZpZWxkczoge1xuICAgIGxhYmVsOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJTdGF0ZW1lbnRcIilcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlN0cmluZ0xpdGVyYWxcIiwge1xuICBidWlsZGVyOiBbXCJ2YWx1ZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIilcbiAgICB9XG4gIH0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIiwgXCJQdXJlaXNoXCIsIFwiTGl0ZXJhbFwiLCBcIkltbXV0YWJsZVwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiTnVtZXJpY0xpdGVyYWxcIiwge1xuICBidWlsZGVyOiBbXCJ2YWx1ZVwiXSxcbiAgZGVwcmVjYXRlZEFsaWFzOiBcIk51bWJlckxpdGVyYWxcIixcbiAgZmllbGRzOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJudW1iZXJcIilcbiAgICB9XG4gIH0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIiwgXCJQdXJlaXNoXCIsIFwiTGl0ZXJhbFwiLCBcIkltbXV0YWJsZVwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiTnVsbExpdGVyYWxcIiwge1xuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCIsIFwiUHVyZWlzaFwiLCBcIkxpdGVyYWxcIiwgXCJJbW11dGFibGVcIl1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkJvb2xlYW5MaXRlcmFsXCIsIHtcbiAgYnVpbGRlcjogW1widmFsdWVcIl0sXG4gIGZpZWxkczoge1xuICAgIHZhbHVlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKVxuICAgIH1cbiAgfSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiLCBcIlB1cmVpc2hcIiwgXCJMaXRlcmFsXCIsIFwiSW1tdXRhYmxlXCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJSZWdFeHBMaXRlcmFsXCIsIHtcbiAgYnVpbGRlcjogW1wicGF0dGVyblwiLCBcImZsYWdzXCJdLFxuICBkZXByZWNhdGVkQWxpYXM6IFwiUmVnZXhMaXRlcmFsXCIsXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIiwgXCJQdXJlaXNoXCIsIFwiTGl0ZXJhbFwiXSxcbiAgZmllbGRzOiB7XG4gICAgcGF0dGVybjoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKVxuICAgIH0sXG4gICAgZmxhZ3M6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIiksIE9iamVjdC5hc3NpZ24oZnVuY3Rpb24gKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgICAgIGlmICghcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORykgcmV0dXJuO1xuICAgICAgICBjb25zdCBpbnZhbGlkID0gL1teZ2ltc3V5XS8uZXhlYyh2YWwpO1xuXG4gICAgICAgIGlmIChpbnZhbGlkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgXCIke2ludmFsaWRbMF19XCIgaXMgbm90IGEgdmFsaWQgUmVnRXhwIGZsYWdgKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICB9KSksXG4gICAgICBkZWZhdWx0OiBcIlwiXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJMb2dpY2FsRXhwcmVzc2lvblwiLCB7XG4gIGJ1aWxkZXI6IFtcIm9wZXJhdG9yXCIsIFwibGVmdFwiLCBcInJpZ2h0XCJdLFxuICB2aXNpdG9yOiBbXCJsZWZ0XCIsIFwicmlnaHRcIl0sXG4gIGFsaWFzZXM6IFtcIkJpbmFyeVwiLCBcIkV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczoge1xuICAgIG9wZXJhdG9yOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRPbmVPZikoLi4uX2NvbnN0YW50cy5MT0dJQ0FMX09QRVJBVE9SUylcbiAgICB9LFxuICAgIGxlZnQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJNZW1iZXJFeHByZXNzaW9uXCIsIHtcbiAgYnVpbGRlcjogW1wib2JqZWN0XCIsIFwicHJvcGVydHlcIiwgXCJjb21wdXRlZFwiLCBcIm9wdGlvbmFsXCJdLFxuICB2aXNpdG9yOiBbXCJvYmplY3RcIiwgXCJwcm9wZXJ0eVwiXSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiLCBcIkxWYWxcIl0sXG4gIGZpZWxkczogT2JqZWN0LmFzc2lnbih7XG4gICAgb2JqZWN0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICBwcm9wZXJ0eToge1xuICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3Qgbm9ybWFsID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIsIFwiUHJpdmF0ZU5hbWVcIik7XG4gICAgICAgIGNvbnN0IGNvbXB1dGVkID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpO1xuXG4gICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IGZ1bmN0aW9uIChub2RlLCBrZXksIHZhbCkge1xuICAgICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IG5vZGUuY29tcHV0ZWQgPyBjb21wdXRlZCA6IG5vcm1hbDtcbiAgICAgICAgICB2YWxpZGF0b3Iobm9kZSwga2V5LCB2YWwpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhbGlkYXRvci5vbmVPZk5vZGVUeXBlcyA9IFtcIkV4cHJlc3Npb25cIiwgXCJJZGVudGlmaWVyXCIsIFwiUHJpdmF0ZU5hbWVcIl07XG4gICAgICAgIHJldHVybiB2YWxpZGF0b3I7XG4gICAgICB9KClcbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH1cbiAgfSwgIXByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcgPyB7XG4gICAgb3B0aW9uYWw6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE9uZU9mKSh0cnVlLCBmYWxzZSksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfSA6IHt9KVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiTmV3RXhwcmVzc2lvblwiLCB7XG4gIGluaGVyaXRzOiBcIkNhbGxFeHByZXNzaW9uXCJcbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlByb2dyYW1cIiwge1xuICB2aXNpdG9yOiBbXCJkaXJlY3RpdmVzXCIsIFwiYm9keVwiXSxcbiAgYnVpbGRlcjogW1wiYm9keVwiLCBcImRpcmVjdGl2ZXNcIiwgXCJzb3VyY2VUeXBlXCIsIFwiaW50ZXJwcmV0ZXJcIl0sXG4gIGZpZWxkczoge1xuICAgIHNvdXJjZUZpbGU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIilcbiAgICB9LFxuICAgIHNvdXJjZVR5cGU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE9uZU9mKShcInNjcmlwdFwiLCBcIm1vZHVsZVwiKSxcbiAgICAgIGRlZmF1bHQ6IFwic2NyaXB0XCJcbiAgICB9LFxuICAgIGludGVycHJldGVyOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJbnRlcnByZXRlckRpcmVjdGl2ZVwiKSxcbiAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgZGlyZWN0aXZlczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRGlyZWN0aXZlXCIpKSksXG4gICAgICBkZWZhdWx0OiBbXVxuICAgIH0sXG4gICAgYm9keToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiU3RhdGVtZW50XCIpKSlcbiAgICB9XG4gIH0sXG4gIGFsaWFzZXM6IFtcIlNjb3BhYmxlXCIsIFwiQmxvY2tQYXJlbnRcIiwgXCJCbG9ja1wiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiT2JqZWN0RXhwcmVzc2lvblwiLCB7XG4gIHZpc2l0b3I6IFtcInByb3BlcnRpZXNcIl0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczoge1xuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJhcnJheVwiKSwgKDAsIF91dGlscy5hc3NlcnRFYWNoKSgoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIk9iamVjdE1ldGhvZFwiLCBcIk9iamVjdFByb3BlcnR5XCIsIFwiU3ByZWFkRWxlbWVudFwiKSkpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJPYmplY3RNZXRob2RcIiwge1xuICBidWlsZGVyOiBbXCJraW5kXCIsIFwia2V5XCIsIFwicGFyYW1zXCIsIFwiYm9keVwiLCBcImNvbXB1dGVkXCIsIFwiZ2VuZXJhdG9yXCIsIFwiYXN5bmNcIl0sXG4gIGZpZWxkczogT2JqZWN0LmFzc2lnbih7fSwgZnVuY3Rpb25Db21tb24sIGZ1bmN0aW9uVHlwZUFubm90YXRpb25Db21tb24sIHtcbiAgICBraW5kOiBPYmplY3QuYXNzaWduKHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE9uZU9mKShcIm1ldGhvZFwiLCBcImdldFwiLCBcInNldFwiKVxuICAgIH0sICFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HID8ge1xuICAgICAgZGVmYXVsdDogXCJtZXRob2RcIlxuICAgIH0gOiB7fSksXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBrZXk6IHtcbiAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbCA9ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiLCBcIlN0cmluZ0xpdGVyYWxcIiwgXCJOdW1lcmljTGl0ZXJhbFwiKTtcbiAgICAgICAgY29uc3QgY29tcHV0ZWQgPSAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIik7XG5cbiAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gZnVuY3Rpb24gKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gbm9kZS5jb21wdXRlZCA/IGNvbXB1dGVkIDogbm9ybWFsO1xuICAgICAgICAgIHZhbGlkYXRvcihub2RlLCBrZXksIHZhbCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFsaWRhdG9yLm9uZU9mTm9kZVR5cGVzID0gW1wiRXhwcmVzc2lvblwiLCBcIklkZW50aWZpZXJcIiwgXCJTdHJpbmdMaXRlcmFsXCIsIFwiTnVtZXJpY0xpdGVyYWxcIl07XG4gICAgICAgIHJldHVybiB2YWxpZGF0b3I7XG4gICAgICB9KClcbiAgICB9LFxuICAgIGRlY29yYXRvcnM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJhcnJheVwiKSwgKDAsIF91dGlscy5hc3NlcnRFYWNoKSgoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkRlY29yYXRvclwiKSkpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkJsb2NrU3RhdGVtZW50XCIpXG4gICAgfVxuICB9KSxcbiAgdmlzaXRvcjogW1wia2V5XCIsIFwicGFyYW1zXCIsIFwiYm9keVwiLCBcImRlY29yYXRvcnNcIiwgXCJyZXR1cm5UeXBlXCIsIFwidHlwZVBhcmFtZXRlcnNcIl0sXG4gIGFsaWFzZXM6IFtcIlVzZXJXaGl0ZXNwYWNhYmxlXCIsIFwiRnVuY3Rpb25cIiwgXCJTY29wYWJsZVwiLCBcIkJsb2NrUGFyZW50XCIsIFwiRnVuY3Rpb25QYXJlbnRcIiwgXCJNZXRob2RcIiwgXCJPYmplY3RNZW1iZXJcIl1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIk9iamVjdFByb3BlcnR5XCIsIHtcbiAgYnVpbGRlcjogW1wia2V5XCIsIFwidmFsdWVcIiwgXCJjb21wdXRlZFwiLCBcInNob3J0aGFuZFwiLCAuLi4oIXByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcgPyBbXCJkZWNvcmF0b3JzXCJdIDogW10pXSxcbiAgZmllbGRzOiB7XG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBrZXk6IHtcbiAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbCA9ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiLCBcIlN0cmluZ0xpdGVyYWxcIiwgXCJOdW1lcmljTGl0ZXJhbFwiKTtcbiAgICAgICAgY29uc3QgY29tcHV0ZWQgPSAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIik7XG5cbiAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gZnVuY3Rpb24gKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gbm9kZS5jb21wdXRlZCA/IGNvbXB1dGVkIDogbm9ybWFsO1xuICAgICAgICAgIHZhbGlkYXRvcihub2RlLCBrZXksIHZhbCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFsaWRhdG9yLm9uZU9mTm9kZVR5cGVzID0gW1wiRXhwcmVzc2lvblwiLCBcIklkZW50aWZpZXJcIiwgXCJTdHJpbmdMaXRlcmFsXCIsIFwiTnVtZXJpY0xpdGVyYWxcIl07XG4gICAgICAgIHJldHVybiB2YWxpZGF0b3I7XG4gICAgICB9KClcbiAgICB9LFxuICAgIHZhbHVlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIsIFwiUGF0dGVybkxpa2VcIilcbiAgICB9LFxuICAgIHNob3J0aGFuZDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksIE9iamVjdC5hc3NpZ24oZnVuY3Rpb24gKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgICAgIGlmICghcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORykgcmV0dXJuO1xuXG4gICAgICAgIGlmICh2YWwgJiYgbm9kZS5jb21wdXRlZCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcm9wZXJ0eSBzaG9ydGhhbmQgb2YgT2JqZWN0UHJvcGVydHkgY2Fubm90IGJlIHRydWUgaWYgY29tcHV0ZWQgaXMgdHJ1ZVwiKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImJvb2xlYW5cIlxuICAgICAgfSksIGZ1bmN0aW9uIChub2RlLCBrZXksIHZhbCkge1xuICAgICAgICBpZiAoIXByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcpIHJldHVybjtcblxuICAgICAgICBpZiAodmFsICYmICEoMCwgX2lzLmRlZmF1bHQpKFwiSWRlbnRpZmllclwiLCBub2RlLmtleSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJvcGVydHkgc2hvcnRoYW5kIG9mIE9iamVjdFByb3BlcnR5IGNhbm5vdCBiZSB0cnVlIGlmIGtleSBpcyBub3QgYW4gSWRlbnRpZmllclwiKTtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgZGVjb3JhdG9yczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRGVjb3JhdG9yXCIpKSksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgdmlzaXRvcjogW1wia2V5XCIsIFwidmFsdWVcIiwgXCJkZWNvcmF0b3JzXCJdLFxuICBhbGlhc2VzOiBbXCJVc2VyV2hpdGVzcGFjYWJsZVwiLCBcIlByb3BlcnR5XCIsIFwiT2JqZWN0TWVtYmVyXCJdLFxuICB2YWxpZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHBhdHRlcm4gPSAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIiwgXCJQYXR0ZXJuXCIpO1xuICAgIGNvbnN0IGV4cHJlc3Npb24gPSAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwYXJlbnQsIGtleSwgbm9kZSkge1xuICAgICAgaWYgKCFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HKSByZXR1cm47XG4gICAgICBjb25zdCB2YWxpZGF0b3IgPSAoMCwgX2lzLmRlZmF1bHQpKFwiT2JqZWN0UGF0dGVyblwiLCBwYXJlbnQpID8gcGF0dGVybiA6IGV4cHJlc3Npb247XG4gICAgICB2YWxpZGF0b3Iobm9kZSwgXCJ2YWx1ZVwiLCBub2RlLnZhbHVlKTtcbiAgICB9O1xuICB9KClcbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlJlc3RFbGVtZW50XCIsIHtcbiAgdmlzaXRvcjogW1wiYXJndW1lbnRcIiwgXCJ0eXBlQW5ub3RhdGlvblwiXSxcbiAgYnVpbGRlcjogW1wiYXJndW1lbnRcIl0sXG4gIGFsaWFzZXM6IFtcIkxWYWxcIiwgXCJQYXR0ZXJuTGlrZVwiXSxcbiAgZGVwcmVjYXRlZEFsaWFzOiBcIlJlc3RQcm9wZXJ0eVwiLFxuICBmaWVsZHM6IE9iamVjdC5hc3NpZ24oe30sIHBhdHRlcm5MaWtlQ29tbW9uLCB7XG4gICAgYXJndW1lbnQ6IHtcbiAgICAgIHZhbGlkYXRlOiAhcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORyA/ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiTFZhbFwiKSA6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiLCBcIlBhdHRlcm5cIiwgXCJNZW1iZXJFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9KSxcblxuICB2YWxpZGF0ZShwYXJlbnQsIGtleSkge1xuICAgIGlmICghcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORykgcmV0dXJuO1xuICAgIGNvbnN0IG1hdGNoID0gLyhcXHcrKVxcWyhcXGQrKVxcXS8uZXhlYyhrZXkpO1xuICAgIGlmICghbWF0Y2gpIHRocm93IG5ldyBFcnJvcihcIkludGVybmFsIEJhYmVsIGVycm9yOiBtYWxmb3JtZWQga2V5LlwiKTtcbiAgICBjb25zdCBbLCBsaXN0S2V5LCBpbmRleF0gPSBtYXRjaDtcblxuICAgIGlmIChwYXJlbnRbbGlzdEtleV0ubGVuZ3RoID4gaW5kZXggKyAxKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBSZXN0RWxlbWVudCBtdXN0IGJlIGxhc3QgZWxlbWVudCBvZiAke2xpc3RLZXl9YCk7XG4gICAgfVxuICB9XG5cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlJldHVyblN0YXRlbWVudFwiLCB7XG4gIHZpc2l0b3I6IFtcImFyZ3VtZW50XCJdLFxuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJUZXJtaW5hdG9ybGVzc1wiLCBcIkNvbXBsZXRpb25TdGF0ZW1lbnRcIl0sXG4gIGZpZWxkczoge1xuICAgIGFyZ3VtZW50OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlNlcXVlbmNlRXhwcmVzc2lvblwiLCB7XG4gIHZpc2l0b3I6IFtcImV4cHJlc3Npb25zXCJdLFxuICBmaWVsZHM6IHtcbiAgICBleHByZXNzaW9uczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKSkpXG4gICAgfVxuICB9LFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiLCB7XG4gIHZpc2l0b3I6IFtcImV4cHJlc3Npb25cIl0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIiwgXCJFeHByZXNzaW9uV3JhcHBlclwiXSxcbiAgZmllbGRzOiB7XG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiU3dpdGNoQ2FzZVwiLCB7XG4gIHZpc2l0b3I6IFtcInRlc3RcIiwgXCJjb25zZXF1ZW50XCJdLFxuICBmaWVsZHM6IHtcbiAgICB0ZXN0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIGNvbnNlcXVlbnQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJhcnJheVwiKSwgKDAsIF91dGlscy5hc3NlcnRFYWNoKSgoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlN0YXRlbWVudFwiKSkpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJTd2l0Y2hTdGF0ZW1lbnRcIiwge1xuICB2aXNpdG9yOiBbXCJkaXNjcmltaW5hbnRcIiwgXCJjYXNlc1wiXSxcbiAgYWxpYXNlczogW1wiU3RhdGVtZW50XCIsIFwiQmxvY2tQYXJlbnRcIiwgXCJTY29wYWJsZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgZGlzY3JpbWluYW50OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICBjYXNlczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiU3dpdGNoQ2FzZVwiKSkpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUaGlzRXhwcmVzc2lvblwiLCB7XG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIl1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRocm93U3RhdGVtZW50XCIsIHtcbiAgdmlzaXRvcjogW1wiYXJndW1lbnRcIl0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIlRlcm1pbmF0b3JsZXNzXCIsIFwiQ29tcGxldGlvblN0YXRlbWVudFwiXSxcbiAgZmllbGRzOiB7XG4gICAgYXJndW1lbnQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRyeVN0YXRlbWVudFwiLCB7XG4gIHZpc2l0b3I6IFtcImJsb2NrXCIsIFwiaGFuZGxlclwiLCBcImZpbmFsaXplclwiXSxcbiAgYWxpYXNlczogW1wiU3RhdGVtZW50XCJdLFxuICBmaWVsZHM6IHtcbiAgICBibG9jazoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiQmxvY2tTdGF0ZW1lbnRcIiksIE9iamVjdC5hc3NpZ24oZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HKSByZXR1cm47XG5cbiAgICAgICAgaWYgKCFub2RlLmhhbmRsZXIgJiYgIW5vZGUuZmluYWxpemVyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRyeVN0YXRlbWVudCBleHBlY3RzIGVpdGhlciBhIGhhbmRsZXIgb3IgZmluYWxpemVyLCBvciBib3RoXCIpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIG9uZU9mTm9kZVR5cGVzOiBbXCJCbG9ja1N0YXRlbWVudFwiXVxuICAgICAgfSkpXG4gICAgfSxcbiAgICBoYW5kbGVyOiB7XG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkNhdGNoQ2xhdXNlXCIpXG4gICAgfSxcbiAgICBmaW5hbGl6ZXI6IHtcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiQmxvY2tTdGF0ZW1lbnRcIilcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlVuYXJ5RXhwcmVzc2lvblwiLCB7XG4gIGJ1aWxkZXI6IFtcIm9wZXJhdG9yXCIsIFwiYXJndW1lbnRcIiwgXCJwcmVmaXhcIl0sXG4gIGZpZWxkczoge1xuICAgIHByZWZpeDoge1xuICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgIH0sXG4gICAgYXJndW1lbnQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIG9wZXJhdG9yOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRPbmVPZikoLi4uX2NvbnN0YW50cy5VTkFSWV9PUEVSQVRPUlMpXG4gICAgfVxuICB9LFxuICB2aXNpdG9yOiBbXCJhcmd1bWVudFwiXSxcbiAgYWxpYXNlczogW1wiVW5hcnlMaWtlXCIsIFwiRXhwcmVzc2lvblwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVXBkYXRlRXhwcmVzc2lvblwiLCB7XG4gIGJ1aWxkZXI6IFtcIm9wZXJhdG9yXCIsIFwiYXJndW1lbnRcIiwgXCJwcmVmaXhcIl0sXG4gIGZpZWxkczoge1xuICAgIHByZWZpeDoge1xuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGFyZ3VtZW50OiB7XG4gICAgICB2YWxpZGF0ZTogIXByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcgPyAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIikgOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIiwgXCJNZW1iZXJFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICBvcGVyYXRvcjoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKC4uLl9jb25zdGFudHMuVVBEQVRFX09QRVJBVE9SUylcbiAgICB9XG4gIH0sXG4gIHZpc2l0b3I6IFtcImFyZ3VtZW50XCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsIHtcbiAgYnVpbGRlcjogW1wia2luZFwiLCBcImRlY2xhcmF0aW9uc1wiXSxcbiAgdmlzaXRvcjogW1wiZGVjbGFyYXRpb25zXCJdLFxuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgZGVjbGFyZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAga2luZDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKFwidmFyXCIsIFwibGV0XCIsIFwiY29uc3RcIilcbiAgICB9LFxuICAgIGRlY2xhcmF0aW9uczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVmFyaWFibGVEZWNsYXJhdG9yXCIpKSlcbiAgICB9XG4gIH0sXG5cbiAgdmFsaWRhdGUocGFyZW50LCBrZXksIG5vZGUpIHtcbiAgICBpZiAoIXByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcpIHJldHVybjtcbiAgICBpZiAoISgwLCBfaXMuZGVmYXVsdCkoXCJGb3JYU3RhdGVtZW50XCIsIHBhcmVudCwge1xuICAgICAgbGVmdDogbm9kZVxuICAgIH0pKSByZXR1cm47XG5cbiAgICBpZiAobm9kZS5kZWNsYXJhdGlvbnMubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeGFjdGx5IG9uZSBWYXJpYWJsZURlY2xhcmF0b3IgaXMgcmVxdWlyZWQgaW4gdGhlIFZhcmlhYmxlRGVjbGFyYXRpb24gb2YgYSAke3BhcmVudC50eXBlfWApO1xuICAgIH1cbiAgfVxuXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJWYXJpYWJsZURlY2xhcmF0b3JcIiwge1xuICB2aXNpdG9yOiBbXCJpZFwiLCBcImluaXRcIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiB7XG4gICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcpIHtcbiAgICAgICAgICByZXR1cm4gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJMVmFsXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgbm9ybWFsID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIsIFwiQXJyYXlQYXR0ZXJuXCIsIFwiT2JqZWN0UGF0dGVyblwiKTtcbiAgICAgICAgY29uc3Qgd2l0aG91dCA9ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChub2RlLCBrZXksIHZhbCkge1xuICAgICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IG5vZGUuaW5pdCA/IG5vcm1hbCA6IHdpdGhvdXQ7XG4gICAgICAgICAgdmFsaWRhdG9yKG5vZGUsIGtleSwgdmFsKTtcbiAgICAgICAgfTtcbiAgICAgIH0oKVxuICAgIH0sXG4gICAgZGVmaW5pdGU6IHtcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIilcbiAgICB9LFxuICAgIGluaXQ6IHtcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiV2hpbGVTdGF0ZW1lbnRcIiwge1xuICB2aXNpdG9yOiBbXCJ0ZXN0XCIsIFwiYm9keVwiXSxcbiAgYWxpYXNlczogW1wiU3RhdGVtZW50XCIsIFwiQmxvY2tQYXJlbnRcIiwgXCJMb29wXCIsIFwiV2hpbGVcIiwgXCJTY29wYWJsZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdGVzdDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgYm9keToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiU3RhdGVtZW50XCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJXaXRoU3RhdGVtZW50XCIsIHtcbiAgdmlzaXRvcjogW1wib2JqZWN0XCIsIFwiYm9keVwiXSxcbiAgYWxpYXNlczogW1wiU3RhdGVtZW50XCJdLFxuICBmaWVsZHM6IHtcbiAgICBvYmplY3Q6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlN0YXRlbWVudFwiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiQXNzaWdubWVudFBhdHRlcm5cIiwge1xuICB2aXNpdG9yOiBbXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJkZWNvcmF0b3JzXCJdLFxuICBidWlsZGVyOiBbXCJsZWZ0XCIsIFwicmlnaHRcIl0sXG4gIGFsaWFzZXM6IFtcIlBhdHRlcm5cIiwgXCJQYXR0ZXJuTGlrZVwiLCBcIkxWYWxcIl0sXG4gIGZpZWxkczogT2JqZWN0LmFzc2lnbih7fSwgcGF0dGVybkxpa2VDb21tb24sIHtcbiAgICBsZWZ0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIsIFwiT2JqZWN0UGF0dGVyblwiLCBcIkFycmF5UGF0dGVyblwiLCBcIk1lbWJlckV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICBkZWNvcmF0b3JzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJEZWNvcmF0b3JcIikpKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9KVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiQXJyYXlQYXR0ZXJuXCIsIHtcbiAgdmlzaXRvcjogW1wiZWxlbWVudHNcIiwgXCJ0eXBlQW5ub3RhdGlvblwiXSxcbiAgYnVpbGRlcjogW1wiZWxlbWVudHNcIl0sXG4gIGFsaWFzZXM6IFtcIlBhdHRlcm5cIiwgXCJQYXR0ZXJuTGlrZVwiLCBcIkxWYWxcIl0sXG4gIGZpZWxkczogT2JqZWN0LmFzc2lnbih7fSwgcGF0dGVybkxpa2VDb21tb24sIHtcbiAgICBlbGVtZW50czoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZU9yVmFsdWVUeXBlKShcIm51bGxcIiwgXCJQYXR0ZXJuTGlrZVwiKSkpXG4gICAgfSxcbiAgICBkZWNvcmF0b3JzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJEZWNvcmF0b3JcIikpKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9KVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiwge1xuICBidWlsZGVyOiBbXCJwYXJhbXNcIiwgXCJib2R5XCIsIFwiYXN5bmNcIl0sXG4gIHZpc2l0b3I6IFtcInBhcmFtc1wiLCBcImJvZHlcIiwgXCJyZXR1cm5UeXBlXCIsIFwidHlwZVBhcmFtZXRlcnNcIl0sXG4gIGFsaWFzZXM6IFtcIlNjb3BhYmxlXCIsIFwiRnVuY3Rpb25cIiwgXCJCbG9ja1BhcmVudFwiLCBcIkZ1bmN0aW9uUGFyZW50XCIsIFwiRXhwcmVzc2lvblwiLCBcIlB1cmVpc2hcIl0sXG4gIGZpZWxkczogT2JqZWN0LmFzc2lnbih7fSwgZnVuY3Rpb25Db21tb24sIGZ1bmN0aW9uVHlwZUFubm90YXRpb25Db21tb24sIHtcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKVxuICAgIH0sXG4gICAgYm9keToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiQmxvY2tTdGF0ZW1lbnRcIiwgXCJFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9KVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiQ2xhc3NCb2R5XCIsIHtcbiAgdmlzaXRvcjogW1wiYm9keVwiXSxcbiAgZmllbGRzOiB7XG4gICAgYm9keToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiQ2xhc3NNZXRob2RcIiwgXCJDbGFzc1ByaXZhdGVNZXRob2RcIiwgXCJDbGFzc1Byb3BlcnR5XCIsIFwiQ2xhc3NQcml2YXRlUHJvcGVydHlcIiwgXCJUU0RlY2xhcmVNZXRob2RcIiwgXCJUU0luZGV4U2lnbmF0dXJlXCIpKSlcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkNsYXNzRXhwcmVzc2lvblwiLCB7XG4gIGJ1aWxkZXI6IFtcImlkXCIsIFwic3VwZXJDbGFzc1wiLCBcImJvZHlcIiwgXCJkZWNvcmF0b3JzXCJdLFxuICB2aXNpdG9yOiBbXCJpZFwiLCBcImJvZHlcIiwgXCJzdXBlckNsYXNzXCIsIFwibWl4aW5zXCIsIFwidHlwZVBhcmFtZXRlcnNcIiwgXCJzdXBlclR5cGVQYXJhbWV0ZXJzXCIsIFwiaW1wbGVtZW50c1wiLCBcImRlY29yYXRvcnNcIl0sXG4gIGFsaWFzZXM6IFtcIlNjb3BhYmxlXCIsIFwiQ2xhc3NcIiwgXCJFeHByZXNzaW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICB0eXBlUGFyYW1ldGVyczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIsIFwiVFNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiwgXCJOb29wXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkNsYXNzQm9keVwiKVxuICAgIH0sXG4gICAgc3VwZXJDbGFzczoge1xuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICBzdXBlclR5cGVQYXJhbWV0ZXJzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiLCBcIlRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgaW1wbGVtZW50czoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVFNFeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHNcIiwgXCJDbGFzc0ltcGxlbWVudHNcIikpKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBkZWNvcmF0b3JzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJEZWNvcmF0b3JcIikpKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBtaXhpbnM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkludGVyZmFjZUV4dGVuZHNcIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiQ2xhc3NEZWNsYXJhdGlvblwiLCB7XG4gIGluaGVyaXRzOiBcIkNsYXNzRXhwcmVzc2lvblwiLFxuICBhbGlhc2VzOiBbXCJTY29wYWJsZVwiLCBcIkNsYXNzXCIsIFwiU3RhdGVtZW50XCIsIFwiRGVjbGFyYXRpb25cIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpXG4gICAgfSxcbiAgICB0eXBlUGFyYW1ldGVyczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIsIFwiVFNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiwgXCJOb29wXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkNsYXNzQm9keVwiKVxuICAgIH0sXG4gICAgc3VwZXJDbGFzczoge1xuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICBzdXBlclR5cGVQYXJhbWV0ZXJzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiLCBcIlRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgaW1wbGVtZW50czoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVFNFeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHNcIiwgXCJDbGFzc0ltcGxlbWVudHNcIikpKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBkZWNvcmF0b3JzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJEZWNvcmF0b3JcIikpKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBtaXhpbnM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkludGVyZmFjZUV4dGVuZHNcIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgZGVjbGFyZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgYWJzdHJhY3Q6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XG4gIH0sXG4gIHZhbGlkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgaWRlbnRpZmllciA9ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHBhcmVudCwga2V5LCBub2RlKSB7XG4gICAgICBpZiAoIXByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcpIHJldHVybjtcblxuICAgICAgaWYgKCEoMCwgX2lzLmRlZmF1bHQpKFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIsIHBhcmVudCkpIHtcbiAgICAgICAgaWRlbnRpZmllcihub2RlLCBcImlkXCIsIG5vZGUuaWQpO1xuICAgICAgfVxuICAgIH07XG4gIH0oKVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIiwge1xuICB2aXNpdG9yOiBbXCJzb3VyY2VcIl0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCIsIFwiTW9kdWxlRGVjbGFyYXRpb25cIiwgXCJFeHBvcnREZWNsYXJhdGlvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgc291cmNlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJTdHJpbmdMaXRlcmFsXCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIiwge1xuICB2aXNpdG9yOiBbXCJkZWNsYXJhdGlvblwiXSxcbiAgYWxpYXNlczogW1wiU3RhdGVtZW50XCIsIFwiRGVjbGFyYXRpb25cIiwgXCJNb2R1bGVEZWNsYXJhdGlvblwiLCBcIkV4cG9ydERlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBkZWNsYXJhdGlvbjoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiLCBcIlRTRGVjbGFyZUZ1bmN0aW9uXCIsIFwiQ2xhc3NEZWNsYXJhdGlvblwiLCBcIkV4cHJlc3Npb25cIilcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIiwge1xuICB2aXNpdG9yOiBbXCJkZWNsYXJhdGlvblwiLCBcInNwZWNpZmllcnNcIiwgXCJzb3VyY2VcIl0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCIsIFwiTW9kdWxlRGVjbGFyYXRpb25cIiwgXCJFeHBvcnREZWNsYXJhdGlvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgZGVjbGFyYXRpb246IHtcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRGVjbGFyYXRpb25cIiksIE9iamVjdC5hc3NpZ24oZnVuY3Rpb24gKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgICAgIGlmICghcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORykgcmV0dXJuO1xuXG4gICAgICAgIGlmICh2YWwgJiYgbm9kZS5zcGVjaWZpZXJzLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPbmx5IGRlY2xhcmF0aW9uIG9yIHNwZWNpZmllcnMgaXMgYWxsb3dlZCBvbiBFeHBvcnROYW1lZERlY2xhcmF0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIG9uZU9mTm9kZVR5cGVzOiBbXCJEZWNsYXJhdGlvblwiXVxuICAgICAgfSksIGZ1bmN0aW9uIChub2RlLCBrZXksIHZhbCkge1xuICAgICAgICBpZiAoIXByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcpIHJldHVybjtcblxuICAgICAgICBpZiAodmFsICYmIG5vZGUuc291cmNlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBleHBvcnQgYSBkZWNsYXJhdGlvbiBmcm9tIGEgc291cmNlXCIpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0sXG4gICAgc3BlY2lmaWVyczoge1xuICAgICAgZGVmYXVsdDogW10sXG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBzb3VyY2VkID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHBvcnRTcGVjaWZpZXJcIiwgXCJFeHBvcnREZWZhdWx0U3BlY2lmaWVyXCIsIFwiRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIpO1xuICAgICAgICBjb25zdCBzb3VyY2VsZXNzID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHBvcnRTcGVjaWZpZXJcIik7XG4gICAgICAgIGlmICghcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORykgcmV0dXJuIHNvdXJjZWQ7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSwga2V5LCB2YWwpIHtcbiAgICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSBub2RlLnNvdXJjZSA/IHNvdXJjZWQgOiBzb3VyY2VsZXNzO1xuICAgICAgICAgIHZhbGlkYXRvcihub2RlLCBrZXksIHZhbCk7XG4gICAgICAgIH07XG4gICAgICB9KCkpKVxuICAgIH0sXG4gICAgc291cmNlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJTdHJpbmdMaXRlcmFsXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIGV4cG9ydEtpbmQ6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoKDAsIF91dGlscy5hc3NlcnRPbmVPZikoXCJ0eXBlXCIsIFwidmFsdWVcIikpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkV4cG9ydFNwZWNpZmllclwiLCB7XG4gIHZpc2l0b3I6IFtcImxvY2FsXCIsIFwiZXhwb3J0ZWRcIl0sXG4gIGFsaWFzZXM6IFtcIk1vZHVsZVNwZWNpZmllclwiXSxcbiAgZmllbGRzOiB7XG4gICAgbG9jYWw6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIilcbiAgICB9LFxuICAgIGV4cG9ydGVkOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJGb3JPZlN0YXRlbWVudFwiLCB7XG4gIHZpc2l0b3I6IFtcImxlZnRcIiwgXCJyaWdodFwiLCBcImJvZHlcIl0sXG4gIGJ1aWxkZXI6IFtcImxlZnRcIiwgXCJyaWdodFwiLCBcImJvZHlcIiwgXCJhd2FpdFwiXSxcbiAgYWxpYXNlczogW1wiU2NvcGFibGVcIiwgXCJTdGF0ZW1lbnRcIiwgXCJGb3JcIiwgXCJCbG9ja1BhcmVudFwiLCBcIkxvb3BcIiwgXCJGb3JYU3RhdGVtZW50XCJdLFxuICBmaWVsZHM6IHtcbiAgICBsZWZ0OiB7XG4gICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcpIHtcbiAgICAgICAgICByZXR1cm4gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsIFwiTFZhbFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpO1xuICAgICAgICBjb25zdCBsdmFsID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIsIFwiTWVtYmVyRXhwcmVzc2lvblwiLCBcIkFycmF5UGF0dGVyblwiLCBcIk9iamVjdFBhdHRlcm5cIik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSwga2V5LCB2YWwpIHtcbiAgICAgICAgICBpZiAoKDAsIF9pcy5kZWZhdWx0KShcIlZhcmlhYmxlRGVjbGFyYXRpb25cIiwgdmFsKSkge1xuICAgICAgICAgICAgZGVjbGFyYXRpb24obm9kZSwga2V5LCB2YWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsdmFsKG5vZGUsIGtleSwgdmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KClcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJTdGF0ZW1lbnRcIilcbiAgICB9LFxuICAgIGF3YWl0OiB7XG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiSW1wb3J0RGVjbGFyYXRpb25cIiwge1xuICB2aXNpdG9yOiBbXCJzcGVjaWZpZXJzXCIsIFwic291cmNlXCJdLFxuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiLCBcIk1vZHVsZURlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBzcGVjaWZpZXJzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJbXBvcnRTcGVjaWZpZXJcIiwgXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIsIFwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIpKSlcbiAgICB9LFxuICAgIHNvdXJjZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiU3RyaW5nTGl0ZXJhbFwiKVxuICAgIH0sXG4gICAgaW1wb3J0S2luZDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKFwidHlwZVwiLCBcInR5cGVvZlwiLCBcInZhbHVlXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIiwge1xuICB2aXNpdG9yOiBbXCJsb2NhbFwiXSxcbiAgYWxpYXNlczogW1wiTW9kdWxlU3BlY2lmaWVyXCJdLFxuICBmaWVsZHM6IHtcbiAgICBsb2NhbDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIsIHtcbiAgdmlzaXRvcjogW1wibG9jYWxcIl0sXG4gIGFsaWFzZXM6IFtcIk1vZHVsZVNwZWNpZmllclwiXSxcbiAgZmllbGRzOiB7XG4gICAgbG9jYWw6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIilcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkltcG9ydFNwZWNpZmllclwiLCB7XG4gIHZpc2l0b3I6IFtcImxvY2FsXCIsIFwiaW1wb3J0ZWRcIl0sXG4gIGFsaWFzZXM6IFtcIk1vZHVsZVNwZWNpZmllclwiXSxcbiAgZmllbGRzOiB7XG4gICAgbG9jYWw6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIilcbiAgICB9LFxuICAgIGltcG9ydGVkOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpXG4gICAgfSxcbiAgICBpbXBvcnRLaW5kOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRPbmVPZikoXCJ0eXBlXCIsIFwidHlwZW9mXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIk1ldGFQcm9wZXJ0eVwiLCB7XG4gIHZpc2l0b3I6IFtcIm1ldGFcIiwgXCJwcm9wZXJ0eVwiXSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgbWV0YToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiKSwgT2JqZWN0LmFzc2lnbihmdW5jdGlvbiAobm9kZSwga2V5LCB2YWwpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HKSByZXR1cm47XG4gICAgICAgIGxldCBwcm9wZXJ0eTtcblxuICAgICAgICBzd2l0Y2ggKHZhbC5uYW1lKSB7XG4gICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICBwcm9wZXJ0eSA9IFwic2VudFwiO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwibmV3XCI6XG4gICAgICAgICAgICBwcm9wZXJ0eSA9IFwidGFyZ2V0XCI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJpbXBvcnRcIjpcbiAgICAgICAgICAgIHByb3BlcnR5ID0gXCJtZXRhXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKDAsIF9pcy5kZWZhdWx0KShcIklkZW50aWZpZXJcIiwgbm9kZS5wcm9wZXJ0eSwge1xuICAgICAgICAgIG5hbWU6IHByb3BlcnR5XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVucmVjb2duaXNlZCBNZXRhUHJvcGVydHlcIik7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgb25lT2ZOb2RlVHlwZXM6IFtcIklkZW50aWZpZXJcIl1cbiAgICAgIH0pKVxuICAgIH0sXG4gICAgcHJvcGVydHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIilcbiAgICB9XG4gIH1cbn0pO1xuY29uc3QgY2xhc3NNZXRob2RPclByb3BlcnR5Q29tbW9uID0ge1xuICBhYnN0cmFjdDoge1xuICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0sXG4gIGFjY2Vzc2liaWxpdHk6IHtcbiAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRPbmVPZikoXCJwdWJsaWNcIiwgXCJwcml2YXRlXCIsIFwicHJvdGVjdGVkXCIpLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0sXG4gIHN0YXRpYzoge1xuICAgIGRlZmF1bHQ6IGZhbHNlXG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgZGVmYXVsdDogZmFsc2VcbiAgfSxcbiAgb3B0aW9uYWw6IHtcbiAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9LFxuICBrZXk6IHtcbiAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3Qgbm9ybWFsID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIsIFwiU3RyaW5nTGl0ZXJhbFwiLCBcIk51bWVyaWNMaXRlcmFsXCIpO1xuICAgICAgY29uc3QgY29tcHV0ZWQgPSAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIik7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IG5vZGUuY29tcHV0ZWQgPyBjb21wdXRlZCA6IG5vcm1hbDtcbiAgICAgICAgdmFsaWRhdG9yKG5vZGUsIGtleSwgdmFsKTtcbiAgICAgIH07XG4gICAgfSgpLCAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIiwgXCJTdHJpbmdMaXRlcmFsXCIsIFwiTnVtZXJpY0xpdGVyYWxcIiwgXCJFeHByZXNzaW9uXCIpKVxuICB9XG59O1xuZXhwb3J0cy5jbGFzc01ldGhvZE9yUHJvcGVydHlDb21tb24gPSBjbGFzc01ldGhvZE9yUHJvcGVydHlDb21tb247XG5jb25zdCBjbGFzc01ldGhvZE9yRGVjbGFyZU1ldGhvZENvbW1vbiA9IE9iamVjdC5hc3NpZ24oe30sIGZ1bmN0aW9uQ29tbW9uLCBjbGFzc01ldGhvZE9yUHJvcGVydHlDb21tb24sIHtcbiAga2luZDoge1xuICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE9uZU9mKShcImdldFwiLCBcInNldFwiLCBcIm1ldGhvZFwiLCBcImNvbnN0cnVjdG9yXCIpLFxuICAgIGRlZmF1bHQ6IFwibWV0aG9kXCJcbiAgfSxcbiAgYWNjZXNzOiB7XG4gICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKSwgKDAsIF91dGlscy5hc3NlcnRPbmVPZikoXCJwdWJsaWNcIiwgXCJwcml2YXRlXCIsIFwicHJvdGVjdGVkXCIpKSxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9LFxuICBkZWNvcmF0b3JzOiB7XG4gICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRGVjb3JhdG9yXCIpKSksXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfVxufSk7XG5leHBvcnRzLmNsYXNzTWV0aG9kT3JEZWNsYXJlTWV0aG9kQ29tbW9uID0gY2xhc3NNZXRob2RPckRlY2xhcmVNZXRob2RDb21tb247XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiQ2xhc3NNZXRob2RcIiwge1xuICBhbGlhc2VzOiBbXCJGdW5jdGlvblwiLCBcIlNjb3BhYmxlXCIsIFwiQmxvY2tQYXJlbnRcIiwgXCJGdW5jdGlvblBhcmVudFwiLCBcIk1ldGhvZFwiXSxcbiAgYnVpbGRlcjogW1wia2luZFwiLCBcImtleVwiLCBcInBhcmFtc1wiLCBcImJvZHlcIiwgXCJjb21wdXRlZFwiLCBcInN0YXRpY1wiLCBcImdlbmVyYXRvclwiLCBcImFzeW5jXCJdLFxuICB2aXNpdG9yOiBbXCJrZXlcIiwgXCJwYXJhbXNcIiwgXCJib2R5XCIsIFwiZGVjb3JhdG9yc1wiLCBcInJldHVyblR5cGVcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiXSxcbiAgZmllbGRzOiBPYmplY3QuYXNzaWduKHt9LCBjbGFzc01ldGhvZE9yRGVjbGFyZU1ldGhvZENvbW1vbiwgZnVuY3Rpb25UeXBlQW5ub3RhdGlvbkNvbW1vbiwge1xuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkJsb2NrU3RhdGVtZW50XCIpXG4gICAgfVxuICB9KVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiT2JqZWN0UGF0dGVyblwiLCB7XG4gIHZpc2l0b3I6IFtcInByb3BlcnRpZXNcIiwgXCJ0eXBlQW5ub3RhdGlvblwiLCBcImRlY29yYXRvcnNcIl0sXG4gIGJ1aWxkZXI6IFtcInByb3BlcnRpZXNcIl0sXG4gIGFsaWFzZXM6IFtcIlBhdHRlcm5cIiwgXCJQYXR0ZXJuTGlrZVwiLCBcIkxWYWxcIl0sXG4gIGZpZWxkczogT2JqZWN0LmFzc2lnbih7fSwgcGF0dGVybkxpa2VDb21tb24sIHtcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJSZXN0RWxlbWVudFwiLCBcIk9iamVjdFByb3BlcnR5XCIpKSlcbiAgICB9XG4gIH0pXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJTcHJlYWRFbGVtZW50XCIsIHtcbiAgdmlzaXRvcjogW1wiYXJndW1lbnRcIl0sXG4gIGFsaWFzZXM6IFtcIlVuYXJ5TGlrZVwiXSxcbiAgZGVwcmVjYXRlZEFsaWFzOiBcIlNwcmVhZFByb3BlcnR5XCIsXG4gIGZpZWxkczoge1xuICAgIGFyZ3VtZW50OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJTdXBlclwiLCB7XG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIl1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiLCB7XG4gIHZpc2l0b3I6IFtcInRhZ1wiLCBcInF1YXNpXCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICB0YWc6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIHF1YXNpOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJUZW1wbGF0ZUxpdGVyYWxcIilcbiAgICB9LFxuICAgIHR5cGVQYXJhbWV0ZXJzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiLCBcIlRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVGVtcGxhdGVFbGVtZW50XCIsIHtcbiAgYnVpbGRlcjogW1widmFsdWVcIiwgXCJ0YWlsXCJdLFxuICBmaWVsZHM6IHtcbiAgICB2YWx1ZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0U2hhcGUpKHtcbiAgICAgICAgcmF3OiB7XG4gICAgICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKVxuICAgICAgICB9LFxuICAgICAgICBjb29rZWQ6IHtcbiAgICAgICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwic3RyaW5nXCIpLFxuICAgICAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSxcbiAgICB0YWlsOiB7XG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVGVtcGxhdGVMaXRlcmFsXCIsIHtcbiAgdmlzaXRvcjogW1wicXVhc2lzXCIsIFwiZXhwcmVzc2lvbnNcIl0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIiwgXCJMaXRlcmFsXCJdLFxuICBmaWVsZHM6IHtcbiAgICBxdWFzaXM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJhcnJheVwiKSwgKDAsIF91dGlscy5hc3NlcnRFYWNoKSgoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlRlbXBsYXRlRWxlbWVudFwiKSkpXG4gICAgfSxcbiAgICBleHByZXNzaW9uczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKSksIGZ1bmN0aW9uIChub2RlLCBrZXksIHZhbCkge1xuICAgICAgICBpZiAobm9kZS5xdWFzaXMubGVuZ3RoICE9PSB2YWwubGVuZ3RoICsgMSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE51bWJlciBvZiAke25vZGUudHlwZX0gcXVhc2lzIHNob3VsZCBiZSBleGFjdGx5IG9uZSBtb3JlIHRoYW4gdGhlIG51bWJlciBvZiBleHByZXNzaW9ucy5cXG5FeHBlY3RlZCAke3ZhbC5sZW5ndGggKyAxfSBxdWFzaXMgYnV0IGdvdCAke25vZGUucXVhc2lzLmxlbmd0aH1gKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIllpZWxkRXhwcmVzc2lvblwiLCB7XG4gIGJ1aWxkZXI6IFtcImFyZ3VtZW50XCIsIFwiZGVsZWdhdGVcIl0sXG4gIHZpc2l0b3I6IFtcImFyZ3VtZW50XCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCIsIFwiVGVybWluYXRvcmxlc3NcIl0sXG4gIGZpZWxkczoge1xuICAgIGRlbGVnYXRlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSwgT2JqZWN0LmFzc2lnbihmdW5jdGlvbiAobm9kZSwga2V5LCB2YWwpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HKSByZXR1cm47XG5cbiAgICAgICAgaWYgKHZhbCAmJiAhbm9kZS5hcmd1bWVudCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcm9wZXJ0eSBkZWxlZ2F0ZSBvZiBZaWVsZEV4cHJlc3Npb24gY2Fubm90IGJlIHRydWUgaWYgdGhlcmUgaXMgbm8gYXJndW1lbnRcIik7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJib29sZWFuXCJcbiAgICAgIH0pKSxcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBhcmd1bWVudDoge1xuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJBd2FpdEV4cHJlc3Npb25cIiwge1xuICBidWlsZGVyOiBbXCJhcmd1bWVudFwiXSxcbiAgdmlzaXRvcjogW1wiYXJndW1lbnRcIl0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIiwgXCJUZXJtaW5hdG9ybGVzc1wiXSxcbiAgZmllbGRzOiB7XG4gICAgYXJndW1lbnQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkltcG9ydFwiLCB7XG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIl1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkJpZ0ludExpdGVyYWxcIiwge1xuICBidWlsZGVyOiBbXCJ2YWx1ZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIilcbiAgICB9XG4gIH0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIiwgXCJQdXJlaXNoXCIsIFwiTGl0ZXJhbFwiLCBcIkltbXV0YWJsZVwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIsIHtcbiAgdmlzaXRvcjogW1wiZXhwb3J0ZWRcIl0sXG4gIGFsaWFzZXM6IFtcIk1vZHVsZVNwZWNpZmllclwiXSxcbiAgZmllbGRzOiB7XG4gICAgZXhwb3J0ZWQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIilcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiLCB7XG4gIGJ1aWxkZXI6IFtcIm9iamVjdFwiLCBcInByb3BlcnR5XCIsIFwiY29tcHV0ZWRcIiwgXCJvcHRpb25hbFwiXSxcbiAgdmlzaXRvcjogW1wib2JqZWN0XCIsIFwicHJvcGVydHlcIl0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczoge1xuICAgIG9iamVjdDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgcHJvcGVydHk6IHtcbiAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbCA9ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiKTtcbiAgICAgICAgY29uc3QgY29tcHV0ZWQgPSAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIik7XG5cbiAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gZnVuY3Rpb24gKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gbm9kZS5jb21wdXRlZCA/IGNvbXB1dGVkIDogbm9ybWFsO1xuICAgICAgICAgIHZhbGlkYXRvcihub2RlLCBrZXksIHZhbCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFsaWRhdG9yLm9uZU9mTm9kZVR5cGVzID0gW1wiRXhwcmVzc2lvblwiLCBcIklkZW50aWZpZXJcIl07XG4gICAgICAgIHJldHVybiB2YWxpZGF0b3I7XG4gICAgICB9KClcbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgb3B0aW9uYWw6IHtcbiAgICAgIHZhbGlkYXRlOiAhcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORyA/ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIikgOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpLCAoMCwgX3V0aWxzLmFzc2VydE9wdGlvbmFsQ2hhaW5TdGFydCkoKSlcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIiwge1xuICB2aXNpdG9yOiBbXCJjYWxsZWVcIiwgXCJhcmd1bWVudHNcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiLCBcInR5cGVBcmd1bWVudHNcIl0sXG4gIGJ1aWxkZXI6IFtcImNhbGxlZVwiLCBcImFyZ3VtZW50c1wiLCBcIm9wdGlvbmFsXCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBjYWxsZWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIGFyZ3VtZW50czoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiLCBcIlNwcmVhZEVsZW1lbnRcIiwgXCJKU1hOYW1lc3BhY2VkTmFtZVwiKSkpXG4gICAgfSxcbiAgICBvcHRpb25hbDoge1xuICAgICAgdmFsaWRhdGU6ICFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HID8gKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSA6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksICgwLCBfdXRpbHMuYXNzZXJ0T3B0aW9uYWxDaGFpblN0YXJ0KSgpKVxuICAgIH0sXG4gICAgdHlwZUFyZ3VtZW50czoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgdHlwZVBhcmFtZXRlcnM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfVxufSk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfdXRpbHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi91dGlsc1wiKSk7XG5cbnZhciBfY29yZSA9IHJlcXVpcmUoXCIuL2NvcmVcIik7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBkZWZhdWx0OiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiQXJndW1lbnRQbGFjZWhvbGRlclwiLCB7fSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiQmluZEV4cHJlc3Npb25cIiwge1xuICB2aXNpdG9yOiBbXCJvYmplY3RcIiwgXCJjYWxsZWVcIl0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczogIXByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcgPyB7XG4gICAgb2JqZWN0OiB7XG4gICAgICB2YWxpZGF0ZTogT2JqZWN0LmFzc2lnbigoKSA9PiB7fSwge1xuICAgICAgICBvbmVPZk5vZGVUeXBlczogW1wiRXhwcmVzc2lvblwiXVxuICAgICAgfSlcbiAgICB9LFxuICAgIGNhbGxlZToge1xuICAgICAgdmFsaWRhdGU6IE9iamVjdC5hc3NpZ24oKCkgPT4ge30sIHtcbiAgICAgICAgb25lT2ZOb2RlVHlwZXM6IFtcIkV4cHJlc3Npb25cIl1cbiAgICAgIH0pXG4gICAgfVxuICB9IDoge1xuICAgIG9iamVjdDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgY2FsbGVlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJDbGFzc1Byb3BlcnR5XCIsIHtcbiAgdmlzaXRvcjogW1wia2V5XCIsIFwidmFsdWVcIiwgXCJ0eXBlQW5ub3RhdGlvblwiLCBcImRlY29yYXRvcnNcIl0sXG4gIGJ1aWxkZXI6IFtcImtleVwiLCBcInZhbHVlXCIsIFwidHlwZUFubm90YXRpb25cIiwgXCJkZWNvcmF0b3JzXCIsIFwiY29tcHV0ZWRcIiwgXCJzdGF0aWNcIl0sXG4gIGFsaWFzZXM6IFtcIlByb3BlcnR5XCJdLFxuICBmaWVsZHM6IE9iamVjdC5hc3NpZ24oe30sIF9jb3JlLmNsYXNzTWV0aG9kT3JQcm9wZXJ0eUNvbW1vbiwge1xuICAgIHZhbHVlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIGRlZmluaXRlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICB0eXBlQW5ub3RhdGlvbjoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVHlwZUFubm90YXRpb25cIiwgXCJUU1R5cGVBbm5vdGF0aW9uXCIsIFwiTm9vcFwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBkZWNvcmF0b3JzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJEZWNvcmF0b3JcIikpKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICByZWFkb25seToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgZGVjbGFyZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfSlcbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlBpcGVsaW5lVG9waWNFeHByZXNzaW9uXCIsIHtcbiAgYnVpbGRlcjogW1wiZXhwcmVzc2lvblwiXSxcbiAgdmlzaXRvcjogW1wiZXhwcmVzc2lvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiUGlwZWxpbmVCYXJlRnVuY3Rpb25cIiwge1xuICBidWlsZGVyOiBbXCJjYWxsZWVcIl0sXG4gIHZpc2l0b3I6IFtcImNhbGxlZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgY2FsbGVlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJQaXBlbGluZVByaW1hcnlUb3BpY1JlZmVyZW5jZVwiLCB7XG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIl1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkNsYXNzUHJpdmF0ZVByb3BlcnR5XCIsIHtcbiAgdmlzaXRvcjogW1wia2V5XCIsIFwidmFsdWVcIiwgXCJkZWNvcmF0b3JzXCJdLFxuICBidWlsZGVyOiBbXCJrZXlcIiwgXCJ2YWx1ZVwiLCBcImRlY29yYXRvcnNcIl0sXG4gIGFsaWFzZXM6IFtcIlByb3BlcnR5XCIsIFwiUHJpdmF0ZVwiXSxcbiAgZmllbGRzOiB7XG4gICAga2V5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJQcml2YXRlTmFtZVwiKVxuICAgIH0sXG4gICAgdmFsdWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgZGVjb3JhdG9yczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRGVjb3JhdG9yXCIpKSksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiQ2xhc3NQcml2YXRlTWV0aG9kXCIsIHtcbiAgYnVpbGRlcjogW1wia2luZFwiLCBcImtleVwiLCBcInBhcmFtc1wiLCBcImJvZHlcIiwgXCJzdGF0aWNcIl0sXG4gIHZpc2l0b3I6IFtcImtleVwiLCBcInBhcmFtc1wiLCBcImJvZHlcIiwgXCJkZWNvcmF0b3JzXCIsIFwicmV0dXJuVHlwZVwiLCBcInR5cGVQYXJhbWV0ZXJzXCJdLFxuICBhbGlhc2VzOiBbXCJGdW5jdGlvblwiLCBcIlNjb3BhYmxlXCIsIFwiQmxvY2tQYXJlbnRcIiwgXCJGdW5jdGlvblBhcmVudFwiLCBcIk1ldGhvZFwiLCBcIlByaXZhdGVcIl0sXG4gIGZpZWxkczogT2JqZWN0LmFzc2lnbih7fSwgX2NvcmUuY2xhc3NNZXRob2RPckRlY2xhcmVNZXRob2RDb21tb24sIF9jb3JlLmZ1bmN0aW9uVHlwZUFubm90YXRpb25Db21tb24sIHtcbiAgICBrZXk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlByaXZhdGVOYW1lXCIpXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJCbG9ja1N0YXRlbWVudFwiKVxuICAgIH1cbiAgfSlcbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkltcG9ydEF0dHJpYnV0ZVwiLCB7XG4gIHZpc2l0b3I6IFtcImtleVwiLCBcInZhbHVlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBrZXk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIilcbiAgICB9LFxuICAgIHZhbHVlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJTdHJpbmdMaXRlcmFsXCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJEZWNvcmF0b3JcIiwge1xuICB2aXNpdG9yOiBbXCJleHByZXNzaW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJEb0V4cHJlc3Npb25cIiwge1xuICB2aXNpdG9yOiBbXCJib2R5XCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJCbG9ja1N0YXRlbWVudFwiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRXhwb3J0RGVmYXVsdFNwZWNpZmllclwiLCB7XG4gIHZpc2l0b3I6IFtcImV4cG9ydGVkXCJdLFxuICBhbGlhc2VzOiBbXCJNb2R1bGVTcGVjaWZpZXJcIl0sXG4gIGZpZWxkczoge1xuICAgIGV4cG9ydGVkOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJQcml2YXRlTmFtZVwiLCB7XG4gIHZpc2l0b3I6IFtcImlkXCJdLFxuICBhbGlhc2VzOiBbXCJQcml2YXRlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiUmVjb3JkRXhwcmVzc2lvblwiLCB7XG4gIHZpc2l0b3I6IFtcInByb3BlcnRpZXNcIl0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczoge1xuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJhcnJheVwiKSwgKDAsIF91dGlscy5hc3NlcnRFYWNoKSgoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIk9iamVjdFByb3BlcnR5XCIsIFwiU3ByZWFkRWxlbWVudFwiKSkpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUdXBsZUV4cHJlc3Npb25cIiwge1xuICBmaWVsZHM6IHtcbiAgICBlbGVtZW50czoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiLCBcIlNwcmVhZEVsZW1lbnRcIikpKSxcbiAgICAgIGRlZmF1bHQ6IFtdXG4gICAgfVxuICB9LFxuICB2aXNpdG9yOiBbXCJlbGVtZW50c1wiXSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRGVjaW1hbExpdGVyYWxcIiwge1xuICBidWlsZGVyOiBbXCJ2YWx1ZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIilcbiAgICB9XG4gIH0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIiwgXCJQdXJlaXNoXCIsIFwiTGl0ZXJhbFwiLCBcIkltbXV0YWJsZVwiXVxufSk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfdXRpbHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi91dGlsc1wiKSk7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBkZWZhdWx0OiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG5jb25zdCBkZWZpbmVJbnRlcmZhY2Vpc2hUeXBlID0gKG5hbWUsIHR5cGVQYXJhbWV0ZXJUeXBlID0gXCJUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIikgPT4ge1xuICAoMCwgX3V0aWxzLmRlZmF1bHQpKG5hbWUsIHtcbiAgICBidWlsZGVyOiBbXCJpZFwiLCBcInR5cGVQYXJhbWV0ZXJzXCIsIFwiZXh0ZW5kc1wiLCBcImJvZHlcIl0sXG4gICAgdmlzaXRvcjogW1wiaWRcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiLCBcImV4dGVuZHNcIiwgXCJtaXhpbnNcIiwgXCJpbXBsZW1lbnRzXCIsIFwiYm9keVwiXSxcbiAgICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiRmxvd0RlY2xhcmF0aW9uXCIsIFwiU3RhdGVtZW50XCIsIFwiRGVjbGFyYXRpb25cIl0sXG4gICAgZmllbGRzOiB7XG4gICAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICAgIHR5cGVQYXJhbWV0ZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKSh0eXBlUGFyYW1ldGVyVHlwZSksXG4gICAgICBleHRlbmRzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKCgwLCBfdXRpbHMuYXJyYXlPZlR5cGUpKFwiSW50ZXJmYWNlRXh0ZW5kc1wiKSksXG4gICAgICBtaXhpbnM6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoKDAsIF91dGlscy5hcnJheU9mVHlwZSkoXCJJbnRlcmZhY2VFeHRlbmRzXCIpKSxcbiAgICAgIGltcGxlbWVudHM6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoKDAsIF91dGlscy5hcnJheU9mVHlwZSkoXCJDbGFzc0ltcGxlbWVudHNcIikpLFxuICAgICAgYm9keTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiT2JqZWN0VHlwZUFubm90YXRpb25cIilcbiAgICB9XG4gIH0pO1xufTtcblxuKDAsIF91dGlscy5kZWZhdWx0KShcIkFueVR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dUeXBlXCIsIFwiRmxvd0Jhc2VBbm5vdGF0aW9uXCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJBcnJheVR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1wiZWxlbWVudFR5cGVcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93VHlwZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgZWxlbWVudFR5cGU6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkZsb3dUeXBlXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkJvb2xlYW5UeXBlQW5ub3RhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93VHlwZVwiLCBcIkZsb3dCYXNlQW5ub3RhdGlvblwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiQm9vbGVhbkxpdGVyYWxUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGJ1aWxkZXI6IFtcInZhbHVlXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiRmxvd1R5cGVcIl0sXG4gIGZpZWxkczoge1xuICAgIHZhbHVlOiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJOdWxsTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dUeXBlXCIsIFwiRmxvd0Jhc2VBbm5vdGF0aW9uXCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJDbGFzc0ltcGxlbWVudHNcIiwge1xuICB2aXNpdG9yOiBbXCJpZFwiLCBcInR5cGVQYXJhbWV0ZXJzXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICB0eXBlUGFyYW1ldGVyczogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiKVxuICB9XG59KTtcbmRlZmluZUludGVyZmFjZWlzaFR5cGUoXCJEZWNsYXJlQ2xhc3NcIik7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRGVjbGFyZUZ1bmN0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1wiaWRcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93RGVjbGFyYXRpb25cIiwgXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgaWQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIklkZW50aWZpZXJcIiksXG4gICAgcHJlZGljYXRlOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIkRlY2xhcmVkUHJlZGljYXRlXCIpXG4gIH1cbn0pO1xuZGVmaW5lSW50ZXJmYWNlaXNoVHlwZShcIkRlY2xhcmVJbnRlcmZhY2VcIik7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRGVjbGFyZU1vZHVsZVwiLCB7XG4gIGJ1aWxkZXI6IFtcImlkXCIsIFwiYm9keVwiLCBcImtpbmRcIl0sXG4gIHZpc2l0b3I6IFtcImlkXCIsIFwiYm9keVwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dEZWNsYXJhdGlvblwiLCBcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFtcIklkZW50aWZpZXJcIiwgXCJTdHJpbmdMaXRlcmFsXCJdKSxcbiAgICBib2R5OiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJCbG9ja1N0YXRlbWVudFwiKSxcbiAgICBraW5kOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKCgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKFwiQ29tbW9uSlNcIiwgXCJFU1wiKSlcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRGVjbGFyZU1vZHVsZUV4cG9ydHNcIiwge1xuICB2aXNpdG9yOiBbXCJ0eXBlQW5ub3RhdGlvblwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dEZWNsYXJhdGlvblwiLCBcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICB0eXBlQW5ub3RhdGlvbjogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVHlwZUFubm90YXRpb25cIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRGVjbGFyZVR5cGVBbGlhc1wiLCB7XG4gIHZpc2l0b3I6IFtcImlkXCIsIFwidHlwZVBhcmFtZXRlcnNcIiwgXCJyaWdodFwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dEZWNsYXJhdGlvblwiLCBcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICB0eXBlUGFyYW1ldGVyczogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiksXG4gICAgcmlnaHQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkZsb3dUeXBlXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkRlY2xhcmVPcGFxdWVUeXBlXCIsIHtcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiLCBcInN1cGVydHlwZVwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dEZWNsYXJhdGlvblwiLCBcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICB0eXBlUGFyYW1ldGVyczogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiksXG4gICAgc3VwZXJ0eXBlOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIkZsb3dUeXBlXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkRlY2xhcmVWYXJpYWJsZVwiLCB7XG4gIHZpc2l0b3I6IFtcImlkXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiRmxvd0RlY2xhcmF0aW9uXCIsIFwiU3RhdGVtZW50XCIsIFwiRGVjbGFyYXRpb25cIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkRlY2xhcmVFeHBvcnREZWNsYXJhdGlvblwiLCB7XG4gIHZpc2l0b3I6IFtcImRlY2xhcmF0aW9uXCIsIFwic3BlY2lmaWVyc1wiLCBcInNvdXJjZVwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dEZWNsYXJhdGlvblwiLCBcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBkZWNsYXJhdGlvbjogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJGbG93XCIpLFxuICAgIHNwZWNpZmllcnM6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoKDAsIF91dGlscy5hcnJheU9mVHlwZSkoW1wiRXhwb3J0U3BlY2lmaWVyXCIsIFwiRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCJdKSksXG4gICAgc291cmNlOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlN0cmluZ0xpdGVyYWxcIiksXG4gICAgZGVmYXVsdDogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJEZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb25cIiwge1xuICB2aXNpdG9yOiBbXCJzb3VyY2VcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93RGVjbGFyYXRpb25cIiwgXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgc291cmNlOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJTdHJpbmdMaXRlcmFsXCIpLFxuICAgIGV4cG9ydEtpbmQ6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoKDAsIF91dGlscy5hc3NlcnRPbmVPZikoXCJ0eXBlXCIsIFwidmFsdWVcIikpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkRlY2xhcmVkUHJlZGljYXRlXCIsIHtcbiAgdmlzaXRvcjogW1widmFsdWVcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93UHJlZGljYXRlXCJdLFxuICBmaWVsZHM6IHtcbiAgICB2YWx1ZTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiRmxvd1wiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJFeGlzdHNUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93VHlwZVwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiLCB7XG4gIHZpc2l0b3I6IFtcInR5cGVQYXJhbWV0ZXJzXCIsIFwicGFyYW1zXCIsIFwicmVzdFwiLCBcInJldHVyblR5cGVcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93VHlwZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdHlwZVBhcmFtZXRlcnM6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIpLFxuICAgIHBhcmFtczogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hcnJheU9mVHlwZSkoXCJGdW5jdGlvblR5cGVQYXJhbVwiKSksXG4gICAgcmVzdDogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJGdW5jdGlvblR5cGVQYXJhbVwiKSxcbiAgICByZXR1cm5UeXBlOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJGbG93VHlwZVwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJGdW5jdGlvblR5cGVQYXJhbVwiLCB7XG4gIHZpc2l0b3I6IFtcIm5hbWVcIiwgXCJ0eXBlQW5ub3RhdGlvblwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiXSxcbiAgZmllbGRzOiB7XG4gICAgbmFtZTogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIHR5cGVBbm5vdGF0aW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJGbG93VHlwZVwiKSxcbiAgICBvcHRpb25hbDogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJHZW5lcmljVHlwZUFubm90YXRpb25cIiwge1xuICB2aXNpdG9yOiBbXCJpZFwiLCBcInR5cGVQYXJhbWV0ZXJzXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiRmxvd1R5cGVcIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoW1wiSWRlbnRpZmllclwiLCBcIlF1YWxpZmllZFR5cGVJZGVudGlmaWVyXCJdKSxcbiAgICB0eXBlUGFyYW1ldGVyczogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJJbmZlcnJlZFByZWRpY2F0ZVwiLCB7XG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93UHJlZGljYXRlXCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJJbnRlcmZhY2VFeHRlbmRzXCIsIHtcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiXSxcbiAgZmllbGRzOiB7XG4gICAgaWQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShbXCJJZGVudGlmaWVyXCIsIFwiUXVhbGlmaWVkVHlwZUlkZW50aWZpZXJcIl0pLFxuICAgIHR5cGVQYXJhbWV0ZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpXG4gIH1cbn0pO1xuZGVmaW5lSW50ZXJmYWNlaXNoVHlwZShcIkludGVyZmFjZURlY2xhcmF0aW9uXCIpO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkludGVyZmFjZVR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1wiZXh0ZW5kc1wiLCBcImJvZHlcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93VHlwZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgZXh0ZW5kczogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsKSgoMCwgX3V0aWxzLmFycmF5T2ZUeXBlKShcIkludGVyZmFjZUV4dGVuZHNcIikpLFxuICAgIGJvZHk6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIk9iamVjdFR5cGVBbm5vdGF0aW9uXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkludGVyc2VjdGlvblR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1widHlwZXNcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93VHlwZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdHlwZXM6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXJyYXlPZlR5cGUpKFwiRmxvd1R5cGVcIikpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIk1peGVkVHlwZUFubm90YXRpb25cIiwge1xuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiRmxvd1R5cGVcIiwgXCJGbG93QmFzZUFubm90YXRpb25cIl1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkVtcHR5VHlwZUFubm90YXRpb25cIiwge1xuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiRmxvd1R5cGVcIiwgXCJGbG93QmFzZUFubm90YXRpb25cIl1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIk51bGxhYmxlVHlwZUFubm90YXRpb25cIiwge1xuICB2aXNpdG9yOiBbXCJ0eXBlQW5ub3RhdGlvblwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dUeXBlXCJdLFxuICBmaWVsZHM6IHtcbiAgICB0eXBlQW5ub3RhdGlvbjogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiRmxvd1R5cGVcIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiTnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgYnVpbGRlcjogW1widmFsdWVcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93VHlwZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdmFsdWU6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcIm51bWJlclwiKSlcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiTnVtYmVyVHlwZUFubm90YXRpb25cIiwge1xuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiRmxvd1R5cGVcIiwgXCJGbG93QmFzZUFubm90YXRpb25cIl1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIk9iamVjdFR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1wicHJvcGVydGllc1wiLCBcImluZGV4ZXJzXCIsIFwiY2FsbFByb3BlcnRpZXNcIiwgXCJpbnRlcm5hbFNsb3RzXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiRmxvd1R5cGVcIl0sXG4gIGJ1aWxkZXI6IFtcInByb3BlcnRpZXNcIiwgXCJpbmRleGVyc1wiLCBcImNhbGxQcm9wZXJ0aWVzXCIsIFwiaW50ZXJuYWxTbG90c1wiLCBcImV4YWN0XCJdLFxuICBmaWVsZHM6IHtcbiAgICBwcm9wZXJ0aWVzOiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFycmF5T2ZUeXBlKShbXCJPYmplY3RUeXBlUHJvcGVydHlcIiwgXCJPYmplY3RUeXBlU3ByZWFkUHJvcGVydHlcIl0pKSxcbiAgICBpbmRleGVyczogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsKSgoMCwgX3V0aWxzLmFycmF5T2ZUeXBlKShcIk9iamVjdFR5cGVJbmRleGVyXCIpKSxcbiAgICBjYWxsUHJvcGVydGllczogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsKSgoMCwgX3V0aWxzLmFycmF5T2ZUeXBlKShcIk9iamVjdFR5cGVDYWxsUHJvcGVydHlcIikpLFxuICAgIGludGVybmFsU2xvdHM6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoKDAsIF91dGlscy5hcnJheU9mVHlwZSkoXCJPYmplY3RUeXBlSW50ZXJuYWxTbG90XCIpKSxcbiAgICBleGFjdDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgaW5leGFjdDogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJPYmplY3RUeXBlSW50ZXJuYWxTbG90XCIsIHtcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJ2YWx1ZVwiLCBcIm9wdGlvbmFsXCIsIFwic3RhdGljXCIsIFwibWV0aG9kXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiVXNlcldoaXRlc3BhY2FibGVcIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIHZhbHVlOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJGbG93VHlwZVwiKSxcbiAgICBvcHRpb25hbDogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSksXG4gICAgc3RhdGljOiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpKSxcbiAgICBtZXRob2Q6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIikpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIk9iamVjdFR5cGVDYWxsUHJvcGVydHlcIiwge1xuICB2aXNpdG9yOiBbXCJ2YWx1ZVwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIlVzZXJXaGl0ZXNwYWNhYmxlXCJdLFxuICBmaWVsZHM6IHtcbiAgICB2YWx1ZTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiRmxvd1R5cGVcIiksXG4gICAgc3RhdGljOiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJPYmplY3RUeXBlSW5kZXhlclwiLCB7XG4gIHZpc2l0b3I6IFtcImlkXCIsIFwia2V5XCIsIFwidmFsdWVcIiwgXCJ2YXJpYW5jZVwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIlVzZXJXaGl0ZXNwYWNhYmxlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIGtleTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiRmxvd1R5cGVcIiksXG4gICAgdmFsdWU6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkZsb3dUeXBlXCIpLFxuICAgIHN0YXRpYzogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSksXG4gICAgdmFyaWFuY2U6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiVmFyaWFuY2VcIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiT2JqZWN0VHlwZVByb3BlcnR5XCIsIHtcbiAgdmlzaXRvcjogW1wia2V5XCIsIFwidmFsdWVcIiwgXCJ2YXJpYW5jZVwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIlVzZXJXaGl0ZXNwYWNhYmxlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBrZXk6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShbXCJJZGVudGlmaWVyXCIsIFwiU3RyaW5nTGl0ZXJhbFwiXSksXG4gICAgdmFsdWU6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkZsb3dUeXBlXCIpLFxuICAgIGtpbmQ6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKFwiaW5pdFwiLCBcImdldFwiLCBcInNldFwiKSksXG4gICAgc3RhdGljOiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpKSxcbiAgICBwcm90bzogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSksXG4gICAgb3B0aW9uYWw6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIikpLFxuICAgIHZhcmlhbmNlOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlZhcmlhbmNlXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIk9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eVwiLCB7XG4gIHZpc2l0b3I6IFtcImFyZ3VtZW50XCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiVXNlcldoaXRlc3BhY2FibGVcIl0sXG4gIGZpZWxkczoge1xuICAgIGFyZ3VtZW50OiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJGbG93VHlwZVwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJPcGFxdWVUeXBlXCIsIHtcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiLCBcInN1cGVydHlwZVwiLCBcImltcGx0eXBlXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiRmxvd0RlY2xhcmF0aW9uXCIsIFwiU3RhdGVtZW50XCIsIFwiRGVjbGFyYXRpb25cIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIHR5cGVQYXJhbWV0ZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiKSxcbiAgICBzdXBlcnR5cGU6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiRmxvd1R5cGVcIiksXG4gICAgaW1wbHR5cGU6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkZsb3dUeXBlXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlF1YWxpZmllZFR5cGVJZGVudGlmaWVyXCIsIHtcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJxdWFsaWZpY2F0aW9uXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICBxdWFsaWZpY2F0aW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoW1wiSWRlbnRpZmllclwiLCBcIlF1YWxpZmllZFR5cGVJZGVudGlmaWVyXCJdKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJTdHJpbmdMaXRlcmFsVHlwZUFubm90YXRpb25cIiwge1xuICBidWlsZGVyOiBbXCJ2YWx1ZVwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1wiLCBcIkZsb3dUeXBlXCJdLFxuICBmaWVsZHM6IHtcbiAgICB2YWx1ZTogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwic3RyaW5nXCIpKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJTdHJpbmdUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93VHlwZVwiLCBcIkZsb3dCYXNlQW5ub3RhdGlvblwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiU3ltYm9sVHlwZUFubm90YXRpb25cIiwge1xuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiRmxvd1R5cGVcIiwgXCJGbG93QmFzZUFubm90YXRpb25cIl1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRoaXNUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93VHlwZVwiLCBcIkZsb3dCYXNlQW5ub3RhdGlvblwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVHVwbGVUeXBlQW5ub3RhdGlvblwiLCB7XG4gIHZpc2l0b3I6IFtcInR5cGVzXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiRmxvd1R5cGVcIl0sXG4gIGZpZWxkczoge1xuICAgIHR5cGVzOiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFycmF5T2ZUeXBlKShcIkZsb3dUeXBlXCIpKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUeXBlb2ZUeXBlQW5ub3RhdGlvblwiLCB7XG4gIHZpc2l0b3I6IFtcImFyZ3VtZW50XCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiRmxvd1R5cGVcIl0sXG4gIGZpZWxkczoge1xuICAgIGFyZ3VtZW50OiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJGbG93VHlwZVwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUeXBlQWxpYXNcIiwge1xuICB2aXNpdG9yOiBbXCJpZFwiLCBcInR5cGVQYXJhbWV0ZXJzXCIsIFwicmlnaHRcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93RGVjbGFyYXRpb25cIiwgXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgaWQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIklkZW50aWZpZXJcIiksXG4gICAgdHlwZVBhcmFtZXRlcnM6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIpLFxuICAgIHJpZ2h0OiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJGbG93VHlwZVwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIkZsb3dcIl0sXG4gIHZpc2l0b3I6IFtcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICB0eXBlQW5ub3RhdGlvbjogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiRmxvd1R5cGVcIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVHlwZUNhc3RFeHByZXNzaW9uXCIsIHtcbiAgdmlzaXRvcjogW1wiZXhwcmVzc2lvblwiLCBcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93XCIsIFwiRXhwcmVzc2lvbldyYXBwZXJcIiwgXCJFeHByZXNzaW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBleHByZXNzaW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJFeHByZXNzaW9uXCIpLFxuICAgIHR5cGVBbm5vdGF0aW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJUeXBlQW5ub3RhdGlvblwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUeXBlUGFyYW1ldGVyXCIsIHtcbiAgYWxpYXNlczogW1wiRmxvd1wiXSxcbiAgdmlzaXRvcjogW1wiYm91bmRcIiwgXCJkZWZhdWx0XCIsIFwidmFyaWFuY2VcIl0sXG4gIGZpZWxkczoge1xuICAgIG5hbWU6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKSksXG4gICAgYm91bmQ6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiVHlwZUFubm90YXRpb25cIiksXG4gICAgZGVmYXVsdDogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJGbG93VHlwZVwiKSxcbiAgICB2YXJpYW5jZTogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJWYXJpYW5jZVwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiwge1xuICBhbGlhc2VzOiBbXCJGbG93XCJdLFxuICB2aXNpdG9yOiBbXCJwYXJhbXNcIl0sXG4gIGZpZWxkczoge1xuICAgIHBhcmFtczogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hcnJheU9mVHlwZSkoXCJUeXBlUGFyYW1ldGVyXCIpKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIkZsb3dcIl0sXG4gIHZpc2l0b3I6IFtcInBhcmFtc1wiXSxcbiAgZmllbGRzOiB7XG4gICAgcGFyYW1zOiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFycmF5T2ZUeXBlKShcIkZsb3dUeXBlXCIpKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJVbmlvblR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1widHlwZXNcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93VHlwZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdHlwZXM6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXJyYXlPZlR5cGUpKFwiRmxvd1R5cGVcIikpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlZhcmlhbmNlXCIsIHtcbiAgYWxpYXNlczogW1wiRmxvd1wiXSxcbiAgYnVpbGRlcjogW1wia2luZFwiXSxcbiAgZmllbGRzOiB7XG4gICAga2luZDogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hc3NlcnRPbmVPZikoXCJtaW51c1wiLCBcInBsdXNcIikpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlZvaWRUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIkZsb3dcIiwgXCJGbG93VHlwZVwiLCBcIkZsb3dCYXNlQW5ub3RhdGlvblwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRW51bURlY2xhcmF0aW9uXCIsIHtcbiAgYWxpYXNlczogW1wiU3RhdGVtZW50XCIsIFwiRGVjbGFyYXRpb25cIl0sXG4gIHZpc2l0b3I6IFtcImlkXCIsIFwiYm9keVwiXSxcbiAgZmllbGRzOiB7XG4gICAgaWQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIklkZW50aWZpZXJcIiksXG4gICAgYm9keTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFtcIkVudW1Cb29sZWFuQm9keVwiLCBcIkVudW1OdW1iZXJCb2R5XCIsIFwiRW51bVN0cmluZ0JvZHlcIiwgXCJFbnVtU3ltYm9sQm9keVwiXSlcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRW51bUJvb2xlYW5Cb2R5XCIsIHtcbiAgYWxpYXNlczogW1wiRW51bUJvZHlcIl0sXG4gIHZpc2l0b3I6IFtcIm1lbWJlcnNcIl0sXG4gIGZpZWxkczoge1xuICAgIGV4cGxpY2l0OiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpKSxcbiAgICBtZW1iZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlQXJyYXlPZlR5cGUpKFwiRW51bUJvb2xlYW5NZW1iZXJcIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRW51bU51bWJlckJvZHlcIiwge1xuICBhbGlhc2VzOiBbXCJFbnVtQm9keVwiXSxcbiAgdmlzaXRvcjogW1wibWVtYmVyc1wiXSxcbiAgZmllbGRzOiB7XG4gICAgZXhwbGljaXQ6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIikpLFxuICAgIG1lbWJlcnM6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJFbnVtTnVtYmVyTWVtYmVyXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkVudW1TdHJpbmdCb2R5XCIsIHtcbiAgYWxpYXNlczogW1wiRW51bUJvZHlcIl0sXG4gIHZpc2l0b3I6IFtcIm1lbWJlcnNcIl0sXG4gIGZpZWxkczoge1xuICAgIGV4cGxpY2l0OiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpKSxcbiAgICBtZW1iZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlQXJyYXlPZlR5cGUpKFtcIkVudW1TdHJpbmdNZW1iZXJcIiwgXCJFbnVtRGVmYXVsdGVkTWVtYmVyXCJdKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJFbnVtU3ltYm9sQm9keVwiLCB7XG4gIGFsaWFzZXM6IFtcIkVudW1Cb2R5XCJdLFxuICB2aXNpdG9yOiBbXCJtZW1iZXJzXCJdLFxuICBmaWVsZHM6IHtcbiAgICBtZW1iZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlQXJyYXlPZlR5cGUpKFwiRW51bURlZmF1bHRlZE1lbWJlclwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJFbnVtQm9vbGVhbk1lbWJlclwiLCB7XG4gIGFsaWFzZXM6IFtcIkVudW1NZW1iZXJcIl0sXG4gIHZpc2l0b3I6IFtcImlkXCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICBpbml0OiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJCb29sZWFuTGl0ZXJhbFwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJFbnVtTnVtYmVyTWVtYmVyXCIsIHtcbiAgYWxpYXNlczogW1wiRW51bU1lbWJlclwiXSxcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJpbml0XCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICBpbml0OiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJOdW1lcmljTGl0ZXJhbFwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJFbnVtU3RyaW5nTWVtYmVyXCIsIHtcbiAgYWxpYXNlczogW1wiRW51bU1lbWJlclwiXSxcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJpbml0XCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICBpbml0OiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJTdHJpbmdMaXRlcmFsXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkVudW1EZWZhdWx0ZWRNZW1iZXJcIiwge1xuICBhbGlhc2VzOiBbXCJFbnVtTWVtYmVyXCJdLFxuICB2aXNpdG9yOiBbXCJpZFwiXSxcbiAgZmllbGRzOiB7XG4gICAgaWQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIklkZW50aWZpZXJcIilcbiAgfVxufSk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWSVNJVE9SX0tFWVNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWxzLlZJU0lUT1JfS0VZUztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBTElBU19LRVlTXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlscy5BTElBU19LRVlTO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZMSVBQRURfQUxJQVNfS0VZU1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbHMuRkxJUFBFRF9BTElBU19LRVlTO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5PREVfRklFTERTXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlscy5OT0RFX0ZJRUxEUztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCVUlMREVSX0tFWVNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWxzLkJVSUxERVJfS0VZUztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJERVBSRUNBVEVEX0tFWVNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWxzLkRFUFJFQ0FURURfS0VZUztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOT0RFX1BBUkVOVF9WQUxJREFUSU9OU1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbHMuTk9ERV9QQVJFTlRfVkFMSURBVElPTlM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUExBQ0VIT0xERVJTXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9wbGFjZWhvbGRlcnMuUExBQ0VIT0xERVJTO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBMQUNFSE9MREVSU19BTElBU1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfcGxhY2Vob2xkZXJzLlBMQUNFSE9MREVSU19BTElBUztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQTEFDRUhPTERFUlNfRkxJUFBFRF9BTElBU1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfcGxhY2Vob2xkZXJzLlBMQUNFSE9MREVSU19GTElQUEVEX0FMSUFTO1xuICB9XG59KTtcbmV4cG9ydHMuVFlQRVMgPSB2b2lkIDA7XG5cbnZhciBfdG9GYXN0UHJvcGVydGllcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInRvLWZhc3QtcHJvcGVydGllc1wiKSk7XG5cbnJlcXVpcmUoXCIuL2NvcmVcIik7XG5cbnJlcXVpcmUoXCIuL2Zsb3dcIik7XG5cbnJlcXVpcmUoXCIuL2pzeFwiKTtcblxucmVxdWlyZShcIi4vbWlzY1wiKTtcblxucmVxdWlyZShcIi4vZXhwZXJpbWVudGFsXCIpO1xuXG5yZXF1aXJlKFwiLi90eXBlc2NyaXB0XCIpO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5cbnZhciBfcGxhY2Vob2xkZXJzID0gcmVxdWlyZShcIi4vcGxhY2Vob2xkZXJzXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4oMCwgX3RvRmFzdFByb3BlcnRpZXMuZGVmYXVsdCkoX3V0aWxzLlZJU0lUT1JfS0VZUyk7XG4oMCwgX3RvRmFzdFByb3BlcnRpZXMuZGVmYXVsdCkoX3V0aWxzLkFMSUFTX0tFWVMpO1xuKDAsIF90b0Zhc3RQcm9wZXJ0aWVzLmRlZmF1bHQpKF91dGlscy5GTElQUEVEX0FMSUFTX0tFWVMpO1xuKDAsIF90b0Zhc3RQcm9wZXJ0aWVzLmRlZmF1bHQpKF91dGlscy5OT0RFX0ZJRUxEUyk7XG4oMCwgX3RvRmFzdFByb3BlcnRpZXMuZGVmYXVsdCkoX3V0aWxzLkJVSUxERVJfS0VZUyk7XG4oMCwgX3RvRmFzdFByb3BlcnRpZXMuZGVmYXVsdCkoX3V0aWxzLkRFUFJFQ0FURURfS0VZUyk7XG4oMCwgX3RvRmFzdFByb3BlcnRpZXMuZGVmYXVsdCkoX3BsYWNlaG9sZGVycy5QTEFDRUhPTERFUlNfQUxJQVMpO1xuKDAsIF90b0Zhc3RQcm9wZXJ0aWVzLmRlZmF1bHQpKF9wbGFjZWhvbGRlcnMuUExBQ0VIT0xERVJTX0ZMSVBQRURfQUxJQVMpO1xuY29uc3QgVFlQRVMgPSBPYmplY3Qua2V5cyhfdXRpbHMuVklTSVRPUl9LRVlTKS5jb25jYXQoT2JqZWN0LmtleXMoX3V0aWxzLkZMSVBQRURfQUxJQVNfS0VZUykpLmNvbmNhdChPYmplY3Qua2V5cyhfdXRpbHMuREVQUkVDQVRFRF9LRVlTKSk7XG5leHBvcnRzLlRZUEVTID0gVFlQRVM7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfdXRpbHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi91dGlsc1wiKSk7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBkZWZhdWx0OiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiSlNYQXR0cmlidXRlXCIsIHtcbiAgdmlzaXRvcjogW1wibmFtZVwiLCBcInZhbHVlXCJdLFxuICBhbGlhc2VzOiBbXCJKU1hcIiwgXCJJbW11dGFibGVcIl0sXG4gIGZpZWxkczoge1xuICAgIG5hbWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkpTWElkZW50aWZpZXJcIiwgXCJKU1hOYW1lc3BhY2VkTmFtZVwiKVxuICAgIH0sXG4gICAgdmFsdWU6IHtcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSlNYRWxlbWVudFwiLCBcIkpTWEZyYWdtZW50XCIsIFwiU3RyaW5nTGl0ZXJhbFwiLCBcIkpTWEV4cHJlc3Npb25Db250YWluZXJcIilcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkpTWENsb3NpbmdFbGVtZW50XCIsIHtcbiAgdmlzaXRvcjogW1wibmFtZVwiXSxcbiAgYWxpYXNlczogW1wiSlNYXCIsIFwiSW1tdXRhYmxlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBuYW1lOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJKU1hJZGVudGlmaWVyXCIsIFwiSlNYTWVtYmVyRXhwcmVzc2lvblwiLCBcIkpTWE5hbWVzcGFjZWROYW1lXCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJKU1hFbGVtZW50XCIsIHtcbiAgYnVpbGRlcjogW1wib3BlbmluZ0VsZW1lbnRcIiwgXCJjbG9zaW5nRWxlbWVudFwiLCBcImNoaWxkcmVuXCIsIFwic2VsZkNsb3NpbmdcIl0sXG4gIHZpc2l0b3I6IFtcIm9wZW5pbmdFbGVtZW50XCIsIFwiY2hpbGRyZW5cIiwgXCJjbG9zaW5nRWxlbWVudFwiXSxcbiAgYWxpYXNlczogW1wiSlNYXCIsIFwiSW1tdXRhYmxlXCIsIFwiRXhwcmVzc2lvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgb3BlbmluZ0VsZW1lbnQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkpTWE9wZW5pbmdFbGVtZW50XCIpXG4gICAgfSxcbiAgICBjbG9zaW5nRWxlbWVudDoge1xuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJKU1hDbG9zaW5nRWxlbWVudFwiKVxuICAgIH0sXG4gICAgY2hpbGRyZW46IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJhcnJheVwiKSwgKDAsIF91dGlscy5hc3NlcnRFYWNoKSgoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkpTWFRleHRcIiwgXCJKU1hFeHByZXNzaW9uQ29udGFpbmVyXCIsIFwiSlNYU3ByZWFkQ2hpbGRcIiwgXCJKU1hFbGVtZW50XCIsIFwiSlNYRnJhZ21lbnRcIikpKVxuICAgIH0sXG4gICAgc2VsZkNsb3Npbmc6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkpTWEVtcHR5RXhwcmVzc2lvblwiLCB7XG4gIGFsaWFzZXM6IFtcIkpTWFwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiLCB7XG4gIHZpc2l0b3I6IFtcImV4cHJlc3Npb25cIl0sXG4gIGFsaWFzZXM6IFtcIkpTWFwiLCBcIkltbXV0YWJsZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiLCBcIkpTWEVtcHR5RXhwcmVzc2lvblwiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiSlNYU3ByZWFkQ2hpbGRcIiwge1xuICB2aXNpdG9yOiBbXCJleHByZXNzaW9uXCJdLFxuICBhbGlhc2VzOiBbXCJKU1hcIiwgXCJJbW11dGFibGVcIl0sXG4gIGZpZWxkczoge1xuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkpTWElkZW50aWZpZXJcIiwge1xuICBidWlsZGVyOiBbXCJuYW1lXCJdLFxuICBhbGlhc2VzOiBbXCJKU1hcIl0sXG4gIGZpZWxkczoge1xuICAgIG5hbWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIilcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkpTWE1lbWJlckV4cHJlc3Npb25cIiwge1xuICB2aXNpdG9yOiBbXCJvYmplY3RcIiwgXCJwcm9wZXJ0eVwiXSxcbiAgYWxpYXNlczogW1wiSlNYXCJdLFxuICBmaWVsZHM6IHtcbiAgICBvYmplY3Q6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkpTWE1lbWJlckV4cHJlc3Npb25cIiwgXCJKU1hJZGVudGlmaWVyXCIpXG4gICAgfSxcbiAgICBwcm9wZXJ0eToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSlNYSWRlbnRpZmllclwiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiSlNYTmFtZXNwYWNlZE5hbWVcIiwge1xuICB2aXNpdG9yOiBbXCJuYW1lc3BhY2VcIiwgXCJuYW1lXCJdLFxuICBhbGlhc2VzOiBbXCJKU1hcIl0sXG4gIGZpZWxkczoge1xuICAgIG5hbWVzcGFjZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSlNYSWRlbnRpZmllclwiKVxuICAgIH0sXG4gICAgbmFtZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSlNYSWRlbnRpZmllclwiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiSlNYT3BlbmluZ0VsZW1lbnRcIiwge1xuICBidWlsZGVyOiBbXCJuYW1lXCIsIFwiYXR0cmlidXRlc1wiLCBcInNlbGZDbG9zaW5nXCJdLFxuICB2aXNpdG9yOiBbXCJuYW1lXCIsIFwiYXR0cmlidXRlc1wiXSxcbiAgYWxpYXNlczogW1wiSlNYXCIsIFwiSW1tdXRhYmxlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBuYW1lOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJKU1hJZGVudGlmaWVyXCIsIFwiSlNYTWVtYmVyRXhwcmVzc2lvblwiLCBcIkpTWE5hbWVzcGFjZWROYW1lXCIpXG4gICAgfSxcbiAgICBzZWxmQ2xvc2luZzoge1xuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJhcnJheVwiKSwgKDAsIF91dGlscy5hc3NlcnRFYWNoKSgoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkpTWEF0dHJpYnV0ZVwiLCBcIkpTWFNwcmVhZEF0dHJpYnV0ZVwiKSkpXG4gICAgfSxcbiAgICB0eXBlUGFyYW1ldGVyczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIiwgXCJUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkpTWFNwcmVhZEF0dHJpYnV0ZVwiLCB7XG4gIHZpc2l0b3I6IFtcImFyZ3VtZW50XCJdLFxuICBhbGlhc2VzOiBbXCJKU1hcIl0sXG4gIGZpZWxkczoge1xuICAgIGFyZ3VtZW50OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJKU1hUZXh0XCIsIHtcbiAgYWxpYXNlczogW1wiSlNYXCIsIFwiSW1tdXRhYmxlXCJdLFxuICBidWlsZGVyOiBbXCJ2YWx1ZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIilcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkpTWEZyYWdtZW50XCIsIHtcbiAgYnVpbGRlcjogW1wib3BlbmluZ0ZyYWdtZW50XCIsIFwiY2xvc2luZ0ZyYWdtZW50XCIsIFwiY2hpbGRyZW5cIl0sXG4gIHZpc2l0b3I6IFtcIm9wZW5pbmdGcmFnbWVudFwiLCBcImNoaWxkcmVuXCIsIFwiY2xvc2luZ0ZyYWdtZW50XCJdLFxuICBhbGlhc2VzOiBbXCJKU1hcIiwgXCJJbW11dGFibGVcIiwgXCJFeHByZXNzaW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBvcGVuaW5nRnJhZ21lbnQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkpTWE9wZW5pbmdGcmFnbWVudFwiKVxuICAgIH0sXG4gICAgY2xvc2luZ0ZyYWdtZW50OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJKU1hDbG9zaW5nRnJhZ21lbnRcIilcbiAgICB9LFxuICAgIGNoaWxkcmVuOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJKU1hUZXh0XCIsIFwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiLCBcIkpTWFNwcmVhZENoaWxkXCIsIFwiSlNYRWxlbWVudFwiLCBcIkpTWEZyYWdtZW50XCIpKSlcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkpTWE9wZW5pbmdGcmFnbWVudFwiLCB7XG4gIGFsaWFzZXM6IFtcIkpTWFwiLCBcIkltbXV0YWJsZVwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiSlNYQ2xvc2luZ0ZyYWdtZW50XCIsIHtcbiAgYWxpYXNlczogW1wiSlNYXCIsIFwiSW1tdXRhYmxlXCJdXG59KTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF91dGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3V0aWxzXCIpKTtcblxudmFyIF9wbGFjZWhvbGRlcnMgPSByZXF1aXJlKFwiLi9wbGFjZWhvbGRlcnNcIik7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpOyBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjYWNoZTsgfTsgcmV0dXJuIGNhY2hlOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBkZWZhdWx0OiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiTm9vcFwiLCB7XG4gIHZpc2l0b3I6IFtdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJQbGFjZWhvbGRlclwiLCB7XG4gIHZpc2l0b3I6IFtdLFxuICBidWlsZGVyOiBbXCJleHBlY3RlZE5vZGVcIiwgXCJuYW1lXCJdLFxuICBmaWVsZHM6IHtcbiAgICBuYW1lOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpXG4gICAgfSxcbiAgICBleHBlY3RlZE5vZGU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE9uZU9mKSguLi5fcGxhY2Vob2xkZXJzLlBMQUNFSE9MREVSUylcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlY4SW50cmluc2ljSWRlbnRpZmllclwiLCB7XG4gIGJ1aWxkZXI6IFtcIm5hbWVcIl0sXG4gIGZpZWxkczoge1xuICAgIG5hbWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIilcbiAgICB9XG4gIH1cbn0pOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5QTEFDRUhPTERFUlNfRkxJUFBFRF9BTElBUyA9IGV4cG9ydHMuUExBQ0VIT0xERVJTX0FMSUFTID0gZXhwb3J0cy5QTEFDRUhPTERFUlMgPSB2b2lkIDA7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcblxuY29uc3QgUExBQ0VIT0xERVJTID0gW1wiSWRlbnRpZmllclwiLCBcIlN0cmluZ0xpdGVyYWxcIiwgXCJFeHByZXNzaW9uXCIsIFwiU3RhdGVtZW50XCIsIFwiRGVjbGFyYXRpb25cIiwgXCJCbG9ja1N0YXRlbWVudFwiLCBcIkNsYXNzQm9keVwiLCBcIlBhdHRlcm5cIl07XG5leHBvcnRzLlBMQUNFSE9MREVSUyA9IFBMQUNFSE9MREVSUztcbmNvbnN0IFBMQUNFSE9MREVSU19BTElBUyA9IHtcbiAgRGVjbGFyYXRpb246IFtcIlN0YXRlbWVudFwiXSxcbiAgUGF0dGVybjogW1wiUGF0dGVybkxpa2VcIiwgXCJMVmFsXCJdXG59O1xuZXhwb3J0cy5QTEFDRUhPTERFUlNfQUxJQVMgPSBQTEFDRUhPTERFUlNfQUxJQVM7XG5cbmZvciAoY29uc3QgdHlwZSBvZiBQTEFDRUhPTERFUlMpIHtcbiAgY29uc3QgYWxpYXMgPSBfdXRpbHMuQUxJQVNfS0VZU1t0eXBlXTtcbiAgaWYgKGFsaWFzID09IG51bGwgPyB2b2lkIDAgOiBhbGlhcy5sZW5ndGgpIFBMQUNFSE9MREVSU19BTElBU1t0eXBlXSA9IGFsaWFzO1xufVxuXG5jb25zdCBQTEFDRUhPTERFUlNfRkxJUFBFRF9BTElBUyA9IHt9O1xuZXhwb3J0cy5QTEFDRUhPTERFUlNfRkxJUFBFRF9BTElBUyA9IFBMQUNFSE9MREVSU19GTElQUEVEX0FMSUFTO1xuT2JqZWN0LmtleXMoUExBQ0VIT0xERVJTX0FMSUFTKS5mb3JFYWNoKHR5cGUgPT4ge1xuICBQTEFDRUhPTERFUlNfQUxJQVNbdHlwZV0uZm9yRWFjaChhbGlhcyA9PiB7XG4gICAgaWYgKCFPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChQTEFDRUhPTERFUlNfRkxJUFBFRF9BTElBUywgYWxpYXMpKSB7XG4gICAgICBQTEFDRUhPTERFUlNfRkxJUFBFRF9BTElBU1thbGlhc10gPSBbXTtcbiAgICB9XG5cbiAgICBQTEFDRUhPTERFUlNfRkxJUFBFRF9BTElBU1thbGlhc10ucHVzaCh0eXBlKTtcbiAgfSk7XG59KTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF91dGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3V0aWxzXCIpKTtcblxudmFyIF9jb3JlID0gcmVxdWlyZShcIi4vY29yZVwiKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhY2hlOyB9OyByZXR1cm4gY2FjaGU7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IGRlZmF1bHQ6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbmNvbnN0IGJvb2wgPSAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpO1xuY29uc3QgdFNGdW5jdGlvblR5cGVBbm5vdGF0aW9uQ29tbW9uID0ge1xuICByZXR1cm5UeXBlOiB7XG4gICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVFNUeXBlQW5ub3RhdGlvblwiLCBcIk5vb3BcIiksXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSxcbiAgdHlwZVBhcmFtZXRlcnM6IHtcbiAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJUU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiLCBcIk5vb3BcIiksXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfVxufTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU1BhcmFtZXRlclByb3BlcnR5XCIsIHtcbiAgYWxpYXNlczogW1wiTFZhbFwiXSxcbiAgdmlzaXRvcjogW1wicGFyYW1ldGVyXCJdLFxuICBmaWVsZHM6IHtcbiAgICBhY2Nlc3NpYmlsaXR5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRPbmVPZikoXCJwdWJsaWNcIiwgXCJwcml2YXRlXCIsIFwicHJvdGVjdGVkXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIHJlYWRvbmx5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBwYXJhbWV0ZXI6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIiwgXCJBc3NpZ25tZW50UGF0dGVyblwiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNEZWNsYXJlRnVuY3Rpb25cIiwge1xuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiXSxcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiLCBcInBhcmFtc1wiLCBcInJldHVyblR5cGVcIl0sXG4gIGZpZWxkczogT2JqZWN0LmFzc2lnbih7fSwgX2NvcmUuZnVuY3Rpb25EZWNsYXJhdGlvbkNvbW1vbiwgdFNGdW5jdGlvblR5cGVBbm5vdGF0aW9uQ29tbW9uKVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNEZWNsYXJlTWV0aG9kXCIsIHtcbiAgdmlzaXRvcjogW1wiZGVjb3JhdG9yc1wiLCBcImtleVwiLCBcInR5cGVQYXJhbWV0ZXJzXCIsIFwicGFyYW1zXCIsIFwicmV0dXJuVHlwZVwiXSxcbiAgZmllbGRzOiBPYmplY3QuYXNzaWduKHt9LCBfY29yZS5jbGFzc01ldGhvZE9yRGVjbGFyZU1ldGhvZENvbW1vbiwgdFNGdW5jdGlvblR5cGVBbm5vdGF0aW9uQ29tbW9uKVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNRdWFsaWZpZWROYW1lXCIsIHtcbiAgYWxpYXNlczogW1wiVFNFbnRpdHlOYW1lXCJdLFxuICB2aXNpdG9yOiBbXCJsZWZ0XCIsIFwicmlnaHRcIl0sXG4gIGZpZWxkczoge1xuICAgIGxlZnQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlRTRW50aXR5TmFtZVwiKSxcbiAgICByaWdodDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKVxuICB9XG59KTtcbmNvbnN0IHNpZ25hdHVyZURlY2xhcmF0aW9uQ29tbW9uID0ge1xuICB0eXBlUGFyYW1ldGVyczogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiKSxcbiAgcGFyYW1ldGVyczogKDAsIF91dGlscy52YWxpZGF0ZUFycmF5T2ZUeXBlKShbXCJJZGVudGlmaWVyXCIsIFwiUmVzdEVsZW1lbnRcIl0pLFxuICB0eXBlQW5ub3RhdGlvbjogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUU1R5cGVBbm5vdGF0aW9uXCIpXG59O1xuY29uc3QgY2FsbENvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uID0ge1xuICBhbGlhc2VzOiBbXCJUU1R5cGVFbGVtZW50XCJdLFxuICB2aXNpdG9yOiBbXCJ0eXBlUGFyYW1ldGVyc1wiLCBcInBhcmFtZXRlcnNcIiwgXCJ0eXBlQW5ub3RhdGlvblwiXSxcbiAgZmllbGRzOiBzaWduYXR1cmVEZWNsYXJhdGlvbkNvbW1vblxufTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvblwiLCBjYWxsQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb24pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb25cIiwgY2FsbENvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uKTtcbmNvbnN0IG5hbWVkVHlwZUVsZW1lbnRDb21tb24gPSB7XG4gIGtleTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiRXhwcmVzc2lvblwiKSxcbiAgY29tcHV0ZWQ6ICgwLCBfdXRpbHMudmFsaWRhdGUpKGJvb2wpLFxuICBvcHRpb25hbDogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsKShib29sKVxufTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU1Byb3BlcnR5U2lnbmF0dXJlXCIsIHtcbiAgYWxpYXNlczogW1wiVFNUeXBlRWxlbWVudFwiXSxcbiAgdmlzaXRvcjogW1wia2V5XCIsIFwidHlwZUFubm90YXRpb25cIiwgXCJpbml0aWFsaXplclwiXSxcbiAgZmllbGRzOiBPYmplY3QuYXNzaWduKHt9LCBuYW1lZFR5cGVFbGVtZW50Q29tbW9uLCB7XG4gICAgcmVhZG9ubHk6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoYm9vbCksXG4gICAgdHlwZUFubm90YXRpb246ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiVFNUeXBlQW5ub3RhdGlvblwiKSxcbiAgICBpbml0aWFsaXplcjogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gIH0pXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU01ldGhvZFNpZ25hdHVyZVwiLCB7XG4gIGFsaWFzZXM6IFtcIlRTVHlwZUVsZW1lbnRcIl0sXG4gIHZpc2l0b3I6IFtcImtleVwiLCBcInR5cGVQYXJhbWV0ZXJzXCIsIFwicGFyYW1ldGVyc1wiLCBcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBmaWVsZHM6IE9iamVjdC5hc3NpZ24oe30sIHNpZ25hdHVyZURlY2xhcmF0aW9uQ29tbW9uLCBuYW1lZFR5cGVFbGVtZW50Q29tbW9uKVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNJbmRleFNpZ25hdHVyZVwiLCB7XG4gIGFsaWFzZXM6IFtcIlRTVHlwZUVsZW1lbnRcIl0sXG4gIHZpc2l0b3I6IFtcInBhcmFtZXRlcnNcIiwgXCJ0eXBlQW5ub3RhdGlvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgcmVhZG9ubHk6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoYm9vbCksXG4gICAgcGFyYW1ldGVyczogKDAsIF91dGlscy52YWxpZGF0ZUFycmF5T2ZUeXBlKShcIklkZW50aWZpZXJcIiksXG4gICAgdHlwZUFubm90YXRpb246ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiVFNUeXBlQW5ub3RhdGlvblwiKVxuICB9XG59KTtcbmNvbnN0IHRzS2V5d29yZFR5cGVzID0gW1wiVFNBbnlLZXl3b3JkXCIsIFwiVFNCb29sZWFuS2V5d29yZFwiLCBcIlRTQmlnSW50S2V5d29yZFwiLCBcIlRTTmV2ZXJLZXl3b3JkXCIsIFwiVFNOdWxsS2V5d29yZFwiLCBcIlRTTnVtYmVyS2V5d29yZFwiLCBcIlRTT2JqZWN0S2V5d29yZFwiLCBcIlRTU3RyaW5nS2V5d29yZFwiLCBcIlRTU3ltYm9sS2V5d29yZFwiLCBcIlRTVW5kZWZpbmVkS2V5d29yZFwiLCBcIlRTVW5rbm93bktleXdvcmRcIiwgXCJUU1ZvaWRLZXl3b3JkXCJdO1xuXG5mb3IgKGNvbnN0IHR5cGUgb2YgdHNLZXl3b3JkVHlwZXMpIHtcbiAgKDAsIF91dGlscy5kZWZhdWx0KSh0eXBlLCB7XG4gICAgYWxpYXNlczogW1wiVFNUeXBlXCIsIFwiVFNCYXNlVHlwZVwiXSxcbiAgICB2aXNpdG9yOiBbXSxcbiAgICBmaWVsZHM6IHt9XG4gIH0pO1xufVxuXG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNUaGlzVHlwZVwiLCB7XG4gIGFsaWFzZXM6IFtcIlRTVHlwZVwiLCBcIlRTQmFzZVR5cGVcIl0sXG4gIHZpc2l0b3I6IFtdLFxuICBmaWVsZHM6IHt9XG59KTtcbmNvbnN0IGZuT3JDdHIgPSB7XG4gIGFsaWFzZXM6IFtcIlRTVHlwZVwiXSxcbiAgdmlzaXRvcjogW1widHlwZVBhcmFtZXRlcnNcIiwgXCJwYXJhbWV0ZXJzXCIsIFwidHlwZUFubm90YXRpb25cIl0sXG4gIGZpZWxkczogc2lnbmF0dXJlRGVjbGFyYXRpb25Db21tb25cbn07XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNGdW5jdGlvblR5cGVcIiwgZm5PckN0cik7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNDb25zdHJ1Y3RvclR5cGVcIiwgZm5PckN0cik7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNUeXBlUmVmZXJlbmNlXCIsIHtcbiAgYWxpYXNlczogW1wiVFNUeXBlXCJdLFxuICB2aXNpdG9yOiBbXCJ0eXBlTmFtZVwiLCBcInR5cGVQYXJhbWV0ZXJzXCJdLFxuICBmaWVsZHM6IHtcbiAgICB0eXBlTmFtZTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVFNFbnRpdHlOYW1lXCIpLFxuICAgIHR5cGVQYXJhbWV0ZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNUeXBlUHJlZGljYXRlXCIsIHtcbiAgYWxpYXNlczogW1wiVFNUeXBlXCJdLFxuICB2aXNpdG9yOiBbXCJwYXJhbWV0ZXJOYW1lXCIsIFwidHlwZUFubm90YXRpb25cIl0sXG4gIGJ1aWxkZXI6IFtcInBhcmFtZXRlck5hbWVcIiwgXCJ0eXBlQW5ub3RhdGlvblwiLCBcImFzc2VydHNcIl0sXG4gIGZpZWxkczoge1xuICAgIHBhcmFtZXRlck5hbWU6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShbXCJJZGVudGlmaWVyXCIsIFwiVFNUaGlzVHlwZVwiXSksXG4gICAgdHlwZUFubm90YXRpb246ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiVFNUeXBlQW5ub3RhdGlvblwiKSxcbiAgICBhc3NlcnRzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKGJvb2wpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTVHlwZVF1ZXJ5XCIsIHtcbiAgYWxpYXNlczogW1wiVFNUeXBlXCJdLFxuICB2aXNpdG9yOiBbXCJleHByTmFtZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgZXhwck5hbWU6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShbXCJUU0VudGl0eU5hbWVcIiwgXCJUU0ltcG9ydFR5cGVcIl0pXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTVHlwZUxpdGVyYWxcIiwge1xuICBhbGlhc2VzOiBbXCJUU1R5cGVcIl0sXG4gIHZpc2l0b3I6IFtcIm1lbWJlcnNcIl0sXG4gIGZpZWxkczoge1xuICAgIG1lbWJlcnM6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJUU1R5cGVFbGVtZW50XCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTQXJyYXlUeXBlXCIsIHtcbiAgYWxpYXNlczogW1wiVFNUeXBlXCJdLFxuICB2aXNpdG9yOiBbXCJlbGVtZW50VHlwZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgZWxlbWVudFR5cGU6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlRTVHlwZVwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU1R1cGxlVHlwZVwiLCB7XG4gIGFsaWFzZXM6IFtcIlRTVHlwZVwiXSxcbiAgdmlzaXRvcjogW1wiZWxlbWVudFR5cGVzXCJdLFxuICBmaWVsZHM6IHtcbiAgICBlbGVtZW50VHlwZXM6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoW1wiVFNUeXBlXCIsIFwiVFNOYW1lZFR1cGxlTWVtYmVyXCJdKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU09wdGlvbmFsVHlwZVwiLCB7XG4gIGFsaWFzZXM6IFtcIlRTVHlwZVwiXSxcbiAgdmlzaXRvcjogW1widHlwZUFubm90YXRpb25cIl0sXG4gIGZpZWxkczoge1xuICAgIHR5cGVBbm5vdGF0aW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJUU1R5cGVcIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNSZXN0VHlwZVwiLCB7XG4gIGFsaWFzZXM6IFtcIlRTVHlwZVwiXSxcbiAgdmlzaXRvcjogW1widHlwZUFubm90YXRpb25cIl0sXG4gIGZpZWxkczoge1xuICAgIHR5cGVBbm5vdGF0aW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJUU1R5cGVcIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNOYW1lZFR1cGxlTWVtYmVyXCIsIHtcbiAgdmlzaXRvcjogW1wibGFiZWxcIiwgXCJlbGVtZW50VHlwZVwiXSxcbiAgYnVpbGRlcjogW1wibGFiZWxcIiwgXCJlbGVtZW50VHlwZVwiLCBcIm9wdGlvbmFsXCJdLFxuICBmaWVsZHM6IHtcbiAgICBsYWJlbDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICBvcHRpb25hbDoge1xuICAgICAgdmFsaWRhdGU6IGJvb2wsXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgZWxlbWVudFR5cGU6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlRTVHlwZVwiKVxuICB9XG59KTtcbmNvbnN0IHVuaW9uT3JJbnRlcnNlY3Rpb24gPSB7XG4gIGFsaWFzZXM6IFtcIlRTVHlwZVwiXSxcbiAgdmlzaXRvcjogW1widHlwZXNcIl0sXG4gIGZpZWxkczoge1xuICAgIHR5cGVzOiAoMCwgX3V0aWxzLnZhbGlkYXRlQXJyYXlPZlR5cGUpKFwiVFNUeXBlXCIpXG4gIH1cbn07XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNVbmlvblR5cGVcIiwgdW5pb25PckludGVyc2VjdGlvbik7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNJbnRlcnNlY3Rpb25UeXBlXCIsIHVuaW9uT3JJbnRlcnNlY3Rpb24pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTQ29uZGl0aW9uYWxUeXBlXCIsIHtcbiAgYWxpYXNlczogW1wiVFNUeXBlXCJdLFxuICB2aXNpdG9yOiBbXCJjaGVja1R5cGVcIiwgXCJleHRlbmRzVHlwZVwiLCBcInRydWVUeXBlXCIsIFwiZmFsc2VUeXBlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBjaGVja1R5cGU6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlRTVHlwZVwiKSxcbiAgICBleHRlbmRzVHlwZTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVFNUeXBlXCIpLFxuICAgIHRydWVUeXBlOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJUU1R5cGVcIiksXG4gICAgZmFsc2VUeXBlOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJUU1R5cGVcIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNJbmZlclR5cGVcIiwge1xuICBhbGlhc2VzOiBbXCJUU1R5cGVcIl0sXG4gIHZpc2l0b3I6IFtcInR5cGVQYXJhbWV0ZXJcIl0sXG4gIGZpZWxkczoge1xuICAgIHR5cGVQYXJhbWV0ZXI6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlRTVHlwZVBhcmFtZXRlclwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU1BhcmVudGhlc2l6ZWRUeXBlXCIsIHtcbiAgYWxpYXNlczogW1wiVFNUeXBlXCJdLFxuICB2aXNpdG9yOiBbXCJ0eXBlQW5ub3RhdGlvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgdHlwZUFubm90YXRpb246ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlRTVHlwZVwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU1R5cGVPcGVyYXRvclwiLCB7XG4gIGFsaWFzZXM6IFtcIlRTVHlwZVwiXSxcbiAgdmlzaXRvcjogW1widHlwZUFubm90YXRpb25cIl0sXG4gIGZpZWxkczoge1xuICAgIG9wZXJhdG9yOiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIikpLFxuICAgIHR5cGVBbm5vdGF0aW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJUU1R5cGVcIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNJbmRleGVkQWNjZXNzVHlwZVwiLCB7XG4gIGFsaWFzZXM6IFtcIlRTVHlwZVwiXSxcbiAgdmlzaXRvcjogW1wib2JqZWN0VHlwZVwiLCBcImluZGV4VHlwZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgb2JqZWN0VHlwZTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVFNUeXBlXCIpLFxuICAgIGluZGV4VHlwZTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVFNUeXBlXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTTWFwcGVkVHlwZVwiLCB7XG4gIGFsaWFzZXM6IFtcIlRTVHlwZVwiXSxcbiAgdmlzaXRvcjogW1widHlwZVBhcmFtZXRlclwiLCBcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICByZWFkb25seTogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsKShib29sKSxcbiAgICB0eXBlUGFyYW1ldGVyOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJUU1R5cGVQYXJhbWV0ZXJcIiksXG4gICAgb3B0aW9uYWw6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoYm9vbCksXG4gICAgdHlwZUFubm90YXRpb246ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiVFNUeXBlXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTTGl0ZXJhbFR5cGVcIiwge1xuICBhbGlhc2VzOiBbXCJUU1R5cGVcIiwgXCJUU0Jhc2VUeXBlXCJdLFxuICB2aXNpdG9yOiBbXCJsaXRlcmFsXCJdLFxuICBmaWVsZHM6IHtcbiAgICBsaXRlcmFsOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoW1wiTnVtZXJpY0xpdGVyYWxcIiwgXCJTdHJpbmdMaXRlcmFsXCIsIFwiQm9vbGVhbkxpdGVyYWxcIiwgXCJCaWdJbnRMaXRlcmFsXCJdKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU0V4cHJlc3Npb25XaXRoVHlwZUFyZ3VtZW50c1wiLCB7XG4gIGFsaWFzZXM6IFtcIlRTVHlwZVwiXSxcbiAgdmlzaXRvcjogW1wiZXhwcmVzc2lvblwiLCBcInR5cGVQYXJhbWV0ZXJzXCJdLFxuICBmaWVsZHM6IHtcbiAgICBleHByZXNzaW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJUU0VudGl0eU5hbWVcIiksXG4gICAgdHlwZVBhcmFtZXRlcnM6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiVFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU0ludGVyZmFjZURlY2xhcmF0aW9uXCIsIHtcbiAgYWxpYXNlczogW1wiU3RhdGVtZW50XCIsIFwiRGVjbGFyYXRpb25cIl0sXG4gIHZpc2l0b3I6IFtcImlkXCIsIFwidHlwZVBhcmFtZXRlcnNcIiwgXCJleHRlbmRzXCIsIFwiYm9keVwiXSxcbiAgZmllbGRzOiB7XG4gICAgZGVjbGFyZTogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsKShib29sKSxcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICB0eXBlUGFyYW1ldGVyczogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiKSxcbiAgICBleHRlbmRzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKCgwLCBfdXRpbHMuYXJyYXlPZlR5cGUpKFwiVFNFeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHNcIikpLFxuICAgIGJvZHk6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlRTSW50ZXJmYWNlQm9keVwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU0ludGVyZmFjZUJvZHlcIiwge1xuICB2aXNpdG9yOiBbXCJib2R5XCJdLFxuICBmaWVsZHM6IHtcbiAgICBib2R5OiAoMCwgX3V0aWxzLnZhbGlkYXRlQXJyYXlPZlR5cGUpKFwiVFNUeXBlRWxlbWVudFwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU1R5cGVBbGlhc0RlY2xhcmF0aW9uXCIsIHtcbiAgYWxpYXNlczogW1wiU3RhdGVtZW50XCIsIFwiRGVjbGFyYXRpb25cIl0sXG4gIHZpc2l0b3I6IFtcImlkXCIsIFwidHlwZVBhcmFtZXRlcnNcIiwgXCJ0eXBlQW5ub3RhdGlvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgZGVjbGFyZTogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsKShib29sKSxcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICB0eXBlUGFyYW1ldGVyczogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiKSxcbiAgICB0eXBlQW5ub3RhdGlvbjogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVFNUeXBlXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTQXNFeHByZXNzaW9uXCIsIHtcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiXSxcbiAgdmlzaXRvcjogW1wiZXhwcmVzc2lvblwiLCBcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBleHByZXNzaW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJFeHByZXNzaW9uXCIpLFxuICAgIHR5cGVBbm5vdGF0aW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJUU1R5cGVcIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNUeXBlQXNzZXJ0aW9uXCIsIHtcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiXSxcbiAgdmlzaXRvcjogW1widHlwZUFubm90YXRpb25cIiwgXCJleHByZXNzaW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICB0eXBlQW5ub3RhdGlvbjogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVFNUeXBlXCIpLFxuICAgIGV4cHJlc3Npb246ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNFbnVtRGVjbGFyYXRpb25cIiwge1xuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiXSxcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJtZW1iZXJzXCJdLFxuICBmaWVsZHM6IHtcbiAgICBkZWNsYXJlOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKGJvb2wpLFxuICAgIGNvbnN0OiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKGJvb2wpLFxuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIG1lbWJlcnM6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJUU0VudW1NZW1iZXJcIiksXG4gICAgaW5pdGlhbGl6ZXI6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU0VudW1NZW1iZXJcIiwge1xuICB2aXNpdG9yOiBbXCJpZFwiLCBcImluaXRpYWxpemVyXCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFtcIklkZW50aWZpZXJcIiwgXCJTdHJpbmdMaXRlcmFsXCJdKSxcbiAgICBpbml0aWFsaXplcjogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTTW9kdWxlRGVjbGFyYXRpb25cIiwge1xuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiXSxcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJib2R5XCJdLFxuICBmaWVsZHM6IHtcbiAgICBkZWNsYXJlOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKGJvb2wpLFxuICAgIGdsb2JhbDogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsKShib29sKSxcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFtcIklkZW50aWZpZXJcIiwgXCJTdHJpbmdMaXRlcmFsXCJdKSxcbiAgICBib2R5OiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoW1wiVFNNb2R1bGVCbG9ja1wiLCBcIlRTTW9kdWxlRGVjbGFyYXRpb25cIl0pXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTTW9kdWxlQmxvY2tcIiwge1xuICBhbGlhc2VzOiBbXCJTY29wYWJsZVwiLCBcIkJsb2NrXCIsIFwiQmxvY2tQYXJlbnRcIl0sXG4gIHZpc2l0b3I6IFtcImJvZHlcIl0sXG4gIGZpZWxkczoge1xuICAgIGJvZHk6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJTdGF0ZW1lbnRcIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNJbXBvcnRUeXBlXCIsIHtcbiAgYWxpYXNlczogW1wiVFNUeXBlXCJdLFxuICB2aXNpdG9yOiBbXCJhcmd1bWVudFwiLCBcInF1YWxpZmllclwiLCBcInR5cGVQYXJhbWV0ZXJzXCJdLFxuICBmaWVsZHM6IHtcbiAgICBhcmd1bWVudDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiU3RyaW5nTGl0ZXJhbFwiKSxcbiAgICBxdWFsaWZpZXI6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiVFNFbnRpdHlOYW1lXCIpLFxuICAgIHR5cGVQYXJhbWV0ZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiXSxcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJtb2R1bGVSZWZlcmVuY2VcIl0sXG4gIGZpZWxkczoge1xuICAgIGlzRXhwb3J0OiAoMCwgX3V0aWxzLnZhbGlkYXRlKShib29sKSxcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICBtb2R1bGVSZWZlcmVuY2U6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShbXCJUU0VudGl0eU5hbWVcIiwgXCJUU0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlXCJdKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlXCIsIHtcbiAgdmlzaXRvcjogW1wiZXhwcmVzc2lvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgZXhwcmVzc2lvbjogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiU3RyaW5nTGl0ZXJhbFwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU05vbk51bGxFeHByZXNzaW9uXCIsIHtcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiXSxcbiAgdmlzaXRvcjogW1wiZXhwcmVzc2lvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgZXhwcmVzc2lvbjogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICB9XG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJUU0V4cG9ydEFzc2lnbm1lbnRcIiwge1xuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIl0sXG4gIHZpc2l0b3I6IFtcImV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczoge1xuICAgIGV4cHJlc3Npb246ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNOYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiXSxcbiAgdmlzaXRvcjogW1wiaWRcIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpXG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTVHlwZUFubm90YXRpb25cIiwge1xuICB2aXNpdG9yOiBbXCJ0eXBlQW5ub3RhdGlvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgdHlwZUFubm90YXRpb246IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlRTVHlwZVwiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiLCB7XG4gIHZpc2l0b3I6IFtcInBhcmFtc1wiXSxcbiAgZmllbGRzOiB7XG4gICAgcGFyYW1zOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJUU1R5cGVcIikpKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVFNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiwge1xuICB2aXNpdG9yOiBbXCJwYXJhbXNcIl0sXG4gIGZpZWxkczoge1xuICAgIHBhcmFtczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVFNUeXBlUGFyYW1ldGVyXCIpKSlcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlRTVHlwZVBhcmFtZXRlclwiLCB7XG4gIGJ1aWxkZXI6IFtcImNvbnN0cmFpbnRcIiwgXCJkZWZhdWx0XCIsIFwibmFtZVwiXSxcbiAgdmlzaXRvcjogW1wiY29uc3RyYWludFwiLCBcImRlZmF1bHRcIl0sXG4gIGZpZWxkczoge1xuICAgIG5hbWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIilcbiAgICB9LFxuICAgIGNvbnN0cmFpbnQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlRTVHlwZVwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBkZWZhdWx0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJUU1R5cGVcIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfVxufSk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnZhbGlkYXRlID0gdmFsaWRhdGU7XG5leHBvcnRzLnR5cGVJcyA9IHR5cGVJcztcbmV4cG9ydHMudmFsaWRhdGVUeXBlID0gdmFsaWRhdGVUeXBlO1xuZXhwb3J0cy52YWxpZGF0ZU9wdGlvbmFsID0gdmFsaWRhdGVPcHRpb25hbDtcbmV4cG9ydHMudmFsaWRhdGVPcHRpb25hbFR5cGUgPSB2YWxpZGF0ZU9wdGlvbmFsVHlwZTtcbmV4cG9ydHMuYXJyYXlPZiA9IGFycmF5T2Y7XG5leHBvcnRzLmFycmF5T2ZUeXBlID0gYXJyYXlPZlR5cGU7XG5leHBvcnRzLnZhbGlkYXRlQXJyYXlPZlR5cGUgPSB2YWxpZGF0ZUFycmF5T2ZUeXBlO1xuZXhwb3J0cy5hc3NlcnRFYWNoID0gYXNzZXJ0RWFjaDtcbmV4cG9ydHMuYXNzZXJ0T25lT2YgPSBhc3NlcnRPbmVPZjtcbmV4cG9ydHMuYXNzZXJ0Tm9kZVR5cGUgPSBhc3NlcnROb2RlVHlwZTtcbmV4cG9ydHMuYXNzZXJ0Tm9kZU9yVmFsdWVUeXBlID0gYXNzZXJ0Tm9kZU9yVmFsdWVUeXBlO1xuZXhwb3J0cy5hc3NlcnRWYWx1ZVR5cGUgPSBhc3NlcnRWYWx1ZVR5cGU7XG5leHBvcnRzLmFzc2VydFNoYXBlID0gYXNzZXJ0U2hhcGU7XG5leHBvcnRzLmFzc2VydE9wdGlvbmFsQ2hhaW5TdGFydCA9IGFzc2VydE9wdGlvbmFsQ2hhaW5TdGFydDtcbmV4cG9ydHMuY2hhaW4gPSBjaGFpbjtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZmluZVR5cGU7XG5leHBvcnRzLk5PREVfUEFSRU5UX1ZBTElEQVRJT05TID0gZXhwb3J0cy5ERVBSRUNBVEVEX0tFWVMgPSBleHBvcnRzLkJVSUxERVJfS0VZUyA9IGV4cG9ydHMuTk9ERV9GSUVMRFMgPSBleHBvcnRzLkZMSVBQRURfQUxJQVNfS0VZUyA9IGV4cG9ydHMuQUxJQVNfS0VZUyA9IGV4cG9ydHMuVklTSVRPUl9LRVlTID0gdm9pZCAwO1xuXG52YXIgX2lzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vdmFsaWRhdG9ycy9pc1wiKSk7XG5cbnZhciBfdmFsaWRhdGUgPSByZXF1aXJlKFwiLi4vdmFsaWRhdG9ycy92YWxpZGF0ZVwiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuY29uc3QgVklTSVRPUl9LRVlTID0ge307XG5leHBvcnRzLlZJU0lUT1JfS0VZUyA9IFZJU0lUT1JfS0VZUztcbmNvbnN0IEFMSUFTX0tFWVMgPSB7fTtcbmV4cG9ydHMuQUxJQVNfS0VZUyA9IEFMSUFTX0tFWVM7XG5jb25zdCBGTElQUEVEX0FMSUFTX0tFWVMgPSB7fTtcbmV4cG9ydHMuRkxJUFBFRF9BTElBU19LRVlTID0gRkxJUFBFRF9BTElBU19LRVlTO1xuY29uc3QgTk9ERV9GSUVMRFMgPSB7fTtcbmV4cG9ydHMuTk9ERV9GSUVMRFMgPSBOT0RFX0ZJRUxEUztcbmNvbnN0IEJVSUxERVJfS0VZUyA9IHt9O1xuZXhwb3J0cy5CVUlMREVSX0tFWVMgPSBCVUlMREVSX0tFWVM7XG5jb25zdCBERVBSRUNBVEVEX0tFWVMgPSB7fTtcbmV4cG9ydHMuREVQUkVDQVRFRF9LRVlTID0gREVQUkVDQVRFRF9LRVlTO1xuY29uc3QgTk9ERV9QQVJFTlRfVkFMSURBVElPTlMgPSB7fTtcbmV4cG9ydHMuTk9ERV9QQVJFTlRfVkFMSURBVElPTlMgPSBOT0RFX1BBUkVOVF9WQUxJREFUSU9OUztcblxuZnVuY3Rpb24gZ2V0VHlwZSh2YWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIHJldHVybiBcImFycmF5XCI7XG4gIH0gZWxzZSBpZiAodmFsID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFwibnVsbFwiO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0eXBlb2YgdmFsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlKHZhbGlkYXRlKSB7XG4gIHJldHVybiB7XG4gICAgdmFsaWRhdGVcbiAgfTtcbn1cblxuZnVuY3Rpb24gdHlwZUlzKHR5cGVOYW1lKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZU5hbWUgPT09IFwic3RyaW5nXCIgPyBhc3NlcnROb2RlVHlwZSh0eXBlTmFtZSkgOiBhc3NlcnROb2RlVHlwZSguLi50eXBlTmFtZSk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVHlwZSh0eXBlTmFtZSkge1xuICByZXR1cm4gdmFsaWRhdGUodHlwZUlzKHR5cGVOYW1lKSk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlT3B0aW9uYWwodmFsaWRhdGUpIHtcbiAgcmV0dXJuIHtcbiAgICB2YWxpZGF0ZSxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9O1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU9wdGlvbmFsVHlwZSh0eXBlTmFtZSkge1xuICByZXR1cm4ge1xuICAgIHZhbGlkYXRlOiB0eXBlSXModHlwZU5hbWUpLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGFycmF5T2YoZWxlbWVudFR5cGUpIHtcbiAgcmV0dXJuIGNoYWluKGFzc2VydFZhbHVlVHlwZShcImFycmF5XCIpLCBhc3NlcnRFYWNoKGVsZW1lbnRUeXBlKSk7XG59XG5cbmZ1bmN0aW9uIGFycmF5T2ZUeXBlKHR5cGVOYW1lKSB7XG4gIHJldHVybiBhcnJheU9mKHR5cGVJcyh0eXBlTmFtZSkpO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUFycmF5T2ZUeXBlKHR5cGVOYW1lKSB7XG4gIHJldHVybiB2YWxpZGF0ZShhcnJheU9mVHlwZSh0eXBlTmFtZSkpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRFYWNoKGNhbGxiYWNrKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRvcihub2RlLCBrZXksIHZhbCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWwpKSByZXR1cm47XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc3Via2V5ID0gYCR7a2V5fVske2l9XWA7XG4gICAgICBjb25zdCB2ID0gdmFsW2ldO1xuICAgICAgY2FsbGJhY2sobm9kZSwgc3Via2V5LCB2KTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HKSAoMCwgX3ZhbGlkYXRlLnZhbGlkYXRlQ2hpbGQpKG5vZGUsIHN1YmtleSwgdik7XG4gICAgfVxuICB9XG5cbiAgdmFsaWRhdG9yLmVhY2ggPSBjYWxsYmFjaztcbiAgcmV0dXJuIHZhbGlkYXRvcjtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0T25lT2YoLi4udmFsdWVzKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgaWYgKHZhbHVlcy5pbmRleE9mKHZhbCkgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQcm9wZXJ0eSAke2tleX0gZXhwZWN0ZWQgdmFsdWUgdG8gYmUgb25lIG9mICR7SlNPTi5zdHJpbmdpZnkodmFsdWVzKX0gYnV0IGdvdCAke0pTT04uc3RyaW5naWZ5KHZhbCl9YCk7XG4gICAgfVxuICB9XG5cbiAgdmFsaWRhdGUub25lT2YgPSB2YWx1ZXM7XG4gIHJldHVybiB2YWxpZGF0ZTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Tm9kZVR5cGUoLi4udHlwZXMpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUobm9kZSwga2V5LCB2YWwpIHtcbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgdHlwZXMpIHtcbiAgICAgIGlmICgoMCwgX2lzLmRlZmF1bHQpKHR5cGUsIHZhbCkpIHtcbiAgICAgICAgKDAsIF92YWxpZGF0ZS52YWxpZGF0ZUNoaWxkKShub2RlLCBrZXksIHZhbCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQcm9wZXJ0eSAke2tleX0gb2YgJHtub2RlLnR5cGV9IGV4cGVjdGVkIG5vZGUgdG8gYmUgb2YgYSB0eXBlICR7SlNPTi5zdHJpbmdpZnkodHlwZXMpfSBidXQgaW5zdGVhZCBnb3QgJHtKU09OLnN0cmluZ2lmeSh2YWwgPT0gbnVsbCA/IHZvaWQgMCA6IHZhbC50eXBlKX1gKTtcbiAgfVxuXG4gIHZhbGlkYXRlLm9uZU9mTm9kZVR5cGVzID0gdHlwZXM7XG4gIHJldHVybiB2YWxpZGF0ZTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Tm9kZU9yVmFsdWVUeXBlKC4uLnR5cGVzKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgZm9yIChjb25zdCB0eXBlIG9mIHR5cGVzKSB7XG4gICAgICBpZiAoZ2V0VHlwZSh2YWwpID09PSB0eXBlIHx8ICgwLCBfaXMuZGVmYXVsdCkodHlwZSwgdmFsKSkge1xuICAgICAgICAoMCwgX3ZhbGlkYXRlLnZhbGlkYXRlQ2hpbGQpKG5vZGUsIGtleSwgdmFsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFByb3BlcnR5ICR7a2V5fSBvZiAke25vZGUudHlwZX0gZXhwZWN0ZWQgbm9kZSB0byBiZSBvZiBhIHR5cGUgJHtKU09OLnN0cmluZ2lmeSh0eXBlcyl9IGJ1dCBpbnN0ZWFkIGdvdCAke0pTT04uc3RyaW5naWZ5KHZhbCA9PSBudWxsID8gdm9pZCAwIDogdmFsLnR5cGUpfWApO1xuICB9XG5cbiAgdmFsaWRhdGUub25lT2ZOb2RlT3JWYWx1ZVR5cGVzID0gdHlwZXM7XG4gIHJldHVybiB2YWxpZGF0ZTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VmFsdWVUeXBlKHR5cGUpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUobm9kZSwga2V5LCB2YWwpIHtcbiAgICBjb25zdCB2YWxpZCA9IGdldFR5cGUodmFsKSA9PT0gdHlwZTtcblxuICAgIGlmICghdmFsaWQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFByb3BlcnR5ICR7a2V5fSBleHBlY3RlZCB0eXBlIG9mICR7dHlwZX0gYnV0IGdvdCAke2dldFR5cGUodmFsKX1gKTtcbiAgICB9XG4gIH1cblxuICB2YWxpZGF0ZS50eXBlID0gdHlwZTtcbiAgcmV0dXJuIHZhbGlkYXRlO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRTaGFwZShzaGFwZSkge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShub2RlLCBrZXksIHZhbCkge1xuICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBPYmplY3Qua2V5cyhzaGFwZSkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgICgwLCBfdmFsaWRhdGUudmFsaWRhdGVGaWVsZCkobm9kZSwgcHJvcGVydHksIHZhbFtwcm9wZXJ0eV0sIHNoYXBlW3Byb3BlcnR5XSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQcm9wZXJ0eSAke2tleX0gb2YgJHtub2RlLnR5cGV9IGV4cGVjdGVkIHRvIGhhdmUgdGhlIGZvbGxvd2luZzpcXG4ke2Vycm9ycy5qb2luKFwiXFxuXCIpfWApO1xuICAgIH1cbiAgfVxuXG4gIHZhbGlkYXRlLnNoYXBlT2YgPSBzaGFwZTtcbiAgcmV0dXJuIHZhbGlkYXRlO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRPcHRpb25hbENoYWluU3RhcnQoKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKG5vZGUpIHtcbiAgICB2YXIgX2N1cnJlbnQ7XG5cbiAgICBsZXQgY3VycmVudCA9IG5vZGU7XG5cbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB0eXBlXG4gICAgICB9ID0gY3VycmVudDtcblxuICAgICAgaWYgKHR5cGUgPT09IFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiKSB7XG4gICAgICAgIGlmIChjdXJyZW50Lm9wdGlvbmFsKSByZXR1cm47XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmNhbGxlZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlID09PSBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiKSB7XG4gICAgICAgIGlmIChjdXJyZW50Lm9wdGlvbmFsKSByZXR1cm47XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm9iamVjdDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vbi1vcHRpb25hbCAke25vZGUudHlwZX0gbXVzdCBjaGFpbiBmcm9tIGFuIG9wdGlvbmFsIE9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbiBvciBPcHRpb25hbENhbGxFeHByZXNzaW9uLiBGb3VuZCBjaGFpbiBmcm9tICR7KF9jdXJyZW50ID0gY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jdXJyZW50LnR5cGV9YCk7XG4gIH1cblxuICByZXR1cm4gdmFsaWRhdGU7XG59XG5cbmZ1bmN0aW9uIGNoYWluKC4uLmZucykge1xuICBmdW5jdGlvbiB2YWxpZGF0ZSguLi5hcmdzKSB7XG4gICAgZm9yIChjb25zdCBmbiBvZiBmbnMpIHtcbiAgICAgIGZuKC4uLmFyZ3MpO1xuICAgIH1cbiAgfVxuXG4gIHZhbGlkYXRlLmNoYWluT2YgPSBmbnM7XG4gIHJldHVybiB2YWxpZGF0ZTtcbn1cblxuY29uc3QgdmFsaWRUeXBlT3B0cyA9IFtcImFsaWFzZXNcIiwgXCJidWlsZGVyXCIsIFwiZGVwcmVjYXRlZEFsaWFzXCIsIFwiZmllbGRzXCIsIFwiaW5oZXJpdHNcIiwgXCJ2aXNpdG9yXCIsIFwidmFsaWRhdGVcIl07XG5jb25zdCB2YWxpZEZpZWxkS2V5cyA9IFtcImRlZmF1bHRcIiwgXCJvcHRpb25hbFwiLCBcInZhbGlkYXRlXCJdO1xuXG5mdW5jdGlvbiBkZWZpbmVUeXBlKHR5cGUsIG9wdHMgPSB7fSkge1xuICBjb25zdCBpbmhlcml0cyA9IG9wdHMuaW5oZXJpdHMgJiYgc3RvcmVbb3B0cy5pbmhlcml0c10gfHwge307XG4gIGxldCBmaWVsZHMgPSBvcHRzLmZpZWxkcztcblxuICBpZiAoIWZpZWxkcykge1xuICAgIGZpZWxkcyA9IHt9O1xuXG4gICAgaWYgKGluaGVyaXRzLmZpZWxkcykge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGluaGVyaXRzLmZpZWxkcyk7XG5cbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgY29uc3QgZmllbGQgPSBpbmhlcml0cy5maWVsZHNba2V5XTtcbiAgICAgICAgZmllbGRzW2tleV0gPSB7XG4gICAgICAgICAgZGVmYXVsdDogZmllbGQuZGVmYXVsdCxcbiAgICAgICAgICBvcHRpb25hbDogZmllbGQub3B0aW9uYWwsXG4gICAgICAgICAgdmFsaWRhdGU6IGZpZWxkLnZhbGlkYXRlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgdmlzaXRvciA9IG9wdHMudmlzaXRvciB8fCBpbmhlcml0cy52aXNpdG9yIHx8IFtdO1xuICBjb25zdCBhbGlhc2VzID0gb3B0cy5hbGlhc2VzIHx8IGluaGVyaXRzLmFsaWFzZXMgfHwgW107XG4gIGNvbnN0IGJ1aWxkZXIgPSBvcHRzLmJ1aWxkZXIgfHwgaW5oZXJpdHMuYnVpbGRlciB8fCBvcHRzLnZpc2l0b3IgfHwgW107XG5cbiAgZm9yIChjb25zdCBrIG9mIE9iamVjdC5rZXlzKG9wdHMpKSB7XG4gICAgaWYgKHZhbGlkVHlwZU9wdHMuaW5kZXhPZihrKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biB0eXBlIG9wdGlvbiBcIiR7a31cIiBvbiAke3R5cGV9YCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdHMuZGVwcmVjYXRlZEFsaWFzKSB7XG4gICAgREVQUkVDQVRFRF9LRVlTW29wdHMuZGVwcmVjYXRlZEFsaWFzXSA9IHR5cGU7XG4gIH1cblxuICBmb3IgKGNvbnN0IGtleSBvZiB2aXNpdG9yLmNvbmNhdChidWlsZGVyKSkge1xuICAgIGZpZWxkc1trZXldID0gZmllbGRzW2tleV0gfHwge307XG4gIH1cblxuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhmaWVsZHMpKSB7XG4gICAgY29uc3QgZmllbGQgPSBmaWVsZHNba2V5XTtcblxuICAgIGlmIChmaWVsZC5kZWZhdWx0ICE9PSB1bmRlZmluZWQgJiYgYnVpbGRlci5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICBmaWVsZC5vcHRpb25hbCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGZpZWxkLmRlZmF1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZmllbGQuZGVmYXVsdCA9IG51bGw7XG4gICAgfSBlbHNlIGlmICghZmllbGQudmFsaWRhdGUgJiYgZmllbGQuZGVmYXVsdCAhPSBudWxsKSB7XG4gICAgICBmaWVsZC52YWxpZGF0ZSA9IGFzc2VydFZhbHVlVHlwZShnZXRUeXBlKGZpZWxkLmRlZmF1bHQpKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXMoZmllbGQpKSB7XG4gICAgICBpZiAodmFsaWRGaWVsZEtleXMuaW5kZXhPZihrKSA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGZpZWxkIGtleSBcIiR7a31cIiBvbiAke3R5cGV9LiR7a2V5fWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIFZJU0lUT1JfS0VZU1t0eXBlXSA9IG9wdHMudmlzaXRvciA9IHZpc2l0b3I7XG4gIEJVSUxERVJfS0VZU1t0eXBlXSA9IG9wdHMuYnVpbGRlciA9IGJ1aWxkZXI7XG4gIE5PREVfRklFTERTW3R5cGVdID0gb3B0cy5maWVsZHMgPSBmaWVsZHM7XG4gIEFMSUFTX0tFWVNbdHlwZV0gPSBvcHRzLmFsaWFzZXMgPSBhbGlhc2VzO1xuICBhbGlhc2VzLmZvckVhY2goYWxpYXMgPT4ge1xuICAgIEZMSVBQRURfQUxJQVNfS0VZU1thbGlhc10gPSBGTElQUEVEX0FMSUFTX0tFWVNbYWxpYXNdIHx8IFtdO1xuICAgIEZMSVBQRURfQUxJQVNfS0VZU1thbGlhc10ucHVzaCh0eXBlKTtcbiAgfSk7XG5cbiAgaWYgKG9wdHMudmFsaWRhdGUpIHtcbiAgICBOT0RFX1BBUkVOVF9WQUxJREFUSU9OU1t0eXBlXSA9IG9wdHMudmFsaWRhdGU7XG4gIH1cblxuICBzdG9yZVt0eXBlXSA9IG9wdHM7XG59XG5cbmNvbnN0IHN0b3JlID0ge307IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgX2V4cG9ydE5hbWVzID0ge1xuICByZWFjdDogdHJ1ZSxcbiAgYXNzZXJ0Tm9kZTogdHJ1ZSxcbiAgY3JlYXRlVHlwZUFubm90YXRpb25CYXNlZE9uVHlwZW9mOiB0cnVlLFxuICBjcmVhdGVVbmlvblR5cGVBbm5vdGF0aW9uOiB0cnVlLFxuICBjcmVhdGVGbG93VW5pb25UeXBlOiB0cnVlLFxuICBjcmVhdGVUU1VuaW9uVHlwZTogdHJ1ZSxcbiAgY2xvbmVOb2RlOiB0cnVlLFxuICBjbG9uZTogdHJ1ZSxcbiAgY2xvbmVEZWVwOiB0cnVlLFxuICBjbG9uZURlZXBXaXRob3V0TG9jOiB0cnVlLFxuICBjbG9uZVdpdGhvdXRMb2M6IHRydWUsXG4gIGFkZENvbW1lbnQ6IHRydWUsXG4gIGFkZENvbW1lbnRzOiB0cnVlLFxuICBpbmhlcml0SW5uZXJDb21tZW50czogdHJ1ZSxcbiAgaW5oZXJpdExlYWRpbmdDb21tZW50czogdHJ1ZSxcbiAgaW5oZXJpdHNDb21tZW50czogdHJ1ZSxcbiAgaW5oZXJpdFRyYWlsaW5nQ29tbWVudHM6IHRydWUsXG4gIHJlbW92ZUNvbW1lbnRzOiB0cnVlLFxuICBlbnN1cmVCbG9jazogdHJ1ZSxcbiAgdG9CaW5kaW5nSWRlbnRpZmllck5hbWU6IHRydWUsXG4gIHRvQmxvY2s6IHRydWUsXG4gIHRvQ29tcHV0ZWRLZXk6IHRydWUsXG4gIHRvRXhwcmVzc2lvbjogdHJ1ZSxcbiAgdG9JZGVudGlmaWVyOiB0cnVlLFxuICB0b0tleUFsaWFzOiB0cnVlLFxuICB0b1NlcXVlbmNlRXhwcmVzc2lvbjogdHJ1ZSxcbiAgdG9TdGF0ZW1lbnQ6IHRydWUsXG4gIHZhbHVlVG9Ob2RlOiB0cnVlLFxuICBhcHBlbmRUb01lbWJlckV4cHJlc3Npb246IHRydWUsXG4gIGluaGVyaXRzOiB0cnVlLFxuICBwcmVwZW5kVG9NZW1iZXJFeHByZXNzaW9uOiB0cnVlLFxuICByZW1vdmVQcm9wZXJ0aWVzOiB0cnVlLFxuICByZW1vdmVQcm9wZXJ0aWVzRGVlcDogdHJ1ZSxcbiAgcmVtb3ZlVHlwZUR1cGxpY2F0ZXM6IHRydWUsXG4gIGdldEJpbmRpbmdJZGVudGlmaWVyczogdHJ1ZSxcbiAgZ2V0T3V0ZXJCaW5kaW5nSWRlbnRpZmllcnM6IHRydWUsXG4gIHRyYXZlcnNlOiB0cnVlLFxuICB0cmF2ZXJzZUZhc3Q6IHRydWUsXG4gIHNoYWxsb3dFcXVhbDogdHJ1ZSxcbiAgaXM6IHRydWUsXG4gIGlzQmluZGluZzogdHJ1ZSxcbiAgaXNCbG9ja1Njb3BlZDogdHJ1ZSxcbiAgaXNJbW11dGFibGU6IHRydWUsXG4gIGlzTGV0OiB0cnVlLFxuICBpc05vZGU6IHRydWUsXG4gIGlzTm9kZXNFcXVpdmFsZW50OiB0cnVlLFxuICBpc1BsYWNlaG9sZGVyVHlwZTogdHJ1ZSxcbiAgaXNSZWZlcmVuY2VkOiB0cnVlLFxuICBpc1Njb3BlOiB0cnVlLFxuICBpc1NwZWNpZmllckRlZmF1bHQ6IHRydWUsXG4gIGlzVHlwZTogdHJ1ZSxcbiAgaXNWYWxpZEVTM0lkZW50aWZpZXI6IHRydWUsXG4gIGlzVmFsaWRJZGVudGlmaWVyOiB0cnVlLFxuICBpc1ZhcjogdHJ1ZSxcbiAgbWF0Y2hlc1BhdHRlcm46IHRydWUsXG4gIHZhbGlkYXRlOiB0cnVlLFxuICBidWlsZE1hdGNoTWVtYmVyRXhwcmVzc2lvbjogdHJ1ZVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFzc2VydE5vZGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Fzc2VydE5vZGUuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVUeXBlQW5ub3RhdGlvbkJhc2VkT25UeXBlb2ZcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2NyZWF0ZVR5cGVBbm5vdGF0aW9uQmFzZWRPblR5cGVvZi5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZVVuaW9uVHlwZUFubm90YXRpb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2NyZWF0ZUZsb3dVbmlvblR5cGUuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVGbG93VW5pb25UeXBlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9jcmVhdGVGbG93VW5pb25UeXBlLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlVFNVbmlvblR5cGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2NyZWF0ZVRTVW5pb25UeXBlLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY2xvbmVOb2RlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9jbG9uZU5vZGUuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjbG9uZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfY2xvbmUuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjbG9uZURlZXBcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Nsb25lRGVlcC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNsb25lRGVlcFdpdGhvdXRMb2NcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Nsb25lRGVlcFdpdGhvdXRMb2MuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjbG9uZVdpdGhvdXRMb2NcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Nsb25lV2l0aG91dExvYy5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFkZENvbW1lbnRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2FkZENvbW1lbnQuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhZGRDb21tZW50c1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfYWRkQ29tbWVudHMuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpbmhlcml0SW5uZXJDb21tZW50c1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5oZXJpdElubmVyQ29tbWVudHMuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpbmhlcml0TGVhZGluZ0NvbW1lbnRzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmhlcml0TGVhZGluZ0NvbW1lbnRzLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaW5oZXJpdHNDb21tZW50c1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5oZXJpdHNDb21tZW50cy5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImluaGVyaXRUcmFpbGluZ0NvbW1lbnRzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmhlcml0VHJhaWxpbmdDb21tZW50cy5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlbW92ZUNvbW1lbnRzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9yZW1vdmVDb21tZW50cy5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuc3VyZUJsb2NrXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9lbnN1cmVCbG9jay5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvQmluZGluZ0lkZW50aWZpZXJOYW1lXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF90b0JpbmRpbmdJZGVudGlmaWVyTmFtZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvQmxvY2tcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3RvQmxvY2suZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b0NvbXB1dGVkS2V5XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF90b0NvbXB1dGVkS2V5LmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9FeHByZXNzaW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF90b0V4cHJlc3Npb24uZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b0lkZW50aWZpZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3RvSWRlbnRpZmllci5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvS2V5QWxpYXNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3RvS2V5QWxpYXMuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b1NlcXVlbmNlRXhwcmVzc2lvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdG9TZXF1ZW5jZUV4cHJlc3Npb24uZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b1N0YXRlbWVudFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdG9TdGF0ZW1lbnQuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2YWx1ZVRvTm9kZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdmFsdWVUb05vZGUuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhcHBlbmRUb01lbWJlckV4cHJlc3Npb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2FwcGVuZFRvTWVtYmVyRXhwcmVzc2lvbi5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImluaGVyaXRzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmhlcml0cy5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInByZXBlbmRUb01lbWJlckV4cHJlc3Npb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3ByZXBlbmRUb01lbWJlckV4cHJlc3Npb24uZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZW1vdmVQcm9wZXJ0aWVzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9yZW1vdmVQcm9wZXJ0aWVzLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVtb3ZlUHJvcGVydGllc0RlZXBcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3JlbW92ZVByb3BlcnRpZXNEZWVwLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVtb3ZlVHlwZUR1cGxpY2F0ZXNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3JlbW92ZVR5cGVEdXBsaWNhdGVzLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0QmluZGluZ0lkZW50aWZpZXJzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9nZXRCaW5kaW5nSWRlbnRpZmllcnMuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRPdXRlckJpbmRpbmdJZGVudGlmaWVyc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfZ2V0T3V0ZXJCaW5kaW5nSWRlbnRpZmllcnMuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0cmF2ZXJzZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdHJhdmVyc2UuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0cmF2ZXJzZUZhc3RcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3RyYXZlcnNlRmFzdC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNoYWxsb3dFcXVhbFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfc2hhbGxvd0VxdWFsLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2lzLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNCaW5kaW5nXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pc0JpbmRpbmcuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0Jsb2NrU2NvcGVkXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pc0Jsb2NrU2NvcGVkLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNJbW11dGFibGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2lzSW1tdXRhYmxlLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNMZXRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2lzTGV0LmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNOb2RlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pc05vZGUuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc05vZGVzRXF1aXZhbGVudFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaXNOb2Rlc0VxdWl2YWxlbnQuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1BsYWNlaG9sZGVyVHlwZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaXNQbGFjZWhvbGRlclR5cGUuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1JlZmVyZW5jZWRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2lzUmVmZXJlbmNlZC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzU2NvcGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2lzU2NvcGUuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1NwZWNpZmllckRlZmF1bHRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2lzU3BlY2lmaWVyRGVmYXVsdC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzVHlwZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaXNUeXBlLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNWYWxpZEVTM0lkZW50aWZpZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2lzVmFsaWRFUzNJZGVudGlmaWVyLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNWYWxpZElkZW50aWZpZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2lzVmFsaWRJZGVudGlmaWVyLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNWYXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2lzVmFyLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibWF0Y2hlc1BhdHRlcm5cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX21hdGNoZXNQYXR0ZXJuLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidmFsaWRhdGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3ZhbGlkYXRlLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYnVpbGRNYXRjaE1lbWJlckV4cHJlc3Npb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2J1aWxkTWF0Y2hNZW1iZXJFeHByZXNzaW9uLmRlZmF1bHQ7XG4gIH1cbn0pO1xuZXhwb3J0cy5yZWFjdCA9IHZvaWQgMDtcblxudmFyIF9pc1JlYWN0Q29tcG9uZW50ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92YWxpZGF0b3JzL3JlYWN0L2lzUmVhY3RDb21wb25lbnRcIikpO1xuXG52YXIgX2lzQ29tcGF0VGFnID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92YWxpZGF0b3JzL3JlYWN0L2lzQ29tcGF0VGFnXCIpKTtcblxudmFyIF9idWlsZENoaWxkcmVuID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9idWlsZGVycy9yZWFjdC9idWlsZENoaWxkcmVuXCIpKTtcblxudmFyIF9hc3NlcnROb2RlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9hc3NlcnRzL2Fzc2VydE5vZGVcIikpO1xuXG52YXIgX2dlbmVyYXRlZCA9IHJlcXVpcmUoXCIuL2Fzc2VydHMvZ2VuZXJhdGVkXCIpO1xuXG5PYmplY3Qua2V5cyhfZ2VuZXJhdGVkKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9leHBvcnROYW1lcywga2V5KSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfZ2VuZXJhdGVkW2tleV07XG4gICAgfVxuICB9KTtcbn0pO1xuXG52YXIgX2NyZWF0ZVR5cGVBbm5vdGF0aW9uQmFzZWRPblR5cGVvZiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vYnVpbGRlcnMvZmxvdy9jcmVhdGVUeXBlQW5ub3RhdGlvbkJhc2VkT25UeXBlb2ZcIikpO1xuXG52YXIgX2NyZWF0ZUZsb3dVbmlvblR5cGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2J1aWxkZXJzL2Zsb3cvY3JlYXRlRmxvd1VuaW9uVHlwZVwiKSk7XG5cbnZhciBfY3JlYXRlVFNVbmlvblR5cGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2J1aWxkZXJzL3R5cGVzY3JpcHQvY3JlYXRlVFNVbmlvblR5cGVcIikpO1xuXG52YXIgX2dlbmVyYXRlZDIgPSByZXF1aXJlKFwiLi9idWlsZGVycy9nZW5lcmF0ZWRcIik7XG5cbk9iamVjdC5rZXlzKF9nZW5lcmF0ZWQyKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9leHBvcnROYW1lcywga2V5KSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfZ2VuZXJhdGVkMltrZXldO1xuICAgIH1cbiAgfSk7XG59KTtcblxudmFyIF9jbG9uZU5vZGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Nsb25lL2Nsb25lTm9kZVwiKSk7XG5cbnZhciBfY2xvbmUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Nsb25lL2Nsb25lXCIpKTtcblxudmFyIF9jbG9uZURlZXAgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Nsb25lL2Nsb25lRGVlcFwiKSk7XG5cbnZhciBfY2xvbmVEZWVwV2l0aG91dExvYyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY2xvbmUvY2xvbmVEZWVwV2l0aG91dExvY1wiKSk7XG5cbnZhciBfY2xvbmVXaXRob3V0TG9jID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jbG9uZS9jbG9uZVdpdGhvdXRMb2NcIikpO1xuXG52YXIgX2FkZENvbW1lbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NvbW1lbnRzL2FkZENvbW1lbnRcIikpO1xuXG52YXIgX2FkZENvbW1lbnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jb21tZW50cy9hZGRDb21tZW50c1wiKSk7XG5cbnZhciBfaW5oZXJpdElubmVyQ29tbWVudHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NvbW1lbnRzL2luaGVyaXRJbm5lckNvbW1lbnRzXCIpKTtcblxudmFyIF9pbmhlcml0TGVhZGluZ0NvbW1lbnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jb21tZW50cy9pbmhlcml0TGVhZGluZ0NvbW1lbnRzXCIpKTtcblxudmFyIF9pbmhlcml0c0NvbW1lbnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jb21tZW50cy9pbmhlcml0c0NvbW1lbnRzXCIpKTtcblxudmFyIF9pbmhlcml0VHJhaWxpbmdDb21tZW50cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY29tbWVudHMvaW5oZXJpdFRyYWlsaW5nQ29tbWVudHNcIikpO1xuXG52YXIgX3JlbW92ZUNvbW1lbnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jb21tZW50cy9yZW1vdmVDb21tZW50c1wiKSk7XG5cbnZhciBfZ2VuZXJhdGVkMyA9IHJlcXVpcmUoXCIuL2NvbnN0YW50cy9nZW5lcmF0ZWRcIik7XG5cbk9iamVjdC5rZXlzKF9nZW5lcmF0ZWQzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9leHBvcnROYW1lcywga2V5KSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfZ2VuZXJhdGVkM1trZXldO1xuICAgIH1cbiAgfSk7XG59KTtcblxudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5cbk9iamVjdC5rZXlzKF9jb25zdGFudHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX2V4cG9ydE5hbWVzLCBrZXkpKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9jb25zdGFudHNba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbnZhciBfZW5zdXJlQmxvY2sgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NvbnZlcnRlcnMvZW5zdXJlQmxvY2tcIikpO1xuXG52YXIgX3RvQmluZGluZ0lkZW50aWZpZXJOYW1lID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jb252ZXJ0ZXJzL3RvQmluZGluZ0lkZW50aWZpZXJOYW1lXCIpKTtcblxudmFyIF90b0Jsb2NrID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jb252ZXJ0ZXJzL3RvQmxvY2tcIikpO1xuXG52YXIgX3RvQ29tcHV0ZWRLZXkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NvbnZlcnRlcnMvdG9Db21wdXRlZEtleVwiKSk7XG5cbnZhciBfdG9FeHByZXNzaW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jb252ZXJ0ZXJzL3RvRXhwcmVzc2lvblwiKSk7XG5cbnZhciBfdG9JZGVudGlmaWVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jb252ZXJ0ZXJzL3RvSWRlbnRpZmllclwiKSk7XG5cbnZhciBfdG9LZXlBbGlhcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY29udmVydGVycy90b0tleUFsaWFzXCIpKTtcblxudmFyIF90b1NlcXVlbmNlRXhwcmVzc2lvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY29udmVydGVycy90b1NlcXVlbmNlRXhwcmVzc2lvblwiKSk7XG5cbnZhciBfdG9TdGF0ZW1lbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NvbnZlcnRlcnMvdG9TdGF0ZW1lbnRcIikpO1xuXG52YXIgX3ZhbHVlVG9Ob2RlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jb252ZXJ0ZXJzL3ZhbHVlVG9Ob2RlXCIpKTtcblxudmFyIF9kZWZpbml0aW9ucyA9IHJlcXVpcmUoXCIuL2RlZmluaXRpb25zXCIpO1xuXG5PYmplY3Qua2V5cyhfZGVmaW5pdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX2V4cG9ydE5hbWVzLCBrZXkpKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9kZWZpbml0aW9uc1trZXldO1xuICAgIH1cbiAgfSk7XG59KTtcblxudmFyIF9hcHBlbmRUb01lbWJlckV4cHJlc3Npb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL21vZGlmaWNhdGlvbnMvYXBwZW5kVG9NZW1iZXJFeHByZXNzaW9uXCIpKTtcblxudmFyIF9pbmhlcml0cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbW9kaWZpY2F0aW9ucy9pbmhlcml0c1wiKSk7XG5cbnZhciBfcHJlcGVuZFRvTWVtYmVyRXhwcmVzc2lvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbW9kaWZpY2F0aW9ucy9wcmVwZW5kVG9NZW1iZXJFeHByZXNzaW9uXCIpKTtcblxudmFyIF9yZW1vdmVQcm9wZXJ0aWVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9tb2RpZmljYXRpb25zL3JlbW92ZVByb3BlcnRpZXNcIikpO1xuXG52YXIgX3JlbW92ZVByb3BlcnRpZXNEZWVwID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9tb2RpZmljYXRpb25zL3JlbW92ZVByb3BlcnRpZXNEZWVwXCIpKTtcblxudmFyIF9yZW1vdmVUeXBlRHVwbGljYXRlcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vbW9kaWZpY2F0aW9ucy9mbG93L3JlbW92ZVR5cGVEdXBsaWNhdGVzXCIpKTtcblxudmFyIF9nZXRCaW5kaW5nSWRlbnRpZmllcnMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3JldHJpZXZlcnMvZ2V0QmluZGluZ0lkZW50aWZpZXJzXCIpKTtcblxudmFyIF9nZXRPdXRlckJpbmRpbmdJZGVudGlmaWVycyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcmV0cmlldmVycy9nZXRPdXRlckJpbmRpbmdJZGVudGlmaWVyc1wiKSk7XG5cbnZhciBfdHJhdmVyc2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3RyYXZlcnNlL3RyYXZlcnNlXCIpKTtcblxudmFyIF90cmF2ZXJzZUZhc3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3RyYXZlcnNlL3RyYXZlcnNlRmFzdFwiKSk7XG5cbnZhciBfc2hhbGxvd0VxdWFsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91dGlscy9zaGFsbG93RXF1YWxcIikpO1xuXG52YXIgX2lzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92YWxpZGF0b3JzL2lzXCIpKTtcblxudmFyIF9pc0JpbmRpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvaXNCaW5kaW5nXCIpKTtcblxudmFyIF9pc0Jsb2NrU2NvcGVkID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92YWxpZGF0b3JzL2lzQmxvY2tTY29wZWRcIikpO1xuXG52YXIgX2lzSW1tdXRhYmxlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92YWxpZGF0b3JzL2lzSW1tdXRhYmxlXCIpKTtcblxudmFyIF9pc0xldCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdmFsaWRhdG9ycy9pc0xldFwiKSk7XG5cbnZhciBfaXNOb2RlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92YWxpZGF0b3JzL2lzTm9kZVwiKSk7XG5cbnZhciBfaXNOb2Rlc0VxdWl2YWxlbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvaXNOb2Rlc0VxdWl2YWxlbnRcIikpO1xuXG52YXIgX2lzUGxhY2Vob2xkZXJUeXBlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92YWxpZGF0b3JzL2lzUGxhY2Vob2xkZXJUeXBlXCIpKTtcblxudmFyIF9pc1JlZmVyZW5jZWQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvaXNSZWZlcmVuY2VkXCIpKTtcblxudmFyIF9pc1Njb3BlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92YWxpZGF0b3JzL2lzU2NvcGVcIikpO1xuXG52YXIgX2lzU3BlY2lmaWVyRGVmYXVsdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdmFsaWRhdG9ycy9pc1NwZWNpZmllckRlZmF1bHRcIikpO1xuXG52YXIgX2lzVHlwZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdmFsaWRhdG9ycy9pc1R5cGVcIikpO1xuXG52YXIgX2lzVmFsaWRFUzNJZGVudGlmaWVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92YWxpZGF0b3JzL2lzVmFsaWRFUzNJZGVudGlmaWVyXCIpKTtcblxudmFyIF9pc1ZhbGlkSWRlbnRpZmllciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdmFsaWRhdG9ycy9pc1ZhbGlkSWRlbnRpZmllclwiKSk7XG5cbnZhciBfaXNWYXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvaXNWYXJcIikpO1xuXG52YXIgX21hdGNoZXNQYXR0ZXJuID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92YWxpZGF0b3JzL21hdGNoZXNQYXR0ZXJuXCIpKTtcblxudmFyIF92YWxpZGF0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdmFsaWRhdG9ycy92YWxpZGF0ZVwiKSk7XG5cbnZhciBfYnVpbGRNYXRjaE1lbWJlckV4cHJlc3Npb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvYnVpbGRNYXRjaE1lbWJlckV4cHJlc3Npb25cIikpO1xuXG52YXIgX2dlbmVyYXRlZDQgPSByZXF1aXJlKFwiLi92YWxpZGF0b3JzL2dlbmVyYXRlZFwiKTtcblxuT2JqZWN0LmtleXMoX2dlbmVyYXRlZDQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX2V4cG9ydE5hbWVzLCBrZXkpKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9nZW5lcmF0ZWQ0W2tleV07XG4gICAgfVxuICB9KTtcbn0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5jb25zdCByZWFjdCA9IHtcbiAgaXNSZWFjdENvbXBvbmVudDogX2lzUmVhY3RDb21wb25lbnQuZGVmYXVsdCxcbiAgaXNDb21wYXRUYWc6IF9pc0NvbXBhdFRhZy5kZWZhdWx0LFxuICBidWlsZENoaWxkcmVuOiBfYnVpbGRDaGlsZHJlbi5kZWZhdWx0XG59O1xuZXhwb3J0cy5yZWFjdCA9IHJlYWN0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gYXBwZW5kVG9NZW1iZXJFeHByZXNzaW9uO1xuXG52YXIgX2dlbmVyYXRlZCA9IHJlcXVpcmUoXCIuLi9idWlsZGVycy9nZW5lcmF0ZWRcIik7XG5cbmZ1bmN0aW9uIGFwcGVuZFRvTWVtYmVyRXhwcmVzc2lvbihtZW1iZXIsIGFwcGVuZCwgY29tcHV0ZWQgPSBmYWxzZSkge1xuICBtZW1iZXIub2JqZWN0ID0gKDAsIF9nZW5lcmF0ZWQubWVtYmVyRXhwcmVzc2lvbikobWVtYmVyLm9iamVjdCwgbWVtYmVyLnByb3BlcnR5LCBtZW1iZXIuY29tcHV0ZWQpO1xuICBtZW1iZXIucHJvcGVydHkgPSBhcHBlbmQ7XG4gIG1lbWJlci5jb21wdXRlZCA9ICEhY29tcHV0ZWQ7XG4gIHJldHVybiBtZW1iZXI7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSByZW1vdmVUeXBlRHVwbGljYXRlcztcblxudmFyIF9nZW5lcmF0ZWQgPSByZXF1aXJlKFwiLi4vLi4vdmFsaWRhdG9ycy9nZW5lcmF0ZWRcIik7XG5cbmZ1bmN0aW9uIHJlbW92ZVR5cGVEdXBsaWNhdGVzKG5vZGVzKSB7XG4gIGNvbnN0IGdlbmVyaWNzID0ge307XG4gIGNvbnN0IGJhc2VzID0ge307XG4gIGNvbnN0IHR5cGVHcm91cHMgPSBbXTtcbiAgY29uc3QgdHlwZXMgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGlmICghbm9kZSkgY29udGludWU7XG5cbiAgICBpZiAodHlwZXMuaW5kZXhPZihub2RlKSA+PSAwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNBbnlUeXBlQW5ub3RhdGlvbikobm9kZSkpIHtcbiAgICAgIHJldHVybiBbbm9kZV07XG4gICAgfVxuXG4gICAgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzRmxvd0Jhc2VBbm5vdGF0aW9uKShub2RlKSkge1xuICAgICAgYmFzZXNbbm9kZS50eXBlXSA9IG5vZGU7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNVbmlvblR5cGVBbm5vdGF0aW9uKShub2RlKSkge1xuICAgICAgaWYgKHR5cGVHcm91cHMuaW5kZXhPZihub2RlLnR5cGVzKSA8IDApIHtcbiAgICAgICAgbm9kZXMgPSBub2Rlcy5jb25jYXQobm9kZS50eXBlcyk7XG4gICAgICAgIHR5cGVHcm91cHMucHVzaChub2RlLnR5cGVzKTtcbiAgICAgIH1cblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzR2VuZXJpY1R5cGVBbm5vdGF0aW9uKShub2RlKSkge1xuICAgICAgY29uc3QgbmFtZSA9IG5vZGUuaWQubmFtZTtcblxuICAgICAgaWYgKGdlbmVyaWNzW25hbWVdKSB7XG4gICAgICAgIGxldCBleGlzdGluZyA9IGdlbmVyaWNzW25hbWVdO1xuXG4gICAgICAgIGlmIChleGlzdGluZy50eXBlUGFyYW1ldGVycykge1xuICAgICAgICAgIGlmIChub2RlLnR5cGVQYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICBleGlzdGluZy50eXBlUGFyYW1ldGVycy5wYXJhbXMgPSByZW1vdmVUeXBlRHVwbGljYXRlcyhleGlzdGluZy50eXBlUGFyYW1ldGVycy5wYXJhbXMuY29uY2F0KG5vZGUudHlwZVBhcmFtZXRlcnMucGFyYW1zKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4aXN0aW5nID0gbm9kZS50eXBlUGFyYW1ldGVycztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2VuZXJpY3NbbmFtZV0gPSBub2RlO1xuICAgICAgfVxuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB0eXBlcy5wdXNoKG5vZGUpO1xuICB9XG5cbiAgZm9yIChjb25zdCB0eXBlIG9mIE9iamVjdC5rZXlzKGJhc2VzKSkge1xuICAgIHR5cGVzLnB1c2goYmFzZXNbdHlwZV0pO1xuICB9XG5cbiAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKGdlbmVyaWNzKSkge1xuICAgIHR5cGVzLnB1c2goZ2VuZXJpY3NbbmFtZV0pO1xuICB9XG5cbiAgcmV0dXJuIHR5cGVzO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaW5oZXJpdHM7XG5cbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcblxudmFyIF9pbmhlcml0c0NvbW1lbnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vY29tbWVudHMvaW5oZXJpdHNDb21tZW50c1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGluaGVyaXRzKGNoaWxkLCBwYXJlbnQpIHtcbiAgaWYgKCFjaGlsZCB8fCAhcGFyZW50KSByZXR1cm4gY2hpbGQ7XG5cbiAgZm9yIChjb25zdCBrZXkgb2YgX2NvbnN0YW50cy5JTkhFUklUX0tFWVMub3B0aW9uYWwpIHtcbiAgICBpZiAoY2hpbGRba2V5XSA9PSBudWxsKSB7XG4gICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG4gICAgfVxuICB9XG5cbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocGFyZW50KSkge1xuICAgIGlmIChrZXlbMF0gPT09IFwiX1wiICYmIGtleSAhPT0gXCJfX2Nsb25lXCIpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTtcbiAgfVxuXG4gIGZvciAoY29uc3Qga2V5IG9mIF9jb25zdGFudHMuSU5IRVJJVF9LRVlTLmZvcmNlKSB7XG4gICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xuICB9XG5cbiAgKDAsIF9pbmhlcml0c0NvbW1lbnRzLmRlZmF1bHQpKGNoaWxkLCBwYXJlbnQpO1xuICByZXR1cm4gY2hpbGQ7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBwcmVwZW5kVG9NZW1iZXJFeHByZXNzaW9uO1xuXG52YXIgX2dlbmVyYXRlZCA9IHJlcXVpcmUoXCIuLi9idWlsZGVycy9nZW5lcmF0ZWRcIik7XG5cbmZ1bmN0aW9uIHByZXBlbmRUb01lbWJlckV4cHJlc3Npb24obWVtYmVyLCBwcmVwZW5kKSB7XG4gIG1lbWJlci5vYmplY3QgPSAoMCwgX2dlbmVyYXRlZC5tZW1iZXJFeHByZXNzaW9uKShwcmVwZW5kLCBtZW1iZXIub2JqZWN0KTtcbiAgcmV0dXJuIG1lbWJlcjtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHJlbW92ZVByb3BlcnRpZXM7XG5cbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcblxuY29uc3QgQ0xFQVJfS0VZUyA9IFtcInRva2Vuc1wiLCBcInN0YXJ0XCIsIFwiZW5kXCIsIFwibG9jXCIsIFwicmF3XCIsIFwicmF3VmFsdWVcIl07XG5cbmNvbnN0IENMRUFSX0tFWVNfUExVU19DT01NRU5UUyA9IF9jb25zdGFudHMuQ09NTUVOVF9LRVlTLmNvbmNhdChbXCJjb21tZW50c1wiXSkuY29uY2F0KENMRUFSX0tFWVMpO1xuXG5mdW5jdGlvbiByZW1vdmVQcm9wZXJ0aWVzKG5vZGUsIG9wdHMgPSB7fSkge1xuICBjb25zdCBtYXAgPSBvcHRzLnByZXNlcnZlQ29tbWVudHMgPyBDTEVBUl9LRVlTIDogQ0xFQVJfS0VZU19QTFVTX0NPTU1FTlRTO1xuXG4gIGZvciAoY29uc3Qga2V5IG9mIG1hcCkge1xuICAgIGlmIChub2RlW2tleV0gIT0gbnVsbCkgbm9kZVtrZXldID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMobm9kZSkpIHtcbiAgICBpZiAoa2V5WzBdID09PSBcIl9cIiAmJiBub2RlW2tleV0gIT0gbnVsbCkgbm9kZVtrZXldID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3Qgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMobm9kZSk7XG5cbiAgZm9yIChjb25zdCBzeW0gb2Ygc3ltYm9scykge1xuICAgIG5vZGVbc3ltXSA9IG51bGw7XG4gIH1cbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHJlbW92ZVByb3BlcnRpZXNEZWVwO1xuXG52YXIgX3RyYXZlcnNlRmFzdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3RyYXZlcnNlL3RyYXZlcnNlRmFzdFwiKSk7XG5cbnZhciBfcmVtb3ZlUHJvcGVydGllcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcmVtb3ZlUHJvcGVydGllc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHJlbW92ZVByb3BlcnRpZXNEZWVwKHRyZWUsIG9wdHMpIHtcbiAgKDAsIF90cmF2ZXJzZUZhc3QuZGVmYXVsdCkodHJlZSwgX3JlbW92ZVByb3BlcnRpZXMuZGVmYXVsdCwgb3B0cyk7XG4gIHJldHVybiB0cmVlO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gcmVtb3ZlVHlwZUR1cGxpY2F0ZXM7XG5cbnZhciBfZ2VuZXJhdGVkID0gcmVxdWlyZShcIi4uLy4uL3ZhbGlkYXRvcnMvZ2VuZXJhdGVkXCIpO1xuXG5mdW5jdGlvbiByZW1vdmVUeXBlRHVwbGljYXRlcyhub2Rlcykge1xuICBjb25zdCBnZW5lcmljcyA9IHt9O1xuICBjb25zdCBiYXNlcyA9IHt9O1xuICBjb25zdCB0eXBlR3JvdXBzID0gW107XG4gIGNvbnN0IHR5cGVzID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICBpZiAoIW5vZGUpIGNvbnRpbnVlO1xuXG4gICAgaWYgKHR5cGVzLmluZGV4T2Yobm9kZSkgPj0gMCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzVFNBbnlLZXl3b3JkKShub2RlLnR5cGUpKSB7XG4gICAgICByZXR1cm4gW25vZGVdO1xuICAgIH1cblxuICAgIGlmICgoMCwgX2dlbmVyYXRlZC5pc1RTQmFzZVR5cGUpKG5vZGUpKSB7XG4gICAgICBiYXNlc1tub2RlLnR5cGVdID0gbm9kZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICgoMCwgX2dlbmVyYXRlZC5pc1RTVW5pb25UeXBlKShub2RlKSkge1xuICAgICAgaWYgKHR5cGVHcm91cHMuaW5kZXhPZihub2RlLnR5cGVzKSA8IDApIHtcbiAgICAgICAgbm9kZXMgPSBub2Rlcy5jb25jYXQobm9kZS50eXBlcyk7XG4gICAgICAgIHR5cGVHcm91cHMucHVzaChub2RlLnR5cGVzKTtcbiAgICAgIH1cblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdHlwZXMucHVzaChub2RlKTtcbiAgfVxuXG4gIGZvciAoY29uc3QgdHlwZSBvZiBPYmplY3Qua2V5cyhiYXNlcykpIHtcbiAgICB0eXBlcy5wdXNoKGJhc2VzW3R5cGVdKTtcbiAgfVxuXG4gIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhnZW5lcmljcykpIHtcbiAgICB0eXBlcy5wdXNoKGdlbmVyaWNzW25hbWVdKTtcbiAgfVxuXG4gIHJldHVybiB0eXBlcztcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGdldEJpbmRpbmdJZGVudGlmaWVycztcblxudmFyIF9nZW5lcmF0ZWQgPSByZXF1aXJlKFwiLi4vdmFsaWRhdG9ycy9nZW5lcmF0ZWRcIik7XG5cbmZ1bmN0aW9uIGdldEJpbmRpbmdJZGVudGlmaWVycyhub2RlLCBkdXBsaWNhdGVzLCBvdXRlck9ubHkpIHtcbiAgbGV0IHNlYXJjaCA9IFtdLmNvbmNhdChub2RlKTtcbiAgY29uc3QgaWRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICB3aGlsZSAoc2VhcmNoLmxlbmd0aCkge1xuICAgIGNvbnN0IGlkID0gc2VhcmNoLnNoaWZ0KCk7XG4gICAgaWYgKCFpZCkgY29udGludWU7XG4gICAgY29uc3Qga2V5cyA9IGdldEJpbmRpbmdJZGVudGlmaWVycy5rZXlzW2lkLnR5cGVdO1xuXG4gICAgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzSWRlbnRpZmllcikoaWQpKSB7XG4gICAgICBpZiAoZHVwbGljYXRlcykge1xuICAgICAgICBjb25zdCBfaWRzID0gaWRzW2lkLm5hbWVdID0gaWRzW2lkLm5hbWVdIHx8IFtdO1xuXG4gICAgICAgIF9pZHMucHVzaChpZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZHNbaWQubmFtZV0gPSBpZDtcbiAgICAgIH1cblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzRXhwb3J0RGVjbGFyYXRpb24pKGlkKSkge1xuICAgICAgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzRGVjbGFyYXRpb24pKGlkLmRlY2xhcmF0aW9uKSkge1xuICAgICAgICBzZWFyY2gucHVzaChpZC5kZWNsYXJhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChvdXRlck9ubHkpIHtcbiAgICAgIGlmICgoMCwgX2dlbmVyYXRlZC5pc0Z1bmN0aW9uRGVjbGFyYXRpb24pKGlkKSkge1xuICAgICAgICBzZWFyY2gucHVzaChpZC5pZCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNGdW5jdGlvbkV4cHJlc3Npb24pKGlkKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5cykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGlkW2tleV0pIHtcbiAgICAgICAgICBzZWFyY2ggPSBzZWFyY2guY29uY2F0KGlkW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGlkcztcbn1cblxuZ2V0QmluZGluZ0lkZW50aWZpZXJzLmtleXMgPSB7XG4gIERlY2xhcmVDbGFzczogW1wiaWRcIl0sXG4gIERlY2xhcmVGdW5jdGlvbjogW1wiaWRcIl0sXG4gIERlY2xhcmVNb2R1bGU6IFtcImlkXCJdLFxuICBEZWNsYXJlVmFyaWFibGU6IFtcImlkXCJdLFxuICBEZWNsYXJlSW50ZXJmYWNlOiBbXCJpZFwiXSxcbiAgRGVjbGFyZVR5cGVBbGlhczogW1wiaWRcIl0sXG4gIERlY2xhcmVPcGFxdWVUeXBlOiBbXCJpZFwiXSxcbiAgSW50ZXJmYWNlRGVjbGFyYXRpb246IFtcImlkXCJdLFxuICBUeXBlQWxpYXM6IFtcImlkXCJdLFxuICBPcGFxdWVUeXBlOiBbXCJpZFwiXSxcbiAgQ2F0Y2hDbGF1c2U6IFtcInBhcmFtXCJdLFxuICBMYWJlbGVkU3RhdGVtZW50OiBbXCJsYWJlbFwiXSxcbiAgVW5hcnlFeHByZXNzaW9uOiBbXCJhcmd1bWVudFwiXSxcbiAgQXNzaWdubWVudEV4cHJlc3Npb246IFtcImxlZnRcIl0sXG4gIEltcG9ydFNwZWNpZmllcjogW1wibG9jYWxcIl0sXG4gIEltcG9ydE5hbWVzcGFjZVNwZWNpZmllcjogW1wibG9jYWxcIl0sXG4gIEltcG9ydERlZmF1bHRTcGVjaWZpZXI6IFtcImxvY2FsXCJdLFxuICBJbXBvcnREZWNsYXJhdGlvbjogW1wic3BlY2lmaWVyc1wiXSxcbiAgRXhwb3J0U3BlY2lmaWVyOiBbXCJleHBvcnRlZFwiXSxcbiAgRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyOiBbXCJleHBvcnRlZFwiXSxcbiAgRXhwb3J0RGVmYXVsdFNwZWNpZmllcjogW1wiZXhwb3J0ZWRcIl0sXG4gIEZ1bmN0aW9uRGVjbGFyYXRpb246IFtcImlkXCIsIFwicGFyYW1zXCJdLFxuICBGdW5jdGlvbkV4cHJlc3Npb246IFtcImlkXCIsIFwicGFyYW1zXCJdLFxuICBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjogW1wicGFyYW1zXCJdLFxuICBPYmplY3RNZXRob2Q6IFtcInBhcmFtc1wiXSxcbiAgQ2xhc3NNZXRob2Q6IFtcInBhcmFtc1wiXSxcbiAgRm9ySW5TdGF0ZW1lbnQ6IFtcImxlZnRcIl0sXG4gIEZvck9mU3RhdGVtZW50OiBbXCJsZWZ0XCJdLFxuICBDbGFzc0RlY2xhcmF0aW9uOiBbXCJpZFwiXSxcbiAgQ2xhc3NFeHByZXNzaW9uOiBbXCJpZFwiXSxcbiAgUmVzdEVsZW1lbnQ6IFtcImFyZ3VtZW50XCJdLFxuICBVcGRhdGVFeHByZXNzaW9uOiBbXCJhcmd1bWVudFwiXSxcbiAgT2JqZWN0UHJvcGVydHk6IFtcInZhbHVlXCJdLFxuICBBc3NpZ25tZW50UGF0dGVybjogW1wibGVmdFwiXSxcbiAgQXJyYXlQYXR0ZXJuOiBbXCJlbGVtZW50c1wiXSxcbiAgT2JqZWN0UGF0dGVybjogW1wicHJvcGVydGllc1wiXSxcbiAgVmFyaWFibGVEZWNsYXJhdGlvbjogW1wiZGVjbGFyYXRpb25zXCJdLFxuICBWYXJpYWJsZURlY2xhcmF0b3I6IFtcImlkXCJdXG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0T3V0ZXJCaW5kaW5nSWRlbnRpZmllcnM7XG5cbnZhciBfZ2V0QmluZGluZ0lkZW50aWZpZXJzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9nZXRCaW5kaW5nSWRlbnRpZmllcnNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBnZXRPdXRlckJpbmRpbmdJZGVudGlmaWVycyhub2RlLCBkdXBsaWNhdGVzKSB7XG4gIHJldHVybiAoMCwgX2dldEJpbmRpbmdJZGVudGlmaWVycy5kZWZhdWx0KShub2RlLCBkdXBsaWNhdGVzLCB0cnVlKTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHRyYXZlcnNlO1xuXG52YXIgX2RlZmluaXRpb25zID0gcmVxdWlyZShcIi4uL2RlZmluaXRpb25zXCIpO1xuXG5mdW5jdGlvbiB0cmF2ZXJzZShub2RlLCBoYW5kbGVycywgc3RhdGUpIHtcbiAgaWYgKHR5cGVvZiBoYW5kbGVycyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgaGFuZGxlcnMgPSB7XG4gICAgICBlbnRlcjogaGFuZGxlcnNcbiAgICB9O1xuICB9XG5cbiAgY29uc3Qge1xuICAgIGVudGVyLFxuICAgIGV4aXRcbiAgfSA9IGhhbmRsZXJzO1xuICB0cmF2ZXJzZVNpbXBsZUltcGwobm9kZSwgZW50ZXIsIGV4aXQsIHN0YXRlLCBbXSk7XG59XG5cbmZ1bmN0aW9uIHRyYXZlcnNlU2ltcGxlSW1wbChub2RlLCBlbnRlciwgZXhpdCwgc3RhdGUsIGFuY2VzdG9ycykge1xuICBjb25zdCBrZXlzID0gX2RlZmluaXRpb25zLlZJU0lUT1JfS0VZU1tub2RlLnR5cGVdO1xuICBpZiAoIWtleXMpIHJldHVybjtcbiAgaWYgKGVudGVyKSBlbnRlcihub2RlLCBhbmNlc3RvcnMsIHN0YXRlKTtcblxuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgY29uc3Qgc3ViTm9kZSA9IG5vZGVba2V5XTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHN1Yk5vZGUpKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN1Yk5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBzdWJOb2RlW2ldO1xuICAgICAgICBpZiAoIWNoaWxkKSBjb250aW51ZTtcbiAgICAgICAgYW5jZXN0b3JzLnB1c2goe1xuICAgICAgICAgIG5vZGUsXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgIH0pO1xuICAgICAgICB0cmF2ZXJzZVNpbXBsZUltcGwoY2hpbGQsIGVudGVyLCBleGl0LCBzdGF0ZSwgYW5jZXN0b3JzKTtcbiAgICAgICAgYW5jZXN0b3JzLnBvcCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3ViTm9kZSkge1xuICAgICAgYW5jZXN0b3JzLnB1c2goe1xuICAgICAgICBub2RlLFxuICAgICAgICBrZXlcbiAgICAgIH0pO1xuICAgICAgdHJhdmVyc2VTaW1wbGVJbXBsKHN1Yk5vZGUsIGVudGVyLCBleGl0LCBzdGF0ZSwgYW5jZXN0b3JzKTtcbiAgICAgIGFuY2VzdG9ycy5wb3AoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZXhpdCkgZXhpdChub2RlLCBhbmNlc3RvcnMsIHN0YXRlKTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHRyYXZlcnNlRmFzdDtcblxudmFyIF9kZWZpbml0aW9ucyA9IHJlcXVpcmUoXCIuLi9kZWZpbml0aW9uc1wiKTtcblxuZnVuY3Rpb24gdHJhdmVyc2VGYXN0KG5vZGUsIGVudGVyLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuO1xuICBjb25zdCBrZXlzID0gX2RlZmluaXRpb25zLlZJU0lUT1JfS0VZU1tub2RlLnR5cGVdO1xuICBpZiAoIWtleXMpIHJldHVybjtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIGVudGVyKG5vZGUsIG9wdHMpO1xuXG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBjb25zdCBzdWJOb2RlID0gbm9kZVtrZXldO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3ViTm9kZSkpIHtcbiAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBzdWJOb2RlKSB7XG4gICAgICAgIHRyYXZlcnNlRmFzdChub2RlLCBlbnRlciwgb3B0cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYXZlcnNlRmFzdChzdWJOb2RlLCBlbnRlciwgb3B0cyk7XG4gICAgfVxuICB9XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpbmhlcml0O1xuXG5mdW5jdGlvbiBpbmhlcml0KGtleSwgY2hpbGQsIHBhcmVudCkge1xuICBpZiAoY2hpbGQgJiYgcGFyZW50KSB7XG4gICAgY2hpbGRba2V5XSA9IEFycmF5LmZyb20obmV3IFNldChbXS5jb25jYXQoY2hpbGRba2V5XSwgcGFyZW50W2tleV0pLmZpbHRlcihCb29sZWFuKSkpO1xuICB9XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBjbGVhbkpTWEVsZW1lbnRMaXRlcmFsQ2hpbGQ7XG5cbnZhciBfZ2VuZXJhdGVkID0gcmVxdWlyZShcIi4uLy4uL2J1aWxkZXJzL2dlbmVyYXRlZFwiKTtcblxuZnVuY3Rpb24gY2xlYW5KU1hFbGVtZW50TGl0ZXJhbENoaWxkKGNoaWxkLCBhcmdzKSB7XG4gIGNvbnN0IGxpbmVzID0gY2hpbGQudmFsdWUuc3BsaXQoL1xcclxcbnxcXG58XFxyLyk7XG4gIGxldCBsYXN0Tm9uRW1wdHlMaW5lID0gMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxpbmVzW2ldLm1hdGNoKC9bXiBcXHRdLykpIHtcbiAgICAgIGxhc3ROb25FbXB0eUxpbmUgPSBpO1xuICAgIH1cbiAgfVxuXG4gIGxldCBzdHIgPSBcIlwiO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBsaW5lID0gbGluZXNbaV07XG4gICAgY29uc3QgaXNGaXJzdExpbmUgPSBpID09PSAwO1xuICAgIGNvbnN0IGlzTGFzdExpbmUgPSBpID09PSBsaW5lcy5sZW5ndGggLSAxO1xuICAgIGNvbnN0IGlzTGFzdE5vbkVtcHR5TGluZSA9IGkgPT09IGxhc3ROb25FbXB0eUxpbmU7XG4gICAgbGV0IHRyaW1tZWRMaW5lID0gbGluZS5yZXBsYWNlKC9cXHQvZywgXCIgXCIpO1xuXG4gICAgaWYgKCFpc0ZpcnN0TGluZSkge1xuICAgICAgdHJpbW1lZExpbmUgPSB0cmltbWVkTGluZS5yZXBsYWNlKC9eWyBdKy8sIFwiXCIpO1xuICAgIH1cblxuICAgIGlmICghaXNMYXN0TGluZSkge1xuICAgICAgdHJpbW1lZExpbmUgPSB0cmltbWVkTGluZS5yZXBsYWNlKC9bIF0rJC8sIFwiXCIpO1xuICAgIH1cblxuICAgIGlmICh0cmltbWVkTGluZSkge1xuICAgICAgaWYgKCFpc0xhc3ROb25FbXB0eUxpbmUpIHtcbiAgICAgICAgdHJpbW1lZExpbmUgKz0gXCIgXCI7XG4gICAgICB9XG5cbiAgICAgIHN0ciArPSB0cmltbWVkTGluZTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RyKSBhcmdzLnB1c2goKDAsIF9nZW5lcmF0ZWQuc3RyaW5nTGl0ZXJhbCkoc3RyKSk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBzaGFsbG93RXF1YWw7XG5cbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhleHBlY3RlZCk7XG5cbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGlmIChhY3R1YWxba2V5XSAhPT0gZXhwZWN0ZWRba2V5XSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gYnVpbGRNYXRjaE1lbWJlckV4cHJlc3Npb247XG5cbnZhciBfbWF0Y2hlc1BhdHRlcm4gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL21hdGNoZXNQYXR0ZXJuXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gYnVpbGRNYXRjaE1lbWJlckV4cHJlc3Npb24obWF0Y2gsIGFsbG93UGFydGlhbCkge1xuICBjb25zdCBwYXJ0cyA9IG1hdGNoLnNwbGl0KFwiLlwiKTtcbiAgcmV0dXJuIG1lbWJlciA9PiAoMCwgX21hdGNoZXNQYXR0ZXJuLmRlZmF1bHQpKG1lbWJlciwgcGFydHMsIGFsbG93UGFydGlhbCk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmlzQXJyYXlFeHByZXNzaW9uID0gaXNBcnJheUV4cHJlc3Npb247XG5leHBvcnRzLmlzQXNzaWdubWVudEV4cHJlc3Npb24gPSBpc0Fzc2lnbm1lbnRFeHByZXNzaW9uO1xuZXhwb3J0cy5pc0JpbmFyeUV4cHJlc3Npb24gPSBpc0JpbmFyeUV4cHJlc3Npb247XG5leHBvcnRzLmlzSW50ZXJwcmV0ZXJEaXJlY3RpdmUgPSBpc0ludGVycHJldGVyRGlyZWN0aXZlO1xuZXhwb3J0cy5pc0RpcmVjdGl2ZSA9IGlzRGlyZWN0aXZlO1xuZXhwb3J0cy5pc0RpcmVjdGl2ZUxpdGVyYWwgPSBpc0RpcmVjdGl2ZUxpdGVyYWw7XG5leHBvcnRzLmlzQmxvY2tTdGF0ZW1lbnQgPSBpc0Jsb2NrU3RhdGVtZW50O1xuZXhwb3J0cy5pc0JyZWFrU3RhdGVtZW50ID0gaXNCcmVha1N0YXRlbWVudDtcbmV4cG9ydHMuaXNDYWxsRXhwcmVzc2lvbiA9IGlzQ2FsbEV4cHJlc3Npb247XG5leHBvcnRzLmlzQ2F0Y2hDbGF1c2UgPSBpc0NhdGNoQ2xhdXNlO1xuZXhwb3J0cy5pc0NvbmRpdGlvbmFsRXhwcmVzc2lvbiA9IGlzQ29uZGl0aW9uYWxFeHByZXNzaW9uO1xuZXhwb3J0cy5pc0NvbnRpbnVlU3RhdGVtZW50ID0gaXNDb250aW51ZVN0YXRlbWVudDtcbmV4cG9ydHMuaXNEZWJ1Z2dlclN0YXRlbWVudCA9IGlzRGVidWdnZXJTdGF0ZW1lbnQ7XG5leHBvcnRzLmlzRG9XaGlsZVN0YXRlbWVudCA9IGlzRG9XaGlsZVN0YXRlbWVudDtcbmV4cG9ydHMuaXNFbXB0eVN0YXRlbWVudCA9IGlzRW1wdHlTdGF0ZW1lbnQ7XG5leHBvcnRzLmlzRXhwcmVzc2lvblN0YXRlbWVudCA9IGlzRXhwcmVzc2lvblN0YXRlbWVudDtcbmV4cG9ydHMuaXNGaWxlID0gaXNGaWxlO1xuZXhwb3J0cy5pc0ZvckluU3RhdGVtZW50ID0gaXNGb3JJblN0YXRlbWVudDtcbmV4cG9ydHMuaXNGb3JTdGF0ZW1lbnQgPSBpc0ZvclN0YXRlbWVudDtcbmV4cG9ydHMuaXNGdW5jdGlvbkRlY2xhcmF0aW9uID0gaXNGdW5jdGlvbkRlY2xhcmF0aW9uO1xuZXhwb3J0cy5pc0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGlzRnVuY3Rpb25FeHByZXNzaW9uO1xuZXhwb3J0cy5pc0lkZW50aWZpZXIgPSBpc0lkZW50aWZpZXI7XG5leHBvcnRzLmlzSWZTdGF0ZW1lbnQgPSBpc0lmU3RhdGVtZW50O1xuZXhwb3J0cy5pc0xhYmVsZWRTdGF0ZW1lbnQgPSBpc0xhYmVsZWRTdGF0ZW1lbnQ7XG5leHBvcnRzLmlzU3RyaW5nTGl0ZXJhbCA9IGlzU3RyaW5nTGl0ZXJhbDtcbmV4cG9ydHMuaXNOdW1lcmljTGl0ZXJhbCA9IGlzTnVtZXJpY0xpdGVyYWw7XG5leHBvcnRzLmlzTnVsbExpdGVyYWwgPSBpc051bGxMaXRlcmFsO1xuZXhwb3J0cy5pc0Jvb2xlYW5MaXRlcmFsID0gaXNCb29sZWFuTGl0ZXJhbDtcbmV4cG9ydHMuaXNSZWdFeHBMaXRlcmFsID0gaXNSZWdFeHBMaXRlcmFsO1xuZXhwb3J0cy5pc0xvZ2ljYWxFeHByZXNzaW9uID0gaXNMb2dpY2FsRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNNZW1iZXJFeHByZXNzaW9uID0gaXNNZW1iZXJFeHByZXNzaW9uO1xuZXhwb3J0cy5pc05ld0V4cHJlc3Npb24gPSBpc05ld0V4cHJlc3Npb247XG5leHBvcnRzLmlzUHJvZ3JhbSA9IGlzUHJvZ3JhbTtcbmV4cG9ydHMuaXNPYmplY3RFeHByZXNzaW9uID0gaXNPYmplY3RFeHByZXNzaW9uO1xuZXhwb3J0cy5pc09iamVjdE1ldGhvZCA9IGlzT2JqZWN0TWV0aG9kO1xuZXhwb3J0cy5pc09iamVjdFByb3BlcnR5ID0gaXNPYmplY3RQcm9wZXJ0eTtcbmV4cG9ydHMuaXNSZXN0RWxlbWVudCA9IGlzUmVzdEVsZW1lbnQ7XG5leHBvcnRzLmlzUmV0dXJuU3RhdGVtZW50ID0gaXNSZXR1cm5TdGF0ZW1lbnQ7XG5leHBvcnRzLmlzU2VxdWVuY2VFeHByZXNzaW9uID0gaXNTZXF1ZW5jZUV4cHJlc3Npb247XG5leHBvcnRzLmlzUGFyZW50aGVzaXplZEV4cHJlc3Npb24gPSBpc1BhcmVudGhlc2l6ZWRFeHByZXNzaW9uO1xuZXhwb3J0cy5pc1N3aXRjaENhc2UgPSBpc1N3aXRjaENhc2U7XG5leHBvcnRzLmlzU3dpdGNoU3RhdGVtZW50ID0gaXNTd2l0Y2hTdGF0ZW1lbnQ7XG5leHBvcnRzLmlzVGhpc0V4cHJlc3Npb24gPSBpc1RoaXNFeHByZXNzaW9uO1xuZXhwb3J0cy5pc1Rocm93U3RhdGVtZW50ID0gaXNUaHJvd1N0YXRlbWVudDtcbmV4cG9ydHMuaXNUcnlTdGF0ZW1lbnQgPSBpc1RyeVN0YXRlbWVudDtcbmV4cG9ydHMuaXNVbmFyeUV4cHJlc3Npb24gPSBpc1VuYXJ5RXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNVcGRhdGVFeHByZXNzaW9uID0gaXNVcGRhdGVFeHByZXNzaW9uO1xuZXhwb3J0cy5pc1ZhcmlhYmxlRGVjbGFyYXRpb24gPSBpc1ZhcmlhYmxlRGVjbGFyYXRpb247XG5leHBvcnRzLmlzVmFyaWFibGVEZWNsYXJhdG9yID0gaXNWYXJpYWJsZURlY2xhcmF0b3I7XG5leHBvcnRzLmlzV2hpbGVTdGF0ZW1lbnQgPSBpc1doaWxlU3RhdGVtZW50O1xuZXhwb3J0cy5pc1dpdGhTdGF0ZW1lbnQgPSBpc1dpdGhTdGF0ZW1lbnQ7XG5leHBvcnRzLmlzQXNzaWdubWVudFBhdHRlcm4gPSBpc0Fzc2lnbm1lbnRQYXR0ZXJuO1xuZXhwb3J0cy5pc0FycmF5UGF0dGVybiA9IGlzQXJyYXlQYXR0ZXJuO1xuZXhwb3J0cy5pc0Fycm93RnVuY3Rpb25FeHByZXNzaW9uID0gaXNBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNDbGFzc0JvZHkgPSBpc0NsYXNzQm9keTtcbmV4cG9ydHMuaXNDbGFzc0V4cHJlc3Npb24gPSBpc0NsYXNzRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNDbGFzc0RlY2xhcmF0aW9uID0gaXNDbGFzc0RlY2xhcmF0aW9uO1xuZXhwb3J0cy5pc0V4cG9ydEFsbERlY2xhcmF0aW9uID0gaXNFeHBvcnRBbGxEZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24gPSBpc0V4cG9ydERlZmF1bHREZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNFeHBvcnROYW1lZERlY2xhcmF0aW9uID0gaXNFeHBvcnROYW1lZERlY2xhcmF0aW9uO1xuZXhwb3J0cy5pc0V4cG9ydFNwZWNpZmllciA9IGlzRXhwb3J0U3BlY2lmaWVyO1xuZXhwb3J0cy5pc0Zvck9mU3RhdGVtZW50ID0gaXNGb3JPZlN0YXRlbWVudDtcbmV4cG9ydHMuaXNJbXBvcnREZWNsYXJhdGlvbiA9IGlzSW1wb3J0RGVjbGFyYXRpb247XG5leHBvcnRzLmlzSW1wb3J0RGVmYXVsdFNwZWNpZmllciA9IGlzSW1wb3J0RGVmYXVsdFNwZWNpZmllcjtcbmV4cG9ydHMuaXNJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIgPSBpc0ltcG9ydE5hbWVzcGFjZVNwZWNpZmllcjtcbmV4cG9ydHMuaXNJbXBvcnRTcGVjaWZpZXIgPSBpc0ltcG9ydFNwZWNpZmllcjtcbmV4cG9ydHMuaXNNZXRhUHJvcGVydHkgPSBpc01ldGFQcm9wZXJ0eTtcbmV4cG9ydHMuaXNDbGFzc01ldGhvZCA9IGlzQ2xhc3NNZXRob2Q7XG5leHBvcnRzLmlzT2JqZWN0UGF0dGVybiA9IGlzT2JqZWN0UGF0dGVybjtcbmV4cG9ydHMuaXNTcHJlYWRFbGVtZW50ID0gaXNTcHJlYWRFbGVtZW50O1xuZXhwb3J0cy5pc1N1cGVyID0gaXNTdXBlcjtcbmV4cG9ydHMuaXNUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24gPSBpc1RhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNUZW1wbGF0ZUVsZW1lbnQgPSBpc1RlbXBsYXRlRWxlbWVudDtcbmV4cG9ydHMuaXNUZW1wbGF0ZUxpdGVyYWwgPSBpc1RlbXBsYXRlTGl0ZXJhbDtcbmV4cG9ydHMuaXNZaWVsZEV4cHJlc3Npb24gPSBpc1lpZWxkRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNBd2FpdEV4cHJlc3Npb24gPSBpc0F3YWl0RXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNJbXBvcnQgPSBpc0ltcG9ydDtcbmV4cG9ydHMuaXNCaWdJbnRMaXRlcmFsID0gaXNCaWdJbnRMaXRlcmFsO1xuZXhwb3J0cy5pc0V4cG9ydE5hbWVzcGFjZVNwZWNpZmllciA9IGlzRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyO1xuZXhwb3J0cy5pc09wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbiA9IGlzT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uO1xuZXhwb3J0cy5pc09wdGlvbmFsQ2FsbEV4cHJlc3Npb24gPSBpc09wdGlvbmFsQ2FsbEV4cHJlc3Npb247XG5leHBvcnRzLmlzQW55VHlwZUFubm90YXRpb24gPSBpc0FueVR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc0FycmF5VHlwZUFubm90YXRpb24gPSBpc0FycmF5VHlwZUFubm90YXRpb247XG5leHBvcnRzLmlzQm9vbGVhblR5cGVBbm5vdGF0aW9uID0gaXNCb29sZWFuVHlwZUFubm90YXRpb247XG5leHBvcnRzLmlzQm9vbGVhbkxpdGVyYWxUeXBlQW5ub3RhdGlvbiA9IGlzQm9vbGVhbkxpdGVyYWxUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNOdWxsTGl0ZXJhbFR5cGVBbm5vdGF0aW9uID0gaXNOdWxsTGl0ZXJhbFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc0NsYXNzSW1wbGVtZW50cyA9IGlzQ2xhc3NJbXBsZW1lbnRzO1xuZXhwb3J0cy5pc0RlY2xhcmVDbGFzcyA9IGlzRGVjbGFyZUNsYXNzO1xuZXhwb3J0cy5pc0RlY2xhcmVGdW5jdGlvbiA9IGlzRGVjbGFyZUZ1bmN0aW9uO1xuZXhwb3J0cy5pc0RlY2xhcmVJbnRlcmZhY2UgPSBpc0RlY2xhcmVJbnRlcmZhY2U7XG5leHBvcnRzLmlzRGVjbGFyZU1vZHVsZSA9IGlzRGVjbGFyZU1vZHVsZTtcbmV4cG9ydHMuaXNEZWNsYXJlTW9kdWxlRXhwb3J0cyA9IGlzRGVjbGFyZU1vZHVsZUV4cG9ydHM7XG5leHBvcnRzLmlzRGVjbGFyZVR5cGVBbGlhcyA9IGlzRGVjbGFyZVR5cGVBbGlhcztcbmV4cG9ydHMuaXNEZWNsYXJlT3BhcXVlVHlwZSA9IGlzRGVjbGFyZU9wYXF1ZVR5cGU7XG5leHBvcnRzLmlzRGVjbGFyZVZhcmlhYmxlID0gaXNEZWNsYXJlVmFyaWFibGU7XG5leHBvcnRzLmlzRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uID0gaXNEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb247XG5leHBvcnRzLmlzRGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uID0gaXNEZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb247XG5leHBvcnRzLmlzRGVjbGFyZWRQcmVkaWNhdGUgPSBpc0RlY2xhcmVkUHJlZGljYXRlO1xuZXhwb3J0cy5pc0V4aXN0c1R5cGVBbm5vdGF0aW9uID0gaXNFeGlzdHNUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNGdW5jdGlvblR5cGVBbm5vdGF0aW9uID0gaXNGdW5jdGlvblR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc0Z1bmN0aW9uVHlwZVBhcmFtID0gaXNGdW5jdGlvblR5cGVQYXJhbTtcbmV4cG9ydHMuaXNHZW5lcmljVHlwZUFubm90YXRpb24gPSBpc0dlbmVyaWNUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNJbmZlcnJlZFByZWRpY2F0ZSA9IGlzSW5mZXJyZWRQcmVkaWNhdGU7XG5leHBvcnRzLmlzSW50ZXJmYWNlRXh0ZW5kcyA9IGlzSW50ZXJmYWNlRXh0ZW5kcztcbmV4cG9ydHMuaXNJbnRlcmZhY2VEZWNsYXJhdGlvbiA9IGlzSW50ZXJmYWNlRGVjbGFyYXRpb247XG5leHBvcnRzLmlzSW50ZXJmYWNlVHlwZUFubm90YXRpb24gPSBpc0ludGVyZmFjZVR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc0ludGVyc2VjdGlvblR5cGVBbm5vdGF0aW9uID0gaXNJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNNaXhlZFR5cGVBbm5vdGF0aW9uID0gaXNNaXhlZFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc0VtcHR5VHlwZUFubm90YXRpb24gPSBpc0VtcHR5VHlwZUFubm90YXRpb247XG5leHBvcnRzLmlzTnVsbGFibGVUeXBlQW5ub3RhdGlvbiA9IGlzTnVsbGFibGVUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNOdW1iZXJMaXRlcmFsVHlwZUFubm90YXRpb24gPSBpc051bWJlckxpdGVyYWxUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNOdW1iZXJUeXBlQW5ub3RhdGlvbiA9IGlzTnVtYmVyVHlwZUFubm90YXRpb247XG5leHBvcnRzLmlzT2JqZWN0VHlwZUFubm90YXRpb24gPSBpc09iamVjdFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc09iamVjdFR5cGVJbnRlcm5hbFNsb3QgPSBpc09iamVjdFR5cGVJbnRlcm5hbFNsb3Q7XG5leHBvcnRzLmlzT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eSA9IGlzT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eTtcbmV4cG9ydHMuaXNPYmplY3RUeXBlSW5kZXhlciA9IGlzT2JqZWN0VHlwZUluZGV4ZXI7XG5leHBvcnRzLmlzT2JqZWN0VHlwZVByb3BlcnR5ID0gaXNPYmplY3RUeXBlUHJvcGVydHk7XG5leHBvcnRzLmlzT2JqZWN0VHlwZVNwcmVhZFByb3BlcnR5ID0gaXNPYmplY3RUeXBlU3ByZWFkUHJvcGVydHk7XG5leHBvcnRzLmlzT3BhcXVlVHlwZSA9IGlzT3BhcXVlVHlwZTtcbmV4cG9ydHMuaXNRdWFsaWZpZWRUeXBlSWRlbnRpZmllciA9IGlzUXVhbGlmaWVkVHlwZUlkZW50aWZpZXI7XG5leHBvcnRzLmlzU3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uID0gaXNTdHJpbmdMaXRlcmFsVHlwZUFubm90YXRpb247XG5leHBvcnRzLmlzU3RyaW5nVHlwZUFubm90YXRpb24gPSBpc1N0cmluZ1R5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc1N5bWJvbFR5cGVBbm5vdGF0aW9uID0gaXNTeW1ib2xUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNUaGlzVHlwZUFubm90YXRpb24gPSBpc1RoaXNUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNUdXBsZVR5cGVBbm5vdGF0aW9uID0gaXNUdXBsZVR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc1R5cGVvZlR5cGVBbm5vdGF0aW9uID0gaXNUeXBlb2ZUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNUeXBlQWxpYXMgPSBpc1R5cGVBbGlhcztcbmV4cG9ydHMuaXNUeXBlQW5ub3RhdGlvbiA9IGlzVHlwZUFubm90YXRpb247XG5leHBvcnRzLmlzVHlwZUNhc3RFeHByZXNzaW9uID0gaXNUeXBlQ2FzdEV4cHJlc3Npb247XG5leHBvcnRzLmlzVHlwZVBhcmFtZXRlciA9IGlzVHlwZVBhcmFtZXRlcjtcbmV4cG9ydHMuaXNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24gPSBpc1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbiA9IGlzVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb247XG5leHBvcnRzLmlzVW5pb25UeXBlQW5ub3RhdGlvbiA9IGlzVW5pb25UeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNWYXJpYW5jZSA9IGlzVmFyaWFuY2U7XG5leHBvcnRzLmlzVm9pZFR5cGVBbm5vdGF0aW9uID0gaXNWb2lkVHlwZUFubm90YXRpb247XG5leHBvcnRzLmlzRW51bURlY2xhcmF0aW9uID0gaXNFbnVtRGVjbGFyYXRpb247XG5leHBvcnRzLmlzRW51bUJvb2xlYW5Cb2R5ID0gaXNFbnVtQm9vbGVhbkJvZHk7XG5leHBvcnRzLmlzRW51bU51bWJlckJvZHkgPSBpc0VudW1OdW1iZXJCb2R5O1xuZXhwb3J0cy5pc0VudW1TdHJpbmdCb2R5ID0gaXNFbnVtU3RyaW5nQm9keTtcbmV4cG9ydHMuaXNFbnVtU3ltYm9sQm9keSA9IGlzRW51bVN5bWJvbEJvZHk7XG5leHBvcnRzLmlzRW51bUJvb2xlYW5NZW1iZXIgPSBpc0VudW1Cb29sZWFuTWVtYmVyO1xuZXhwb3J0cy5pc0VudW1OdW1iZXJNZW1iZXIgPSBpc0VudW1OdW1iZXJNZW1iZXI7XG5leHBvcnRzLmlzRW51bVN0cmluZ01lbWJlciA9IGlzRW51bVN0cmluZ01lbWJlcjtcbmV4cG9ydHMuaXNFbnVtRGVmYXVsdGVkTWVtYmVyID0gaXNFbnVtRGVmYXVsdGVkTWVtYmVyO1xuZXhwb3J0cy5pc0pTWEF0dHJpYnV0ZSA9IGlzSlNYQXR0cmlidXRlO1xuZXhwb3J0cy5pc0pTWENsb3NpbmdFbGVtZW50ID0gaXNKU1hDbG9zaW5nRWxlbWVudDtcbmV4cG9ydHMuaXNKU1hFbGVtZW50ID0gaXNKU1hFbGVtZW50O1xuZXhwb3J0cy5pc0pTWEVtcHR5RXhwcmVzc2lvbiA9IGlzSlNYRW1wdHlFeHByZXNzaW9uO1xuZXhwb3J0cy5pc0pTWEV4cHJlc3Npb25Db250YWluZXIgPSBpc0pTWEV4cHJlc3Npb25Db250YWluZXI7XG5leHBvcnRzLmlzSlNYU3ByZWFkQ2hpbGQgPSBpc0pTWFNwcmVhZENoaWxkO1xuZXhwb3J0cy5pc0pTWElkZW50aWZpZXIgPSBpc0pTWElkZW50aWZpZXI7XG5leHBvcnRzLmlzSlNYTWVtYmVyRXhwcmVzc2lvbiA9IGlzSlNYTWVtYmVyRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNKU1hOYW1lc3BhY2VkTmFtZSA9IGlzSlNYTmFtZXNwYWNlZE5hbWU7XG5leHBvcnRzLmlzSlNYT3BlbmluZ0VsZW1lbnQgPSBpc0pTWE9wZW5pbmdFbGVtZW50O1xuZXhwb3J0cy5pc0pTWFNwcmVhZEF0dHJpYnV0ZSA9IGlzSlNYU3ByZWFkQXR0cmlidXRlO1xuZXhwb3J0cy5pc0pTWFRleHQgPSBpc0pTWFRleHQ7XG5leHBvcnRzLmlzSlNYRnJhZ21lbnQgPSBpc0pTWEZyYWdtZW50O1xuZXhwb3J0cy5pc0pTWE9wZW5pbmdGcmFnbWVudCA9IGlzSlNYT3BlbmluZ0ZyYWdtZW50O1xuZXhwb3J0cy5pc0pTWENsb3NpbmdGcmFnbWVudCA9IGlzSlNYQ2xvc2luZ0ZyYWdtZW50O1xuZXhwb3J0cy5pc05vb3AgPSBpc05vb3A7XG5leHBvcnRzLmlzUGxhY2Vob2xkZXIgPSBpc1BsYWNlaG9sZGVyO1xuZXhwb3J0cy5pc1Y4SW50cmluc2ljSWRlbnRpZmllciA9IGlzVjhJbnRyaW5zaWNJZGVudGlmaWVyO1xuZXhwb3J0cy5pc0FyZ3VtZW50UGxhY2Vob2xkZXIgPSBpc0FyZ3VtZW50UGxhY2Vob2xkZXI7XG5leHBvcnRzLmlzQmluZEV4cHJlc3Npb24gPSBpc0JpbmRFeHByZXNzaW9uO1xuZXhwb3J0cy5pc0NsYXNzUHJvcGVydHkgPSBpc0NsYXNzUHJvcGVydHk7XG5leHBvcnRzLmlzUGlwZWxpbmVUb3BpY0V4cHJlc3Npb24gPSBpc1BpcGVsaW5lVG9waWNFeHByZXNzaW9uO1xuZXhwb3J0cy5pc1BpcGVsaW5lQmFyZUZ1bmN0aW9uID0gaXNQaXBlbGluZUJhcmVGdW5jdGlvbjtcbmV4cG9ydHMuaXNQaXBlbGluZVByaW1hcnlUb3BpY1JlZmVyZW5jZSA9IGlzUGlwZWxpbmVQcmltYXJ5VG9waWNSZWZlcmVuY2U7XG5leHBvcnRzLmlzQ2xhc3NQcml2YXRlUHJvcGVydHkgPSBpc0NsYXNzUHJpdmF0ZVByb3BlcnR5O1xuZXhwb3J0cy5pc0NsYXNzUHJpdmF0ZU1ldGhvZCA9IGlzQ2xhc3NQcml2YXRlTWV0aG9kO1xuZXhwb3J0cy5pc0ltcG9ydEF0dHJpYnV0ZSA9IGlzSW1wb3J0QXR0cmlidXRlO1xuZXhwb3J0cy5pc0RlY29yYXRvciA9IGlzRGVjb3JhdG9yO1xuZXhwb3J0cy5pc0RvRXhwcmVzc2lvbiA9IGlzRG9FeHByZXNzaW9uO1xuZXhwb3J0cy5pc0V4cG9ydERlZmF1bHRTcGVjaWZpZXIgPSBpc0V4cG9ydERlZmF1bHRTcGVjaWZpZXI7XG5leHBvcnRzLmlzUHJpdmF0ZU5hbWUgPSBpc1ByaXZhdGVOYW1lO1xuZXhwb3J0cy5pc1JlY29yZEV4cHJlc3Npb24gPSBpc1JlY29yZEV4cHJlc3Npb247XG5leHBvcnRzLmlzVHVwbGVFeHByZXNzaW9uID0gaXNUdXBsZUV4cHJlc3Npb247XG5leHBvcnRzLmlzRGVjaW1hbExpdGVyYWwgPSBpc0RlY2ltYWxMaXRlcmFsO1xuZXhwb3J0cy5pc1RTUGFyYW1ldGVyUHJvcGVydHkgPSBpc1RTUGFyYW1ldGVyUHJvcGVydHk7XG5leHBvcnRzLmlzVFNEZWNsYXJlRnVuY3Rpb24gPSBpc1RTRGVjbGFyZUZ1bmN0aW9uO1xuZXhwb3J0cy5pc1RTRGVjbGFyZU1ldGhvZCA9IGlzVFNEZWNsYXJlTWV0aG9kO1xuZXhwb3J0cy5pc1RTUXVhbGlmaWVkTmFtZSA9IGlzVFNRdWFsaWZpZWROYW1lO1xuZXhwb3J0cy5pc1RTQ2FsbFNpZ25hdHVyZURlY2xhcmF0aW9uID0gaXNUU0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNUU0NvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uID0gaXNUU0NvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uO1xuZXhwb3J0cy5pc1RTUHJvcGVydHlTaWduYXR1cmUgPSBpc1RTUHJvcGVydHlTaWduYXR1cmU7XG5leHBvcnRzLmlzVFNNZXRob2RTaWduYXR1cmUgPSBpc1RTTWV0aG9kU2lnbmF0dXJlO1xuZXhwb3J0cy5pc1RTSW5kZXhTaWduYXR1cmUgPSBpc1RTSW5kZXhTaWduYXR1cmU7XG5leHBvcnRzLmlzVFNBbnlLZXl3b3JkID0gaXNUU0FueUtleXdvcmQ7XG5leHBvcnRzLmlzVFNCb29sZWFuS2V5d29yZCA9IGlzVFNCb29sZWFuS2V5d29yZDtcbmV4cG9ydHMuaXNUU0JpZ0ludEtleXdvcmQgPSBpc1RTQmlnSW50S2V5d29yZDtcbmV4cG9ydHMuaXNUU05ldmVyS2V5d29yZCA9IGlzVFNOZXZlcktleXdvcmQ7XG5leHBvcnRzLmlzVFNOdWxsS2V5d29yZCA9IGlzVFNOdWxsS2V5d29yZDtcbmV4cG9ydHMuaXNUU051bWJlcktleXdvcmQgPSBpc1RTTnVtYmVyS2V5d29yZDtcbmV4cG9ydHMuaXNUU09iamVjdEtleXdvcmQgPSBpc1RTT2JqZWN0S2V5d29yZDtcbmV4cG9ydHMuaXNUU1N0cmluZ0tleXdvcmQgPSBpc1RTU3RyaW5nS2V5d29yZDtcbmV4cG9ydHMuaXNUU1N5bWJvbEtleXdvcmQgPSBpc1RTU3ltYm9sS2V5d29yZDtcbmV4cG9ydHMuaXNUU1VuZGVmaW5lZEtleXdvcmQgPSBpc1RTVW5kZWZpbmVkS2V5d29yZDtcbmV4cG9ydHMuaXNUU1Vua25vd25LZXl3b3JkID0gaXNUU1Vua25vd25LZXl3b3JkO1xuZXhwb3J0cy5pc1RTVm9pZEtleXdvcmQgPSBpc1RTVm9pZEtleXdvcmQ7XG5leHBvcnRzLmlzVFNUaGlzVHlwZSA9IGlzVFNUaGlzVHlwZTtcbmV4cG9ydHMuaXNUU0Z1bmN0aW9uVHlwZSA9IGlzVFNGdW5jdGlvblR5cGU7XG5leHBvcnRzLmlzVFNDb25zdHJ1Y3RvclR5cGUgPSBpc1RTQ29uc3RydWN0b3JUeXBlO1xuZXhwb3J0cy5pc1RTVHlwZVJlZmVyZW5jZSA9IGlzVFNUeXBlUmVmZXJlbmNlO1xuZXhwb3J0cy5pc1RTVHlwZVByZWRpY2F0ZSA9IGlzVFNUeXBlUHJlZGljYXRlO1xuZXhwb3J0cy5pc1RTVHlwZVF1ZXJ5ID0gaXNUU1R5cGVRdWVyeTtcbmV4cG9ydHMuaXNUU1R5cGVMaXRlcmFsID0gaXNUU1R5cGVMaXRlcmFsO1xuZXhwb3J0cy5pc1RTQXJyYXlUeXBlID0gaXNUU0FycmF5VHlwZTtcbmV4cG9ydHMuaXNUU1R1cGxlVHlwZSA9IGlzVFNUdXBsZVR5cGU7XG5leHBvcnRzLmlzVFNPcHRpb25hbFR5cGUgPSBpc1RTT3B0aW9uYWxUeXBlO1xuZXhwb3J0cy5pc1RTUmVzdFR5cGUgPSBpc1RTUmVzdFR5cGU7XG5leHBvcnRzLmlzVFNOYW1lZFR1cGxlTWVtYmVyID0gaXNUU05hbWVkVHVwbGVNZW1iZXI7XG5leHBvcnRzLmlzVFNVbmlvblR5cGUgPSBpc1RTVW5pb25UeXBlO1xuZXhwb3J0cy5pc1RTSW50ZXJzZWN0aW9uVHlwZSA9IGlzVFNJbnRlcnNlY3Rpb25UeXBlO1xuZXhwb3J0cy5pc1RTQ29uZGl0aW9uYWxUeXBlID0gaXNUU0NvbmRpdGlvbmFsVHlwZTtcbmV4cG9ydHMuaXNUU0luZmVyVHlwZSA9IGlzVFNJbmZlclR5cGU7XG5leHBvcnRzLmlzVFNQYXJlbnRoZXNpemVkVHlwZSA9IGlzVFNQYXJlbnRoZXNpemVkVHlwZTtcbmV4cG9ydHMuaXNUU1R5cGVPcGVyYXRvciA9IGlzVFNUeXBlT3BlcmF0b3I7XG5leHBvcnRzLmlzVFNJbmRleGVkQWNjZXNzVHlwZSA9IGlzVFNJbmRleGVkQWNjZXNzVHlwZTtcbmV4cG9ydHMuaXNUU01hcHBlZFR5cGUgPSBpc1RTTWFwcGVkVHlwZTtcbmV4cG9ydHMuaXNUU0xpdGVyYWxUeXBlID0gaXNUU0xpdGVyYWxUeXBlO1xuZXhwb3J0cy5pc1RTRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzID0gaXNUU0V4cHJlc3Npb25XaXRoVHlwZUFyZ3VtZW50cztcbmV4cG9ydHMuaXNUU0ludGVyZmFjZURlY2xhcmF0aW9uID0gaXNUU0ludGVyZmFjZURlY2xhcmF0aW9uO1xuZXhwb3J0cy5pc1RTSW50ZXJmYWNlQm9keSA9IGlzVFNJbnRlcmZhY2VCb2R5O1xuZXhwb3J0cy5pc1RTVHlwZUFsaWFzRGVjbGFyYXRpb24gPSBpc1RTVHlwZUFsaWFzRGVjbGFyYXRpb247XG5leHBvcnRzLmlzVFNBc0V4cHJlc3Npb24gPSBpc1RTQXNFeHByZXNzaW9uO1xuZXhwb3J0cy5pc1RTVHlwZUFzc2VydGlvbiA9IGlzVFNUeXBlQXNzZXJ0aW9uO1xuZXhwb3J0cy5pc1RTRW51bURlY2xhcmF0aW9uID0gaXNUU0VudW1EZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNUU0VudW1NZW1iZXIgPSBpc1RTRW51bU1lbWJlcjtcbmV4cG9ydHMuaXNUU01vZHVsZURlY2xhcmF0aW9uID0gaXNUU01vZHVsZURlY2xhcmF0aW9uO1xuZXhwb3J0cy5pc1RTTW9kdWxlQmxvY2sgPSBpc1RTTW9kdWxlQmxvY2s7XG5leHBvcnRzLmlzVFNJbXBvcnRUeXBlID0gaXNUU0ltcG9ydFR5cGU7XG5leHBvcnRzLmlzVFNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvbiA9IGlzVFNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNUU0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlID0gaXNUU0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlO1xuZXhwb3J0cy5pc1RTTm9uTnVsbEV4cHJlc3Npb24gPSBpc1RTTm9uTnVsbEV4cHJlc3Npb247XG5leHBvcnRzLmlzVFNFeHBvcnRBc3NpZ25tZW50ID0gaXNUU0V4cG9ydEFzc2lnbm1lbnQ7XG5leHBvcnRzLmlzVFNOYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvbiA9IGlzVFNOYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNUU1R5cGVBbm5vdGF0aW9uID0gaXNUU1R5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc1RTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24gPSBpc1RTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb247XG5leHBvcnRzLmlzVFNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24gPSBpc1RTVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uO1xuZXhwb3J0cy5pc1RTVHlwZVBhcmFtZXRlciA9IGlzVFNUeXBlUGFyYW1ldGVyO1xuZXhwb3J0cy5pc0V4cHJlc3Npb24gPSBpc0V4cHJlc3Npb247XG5leHBvcnRzLmlzQmluYXJ5ID0gaXNCaW5hcnk7XG5leHBvcnRzLmlzU2NvcGFibGUgPSBpc1Njb3BhYmxlO1xuZXhwb3J0cy5pc0Jsb2NrUGFyZW50ID0gaXNCbG9ja1BhcmVudDtcbmV4cG9ydHMuaXNCbG9jayA9IGlzQmxvY2s7XG5leHBvcnRzLmlzU3RhdGVtZW50ID0gaXNTdGF0ZW1lbnQ7XG5leHBvcnRzLmlzVGVybWluYXRvcmxlc3MgPSBpc1Rlcm1pbmF0b3JsZXNzO1xuZXhwb3J0cy5pc0NvbXBsZXRpb25TdGF0ZW1lbnQgPSBpc0NvbXBsZXRpb25TdGF0ZW1lbnQ7XG5leHBvcnRzLmlzQ29uZGl0aW9uYWwgPSBpc0NvbmRpdGlvbmFsO1xuZXhwb3J0cy5pc0xvb3AgPSBpc0xvb3A7XG5leHBvcnRzLmlzV2hpbGUgPSBpc1doaWxlO1xuZXhwb3J0cy5pc0V4cHJlc3Npb25XcmFwcGVyID0gaXNFeHByZXNzaW9uV3JhcHBlcjtcbmV4cG9ydHMuaXNGb3IgPSBpc0ZvcjtcbmV4cG9ydHMuaXNGb3JYU3RhdGVtZW50ID0gaXNGb3JYU3RhdGVtZW50O1xuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmV4cG9ydHMuaXNGdW5jdGlvblBhcmVudCA9IGlzRnVuY3Rpb25QYXJlbnQ7XG5leHBvcnRzLmlzUHVyZWlzaCA9IGlzUHVyZWlzaDtcbmV4cG9ydHMuaXNEZWNsYXJhdGlvbiA9IGlzRGVjbGFyYXRpb247XG5leHBvcnRzLmlzUGF0dGVybkxpa2UgPSBpc1BhdHRlcm5MaWtlO1xuZXhwb3J0cy5pc0xWYWwgPSBpc0xWYWw7XG5leHBvcnRzLmlzVFNFbnRpdHlOYW1lID0gaXNUU0VudGl0eU5hbWU7XG5leHBvcnRzLmlzTGl0ZXJhbCA9IGlzTGl0ZXJhbDtcbmV4cG9ydHMuaXNJbW11dGFibGUgPSBpc0ltbXV0YWJsZTtcbmV4cG9ydHMuaXNVc2VyV2hpdGVzcGFjYWJsZSA9IGlzVXNlcldoaXRlc3BhY2FibGU7XG5leHBvcnRzLmlzTWV0aG9kID0gaXNNZXRob2Q7XG5leHBvcnRzLmlzT2JqZWN0TWVtYmVyID0gaXNPYmplY3RNZW1iZXI7XG5leHBvcnRzLmlzUHJvcGVydHkgPSBpc1Byb3BlcnR5O1xuZXhwb3J0cy5pc1VuYXJ5TGlrZSA9IGlzVW5hcnlMaWtlO1xuZXhwb3J0cy5pc1BhdHRlcm4gPSBpc1BhdHRlcm47XG5leHBvcnRzLmlzQ2xhc3MgPSBpc0NsYXNzO1xuZXhwb3J0cy5pc01vZHVsZURlY2xhcmF0aW9uID0gaXNNb2R1bGVEZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNFeHBvcnREZWNsYXJhdGlvbiA9IGlzRXhwb3J0RGVjbGFyYXRpb247XG5leHBvcnRzLmlzTW9kdWxlU3BlY2lmaWVyID0gaXNNb2R1bGVTcGVjaWZpZXI7XG5leHBvcnRzLmlzRmxvdyA9IGlzRmxvdztcbmV4cG9ydHMuaXNGbG93VHlwZSA9IGlzRmxvd1R5cGU7XG5leHBvcnRzLmlzRmxvd0Jhc2VBbm5vdGF0aW9uID0gaXNGbG93QmFzZUFubm90YXRpb247XG5leHBvcnRzLmlzRmxvd0RlY2xhcmF0aW9uID0gaXNGbG93RGVjbGFyYXRpb247XG5leHBvcnRzLmlzRmxvd1ByZWRpY2F0ZSA9IGlzRmxvd1ByZWRpY2F0ZTtcbmV4cG9ydHMuaXNFbnVtQm9keSA9IGlzRW51bUJvZHk7XG5leHBvcnRzLmlzRW51bU1lbWJlciA9IGlzRW51bU1lbWJlcjtcbmV4cG9ydHMuaXNKU1ggPSBpc0pTWDtcbmV4cG9ydHMuaXNQcml2YXRlID0gaXNQcml2YXRlO1xuZXhwb3J0cy5pc1RTVHlwZUVsZW1lbnQgPSBpc1RTVHlwZUVsZW1lbnQ7XG5leHBvcnRzLmlzVFNUeXBlID0gaXNUU1R5cGU7XG5leHBvcnRzLmlzVFNCYXNlVHlwZSA9IGlzVFNCYXNlVHlwZTtcbmV4cG9ydHMuaXNOdW1iZXJMaXRlcmFsID0gaXNOdW1iZXJMaXRlcmFsO1xuZXhwb3J0cy5pc1JlZ2V4TGl0ZXJhbCA9IGlzUmVnZXhMaXRlcmFsO1xuZXhwb3J0cy5pc1Jlc3RQcm9wZXJ0eSA9IGlzUmVzdFByb3BlcnR5O1xuZXhwb3J0cy5pc1NwcmVhZFByb3BlcnR5ID0gaXNTcHJlYWRQcm9wZXJ0eTtcblxudmFyIF9zaGFsbG93RXF1YWwgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi91dGlscy9zaGFsbG93RXF1YWxcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBpc0FycmF5RXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiQXJyYXlFeHByZXNzaW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0Fzc2lnbm1lbnRFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNCaW5hcnlFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJCaW5hcnlFeHByZXNzaW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0ludGVycHJldGVyRGlyZWN0aXZlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJJbnRlcnByZXRlckRpcmVjdGl2ZVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNEaXJlY3RpdmUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkRpcmVjdGl2ZVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNEaXJlY3RpdmVMaXRlcmFsKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJEaXJlY3RpdmVMaXRlcmFsXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0Jsb2NrU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJCbG9ja1N0YXRlbWVudFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNCcmVha1N0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiQnJlYWtTdGF0ZW1lbnRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzQ2FsbEV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkNhbGxFeHByZXNzaW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0NhdGNoQ2xhdXNlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJDYXRjaENsYXVzZVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNDb25kaXRpb25hbEV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNDb250aW51ZVN0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiQ29udGludWVTdGF0ZW1lbnRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRGVidWdnZXJTdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkRlYnVnZ2VyU3RhdGVtZW50XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0RvV2hpbGVTdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkRvV2hpbGVTdGF0ZW1lbnRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRW1wdHlTdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkVtcHR5U3RhdGVtZW50XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0V4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRmlsZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRmlsZVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNGb3JJblN0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRm9ySW5TdGF0ZW1lbnRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRm9yU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJGb3JTdGF0ZW1lbnRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb25EZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbkV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNJZGVudGlmaWVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0lmU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJJZlN0YXRlbWVudFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNMYWJlbGVkU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJMYWJlbGVkU3RhdGVtZW50XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1N0cmluZ0xpdGVyYWwobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlN0cmluZ0xpdGVyYWxcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzTnVtZXJpY0xpdGVyYWwobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIk51bWVyaWNMaXRlcmFsXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc051bGxMaXRlcmFsKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJOdWxsTGl0ZXJhbFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNCb29sZWFuTGl0ZXJhbChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiQm9vbGVhbkxpdGVyYWxcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzUmVnRXhwTGl0ZXJhbChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiUmVnRXhwTGl0ZXJhbFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNMb2dpY2FsRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiTG9naWNhbEV4cHJlc3Npb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzTWVtYmVyRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNOZXdFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJOZXdFeHByZXNzaW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1Byb2dyYW0obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlByb2dyYW1cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0RXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiT2JqZWN0RXhwcmVzc2lvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3RNZXRob2Qobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIk9iamVjdE1ldGhvZFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3RQcm9wZXJ0eShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiT2JqZWN0UHJvcGVydHlcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzUmVzdEVsZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlJlc3RFbGVtZW50XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1JldHVyblN0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiUmV0dXJuU3RhdGVtZW50XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1NlcXVlbmNlRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiU2VxdWVuY2VFeHByZXNzaW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1BhcmVudGhlc2l6ZWRFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNTd2l0Y2hDYXNlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJTd2l0Y2hDYXNlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1N3aXRjaFN0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiU3dpdGNoU3RhdGVtZW50XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RoaXNFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUaGlzRXhwcmVzc2lvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUaHJvd1N0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVGhyb3dTdGF0ZW1lbnRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVHJ5U3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUcnlTdGF0ZW1lbnRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVW5hcnlFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJVbmFyeUV4cHJlc3Npb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVXBkYXRlRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVXBkYXRlRXhwcmVzc2lvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNWYXJpYWJsZURlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1ZhcmlhYmxlRGVjbGFyYXRvcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVmFyaWFibGVEZWNsYXJhdG9yXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1doaWxlU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJXaGlsZVN0YXRlbWVudFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNXaXRoU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJXaXRoU3RhdGVtZW50XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0Fzc2lnbm1lbnRQYXR0ZXJuKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJBc3NpZ25tZW50UGF0dGVyblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNBcnJheVBhdHRlcm4obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkFycmF5UGF0dGVyblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzQ2xhc3NCb2R5KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJDbGFzc0JvZHlcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzQ2xhc3NFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJDbGFzc0V4cHJlc3Npb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzQ2xhc3NEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiQ2xhc3NEZWNsYXJhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNFeHBvcnRBbGxEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRXhwb3J0TmFtZWREZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNFeHBvcnRTcGVjaWZpZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkV4cG9ydFNwZWNpZmllclwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNGb3JPZlN0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRm9yT2ZTdGF0ZW1lbnRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzSW1wb3J0RGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkltcG9ydERlY2xhcmF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0ltcG9ydERlZmF1bHRTcGVjaWZpZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzSW1wb3J0U3BlY2lmaWVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJJbXBvcnRTcGVjaWZpZXJcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzTWV0YVByb3BlcnR5KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJNZXRhUHJvcGVydHlcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzQ2xhc3NNZXRob2Qobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkNsYXNzTWV0aG9kXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdFBhdHRlcm4obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIk9iamVjdFBhdHRlcm5cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzU3ByZWFkRWxlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiU3ByZWFkRWxlbWVudFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNTdXBlcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiU3VwZXJcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVGVtcGxhdGVFbGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUZW1wbGF0ZUVsZW1lbnRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVGVtcGxhdGVMaXRlcmFsKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUZW1wbGF0ZUxpdGVyYWxcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzWWllbGRFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJZaWVsZEV4cHJlc3Npb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzQXdhaXRFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJBd2FpdEV4cHJlc3Npb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzSW1wb3J0KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJJbXBvcnRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzQmlnSW50TGl0ZXJhbChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiQmlnSW50TGl0ZXJhbFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkV4cG9ydE5hbWVzcGFjZVNwZWNpZmllclwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNPcHRpb25hbE1lbWJlckV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNPcHRpb25hbENhbGxFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0FueVR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJBbnlUeXBlQW5ub3RhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNBcnJheVR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJBcnJheVR5cGVBbm5vdGF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0Jvb2xlYW5UeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiQm9vbGVhblR5cGVBbm5vdGF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0Jvb2xlYW5MaXRlcmFsVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkJvb2xlYW5MaXRlcmFsVHlwZUFubm90YXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzTnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiTnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNDbGFzc0ltcGxlbWVudHMobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkNsYXNzSW1wbGVtZW50c1wiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNEZWNsYXJlQ2xhc3Mobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkRlY2xhcmVDbGFzc1wiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNEZWNsYXJlRnVuY3Rpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkRlY2xhcmVGdW5jdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNEZWNsYXJlSW50ZXJmYWNlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJEZWNsYXJlSW50ZXJmYWNlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0RlY2xhcmVNb2R1bGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkRlY2xhcmVNb2R1bGVcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRGVjbGFyZU1vZHVsZUV4cG9ydHMobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkRlY2xhcmVNb2R1bGVFeHBvcnRzXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0RlY2xhcmVUeXBlQWxpYXMobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkRlY2xhcmVUeXBlQWxpYXNcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRGVjbGFyZU9wYXF1ZVR5cGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkRlY2xhcmVPcGFxdWVUeXBlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0RlY2xhcmVWYXJpYWJsZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRGVjbGFyZVZhcmlhYmxlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0RlY2xhcmVFeHBvcnREZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0RlY2xhcmVFeHBvcnRBbGxEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0RlY2xhcmVkUHJlZGljYXRlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJEZWNsYXJlZFByZWRpY2F0ZVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNFeGlzdHNUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRXhpc3RzVHlwZUFubm90YXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb25UeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvblR5cGVQYXJhbShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRnVuY3Rpb25UeXBlUGFyYW1cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzR2VuZXJpY1R5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJHZW5lcmljVHlwZUFubm90YXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzSW5mZXJyZWRQcmVkaWNhdGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkluZmVycmVkUHJlZGljYXRlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0ludGVyZmFjZUV4dGVuZHMobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkludGVyZmFjZUV4dGVuZHNcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzSW50ZXJmYWNlRGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkludGVyZmFjZURlY2xhcmF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0ludGVyZmFjZVR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJJbnRlcmZhY2VUeXBlQW5ub3RhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiSW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzTWl4ZWRUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiTWl4ZWRUeXBlQW5ub3RhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNFbXB0eVR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJFbXB0eVR5cGVBbm5vdGF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc051bGxhYmxlVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIk51bGxhYmxlVHlwZUFubm90YXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJOdW1iZXJMaXRlcmFsVHlwZUFubm90YXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIk51bWJlclR5cGVBbm5vdGF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdFR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJPYmplY3RUeXBlQW5ub3RhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3RUeXBlSW50ZXJuYWxTbG90KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJPYmplY3RUeXBlSW50ZXJuYWxTbG90XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdFR5cGVDYWxsUHJvcGVydHkobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIk9iamVjdFR5cGVDYWxsUHJvcGVydHlcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0VHlwZUluZGV4ZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIk9iamVjdFR5cGVJbmRleGVyXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdFR5cGVQcm9wZXJ0eShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiT2JqZWN0VHlwZVByb3BlcnR5XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiT2JqZWN0VHlwZVNwcmVhZFByb3BlcnR5XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc09wYXF1ZVR5cGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIk9wYXF1ZVR5cGVcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzUXVhbGlmaWVkVHlwZUlkZW50aWZpZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlF1YWxpZmllZFR5cGVJZGVudGlmaWVyXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1N0cmluZ0xpdGVyYWxUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiU3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1N0cmluZ1R5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJTdHJpbmdUeXBlQW5ub3RhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNTeW1ib2xUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiU3ltYm9sVHlwZUFubm90YXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVGhpc1R5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUaGlzVHlwZUFubm90YXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVHVwbGVUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVHVwbGVUeXBlQW5ub3RhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUeXBlb2ZUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVHlwZW9mVHlwZUFubm90YXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVHlwZUFsaWFzKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUeXBlQWxpYXNcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlR5cGVBbm5vdGF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1R5cGVDYXN0RXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVHlwZUNhc3RFeHByZXNzaW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1R5cGVQYXJhbWV0ZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlR5cGVQYXJhbWV0ZXJcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1VuaW9uVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlVuaW9uVHlwZUFubm90YXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVmFyaWFuY2Uobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlZhcmlhbmNlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1ZvaWRUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVm9pZFR5cGVBbm5vdGF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0VudW1EZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRW51bURlY2xhcmF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0VudW1Cb29sZWFuQm9keShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRW51bUJvb2xlYW5Cb2R5XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0VudW1OdW1iZXJCb2R5KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJFbnVtTnVtYmVyQm9keVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNFbnVtU3RyaW5nQm9keShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRW51bVN0cmluZ0JvZHlcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRW51bVN5bWJvbEJvZHkobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkVudW1TeW1ib2xCb2R5XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0VudW1Cb29sZWFuTWVtYmVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJFbnVtQm9vbGVhbk1lbWJlclwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNFbnVtTnVtYmVyTWVtYmVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJFbnVtTnVtYmVyTWVtYmVyXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0VudW1TdHJpbmdNZW1iZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkVudW1TdHJpbmdNZW1iZXJcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRW51bURlZmF1bHRlZE1lbWJlcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRW51bURlZmF1bHRlZE1lbWJlclwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNKU1hBdHRyaWJ1dGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkpTWEF0dHJpYnV0ZVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNKU1hDbG9zaW5nRWxlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiSlNYQ2xvc2luZ0VsZW1lbnRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzSlNYRWxlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiSlNYRWxlbWVudFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNKU1hFbXB0eUV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkpTWEVtcHR5RXhwcmVzc2lvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNKU1hFeHByZXNzaW9uQ29udGFpbmVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJKU1hFeHByZXNzaW9uQ29udGFpbmVyXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0pTWFNwcmVhZENoaWxkKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJKU1hTcHJlYWRDaGlsZFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNKU1hJZGVudGlmaWVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJKU1hJZGVudGlmaWVyXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0pTWE1lbWJlckV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkpTWE1lbWJlckV4cHJlc3Npb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzSlNYTmFtZXNwYWNlZE5hbWUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkpTWE5hbWVzcGFjZWROYW1lXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0pTWE9wZW5pbmdFbGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJKU1hPcGVuaW5nRWxlbWVudFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNKU1hTcHJlYWRBdHRyaWJ1dGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkpTWFNwcmVhZEF0dHJpYnV0ZVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNKU1hUZXh0KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJKU1hUZXh0XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0pTWEZyYWdtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJKU1hGcmFnbWVudFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNKU1hPcGVuaW5nRnJhZ21lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkpTWE9wZW5pbmdGcmFnbWVudFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNKU1hDbG9zaW5nRnJhZ21lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkpTWENsb3NpbmdGcmFnbWVudFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNOb29wKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJOb29wXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1BsYWNlaG9sZGVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJQbGFjZWhvbGRlclwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNWOEludHJpbnNpY0lkZW50aWZpZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlY4SW50cmluc2ljSWRlbnRpZmllclwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNBcmd1bWVudFBsYWNlaG9sZGVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJBcmd1bWVudFBsYWNlaG9sZGVyXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0JpbmRFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJCaW5kRXhwcmVzc2lvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNDbGFzc1Byb3BlcnR5KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJDbGFzc1Byb3BlcnR5XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1BpcGVsaW5lVG9waWNFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJQaXBlbGluZVRvcGljRXhwcmVzc2lvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNQaXBlbGluZUJhcmVGdW5jdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiUGlwZWxpbmVCYXJlRnVuY3Rpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzUGlwZWxpbmVQcmltYXJ5VG9waWNSZWZlcmVuY2Uobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlBpcGVsaW5lUHJpbWFyeVRvcGljUmVmZXJlbmNlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0NsYXNzUHJpdmF0ZVByb3BlcnR5KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJDbGFzc1ByaXZhdGVQcm9wZXJ0eVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNDbGFzc1ByaXZhdGVNZXRob2Qobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkNsYXNzUHJpdmF0ZU1ldGhvZFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNJbXBvcnRBdHRyaWJ1dGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkltcG9ydEF0dHJpYnV0ZVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNEZWNvcmF0b3Iobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkRlY29yYXRvclwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNEb0V4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkRvRXhwcmVzc2lvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNFeHBvcnREZWZhdWx0U3BlY2lmaWVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJFeHBvcnREZWZhdWx0U3BlY2lmaWVyXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1ByaXZhdGVOYW1lKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJQcml2YXRlTmFtZVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNSZWNvcmRFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJSZWNvcmRFeHByZXNzaW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1R1cGxlRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVHVwbGVFeHByZXNzaW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0RlY2ltYWxMaXRlcmFsKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJEZWNpbWFsTGl0ZXJhbFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU1BhcmFtZXRlclByb3BlcnR5KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU1BhcmFtZXRlclByb3BlcnR5XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTRGVjbGFyZUZ1bmN0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU0RlY2xhcmVGdW5jdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU0RlY2xhcmVNZXRob2Qobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTRGVjbGFyZU1ldGhvZFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU1F1YWxpZmllZE5hbWUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTUXVhbGlmaWVkTmFtZVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNDYWxsU2lnbmF0dXJlRGVjbGFyYXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU1Byb3BlcnR5U2lnbmF0dXJlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU1Byb3BlcnR5U2lnbmF0dXJlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTTWV0aG9kU2lnbmF0dXJlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU01ldGhvZFNpZ25hdHVyZVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU0luZGV4U2lnbmF0dXJlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU0luZGV4U2lnbmF0dXJlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTQW55S2V5d29yZChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNBbnlLZXl3b3JkXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTQm9vbGVhbktleXdvcmQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTQm9vbGVhbktleXdvcmRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNCaWdJbnRLZXl3b3JkKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU0JpZ0ludEtleXdvcmRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNOZXZlcktleXdvcmQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTTmV2ZXJLZXl3b3JkXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTTnVsbEtleXdvcmQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTTnVsbEtleXdvcmRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNOdW1iZXJLZXl3b3JkKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU051bWJlcktleXdvcmRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNPYmplY3RLZXl3b3JkKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU09iamVjdEtleXdvcmRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNTdHJpbmdLZXl3b3JkKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU1N0cmluZ0tleXdvcmRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNTeW1ib2xLZXl3b3JkKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU1N5bWJvbEtleXdvcmRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNVbmRlZmluZWRLZXl3b3JkKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU1VuZGVmaW5lZEtleXdvcmRcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNVbmtub3duS2V5d29yZChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNVbmtub3duS2V5d29yZFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU1ZvaWRLZXl3b3JkKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU1ZvaWRLZXl3b3JkXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTVGhpc1R5cGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTVGhpc1R5cGVcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNGdW5jdGlvblR5cGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTRnVuY3Rpb25UeXBlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTQ29uc3RydWN0b3JUeXBlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU0NvbnN0cnVjdG9yVHlwZVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU1R5cGVSZWZlcmVuY2Uobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTVHlwZVJlZmVyZW5jZVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU1R5cGVQcmVkaWNhdGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTVHlwZVByZWRpY2F0ZVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU1R5cGVRdWVyeShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNUeXBlUXVlcnlcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNUeXBlTGl0ZXJhbChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNUeXBlTGl0ZXJhbFwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU0FycmF5VHlwZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNBcnJheVR5cGVcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNUdXBsZVR5cGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTVHVwbGVUeXBlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTT3B0aW9uYWxUeXBlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU09wdGlvbmFsVHlwZVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU1Jlc3RUeXBlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU1Jlc3RUeXBlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTTmFtZWRUdXBsZU1lbWJlcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNOYW1lZFR1cGxlTWVtYmVyXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTVW5pb25UeXBlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU1VuaW9uVHlwZVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU0ludGVyc2VjdGlvblR5cGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTSW50ZXJzZWN0aW9uVHlwZVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU0NvbmRpdGlvbmFsVHlwZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNDb25kaXRpb25hbFR5cGVcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNJbmZlclR5cGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTSW5mZXJUeXBlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTUGFyZW50aGVzaXplZFR5cGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTUGFyZW50aGVzaXplZFR5cGVcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNUeXBlT3BlcmF0b3Iobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTVHlwZU9wZXJhdG9yXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTSW5kZXhlZEFjY2Vzc1R5cGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTSW5kZXhlZEFjY2Vzc1R5cGVcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNNYXBwZWRUeXBlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU01hcHBlZFR5cGVcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNMaXRlcmFsVHlwZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNMaXRlcmFsVHlwZVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU0V4cHJlc3Npb25XaXRoVHlwZUFyZ3VtZW50cyhub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNFeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHNcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNJbnRlcmZhY2VEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNJbnRlcmZhY2VEZWNsYXJhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU0ludGVyZmFjZUJvZHkobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTSW50ZXJmYWNlQm9keVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU1R5cGVBbGlhc0RlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU1R5cGVBbGlhc0RlY2xhcmF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTQXNFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU0FzRXhwcmVzc2lvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU1R5cGVBc3NlcnRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTVHlwZUFzc2VydGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU0VudW1EZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNFbnVtRGVjbGFyYXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNFbnVtTWVtYmVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU0VudW1NZW1iZXJcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNNb2R1bGVEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNNb2R1bGVEZWNsYXJhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU01vZHVsZUJsb2NrKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU01vZHVsZUJsb2NrXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTSW1wb3J0VHlwZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNJbXBvcnRUeXBlXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTSW1wb3J0RXF1YWxzRGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTSW1wb3J0RXF1YWxzRGVjbGFyYXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZVwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU05vbk51bGxFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU05vbk51bGxFeHByZXNzaW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTRXhwb3J0QXNzaWdubWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNFeHBvcnRBc3NpZ25tZW50XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb25cIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNUeXBlQW5ub3RhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNUU1R5cGVQYXJhbWV0ZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTVHlwZVBhcmFtZXRlclwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJFeHByZXNzaW9uXCIgfHwgXCJBcnJheUV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIkJpbmFyeUV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJDYWxsRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIklkZW50aWZpZXJcIiA9PT0gbm9kZVR5cGUgfHwgXCJTdHJpbmdMaXRlcmFsXCIgPT09IG5vZGVUeXBlIHx8IFwiTnVtZXJpY0xpdGVyYWxcIiA9PT0gbm9kZVR5cGUgfHwgXCJOdWxsTGl0ZXJhbFwiID09PSBub2RlVHlwZSB8fCBcIkJvb2xlYW5MaXRlcmFsXCIgPT09IG5vZGVUeXBlIHx8IFwiUmVnRXhwTGl0ZXJhbFwiID09PSBub2RlVHlwZSB8fCBcIkxvZ2ljYWxFeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiTWVtYmVyRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIk5ld0V4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJPYmplY3RFeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiU2VxdWVuY2VFeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJUaGlzRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIlVuYXJ5RXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIlVwZGF0ZUV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIkNsYXNzRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIk1ldGFQcm9wZXJ0eVwiID09PSBub2RlVHlwZSB8fCBcIlN1cGVyXCIgPT09IG5vZGVUeXBlIHx8IFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiVGVtcGxhdGVMaXRlcmFsXCIgPT09IG5vZGVUeXBlIHx8IFwiWWllbGRFeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiQXdhaXRFeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiSW1wb3J0XCIgPT09IG5vZGVUeXBlIHx8IFwiQmlnSW50TGl0ZXJhbFwiID09PSBub2RlVHlwZSB8fCBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJUeXBlQ2FzdEV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJKU1hFbGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiSlNYRnJhZ21lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJCaW5kRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIlBpcGVsaW5lUHJpbWFyeVRvcGljUmVmZXJlbmNlXCIgPT09IG5vZGVUeXBlIHx8IFwiRG9FeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiUmVjb3JkRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIlR1cGxlRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIkRlY2ltYWxMaXRlcmFsXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNBc0V4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJUU1R5cGVBc3NlcnRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJUU05vbk51bGxFeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IG5vZGVUeXBlID09PSBcIlBsYWNlaG9sZGVyXCIgJiYgKFwiRXhwcmVzc2lvblwiID09PSBub2RlLmV4cGVjdGVkTm9kZSB8fCBcIklkZW50aWZpZXJcIiA9PT0gbm9kZS5leHBlY3RlZE5vZGUgfHwgXCJTdHJpbmdMaXRlcmFsXCIgPT09IG5vZGUuZXhwZWN0ZWROb2RlKSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzQmluYXJ5KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJCaW5hcnlcIiB8fCBcIkJpbmFyeUV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJMb2dpY2FsRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzU2NvcGFibGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlNjb3BhYmxlXCIgfHwgXCJCbG9ja1N0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkNhdGNoQ2xhdXNlXCIgPT09IG5vZGVUeXBlIHx8IFwiRG9XaGlsZVN0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkZvckluU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiRm9yU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIlByb2dyYW1cIiA9PT0gbm9kZVR5cGUgfHwgXCJPYmplY3RNZXRob2RcIiA9PT0gbm9kZVR5cGUgfHwgXCJTd2l0Y2hTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJXaGlsZVN0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiQ2xhc3NFeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiQ2xhc3NEZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkZvck9mU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiQ2xhc3NNZXRob2RcIiA9PT0gbm9kZVR5cGUgfHwgXCJDbGFzc1ByaXZhdGVNZXRob2RcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU01vZHVsZUJsb2NrXCIgPT09IG5vZGVUeXBlIHx8IG5vZGVUeXBlID09PSBcIlBsYWNlaG9sZGVyXCIgJiYgXCJCbG9ja1N0YXRlbWVudFwiID09PSBub2RlLmV4cGVjdGVkTm9kZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzQmxvY2tQYXJlbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkJsb2NrUGFyZW50XCIgfHwgXCJCbG9ja1N0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkNhdGNoQ2xhdXNlXCIgPT09IG5vZGVUeXBlIHx8IFwiRG9XaGlsZVN0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkZvckluU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiRm9yU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIlByb2dyYW1cIiA9PT0gbm9kZVR5cGUgfHwgXCJPYmplY3RNZXRob2RcIiA9PT0gbm9kZVR5cGUgfHwgXCJTd2l0Y2hTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJXaGlsZVN0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiRm9yT2ZTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJDbGFzc01ldGhvZFwiID09PSBub2RlVHlwZSB8fCBcIkNsYXNzUHJpdmF0ZU1ldGhvZFwiID09PSBub2RlVHlwZSB8fCBcIlRTTW9kdWxlQmxvY2tcIiA9PT0gbm9kZVR5cGUgfHwgbm9kZVR5cGUgPT09IFwiUGxhY2Vob2xkZXJcIiAmJiBcIkJsb2NrU3RhdGVtZW50XCIgPT09IG5vZGUuZXhwZWN0ZWROb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNCbG9jayhub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiQmxvY2tcIiB8fCBcIkJsb2NrU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiUHJvZ3JhbVwiID09PSBub2RlVHlwZSB8fCBcIlRTTW9kdWxlQmxvY2tcIiA9PT0gbm9kZVR5cGUgfHwgbm9kZVR5cGUgPT09IFwiUGxhY2Vob2xkZXJcIiAmJiBcIkJsb2NrU3RhdGVtZW50XCIgPT09IG5vZGUuZXhwZWN0ZWROb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNTdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlN0YXRlbWVudFwiIHx8IFwiQmxvY2tTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJCcmVha1N0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkNvbnRpbnVlU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiRGVidWdnZXJTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJEb1doaWxlU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiRW1wdHlTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJFeHByZXNzaW9uU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiRm9ySW5TdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJGb3JTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiSWZTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJMYWJlbGVkU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiUmV0dXJuU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiU3dpdGNoU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiVGhyb3dTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJUcnlTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiV2hpbGVTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJXaXRoU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiQ2xhc3NEZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkZvck9mU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiSW1wb3J0RGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJEZWNsYXJlQ2xhc3NcIiA9PT0gbm9kZVR5cGUgfHwgXCJEZWNsYXJlRnVuY3Rpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJEZWNsYXJlSW50ZXJmYWNlXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZU1vZHVsZVwiID09PSBub2RlVHlwZSB8fCBcIkRlY2xhcmVNb2R1bGVFeHBvcnRzXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZVR5cGVBbGlhc1wiID09PSBub2RlVHlwZSB8fCBcIkRlY2xhcmVPcGFxdWVUeXBlXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZVZhcmlhYmxlXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiSW50ZXJmYWNlRGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJPcGFxdWVUeXBlXCIgPT09IG5vZGVUeXBlIHx8IFwiVHlwZUFsaWFzXCIgPT09IG5vZGVUeXBlIHx8IFwiRW51bURlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNEZWNsYXJlRnVuY3Rpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJUU0ludGVyZmFjZURlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNUeXBlQWxpYXNEZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIlRTRW51bURlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNNb2R1bGVEZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIlRTSW1wb3J0RXF1YWxzRGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJUU0V4cG9ydEFzc2lnbm1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU05hbWVzcGFjZUV4cG9ydERlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IG5vZGVUeXBlID09PSBcIlBsYWNlaG9sZGVyXCIgJiYgKFwiU3RhdGVtZW50XCIgPT09IG5vZGUuZXhwZWN0ZWROb2RlIHx8IFwiRGVjbGFyYXRpb25cIiA9PT0gbm9kZS5leHBlY3RlZE5vZGUgfHwgXCJCbG9ja1N0YXRlbWVudFwiID09PSBub2RlLmV4cGVjdGVkTm9kZSkpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1Rlcm1pbmF0b3JsZXNzKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUZXJtaW5hdG9ybGVzc1wiIHx8IFwiQnJlYWtTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJDb250aW51ZVN0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIlJldHVyblN0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIlRocm93U3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiWWllbGRFeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiQXdhaXRFeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNDb21wbGV0aW9uU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJDb21wbGV0aW9uU3RhdGVtZW50XCIgfHwgXCJCcmVha1N0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkNvbnRpbnVlU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiUmV0dXJuU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiVGhyb3dTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0NvbmRpdGlvbmFsKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJDb25kaXRpb25hbFwiIHx8IFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiSWZTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0xvb3Aobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkxvb3BcIiB8fCBcIkRvV2hpbGVTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJGb3JJblN0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkZvclN0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIldoaWxlU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiRm9yT2ZTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1doaWxlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJXaGlsZVwiIHx8IFwiRG9XaGlsZVN0YXRlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIldoaWxlU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNFeHByZXNzaW9uV3JhcHBlcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRXhwcmVzc2lvbldyYXBwZXJcIiB8fCBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIlR5cGVDYXN0RXhwcmVzc2lvblwiID09PSBub2RlVHlwZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRm9yKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJGb3JcIiB8fCBcIkZvckluU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiRm9yU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiRm9yT2ZTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0ZvclhTdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkZvclhTdGF0ZW1lbnRcIiB8fCBcIkZvckluU3RhdGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiRm9yT2ZTdGF0ZW1lbnRcIiA9PT0gbm9kZVR5cGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJGdW5jdGlvblwiIHx8IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIk9iamVjdE1ldGhvZFwiID09PSBub2RlVHlwZSB8fCBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiQ2xhc3NNZXRob2RcIiA9PT0gbm9kZVR5cGUgfHwgXCJDbGFzc1ByaXZhdGVNZXRob2RcIiA9PT0gbm9kZVR5cGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uUGFyZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJGdW5jdGlvblBhcmVudFwiIHx8IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIk9iamVjdE1ldGhvZFwiID09PSBub2RlVHlwZSB8fCBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiQ2xhc3NNZXRob2RcIiA9PT0gbm9kZVR5cGUgfHwgXCJDbGFzc1ByaXZhdGVNZXRob2RcIiA9PT0gbm9kZVR5cGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1B1cmVpc2gobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlB1cmVpc2hcIiB8fCBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJGdW5jdGlvbkV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJTdHJpbmdMaXRlcmFsXCIgPT09IG5vZGVUeXBlIHx8IFwiTnVtZXJpY0xpdGVyYWxcIiA9PT0gbm9kZVR5cGUgfHwgXCJOdWxsTGl0ZXJhbFwiID09PSBub2RlVHlwZSB8fCBcIkJvb2xlYW5MaXRlcmFsXCIgPT09IG5vZGVUeXBlIHx8IFwiUmVnRXhwTGl0ZXJhbFwiID09PSBub2RlVHlwZSB8fCBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiQmlnSW50TGl0ZXJhbFwiID09PSBub2RlVHlwZSB8fCBcIkRlY2ltYWxMaXRlcmFsXCIgPT09IG5vZGVUeXBlIHx8IG5vZGVUeXBlID09PSBcIlBsYWNlaG9sZGVyXCIgJiYgXCJTdHJpbmdMaXRlcmFsXCIgPT09IG5vZGUuZXhwZWN0ZWROb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRGVjbGFyYXRpb25cIiB8fCBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiQ2xhc3NEZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkltcG9ydERlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZUNsYXNzXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZUZ1bmN0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZUludGVyZmFjZVwiID09PSBub2RlVHlwZSB8fCBcIkRlY2xhcmVNb2R1bGVcIiA9PT0gbm9kZVR5cGUgfHwgXCJEZWNsYXJlTW9kdWxlRXhwb3J0c1wiID09PSBub2RlVHlwZSB8fCBcIkRlY2xhcmVUeXBlQWxpYXNcIiA9PT0gbm9kZVR5cGUgfHwgXCJEZWNsYXJlT3BhcXVlVHlwZVwiID09PSBub2RlVHlwZSB8fCBcIkRlY2xhcmVWYXJpYWJsZVwiID09PSBub2RlVHlwZSB8fCBcIkRlY2xhcmVFeHBvcnREZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkRlY2xhcmVFeHBvcnRBbGxEZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkludGVyZmFjZURlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiT3BhcXVlVHlwZVwiID09PSBub2RlVHlwZSB8fCBcIlR5cGVBbGlhc1wiID09PSBub2RlVHlwZSB8fCBcIkVudW1EZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIlRTRGVjbGFyZUZ1bmN0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNJbnRlcmZhY2VEZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIlRTVHlwZUFsaWFzRGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJUU0VudW1EZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIlRTTW9kdWxlRGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgbm9kZVR5cGUgPT09IFwiUGxhY2Vob2xkZXJcIiAmJiBcIkRlY2xhcmF0aW9uXCIgPT09IG5vZGUuZXhwZWN0ZWROb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNQYXR0ZXJuTGlrZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiUGF0dGVybkxpa2VcIiB8fCBcIklkZW50aWZpZXJcIiA9PT0gbm9kZVR5cGUgfHwgXCJSZXN0RWxlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIgPT09IG5vZGVUeXBlIHx8IFwiQXJyYXlQYXR0ZXJuXCIgPT09IG5vZGVUeXBlIHx8IFwiT2JqZWN0UGF0dGVyblwiID09PSBub2RlVHlwZSB8fCBub2RlVHlwZSA9PT0gXCJQbGFjZWhvbGRlclwiICYmIChcIlBhdHRlcm5cIiA9PT0gbm9kZS5leHBlY3RlZE5vZGUgfHwgXCJJZGVudGlmaWVyXCIgPT09IG5vZGUuZXhwZWN0ZWROb2RlKSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzTFZhbChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiTFZhbFwiIHx8IFwiSWRlbnRpZmllclwiID09PSBub2RlVHlwZSB8fCBcIk1lbWJlckV4cHJlc3Npb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJSZXN0RWxlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIgPT09IG5vZGVUeXBlIHx8IFwiQXJyYXlQYXR0ZXJuXCIgPT09IG5vZGVUeXBlIHx8IFwiT2JqZWN0UGF0dGVyblwiID09PSBub2RlVHlwZSB8fCBcIlRTUGFyYW1ldGVyUHJvcGVydHlcIiA9PT0gbm9kZVR5cGUgfHwgbm9kZVR5cGUgPT09IFwiUGxhY2Vob2xkZXJcIiAmJiAoXCJQYXR0ZXJuXCIgPT09IG5vZGUuZXhwZWN0ZWROb2RlIHx8IFwiSWRlbnRpZmllclwiID09PSBub2RlLmV4cGVjdGVkTm9kZSkpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTRW50aXR5TmFtZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNFbnRpdHlOYW1lXCIgfHwgXCJJZGVudGlmaWVyXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNRdWFsaWZpZWROYW1lXCIgPT09IG5vZGVUeXBlIHx8IG5vZGVUeXBlID09PSBcIlBsYWNlaG9sZGVyXCIgJiYgXCJJZGVudGlmaWVyXCIgPT09IG5vZGUuZXhwZWN0ZWROb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNMaXRlcmFsKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJMaXRlcmFsXCIgfHwgXCJTdHJpbmdMaXRlcmFsXCIgPT09IG5vZGVUeXBlIHx8IFwiTnVtZXJpY0xpdGVyYWxcIiA9PT0gbm9kZVR5cGUgfHwgXCJOdWxsTGl0ZXJhbFwiID09PSBub2RlVHlwZSB8fCBcIkJvb2xlYW5MaXRlcmFsXCIgPT09IG5vZGVUeXBlIHx8IFwiUmVnRXhwTGl0ZXJhbFwiID09PSBub2RlVHlwZSB8fCBcIlRlbXBsYXRlTGl0ZXJhbFwiID09PSBub2RlVHlwZSB8fCBcIkJpZ0ludExpdGVyYWxcIiA9PT0gbm9kZVR5cGUgfHwgXCJEZWNpbWFsTGl0ZXJhbFwiID09PSBub2RlVHlwZSB8fCBub2RlVHlwZSA9PT0gXCJQbGFjZWhvbGRlclwiICYmIFwiU3RyaW5nTGl0ZXJhbFwiID09PSBub2RlLmV4cGVjdGVkTm9kZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzSW1tdXRhYmxlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJJbW11dGFibGVcIiB8fCBcIlN0cmluZ0xpdGVyYWxcIiA9PT0gbm9kZVR5cGUgfHwgXCJOdW1lcmljTGl0ZXJhbFwiID09PSBub2RlVHlwZSB8fCBcIk51bGxMaXRlcmFsXCIgPT09IG5vZGVUeXBlIHx8IFwiQm9vbGVhbkxpdGVyYWxcIiA9PT0gbm9kZVR5cGUgfHwgXCJCaWdJbnRMaXRlcmFsXCIgPT09IG5vZGVUeXBlIHx8IFwiSlNYQXR0cmlidXRlXCIgPT09IG5vZGVUeXBlIHx8IFwiSlNYQ2xvc2luZ0VsZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJKU1hFbGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiID09PSBub2RlVHlwZSB8fCBcIkpTWFNwcmVhZENoaWxkXCIgPT09IG5vZGVUeXBlIHx8IFwiSlNYT3BlbmluZ0VsZW1lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJKU1hUZXh0XCIgPT09IG5vZGVUeXBlIHx8IFwiSlNYRnJhZ21lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJKU1hPcGVuaW5nRnJhZ21lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJKU1hDbG9zaW5nRnJhZ21lbnRcIiA9PT0gbm9kZVR5cGUgfHwgXCJEZWNpbWFsTGl0ZXJhbFwiID09PSBub2RlVHlwZSB8fCBub2RlVHlwZSA9PT0gXCJQbGFjZWhvbGRlclwiICYmIFwiU3RyaW5nTGl0ZXJhbFwiID09PSBub2RlLmV4cGVjdGVkTm9kZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVXNlcldoaXRlc3BhY2FibGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlVzZXJXaGl0ZXNwYWNhYmxlXCIgfHwgXCJPYmplY3RNZXRob2RcIiA9PT0gbm9kZVR5cGUgfHwgXCJPYmplY3RQcm9wZXJ0eVwiID09PSBub2RlVHlwZSB8fCBcIk9iamVjdFR5cGVJbnRlcm5hbFNsb3RcIiA9PT0gbm9kZVR5cGUgfHwgXCJPYmplY3RUeXBlQ2FsbFByb3BlcnR5XCIgPT09IG5vZGVUeXBlIHx8IFwiT2JqZWN0VHlwZUluZGV4ZXJcIiA9PT0gbm9kZVR5cGUgfHwgXCJPYmplY3RUeXBlUHJvcGVydHlcIiA9PT0gbm9kZVR5cGUgfHwgXCJPYmplY3RUeXBlU3ByZWFkUHJvcGVydHlcIiA9PT0gbm9kZVR5cGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc01ldGhvZChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiTWV0aG9kXCIgfHwgXCJPYmplY3RNZXRob2RcIiA9PT0gbm9kZVR5cGUgfHwgXCJDbGFzc01ldGhvZFwiID09PSBub2RlVHlwZSB8fCBcIkNsYXNzUHJpdmF0ZU1ldGhvZFwiID09PSBub2RlVHlwZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0TWVtYmVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJPYmplY3RNZW1iZXJcIiB8fCBcIk9iamVjdE1ldGhvZFwiID09PSBub2RlVHlwZSB8fCBcIk9iamVjdFByb3BlcnR5XCIgPT09IG5vZGVUeXBlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNQcm9wZXJ0eShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiUHJvcGVydHlcIiB8fCBcIk9iamVjdFByb3BlcnR5XCIgPT09IG5vZGVUeXBlIHx8IFwiQ2xhc3NQcm9wZXJ0eVwiID09PSBub2RlVHlwZSB8fCBcIkNsYXNzUHJpdmF0ZVByb3BlcnR5XCIgPT09IG5vZGVUeXBlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNVbmFyeUxpa2Uobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlVuYXJ5TGlrZVwiIHx8IFwiVW5hcnlFeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiU3ByZWFkRWxlbWVudFwiID09PSBub2RlVHlwZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzUGF0dGVybihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiUGF0dGVyblwiIHx8IFwiQXNzaWdubWVudFBhdHRlcm5cIiA9PT0gbm9kZVR5cGUgfHwgXCJBcnJheVBhdHRlcm5cIiA9PT0gbm9kZVR5cGUgfHwgXCJPYmplY3RQYXR0ZXJuXCIgPT09IG5vZGVUeXBlIHx8IG5vZGVUeXBlID09PSBcIlBsYWNlaG9sZGVyXCIgJiYgXCJQYXR0ZXJuXCIgPT09IG5vZGUuZXhwZWN0ZWROb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNDbGFzcyhub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiQ2xhc3NcIiB8fCBcIkNsYXNzRXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIkNsYXNzRGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc01vZHVsZURlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJNb2R1bGVEZWNsYXJhdGlvblwiIHx8IFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiSW1wb3J0RGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0V4cG9ydERlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJFeHBvcnREZWNsYXJhdGlvblwiIHx8IFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNNb2R1bGVTcGVjaWZpZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIk1vZHVsZVNwZWNpZmllclwiIHx8IFwiRXhwb3J0U3BlY2lmaWVyXCIgPT09IG5vZGVUeXBlIHx8IFwiSW1wb3J0RGVmYXVsdFNwZWNpZmllclwiID09PSBub2RlVHlwZSB8fCBcIkltcG9ydE5hbWVzcGFjZVNwZWNpZmllclwiID09PSBub2RlVHlwZSB8fCBcIkltcG9ydFNwZWNpZmllclwiID09PSBub2RlVHlwZSB8fCBcIkV4cG9ydE5hbWVzcGFjZVNwZWNpZmllclwiID09PSBub2RlVHlwZSB8fCBcIkV4cG9ydERlZmF1bHRTcGVjaWZpZXJcIiA9PT0gbm9kZVR5cGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0Zsb3cobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkZsb3dcIiB8fCBcIkFueVR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiQXJyYXlUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkJvb2xlYW5UeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkJvb2xlYW5MaXRlcmFsVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJOdWxsTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiQ2xhc3NJbXBsZW1lbnRzXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZUNsYXNzXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZUZ1bmN0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZUludGVyZmFjZVwiID09PSBub2RlVHlwZSB8fCBcIkRlY2xhcmVNb2R1bGVcIiA9PT0gbm9kZVR5cGUgfHwgXCJEZWNsYXJlTW9kdWxlRXhwb3J0c1wiID09PSBub2RlVHlwZSB8fCBcIkRlY2xhcmVUeXBlQWxpYXNcIiA9PT0gbm9kZVR5cGUgfHwgXCJEZWNsYXJlT3BhcXVlVHlwZVwiID09PSBub2RlVHlwZSB8fCBcIkRlY2xhcmVWYXJpYWJsZVwiID09PSBub2RlVHlwZSB8fCBcIkRlY2xhcmVFeHBvcnREZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkRlY2xhcmVFeHBvcnRBbGxEZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkRlY2xhcmVkUHJlZGljYXRlXCIgPT09IG5vZGVUeXBlIHx8IFwiRXhpc3RzVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiRnVuY3Rpb25UeXBlUGFyYW1cIiA9PT0gbm9kZVR5cGUgfHwgXCJHZW5lcmljVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJJbmZlcnJlZFByZWRpY2F0ZVwiID09PSBub2RlVHlwZSB8fCBcIkludGVyZmFjZUV4dGVuZHNcIiA9PT0gbm9kZVR5cGUgfHwgXCJJbnRlcmZhY2VEZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkludGVyZmFjZVR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiSW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJNaXhlZFR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiRW1wdHlUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIk51bGxhYmxlVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJOdW1iZXJMaXRlcmFsVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJOdW1iZXJUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIk9iamVjdFR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiT2JqZWN0VHlwZUludGVybmFsU2xvdFwiID09PSBub2RlVHlwZSB8fCBcIk9iamVjdFR5cGVDYWxsUHJvcGVydHlcIiA9PT0gbm9kZVR5cGUgfHwgXCJPYmplY3RUeXBlSW5kZXhlclwiID09PSBub2RlVHlwZSB8fCBcIk9iamVjdFR5cGVQcm9wZXJ0eVwiID09PSBub2RlVHlwZSB8fCBcIk9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eVwiID09PSBub2RlVHlwZSB8fCBcIk9wYXF1ZVR5cGVcIiA9PT0gbm9kZVR5cGUgfHwgXCJRdWFsaWZpZWRUeXBlSWRlbnRpZmllclwiID09PSBub2RlVHlwZSB8fCBcIlN0cmluZ0xpdGVyYWxUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIlN0cmluZ1R5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiU3ltYm9sVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJUaGlzVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJUdXBsZVR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiVHlwZW9mVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJUeXBlQWxpYXNcIiA9PT0gbm9kZVR5cGUgfHwgXCJUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIlR5cGVDYXN0RXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIlR5cGVQYXJhbWV0ZXJcIiA9PT0gbm9kZVR5cGUgfHwgXCJUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIlVuaW9uVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJWYXJpYW5jZVwiID09PSBub2RlVHlwZSB8fCBcIlZvaWRUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRmxvd1R5cGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkZsb3dUeXBlXCIgfHwgXCJBbnlUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkFycmF5VHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJCb29sZWFuVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJCb29sZWFuTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiTnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkV4aXN0c1R5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkdlbmVyaWNUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkludGVyZmFjZVR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiSW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJNaXhlZFR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiRW1wdHlUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIk51bGxhYmxlVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJOdW1iZXJMaXRlcmFsVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJOdW1iZXJUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIk9iamVjdFR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiU3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiU3RyaW5nVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJTeW1ib2xUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIlRoaXNUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIlR1cGxlVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJUeXBlb2ZUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIlVuaW9uVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJWb2lkVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0Zsb3dCYXNlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiRmxvd0Jhc2VBbm5vdGF0aW9uXCIgfHwgXCJBbnlUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkJvb2xlYW5UeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIk51bGxMaXRlcmFsVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJNaXhlZFR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiRW1wdHlUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIk51bWJlclR5cGVBbm5vdGF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiU3RyaW5nVHlwZUFubm90YXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJTeW1ib2xUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIlRoaXNUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIlZvaWRUeXBlQW5ub3RhdGlvblwiID09PSBub2RlVHlwZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzRmxvd0RlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJGbG93RGVjbGFyYXRpb25cIiB8fCBcIkRlY2xhcmVDbGFzc1wiID09PSBub2RlVHlwZSB8fCBcIkRlY2xhcmVGdW5jdGlvblwiID09PSBub2RlVHlwZSB8fCBcIkRlY2xhcmVJbnRlcmZhY2VcIiA9PT0gbm9kZVR5cGUgfHwgXCJEZWNsYXJlTW9kdWxlXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZU1vZHVsZUV4cG9ydHNcIiA9PT0gbm9kZVR5cGUgfHwgXCJEZWNsYXJlVHlwZUFsaWFzXCIgPT09IG5vZGVUeXBlIHx8IFwiRGVjbGFyZU9wYXF1ZVR5cGVcIiA9PT0gbm9kZVR5cGUgfHwgXCJEZWNsYXJlVmFyaWFibGVcIiA9PT0gbm9kZVR5cGUgfHwgXCJEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJEZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJJbnRlcmZhY2VEZWNsYXJhdGlvblwiID09PSBub2RlVHlwZSB8fCBcIk9wYXF1ZVR5cGVcIiA9PT0gbm9kZVR5cGUgfHwgXCJUeXBlQWxpYXNcIiA9PT0gbm9kZVR5cGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0Zsb3dQcmVkaWNhdGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIkZsb3dQcmVkaWNhdGVcIiB8fCBcIkRlY2xhcmVkUHJlZGljYXRlXCIgPT09IG5vZGVUeXBlIHx8IFwiSW5mZXJyZWRQcmVkaWNhdGVcIiA9PT0gbm9kZVR5cGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0VudW1Cb2R5KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJFbnVtQm9keVwiIHx8IFwiRW51bUJvb2xlYW5Cb2R5XCIgPT09IG5vZGVUeXBlIHx8IFwiRW51bU51bWJlckJvZHlcIiA9PT0gbm9kZVR5cGUgfHwgXCJFbnVtU3RyaW5nQm9keVwiID09PSBub2RlVHlwZSB8fCBcIkVudW1TeW1ib2xCb2R5XCIgPT09IG5vZGVUeXBlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNFbnVtTWVtYmVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJFbnVtTWVtYmVyXCIgfHwgXCJFbnVtQm9vbGVhbk1lbWJlclwiID09PSBub2RlVHlwZSB8fCBcIkVudW1OdW1iZXJNZW1iZXJcIiA9PT0gbm9kZVR5cGUgfHwgXCJFbnVtU3RyaW5nTWVtYmVyXCIgPT09IG5vZGVUeXBlIHx8IFwiRW51bURlZmF1bHRlZE1lbWJlclwiID09PSBub2RlVHlwZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzSlNYKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJKU1hcIiB8fCBcIkpTWEF0dHJpYnV0ZVwiID09PSBub2RlVHlwZSB8fCBcIkpTWENsb3NpbmdFbGVtZW50XCIgPT09IG5vZGVUeXBlIHx8IFwiSlNYRWxlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkpTWEVtcHR5RXhwcmVzc2lvblwiID09PSBub2RlVHlwZSB8fCBcIkpTWEV4cHJlc3Npb25Db250YWluZXJcIiA9PT0gbm9kZVR5cGUgfHwgXCJKU1hTcHJlYWRDaGlsZFwiID09PSBub2RlVHlwZSB8fCBcIkpTWElkZW50aWZpZXJcIiA9PT0gbm9kZVR5cGUgfHwgXCJKU1hNZW1iZXJFeHByZXNzaW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiSlNYTmFtZXNwYWNlZE5hbWVcIiA9PT0gbm9kZVR5cGUgfHwgXCJKU1hPcGVuaW5nRWxlbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkpTWFNwcmVhZEF0dHJpYnV0ZVwiID09PSBub2RlVHlwZSB8fCBcIkpTWFRleHRcIiA9PT0gbm9kZVR5cGUgfHwgXCJKU1hGcmFnbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkpTWE9wZW5pbmdGcmFnbWVudFwiID09PSBub2RlVHlwZSB8fCBcIkpTWENsb3NpbmdGcmFnbWVudFwiID09PSBub2RlVHlwZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzUHJpdmF0ZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiUHJpdmF0ZVwiIHx8IFwiQ2xhc3NQcml2YXRlUHJvcGVydHlcIiA9PT0gbm9kZVR5cGUgfHwgXCJDbGFzc1ByaXZhdGVNZXRob2RcIiA9PT0gbm9kZVR5cGUgfHwgXCJQcml2YXRlTmFtZVwiID09PSBub2RlVHlwZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNUeXBlRWxlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiVFNUeXBlRWxlbWVudFwiIHx8IFwiVFNDYWxsU2lnbmF0dXJlRGVjbGFyYXRpb25cIiA9PT0gbm9kZVR5cGUgfHwgXCJUU0NvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNQcm9wZXJ0eVNpZ25hdHVyZVwiID09PSBub2RlVHlwZSB8fCBcIlRTTWV0aG9kU2lnbmF0dXJlXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNJbmRleFNpZ25hdHVyZVwiID09PSBub2RlVHlwZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVFNUeXBlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJUU1R5cGVcIiB8fCBcIlRTQW55S2V5d29yZFwiID09PSBub2RlVHlwZSB8fCBcIlRTQm9vbGVhbktleXdvcmRcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU0JpZ0ludEtleXdvcmRcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU05ldmVyS2V5d29yZFwiID09PSBub2RlVHlwZSB8fCBcIlRTTnVsbEtleXdvcmRcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU051bWJlcktleXdvcmRcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU09iamVjdEtleXdvcmRcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU1N0cmluZ0tleXdvcmRcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU1N5bWJvbEtleXdvcmRcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU1VuZGVmaW5lZEtleXdvcmRcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU1Vua25vd25LZXl3b3JkXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNWb2lkS2V5d29yZFwiID09PSBub2RlVHlwZSB8fCBcIlRTVGhpc1R5cGVcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU0Z1bmN0aW9uVHlwZVwiID09PSBub2RlVHlwZSB8fCBcIlRTQ29uc3RydWN0b3JUeXBlXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNUeXBlUmVmZXJlbmNlXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNUeXBlUHJlZGljYXRlXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNUeXBlUXVlcnlcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU1R5cGVMaXRlcmFsXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNBcnJheVR5cGVcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU1R1cGxlVHlwZVwiID09PSBub2RlVHlwZSB8fCBcIlRTT3B0aW9uYWxUeXBlXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNSZXN0VHlwZVwiID09PSBub2RlVHlwZSB8fCBcIlRTVW5pb25UeXBlXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNJbnRlcnNlY3Rpb25UeXBlXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNDb25kaXRpb25hbFR5cGVcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU0luZmVyVHlwZVwiID09PSBub2RlVHlwZSB8fCBcIlRTUGFyZW50aGVzaXplZFR5cGVcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU1R5cGVPcGVyYXRvclwiID09PSBub2RlVHlwZSB8fCBcIlRTSW5kZXhlZEFjY2Vzc1R5cGVcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU01hcHBlZFR5cGVcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU0xpdGVyYWxUeXBlXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNFeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHNcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU0ltcG9ydFR5cGVcIiA9PT0gbm9kZVR5cGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1RTQmFzZVR5cGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTQmFzZVR5cGVcIiB8fCBcIlRTQW55S2V5d29yZFwiID09PSBub2RlVHlwZSB8fCBcIlRTQm9vbGVhbktleXdvcmRcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU0JpZ0ludEtleXdvcmRcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU05ldmVyS2V5d29yZFwiID09PSBub2RlVHlwZSB8fCBcIlRTTnVsbEtleXdvcmRcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU051bWJlcktleXdvcmRcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU09iamVjdEtleXdvcmRcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU1N0cmluZ0tleXdvcmRcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU1N5bWJvbEtleXdvcmRcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU1VuZGVmaW5lZEtleXdvcmRcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU1Vua25vd25LZXl3b3JkXCIgPT09IG5vZGVUeXBlIHx8IFwiVFNWb2lkS2V5d29yZFwiID09PSBub2RlVHlwZSB8fCBcIlRTVGhpc1R5cGVcIiA9PT0gbm9kZVR5cGUgfHwgXCJUU0xpdGVyYWxUeXBlXCIgPT09IG5vZGVUeXBlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXJMaXRlcmFsKG5vZGUsIG9wdHMpIHtcbiAgY29uc29sZS50cmFjZShcIlRoZSBub2RlIHR5cGUgTnVtYmVyTGl0ZXJhbCBoYXMgYmVlbiByZW5hbWVkIHRvIE51bWVyaWNMaXRlcmFsXCIpO1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIk51bWJlckxpdGVyYWxcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzUmVnZXhMaXRlcmFsKG5vZGUsIG9wdHMpIHtcbiAgY29uc29sZS50cmFjZShcIlRoZSBub2RlIHR5cGUgUmVnZXhMaXRlcmFsIGhhcyBiZWVuIHJlbmFtZWQgdG8gUmVnRXhwTGl0ZXJhbFwiKTtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS50eXBlO1xuXG4gIGlmIChub2RlVHlwZSA9PT0gXCJSZWdleExpdGVyYWxcIikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzUmVzdFByb3BlcnR5KG5vZGUsIG9wdHMpIHtcbiAgY29uc29sZS50cmFjZShcIlRoZSBub2RlIHR5cGUgUmVzdFByb3BlcnR5IGhhcyBiZWVuIHJlbmFtZWQgdG8gUmVzdEVsZW1lbnRcIik7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUudHlwZTtcblxuICBpZiAobm9kZVR5cGUgPT09IFwiUmVzdFByb3BlcnR5XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1NwcmVhZFByb3BlcnR5KG5vZGUsIG9wdHMpIHtcbiAgY29uc29sZS50cmFjZShcIlRoZSBub2RlIHR5cGUgU3ByZWFkUHJvcGVydHkgaGFzIGJlZW4gcmVuYW1lZCB0byBTcHJlYWRFbGVtZW50XCIpO1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgaWYgKG5vZGVUeXBlID09PSBcIlNwcmVhZFByb3BlcnR5XCIpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXM7XG5cbnZhciBfc2hhbGxvd0VxdWFsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vdXRpbHMvc2hhbGxvd0VxdWFsXCIpKTtcblxudmFyIF9pc1R5cGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2lzVHlwZVwiKSk7XG5cbnZhciBfaXNQbGFjZWhvbGRlclR5cGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2lzUGxhY2Vob2xkZXJUeXBlXCIpKTtcblxudmFyIF9kZWZpbml0aW9ucyA9IHJlcXVpcmUoXCIuLi9kZWZpbml0aW9uc1wiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gaXModHlwZSwgbm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgbWF0Y2hlcyA9ICgwLCBfaXNUeXBlLmRlZmF1bHQpKG5vZGUudHlwZSwgdHlwZSk7XG5cbiAgaWYgKCFtYXRjaGVzKSB7XG4gICAgaWYgKCFvcHRzICYmIG5vZGUudHlwZSA9PT0gXCJQbGFjZWhvbGRlclwiICYmIHR5cGUgaW4gX2RlZmluaXRpb25zLkZMSVBQRURfQUxJQVNfS0VZUykge1xuICAgICAgcmV0dXJuICgwLCBfaXNQbGFjZWhvbGRlclR5cGUuZGVmYXVsdCkobm9kZS5leHBlY3RlZE5vZGUsIHR5cGUpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgfVxufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNCaW5kaW5nO1xuXG52YXIgX2dldEJpbmRpbmdJZGVudGlmaWVycyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3JldHJpZXZlcnMvZ2V0QmluZGluZ0lkZW50aWZpZXJzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gaXNCaW5kaW5nKG5vZGUsIHBhcmVudCwgZ3JhbmRwYXJlbnQpIHtcbiAgaWYgKGdyYW5kcGFyZW50ICYmIG5vZGUudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgcGFyZW50LnR5cGUgPT09IFwiT2JqZWN0UHJvcGVydHlcIiAmJiBncmFuZHBhcmVudC50eXBlID09PSBcIk9iamVjdEV4cHJlc3Npb25cIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGtleXMgPSBfZ2V0QmluZGluZ0lkZW50aWZpZXJzLmRlZmF1bHQua2V5c1twYXJlbnQudHlwZV07XG5cbiAgaWYgKGtleXMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICBjb25zdCB2YWwgPSBwYXJlbnRba2V5XTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICBpZiAodmFsLmluZGV4T2Yobm9kZSkgPj0gMCkgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodmFsID09PSBub2RlKSByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0Jsb2NrU2NvcGVkO1xuXG52YXIgX2dlbmVyYXRlZCA9IHJlcXVpcmUoXCIuL2dlbmVyYXRlZFwiKTtcblxudmFyIF9pc0xldCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaXNMZXRcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBpc0Jsb2NrU2NvcGVkKG5vZGUpIHtcbiAgcmV0dXJuICgwLCBfZ2VuZXJhdGVkLmlzRnVuY3Rpb25EZWNsYXJhdGlvbikobm9kZSkgfHwgKDAsIF9nZW5lcmF0ZWQuaXNDbGFzc0RlY2xhcmF0aW9uKShub2RlKSB8fCAoMCwgX2lzTGV0LmRlZmF1bHQpKG5vZGUpO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNJbW11dGFibGU7XG5cbnZhciBfaXNUeXBlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pc1R5cGVcIikpO1xuXG52YXIgX2dlbmVyYXRlZCA9IHJlcXVpcmUoXCIuL2dlbmVyYXRlZFwiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gaXNJbW11dGFibGUobm9kZSkge1xuICBpZiAoKDAsIF9pc1R5cGUuZGVmYXVsdCkobm9kZS50eXBlLCBcIkltbXV0YWJsZVwiKSkgcmV0dXJuIHRydWU7XG5cbiAgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzSWRlbnRpZmllcikobm9kZSkpIHtcbiAgICBpZiAobm9kZS5uYW1lID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzTGV0O1xuXG52YXIgX2dlbmVyYXRlZCA9IHJlcXVpcmUoXCIuL2dlbmVyYXRlZFwiKTtcblxudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xuXG5mdW5jdGlvbiBpc0xldChub2RlKSB7XG4gIHJldHVybiAoMCwgX2dlbmVyYXRlZC5pc1ZhcmlhYmxlRGVjbGFyYXRpb24pKG5vZGUpICYmIChub2RlLmtpbmQgIT09IFwidmFyXCIgfHwgbm9kZVtfY29uc3RhbnRzLkJMT0NLX1NDT1BFRF9TWU1CT0xdKTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzTm9kZTtcblxudmFyIF9kZWZpbml0aW9ucyA9IHJlcXVpcmUoXCIuLi9kZWZpbml0aW9uc1wiKTtcblxuZnVuY3Rpb24gaXNOb2RlKG5vZGUpIHtcbiAgcmV0dXJuICEhKG5vZGUgJiYgX2RlZmluaXRpb25zLlZJU0lUT1JfS0VZU1tub2RlLnR5cGVdKTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzTm9kZXNFcXVpdmFsZW50O1xuXG52YXIgX2RlZmluaXRpb25zID0gcmVxdWlyZShcIi4uL2RlZmluaXRpb25zXCIpO1xuXG5mdW5jdGlvbiBpc05vZGVzRXF1aXZhbGVudChhLCBiKSB7XG4gIGlmICh0eXBlb2YgYSAhPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgYiAhPT0gXCJvYmplY3RcIiB8fCBhID09IG51bGwgfHwgYiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGEgPT09IGI7XG4gIH1cblxuICBpZiAoYS50eXBlICE9PSBiLnR5cGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBmaWVsZHMgPSBPYmplY3Qua2V5cyhfZGVmaW5pdGlvbnMuTk9ERV9GSUVMRFNbYS50eXBlXSB8fCBhLnR5cGUpO1xuICBjb25zdCB2aXNpdG9yS2V5cyA9IF9kZWZpbml0aW9ucy5WSVNJVE9SX0tFWVNbYS50eXBlXTtcblxuICBmb3IgKGNvbnN0IGZpZWxkIG9mIGZpZWxkcykge1xuICAgIGlmICh0eXBlb2YgYVtmaWVsZF0gIT09IHR5cGVvZiBiW2ZpZWxkXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChhW2ZpZWxkXSA9PSBudWxsICYmIGJbZmllbGRdID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAoYVtmaWVsZF0gPT0gbnVsbCB8fCBiW2ZpZWxkXSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYVtmaWVsZF0pKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYltmaWVsZF0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFbZmllbGRdLmxlbmd0aCAhPT0gYltmaWVsZF0ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhW2ZpZWxkXS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIWlzTm9kZXNFcXVpdmFsZW50KGFbZmllbGRdW2ldLCBiW2ZpZWxkXVtpXSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBhW2ZpZWxkXSA9PT0gXCJvYmplY3RcIiAmJiAhKHZpc2l0b3JLZXlzID09IG51bGwgPyB2b2lkIDAgOiB2aXNpdG9yS2V5cy5pbmNsdWRlcyhmaWVsZCkpKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhhW2ZpZWxkXSkpIHtcbiAgICAgICAgaWYgKGFbZmllbGRdW2tleV0gIT09IGJbZmllbGRdW2tleV0pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKCFpc05vZGVzRXF1aXZhbGVudChhW2ZpZWxkXSwgYltmaWVsZF0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc1BsYWNlaG9sZGVyVHlwZTtcblxudmFyIF9kZWZpbml0aW9ucyA9IHJlcXVpcmUoXCIuLi9kZWZpbml0aW9uc1wiKTtcblxuZnVuY3Rpb24gaXNQbGFjZWhvbGRlclR5cGUocGxhY2Vob2xkZXJUeXBlLCB0YXJnZXRUeXBlKSB7XG4gIGlmIChwbGFjZWhvbGRlclR5cGUgPT09IHRhcmdldFR5cGUpIHJldHVybiB0cnVlO1xuICBjb25zdCBhbGlhc2VzID0gX2RlZmluaXRpb25zLlBMQUNFSE9MREVSU19BTElBU1twbGFjZWhvbGRlclR5cGVdO1xuXG4gIGlmIChhbGlhc2VzKSB7XG4gICAgZm9yIChjb25zdCBhbGlhcyBvZiBhbGlhc2VzKSB7XG4gICAgICBpZiAodGFyZ2V0VHlwZSA9PT0gYWxpYXMpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzUmVmZXJlbmNlZDtcblxuZnVuY3Rpb24gaXNSZWZlcmVuY2VkKG5vZGUsIHBhcmVudCwgZ3JhbmRwYXJlbnQpIHtcbiAgc3dpdGNoIChwYXJlbnQudHlwZSkge1xuICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIkpTWE1lbWJlckV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICBpZiAocGFyZW50LnByb3BlcnR5ID09PSBub2RlKSB7XG4gICAgICAgIHJldHVybiAhIXBhcmVudC5jb21wdXRlZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcmVudC5vYmplY3QgPT09IG5vZGU7XG5cbiAgICBjYXNlIFwiVmFyaWFibGVEZWNsYXJhdG9yXCI6XG4gICAgICByZXR1cm4gcGFyZW50LmluaXQgPT09IG5vZGU7XG5cbiAgICBjYXNlIFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIjpcbiAgICAgIHJldHVybiBwYXJlbnQuYm9keSA9PT0gbm9kZTtcblxuICAgIGNhc2UgXCJFeHBvcnRTcGVjaWZpZXJcIjpcbiAgICAgIGlmIChwYXJlbnQuc291cmNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcmVudC5sb2NhbCA9PT0gbm9kZTtcblxuICAgIGNhc2UgXCJQcml2YXRlTmFtZVwiOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgY2FzZSBcIkNsYXNzTWV0aG9kXCI6XG4gICAgY2FzZSBcIkNsYXNzUHJpdmF0ZU1ldGhvZFwiOlxuICAgIGNhc2UgXCJPYmplY3RNZXRob2RcIjpcbiAgICAgIGlmIChwYXJlbnQucGFyYW1zLmluY2x1ZGVzKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgIGNhc2UgXCJPYmplY3RQcm9wZXJ0eVwiOlxuICAgIGNhc2UgXCJDbGFzc1Byb3BlcnR5XCI6XG4gICAgY2FzZSBcIkNsYXNzUHJpdmF0ZVByb3BlcnR5XCI6XG4gICAgICBpZiAocGFyZW50LmtleSA9PT0gbm9kZSkge1xuICAgICAgICByZXR1cm4gISFwYXJlbnQuY29tcHV0ZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJlbnQudmFsdWUgPT09IG5vZGUpIHtcbiAgICAgICAgcmV0dXJuICFncmFuZHBhcmVudCB8fCBncmFuZHBhcmVudC50eXBlICE9PSBcIk9iamVjdFBhdHRlcm5cIjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlIFwiQ2xhc3NEZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJDbGFzc0V4cHJlc3Npb25cIjpcbiAgICAgIHJldHVybiBwYXJlbnQuc3VwZXJDbGFzcyA9PT0gbm9kZTtcblxuICAgIGNhc2UgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiOlxuICAgICAgcmV0dXJuIHBhcmVudC5yaWdodCA9PT0gbm9kZTtcblxuICAgIGNhc2UgXCJBc3NpZ25tZW50UGF0dGVyblwiOlxuICAgICAgcmV0dXJuIHBhcmVudC5yaWdodCA9PT0gbm9kZTtcblxuICAgIGNhc2UgXCJMYWJlbGVkU3RhdGVtZW50XCI6XG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBjYXNlIFwiQ2F0Y2hDbGF1c2VcIjpcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGNhc2UgXCJSZXN0RWxlbWVudFwiOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgY2FzZSBcIkJyZWFrU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIkNvbnRpbnVlU3RhdGVtZW50XCI6XG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBjYXNlIFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJGdW5jdGlvbkV4cHJlc3Npb25cIjpcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGNhc2UgXCJFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIjpcbiAgICBjYXNlIFwiRXhwb3J0RGVmYXVsdFNwZWNpZmllclwiOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgY2FzZSBcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIjpcbiAgICBjYXNlIFwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCI6XG4gICAgY2FzZSBcIkltcG9ydFNwZWNpZmllclwiOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgY2FzZSBcIkpTWEF0dHJpYnV0ZVwiOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgY2FzZSBcIk9iamVjdFBhdHRlcm5cIjpcbiAgICBjYXNlIFwiQXJyYXlQYXR0ZXJuXCI6XG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBjYXNlIFwiTWV0YVByb3BlcnR5XCI6XG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBjYXNlIFwiT2JqZWN0VHlwZVByb3BlcnR5XCI6XG4gICAgICByZXR1cm4gcGFyZW50LmtleSAhPT0gbm9kZTtcblxuICAgIGNhc2UgXCJUU0VudW1NZW1iZXJcIjpcbiAgICAgIHJldHVybiBwYXJlbnQuaWQgIT09IG5vZGU7XG5cbiAgICBjYXNlIFwiVFNQcm9wZXJ0eVNpZ25hdHVyZVwiOlxuICAgICAgaWYgKHBhcmVudC5rZXkgPT09IG5vZGUpIHtcbiAgICAgICAgcmV0dXJuICEhcGFyZW50LmNvbXB1dGVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNTY29wZTtcblxudmFyIF9nZW5lcmF0ZWQgPSByZXF1aXJlKFwiLi9nZW5lcmF0ZWRcIik7XG5cbmZ1bmN0aW9uIGlzU2NvcGUobm9kZSwgcGFyZW50KSB7XG4gIGlmICgoMCwgX2dlbmVyYXRlZC5pc0Jsb2NrU3RhdGVtZW50KShub2RlKSAmJiAoMCwgX2dlbmVyYXRlZC5pc0Z1bmN0aW9uKShwYXJlbnQsIHtcbiAgICBib2R5OiBub2RlXG4gIH0pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzQmxvY2tTdGF0ZW1lbnQpKG5vZGUpICYmICgwLCBfZ2VuZXJhdGVkLmlzQ2F0Y2hDbGF1c2UpKHBhcmVudCwge1xuICAgIGJvZHk6IG5vZGVcbiAgfSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoKDAsIF9nZW5lcmF0ZWQuaXNQYXR0ZXJuKShub2RlKSAmJiAoMCwgX2dlbmVyYXRlZC5pc0Z1bmN0aW9uKShwYXJlbnQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gKDAsIF9nZW5lcmF0ZWQuaXNTY29wYWJsZSkobm9kZSk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc1NwZWNpZmllckRlZmF1bHQ7XG5cbnZhciBfZ2VuZXJhdGVkID0gcmVxdWlyZShcIi4vZ2VuZXJhdGVkXCIpO1xuXG5mdW5jdGlvbiBpc1NwZWNpZmllckRlZmF1bHQoc3BlY2lmaWVyKSB7XG4gIHJldHVybiAoMCwgX2dlbmVyYXRlZC5pc0ltcG9ydERlZmF1bHRTcGVjaWZpZXIpKHNwZWNpZmllcikgfHwgKDAsIF9nZW5lcmF0ZWQuaXNJZGVudGlmaWVyKShzcGVjaWZpZXIuaW1wb3J0ZWQgfHwgc3BlY2lmaWVyLmV4cG9ydGVkLCB7XG4gICAgbmFtZTogXCJkZWZhdWx0XCJcbiAgfSk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc1R5cGU7XG5cbnZhciBfZGVmaW5pdGlvbnMgPSByZXF1aXJlKFwiLi4vZGVmaW5pdGlvbnNcIik7XG5cbmZ1bmN0aW9uIGlzVHlwZShub2RlVHlwZSwgdGFyZ2V0VHlwZSkge1xuICBpZiAobm9kZVR5cGUgPT09IHRhcmdldFR5cGUpIHJldHVybiB0cnVlO1xuICBpZiAoX2RlZmluaXRpb25zLkFMSUFTX0tFWVNbdGFyZ2V0VHlwZV0pIHJldHVybiBmYWxzZTtcbiAgY29uc3QgYWxpYXNlcyA9IF9kZWZpbml0aW9ucy5GTElQUEVEX0FMSUFTX0tFWVNbdGFyZ2V0VHlwZV07XG5cbiAgaWYgKGFsaWFzZXMpIHtcbiAgICBpZiAoYWxpYXNlc1swXSA9PT0gbm9kZVR5cGUpIHJldHVybiB0cnVlO1xuXG4gICAgZm9yIChjb25zdCBhbGlhcyBvZiBhbGlhc2VzKSB7XG4gICAgICBpZiAobm9kZVR5cGUgPT09IGFsaWFzKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc1ZhbGlkRVMzSWRlbnRpZmllcjtcblxudmFyIF9pc1ZhbGlkSWRlbnRpZmllciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaXNWYWxpZElkZW50aWZpZXJcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5jb25zdCBSRVNFUlZFRF9XT1JEU19FUzNfT05MWSA9IG5ldyBTZXQoW1wiYWJzdHJhY3RcIiwgXCJib29sZWFuXCIsIFwiYnl0ZVwiLCBcImNoYXJcIiwgXCJkb3VibGVcIiwgXCJlbnVtXCIsIFwiZmluYWxcIiwgXCJmbG9hdFwiLCBcImdvdG9cIiwgXCJpbXBsZW1lbnRzXCIsIFwiaW50XCIsIFwiaW50ZXJmYWNlXCIsIFwibG9uZ1wiLCBcIm5hdGl2ZVwiLCBcInBhY2thZ2VcIiwgXCJwcml2YXRlXCIsIFwicHJvdGVjdGVkXCIsIFwicHVibGljXCIsIFwic2hvcnRcIiwgXCJzdGF0aWNcIiwgXCJzeW5jaHJvbml6ZWRcIiwgXCJ0aHJvd3NcIiwgXCJ0cmFuc2llbnRcIiwgXCJ2b2xhdGlsZVwiXSk7XG5cbmZ1bmN0aW9uIGlzVmFsaWRFUzNJZGVudGlmaWVyKG5hbWUpIHtcbiAgcmV0dXJuICgwLCBfaXNWYWxpZElkZW50aWZpZXIuZGVmYXVsdCkobmFtZSkgJiYgIVJFU0VSVkVEX1dPUkRTX0VTM19PTkxZLmhhcyhuYW1lKTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzVmFsaWRJZGVudGlmaWVyO1xuXG52YXIgX2hlbHBlclZhbGlkYXRvcklkZW50aWZpZXIgPSByZXF1aXJlKFwiQGJhYmVsL2hlbHBlci12YWxpZGF0b3ItaWRlbnRpZmllclwiKTtcblxuZnVuY3Rpb24gaXNWYWxpZElkZW50aWZpZXIobmFtZSwgcmVzZXJ2ZWQgPSB0cnVlKSB7XG4gIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIikgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChyZXNlcnZlZCkge1xuICAgIGlmICgoMCwgX2hlbHBlclZhbGlkYXRvcklkZW50aWZpZXIuaXNLZXl3b3JkKShuYW1lKSB8fCAoMCwgX2hlbHBlclZhbGlkYXRvcklkZW50aWZpZXIuaXNTdHJpY3RSZXNlcnZlZFdvcmQpKG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSBcImF3YWl0XCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gKDAsIF9oZWxwZXJWYWxpZGF0b3JJZGVudGlmaWVyLmlzSWRlbnRpZmllck5hbWUpKG5hbWUpO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNWYXI7XG5cbnZhciBfZ2VuZXJhdGVkID0gcmVxdWlyZShcIi4vZ2VuZXJhdGVkXCIpO1xuXG52YXIgX2NvbnN0YW50cyA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHNcIik7XG5cbmZ1bmN0aW9uIGlzVmFyKG5vZGUpIHtcbiAgcmV0dXJuICgwLCBfZ2VuZXJhdGVkLmlzVmFyaWFibGVEZWNsYXJhdGlvbikobm9kZSwge1xuICAgIGtpbmQ6IFwidmFyXCJcbiAgfSkgJiYgIW5vZGVbX2NvbnN0YW50cy5CTE9DS19TQ09QRURfU1lNQk9MXTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IG1hdGNoZXNQYXR0ZXJuO1xuXG52YXIgX2dlbmVyYXRlZCA9IHJlcXVpcmUoXCIuL2dlbmVyYXRlZFwiKTtcblxuZnVuY3Rpb24gbWF0Y2hlc1BhdHRlcm4obWVtYmVyLCBtYXRjaCwgYWxsb3dQYXJ0aWFsKSB7XG4gIGlmICghKDAsIF9nZW5lcmF0ZWQuaXNNZW1iZXJFeHByZXNzaW9uKShtZW1iZXIpKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHBhcnRzID0gQXJyYXkuaXNBcnJheShtYXRjaCkgPyBtYXRjaCA6IG1hdGNoLnNwbGl0KFwiLlwiKTtcbiAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgbGV0IG5vZGU7XG5cbiAgZm9yIChub2RlID0gbWVtYmVyOyAoMCwgX2dlbmVyYXRlZC5pc01lbWJlckV4cHJlc3Npb24pKG5vZGUpOyBub2RlID0gbm9kZS5vYmplY3QpIHtcbiAgICBub2Rlcy5wdXNoKG5vZGUucHJvcGVydHkpO1xuICB9XG5cbiAgbm9kZXMucHVzaChub2RlKTtcbiAgaWYgKG5vZGVzLmxlbmd0aCA8IHBhcnRzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoIWFsbG93UGFydGlhbCAmJiBub2Rlcy5sZW5ndGggPiBwYXJ0cy5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICBmb3IgKGxldCBpID0gMCwgaiA9IG5vZGVzLmxlbmd0aCAtIDE7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKywgai0tKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2pdO1xuICAgIGxldCB2YWx1ZTtcblxuICAgIGlmICgoMCwgX2dlbmVyYXRlZC5pc0lkZW50aWZpZXIpKG5vZGUpKSB7XG4gICAgICB2YWx1ZSA9IG5vZGUubmFtZTtcbiAgICB9IGVsc2UgaWYgKCgwLCBfZ2VuZXJhdGVkLmlzU3RyaW5nTGl0ZXJhbCkobm9kZSkpIHtcbiAgICAgIHZhbHVlID0gbm9kZS52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChwYXJ0c1tpXSAhPT0gdmFsdWUpIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNDb21wYXRUYWc7XG5cbmZ1bmN0aW9uIGlzQ29tcGF0VGFnKHRhZ05hbWUpIHtcbiAgcmV0dXJuICEhdGFnTmFtZSAmJiAvXlthLXpdLy50ZXN0KHRhZ05hbWUpO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2J1aWxkTWF0Y2hNZW1iZXJFeHByZXNzaW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vYnVpbGRNYXRjaE1lbWJlckV4cHJlc3Npb25cIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5jb25zdCBpc1JlYWN0Q29tcG9uZW50ID0gKDAsIF9idWlsZE1hdGNoTWVtYmVyRXhwcmVzc2lvbi5kZWZhdWx0KShcIlJlYWN0LkNvbXBvbmVudFwiKTtcbnZhciBfZGVmYXVsdCA9IGlzUmVhY3RDb21wb25lbnQ7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZhbGlkYXRlO1xuZXhwb3J0cy52YWxpZGF0ZUZpZWxkID0gdmFsaWRhdGVGaWVsZDtcbmV4cG9ydHMudmFsaWRhdGVDaGlsZCA9IHZhbGlkYXRlQ2hpbGQ7XG5cbnZhciBfZGVmaW5pdGlvbnMgPSByZXF1aXJlKFwiLi4vZGVmaW5pdGlvbnNcIik7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlKG5vZGUsIGtleSwgdmFsKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuO1xuICBjb25zdCBmaWVsZHMgPSBfZGVmaW5pdGlvbnMuTk9ERV9GSUVMRFNbbm9kZS50eXBlXTtcbiAgaWYgKCFmaWVsZHMpIHJldHVybjtcbiAgY29uc3QgZmllbGQgPSBmaWVsZHNba2V5XTtcbiAgdmFsaWRhdGVGaWVsZChub2RlLCBrZXksIHZhbCwgZmllbGQpO1xuICB2YWxpZGF0ZUNoaWxkKG5vZGUsIGtleSwgdmFsKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVGaWVsZChub2RlLCBrZXksIHZhbCwgZmllbGQpIHtcbiAgaWYgKCEoZmllbGQgPT0gbnVsbCA/IHZvaWQgMCA6IGZpZWxkLnZhbGlkYXRlKSkgcmV0dXJuO1xuICBpZiAoZmllbGQub3B0aW9uYWwgJiYgdmFsID09IG51bGwpIHJldHVybjtcbiAgZmllbGQudmFsaWRhdGUobm9kZSwga2V5LCB2YWwpO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkKG5vZGUsIGtleSwgdmFsKSB7XG4gIGlmICh2YWwgPT0gbnVsbCkgcmV0dXJuO1xuICBjb25zdCB2YWxpZGF0ZSA9IF9kZWZpbml0aW9ucy5OT0RFX1BBUkVOVF9WQUxJREFUSU9OU1t2YWwudHlwZV07XG4gIGlmICghdmFsaWRhdGUpIHJldHVybjtcbiAgdmFsaWRhdGUobm9kZSwga2V5LCB2YWwpO1xufSIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayhcbiAgICAgIHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aClcbiAgICApKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxudmFyIEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7IF9fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfSB9XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAncGFyZW50Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ1ZmZlclxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgIT0gbnVsbCAmJlxuICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSlcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2UodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IFR5cGVFcnJvcihcbiAgICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgICApXG4gIH1cblxuICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgKVxuICB9XG5cbiAgdmFyIHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mICYmIHZhbHVlLnZhbHVlT2YoKVxuICBpZiAodmFsdWVPZiAhPSBudWxsICYmIHZhbHVlT2YgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlT2YsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIHZhciBiID0gZnJvbU9iamVjdCh2YWx1ZSlcbiAgaWYgKGIpIHJldHVybiBiXG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmXG4gICAgICB0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShcbiAgICAgIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oJ3N0cmluZycpLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGhcbiAgICApXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gIClcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OFxuQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIHNpemUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICB2YXIgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICB9XG5cbiAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJlxuICAgIGIgIT09IEJ1ZmZlci5wcm90b3R5cGUgLy8gc28gQnVmZmVyLmlzQnVmZmVyKEJ1ZmZlci5wcm90b3R5cGUpIHdpbGwgYmUgZmFsc2Vcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKSBhID0gQnVmZmVyLmZyb20oYSwgYS5vZmZzZXQsIGEuYnl0ZUxlbmd0aClcbiAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpIGIgPSBCdWZmZXIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5J1xuICAgIClcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHtcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZilcbiAgICB9XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICApXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbXVzdE1hdGNoID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZSlcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7XG4gICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmdcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKVxuICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICB0YXJnZXQgPSBCdWZmZXIuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKVxuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdGFyZ2V0KVxuICAgIClcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnICYmIGNvZGUgPCAxMjgpIHx8XG4gICAgICAgICAgZW5jb2RpbmcgPT09ICdsYXRpbjEnKSB7XG4gICAgICAgIC8vIEZhc3QgcGF0aDogSWYgYHZhbGAgZml0cyBpbnRvIGEgc2luZ2xlIGJ5dGUsIHVzZSB0aGF0IG51bWVyaWMgdmFsdWUuXG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgdmFsICtcbiAgICAgICAgJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpXG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgdGFrZXMgZXF1YWwgc2lnbnMgYXMgZW5kIG9mIHRoZSBCYXNlNjQgZW5jb2RpbmdcbiAgc3RyID0gc3RyLnNwbGl0KCc9JylbMF1cbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG4vLyBBcnJheUJ1ZmZlciBvciBVaW50OEFycmF5IG9iamVjdHMgZnJvbSBvdGhlciBjb250ZXh0cyAoaS5lLiBpZnJhbWVzKSBkbyBub3QgcGFzc1xuLy8gdGhlIGBpbnN0YW5jZW9mYCBjaGVjayBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyBvZiB0aGF0IHR5cGUuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjZcbmZ1bmN0aW9uIGlzSW5zdGFuY2UgKG9iaiwgdHlwZSkge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdHlwZSB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSAhPSBudWxsICYmXG4gICAgICBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gdHlwZS5uYW1lKVxufVxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICAvLyBGb3IgSUUxMSBzdXBwb3J0XG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwidmFyIGNoYXJlbmMgPSB7XG4gIC8vIFVURi04IGVuY29kaW5nXG4gIHV0Zjg6IHtcbiAgICAvLyBDb252ZXJ0IGEgc3RyaW5nIHRvIGEgYnl0ZSBhcnJheVxuICAgIHN0cmluZ1RvQnl0ZXM6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgcmV0dXJuIGNoYXJlbmMuYmluLnN0cmluZ1RvQnl0ZXModW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpKTtcbiAgICB9LFxuXG4gICAgLy8gQ29udmVydCBhIGJ5dGUgYXJyYXkgdG8gYSBzdHJpbmdcbiAgICBieXRlc1RvU3RyaW5nOiBmdW5jdGlvbihieXRlcykge1xuICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoY2hhcmVuYy5iaW4uYnl0ZXNUb1N0cmluZyhieXRlcykpKTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gQmluYXJ5IGVuY29kaW5nXG4gIGJpbjoge1xuICAgIC8vIENvbnZlcnQgYSBzdHJpbmcgdG8gYSBieXRlIGFycmF5XG4gICAgc3RyaW5nVG9CeXRlczogZnVuY3Rpb24oc3RyKSB7XG4gICAgICBmb3IgKHZhciBieXRlcyA9IFtdLCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKylcbiAgICAgICAgYnl0ZXMucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpO1xuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgYnl0ZSBhcnJheSB0byBhIHN0cmluZ1xuICAgIGJ5dGVzVG9TdHJpbmc6IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICBmb3IgKHZhciBzdHIgPSBbXSwgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgc3RyLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSkpO1xuICAgICAgcmV0dXJuIHN0ci5qb2luKCcnKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY2hhcmVuYztcbiIsIihmdW5jdGlvbigpIHtcbiAgdmFyIGJhc2U2NG1hcFxuICAgICAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycsXG5cbiAgY3J5cHQgPSB7XG4gICAgLy8gQml0LXdpc2Ugcm90YXRpb24gbGVmdFxuICAgIHJvdGw6IGZ1bmN0aW9uKG4sIGIpIHtcbiAgICAgIHJldHVybiAobiA8PCBiKSB8IChuID4+PiAoMzIgLSBiKSk7XG4gICAgfSxcblxuICAgIC8vIEJpdC13aXNlIHJvdGF0aW9uIHJpZ2h0XG4gICAgcm90cjogZnVuY3Rpb24obiwgYikge1xuICAgICAgcmV0dXJuIChuIDw8ICgzMiAtIGIpKSB8IChuID4+PiBiKTtcbiAgICB9LFxuXG4gICAgLy8gU3dhcCBiaWctZW5kaWFuIHRvIGxpdHRsZS1lbmRpYW4gYW5kIHZpY2UgdmVyc2FcbiAgICBlbmRpYW46IGZ1bmN0aW9uKG4pIHtcbiAgICAgIC8vIElmIG51bWJlciBnaXZlbiwgc3dhcCBlbmRpYW5cbiAgICAgIGlmIChuLmNvbnN0cnVjdG9yID09IE51bWJlcikge1xuICAgICAgICByZXR1cm4gY3J5cHQucm90bChuLCA4KSAmIDB4MDBGRjAwRkYgfCBjcnlwdC5yb3RsKG4sIDI0KSAmIDB4RkYwMEZGMDA7XG4gICAgICB9XG5cbiAgICAgIC8vIEVsc2UsIGFzc3VtZSBhcnJheSBhbmQgc3dhcCBhbGwgaXRlbXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbi5sZW5ndGg7IGkrKylcbiAgICAgICAgbltpXSA9IGNyeXB0LmVuZGlhbihuW2ldKTtcbiAgICAgIHJldHVybiBuO1xuICAgIH0sXG5cbiAgICAvLyBHZW5lcmF0ZSBhbiBhcnJheSBvZiBhbnkgbGVuZ3RoIG9mIHJhbmRvbSBieXRlc1xuICAgIHJhbmRvbUJ5dGVzOiBmdW5jdGlvbihuKSB7XG4gICAgICBmb3IgKHZhciBieXRlcyA9IFtdOyBuID4gMDsgbi0tKVxuICAgICAgICBieXRlcy5wdXNoKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDI1NikpO1xuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgYnl0ZSBhcnJheSB0byBiaWctZW5kaWFuIDMyLWJpdCB3b3Jkc1xuICAgIGJ5dGVzVG9Xb3JkczogZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGZvciAodmFyIHdvcmRzID0gW10sIGkgPSAwLCBiID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrLCBiICs9IDgpXG4gICAgICAgIHdvcmRzW2IgPj4+IDVdIHw9IGJ5dGVzW2ldIDw8ICgyNCAtIGIgJSAzMik7XG4gICAgICByZXR1cm4gd29yZHM7XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYmlnLWVuZGlhbiAzMi1iaXQgd29yZHMgdG8gYSBieXRlIGFycmF5XG4gICAgd29yZHNUb0J5dGVzOiBmdW5jdGlvbih3b3Jkcykge1xuICAgICAgZm9yICh2YXIgYnl0ZXMgPSBbXSwgYiA9IDA7IGIgPCB3b3Jkcy5sZW5ndGggKiAzMjsgYiArPSA4KVxuICAgICAgICBieXRlcy5wdXNoKCh3b3Jkc1tiID4+PiA1XSA+Pj4gKDI0IC0gYiAlIDMyKSkgJiAweEZGKTtcbiAgICAgIHJldHVybiBieXRlcztcbiAgICB9LFxuXG4gICAgLy8gQ29udmVydCBhIGJ5dGUgYXJyYXkgdG8gYSBoZXggc3RyaW5nXG4gICAgYnl0ZXNUb0hleDogZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGZvciAodmFyIGhleCA9IFtdLCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleC5wdXNoKChieXRlc1tpXSA+Pj4gNCkudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgaGV4LnB1c2goKGJ5dGVzW2ldICYgMHhGKS50b1N0cmluZygxNikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhleC5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLy8gQ29udmVydCBhIGhleCBzdHJpbmcgdG8gYSBieXRlIGFycmF5XG4gICAgaGV4VG9CeXRlczogZnVuY3Rpb24oaGV4KSB7XG4gICAgICBmb3IgKHZhciBieXRlcyA9IFtdLCBjID0gMDsgYyA8IGhleC5sZW5ndGg7IGMgKz0gMilcbiAgICAgICAgYnl0ZXMucHVzaChwYXJzZUludChoZXguc3Vic3RyKGMsIDIpLCAxNikpO1xuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgYnl0ZSBhcnJheSB0byBhIGJhc2UtNjQgc3RyaW5nXG4gICAgYnl0ZXNUb0Jhc2U2NDogZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGZvciAodmFyIGJhc2U2NCA9IFtdLCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIHZhciB0cmlwbGV0ID0gKGJ5dGVzW2ldIDw8IDE2KSB8IChieXRlc1tpICsgMV0gPDwgOCkgfCBieXRlc1tpICsgMl07XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgNDsgaisrKVxuICAgICAgICAgIGlmIChpICogOCArIGogKiA2IDw9IGJ5dGVzLmxlbmd0aCAqIDgpXG4gICAgICAgICAgICBiYXNlNjQucHVzaChiYXNlNjRtYXAuY2hhckF0KCh0cmlwbGV0ID4+PiA2ICogKDMgLSBqKSkgJiAweDNGKSk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgYmFzZTY0LnB1c2goJz0nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlNjQuam9pbignJyk7XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYSBiYXNlLTY0IHN0cmluZyB0byBhIGJ5dGUgYXJyYXlcbiAgICBiYXNlNjRUb0J5dGVzOiBmdW5jdGlvbihiYXNlNjQpIHtcbiAgICAgIC8vIFJlbW92ZSBub24tYmFzZS02NCBjaGFyYWN0ZXJzXG4gICAgICBiYXNlNjQgPSBiYXNlNjQucmVwbGFjZSgvW15BLVowLTkrXFwvXS9pZywgJycpO1xuXG4gICAgICBmb3IgKHZhciBieXRlcyA9IFtdLCBpID0gMCwgaW1vZDQgPSAwOyBpIDwgYmFzZTY0Lmxlbmd0aDtcbiAgICAgICAgICBpbW9kNCA9ICsraSAlIDQpIHtcbiAgICAgICAgaWYgKGltb2Q0ID09IDApIGNvbnRpbnVlO1xuICAgICAgICBieXRlcy5wdXNoKCgoYmFzZTY0bWFwLmluZGV4T2YoYmFzZTY0LmNoYXJBdChpIC0gMSkpXG4gICAgICAgICAgICAmIChNYXRoLnBvdygyLCAtMiAqIGltb2Q0ICsgOCkgLSAxKSkgPDwgKGltb2Q0ICogMikpXG4gICAgICAgICAgICB8IChiYXNlNjRtYXAuaW5kZXhPZihiYXNlNjQuY2hhckF0KGkpKSA+Pj4gKDYgLSBpbW9kNCAqIDIpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gY3J5cHQ7XG59KSgpO1xuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhVmlldztcbiIsInZhciBoYXNoQ2xlYXIgPSByZXF1aXJlKCcuL19oYXNoQ2xlYXInKSxcbiAgICBoYXNoRGVsZXRlID0gcmVxdWlyZSgnLi9faGFzaERlbGV0ZScpLFxuICAgIGhhc2hHZXQgPSByZXF1aXJlKCcuL19oYXNoR2V0JyksXG4gICAgaGFzaEhhcyA9IHJlcXVpcmUoJy4vX2hhc2hIYXMnKSxcbiAgICBoYXNoU2V0ID0gcmVxdWlyZSgnLi9faGFzaFNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoO1xuIiwidmFyIGxpc3RDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlQ2xlYXInKSxcbiAgICBsaXN0Q2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVEZWxldGUnKSxcbiAgICBsaXN0Q2FjaGVHZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVHZXQnKSxcbiAgICBsaXN0Q2FjaGVIYXMgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVIYXMnKSxcbiAgICBsaXN0Q2FjaGVTZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpc3RDYWNoZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXA7XG4iLCJ2YXIgbWFwQ2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX21hcENhY2hlQ2xlYXInKSxcbiAgICBtYXBDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX21hcENhY2hlRGVsZXRlJyksXG4gICAgbWFwQ2FjaGVHZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZUdldCcpLFxuICAgIG1hcENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVIYXMnKSxcbiAgICBtYXBDYWNoZVNldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcENhY2hlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXQ7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgc3RhY2tDbGVhciA9IHJlcXVpcmUoJy4vX3N0YWNrQ2xlYXInKSxcbiAgICBzdGFja0RlbGV0ZSA9IHJlcXVpcmUoJy4vX3N0YWNrRGVsZXRlJyksXG4gICAgc3RhY2tHZXQgPSByZXF1aXJlKCcuL19zdGFja0dldCcpLFxuICAgIHN0YWNrSGFzID0gcmVxdWlyZSgnLi9fc3RhY2tIYXMnKSxcbiAgICBzdGFja1NldCA9IHJlcXVpcmUoJy4vX3N0YWNrU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGFjaztcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2w7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBVaW50OEFycmF5O1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gV2Vha01hcDtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUVhY2g7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlGaWx0ZXI7XG4iLCJ2YXIgYmFzZVRpbWVzID0gcmVxdWlyZSgnLi9fYmFzZVRpbWVzJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TGlrZUtleXM7XG4iLCIvKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlQdXNoO1xuIiwidmFyIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnblZhbHVlO1xuIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc29jSW5kZXhPZjtcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ247XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbkluYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduSW4ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnbkluO1xuIiwidmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fZGVmaW5lUHJvcGVydHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuICogdmFsdWUgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSkge1xuICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcbiAgICAgICd2YWx1ZSc6IHZhbHVlLFxuICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduVmFsdWU7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGFycmF5RWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5RWFjaCcpLFxuICAgIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBiYXNlQXNzaWduID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnbicpLFxuICAgIGJhc2VBc3NpZ25JbiA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25JbicpLFxuICAgIGNsb25lQnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVCdWZmZXInKSxcbiAgICBjb3B5QXJyYXkgPSByZXF1aXJlKCcuL19jb3B5QXJyYXknKSxcbiAgICBjb3B5U3ltYm9scyA9IHJlcXVpcmUoJy4vX2NvcHlTeW1ib2xzJyksXG4gICAgY29weVN5bWJvbHNJbiA9IHJlcXVpcmUoJy4vX2NvcHlTeW1ib2xzSW4nKSxcbiAgICBnZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5cycpLFxuICAgIGdldEFsbEtleXNJbiA9IHJlcXVpcmUoJy4vX2dldEFsbEtleXNJbicpLFxuICAgIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGluaXRDbG9uZUFycmF5ID0gcmVxdWlyZSgnLi9faW5pdENsb25lQXJyYXknKSxcbiAgICBpbml0Q2xvbmVCeVRhZyA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZUJ5VGFnJyksXG4gICAgaW5pdENsb25lT2JqZWN0ID0gcmVxdWlyZSgnLi9faW5pdENsb25lT2JqZWN0JyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzTWFwID0gcmVxdWlyZSgnLi9pc01hcCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzU2V0ID0gcmVxdWlyZSgnLi9pc1NldCcpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDEsXG4gICAgQ0xPTkVfRkxBVF9GTEFHID0gMixcbiAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIHN1cHBvcnRlZCBieSBgXy5jbG9uZWAuICovXG52YXIgY2xvbmVhYmxlVGFncyA9IHt9O1xuY2xvbmVhYmxlVGFnc1thcmdzVGFnXSA9IGNsb25lYWJsZVRhZ3NbYXJyYXlUYWddID1cbmNsb25lYWJsZVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRhVmlld1RhZ10gPVxuY2xvbmVhYmxlVGFnc1tib29sVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPVxuY2xvbmVhYmxlVGFnc1tmbG9hdDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50MTZUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50MzJUYWddID0gY2xvbmVhYmxlVGFnc1ttYXBUYWddID1cbmNsb25lYWJsZVRhZ3NbbnVtYmVyVGFnXSA9IGNsb25lYWJsZVRhZ3Nbb2JqZWN0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3JlZ2V4cFRhZ10gPSBjbG9uZWFibGVUYWdzW3NldFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tzdHJpbmdUYWddID0gY2xvbmVhYmxlVGFnc1tzeW1ib2xUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDhUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG5jbG9uZWFibGVUYWdzW2Vycm9yVGFnXSA9IGNsb25lYWJsZVRhZ3NbZnVuY1RhZ10gPVxuY2xvbmVhYmxlVGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCBhbmQgYF8uY2xvbmVEZWVwYCB3aGljaCB0cmFja3NcbiAqIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gRGVlcCBjbG9uZVxuICogIDIgLSBGbGF0dGVuIGluaGVyaXRlZCBwcm9wZXJ0aWVzXG4gKiAgNCAtIENsb25lIHN5bWJvbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIG9iamVjdHMgYW5kIHRoZWlyIGNsb25lIGNvdW50ZXJwYXJ0cy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCBvYmplY3QsIHN0YWNrKSB7XG4gIHZhciByZXN1bHQsXG4gICAgICBpc0RlZXAgPSBiaXRtYXNrICYgQ0xPTkVfREVFUF9GTEFHLFxuICAgICAgaXNGbGF0ID0gYml0bWFzayAmIENMT05FX0ZMQVRfRkxBRyxcbiAgICAgIGlzRnVsbCA9IGJpdG1hc2sgJiBDTE9ORV9TWU1CT0xTX0ZMQUc7XG5cbiAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCwgc3RhY2spIDogY3VzdG9taXplcih2YWx1ZSk7XG4gIH1cbiAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgaWYgKGlzQXJyKSB7XG4gICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuICAgIGlmICghaXNEZWVwKSB7XG4gICAgICByZXR1cm4gY29weUFycmF5KHZhbHVlLCByZXN1bHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgaXNGdW5jID0gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcblxuICAgIGlmIChpc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjbG9uZUJ1ZmZlcih2YWx1ZSwgaXNEZWVwKTtcbiAgICB9XG4gICAgaWYgKHRhZyA9PSBvYmplY3RUYWcgfHwgdGFnID09IGFyZ3NUYWcgfHwgKGlzRnVuYyAmJiAhb2JqZWN0KSkge1xuICAgICAgcmVzdWx0ID0gKGlzRmxhdCB8fCBpc0Z1bmMpID8ge30gOiBpbml0Q2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgcmV0dXJuIGlzRmxhdFxuICAgICAgICAgID8gY29weVN5bWJvbHNJbih2YWx1ZSwgYmFzZUFzc2lnbkluKHJlc3VsdCwgdmFsdWUpKVxuICAgICAgICAgIDogY29weVN5bWJvbHModmFsdWUsIGJhc2VBc3NpZ24ocmVzdWx0LCB2YWx1ZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWNsb25lYWJsZVRhZ3NbdGFnXSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID8gdmFsdWUgOiB7fTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGlzRGVlcCk7XG4gICAgfVxuICB9XG4gIC8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gaXRzIGNvcnJlc3BvbmRpbmcgY2xvbmUuXG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KHZhbHVlKTtcbiAgaWYgKHN0YWNrZWQpIHtcbiAgICByZXR1cm4gc3RhY2tlZDtcbiAgfVxuICBzdGFjay5zZXQodmFsdWUsIHJlc3VsdCk7XG5cbiAgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUpIHtcbiAgICAgIHJlc3VsdC5hZGQoYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdWJWYWx1ZSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoaXNNYXAodmFsdWUpKSB7XG4gICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHQuc2V0KGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGtleXNGdW5jID0gaXNGdWxsXG4gICAgPyAoaXNGbGF0ID8gZ2V0QWxsS2V5c0luIDogZ2V0QWxsS2V5cylcbiAgICA6IChpc0ZsYXQgPyBrZXlzSW4gOiBrZXlzKTtcblxuICB2YXIgcHJvcHMgPSBpc0FyciA/IHVuZGVmaW5lZCA6IGtleXNGdW5jKHZhbHVlKTtcbiAgYXJyYXlFYWNoKHByb3BzIHx8IHZhbHVlLCBmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICBrZXkgPSBzdWJWYWx1ZTtcbiAgICAgIHN1YlZhbHVlID0gdmFsdWVba2V5XTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgcG9wdWxhdGUgY2xvbmUgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBhc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ2xvbmU7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbnZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICByZXR1cm4gZnVuY3Rpb24ocHJvdG8pIHtcbiAgICBpZiAoIWlzT2JqZWN0KHByb3RvKSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBpZiAob2JqZWN0Q3JlYXRlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcbiAgICB9XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvO1xuICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xuICAgIG9iamVjdC5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUNyZWF0ZTtcbiIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0QWxsS2V5cztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBnZXRSYXdUYWcgPSByZXF1aXJlKCcuL19nZXRSYXdUYWcnKSxcbiAgICBvYmplY3RUb1N0cmluZyA9IHJlcXVpcmUoJy4vX29iamVjdFRvU3RyaW5nJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRUYWc7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0FyZ3VtZW50cztcbiIsInZhciBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXBgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc01hcCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IG1hcFRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNNYXA7XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTWFza2VkID0gcmVxdWlyZSgnLi9faXNNYXNrZWQnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICB0b1NvdXJjZSA9IHJlcXVpcmUoJy4vX3RvU291cmNlJyk7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTmF0aXZlO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzUmVnRXhwYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHJlZ2V4cCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNSZWdFeHAodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gcmVnZXhwVGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc1JlZ0V4cDtcbiIsInZhciBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc2V0VGFnID0gJ1tvYmplY3QgU2V0XSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNTZXRgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2V0LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1NldCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IHNldFRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNTZXQ7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzVHlwZWRBcnJheTtcbiIsInZhciBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyksXG4gICAgbmF0aXZlS2V5cyA9IHJlcXVpcmUoJy4vX25hdGl2ZUtleXMnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBuYXRpdmVLZXlzSW4gPSByZXF1aXJlKCcuL19uYXRpdmVLZXlzSW4nKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXNJbihvYmplY3QpO1xuICB9XG4gIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlS2V5c0luO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVGltZXM7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVVuYXJ5O1xuIiwidmFyIFVpbnQ4QXJyYXkgPSByZXF1aXJlKCcuL19VaW50OEFycmF5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUFycmF5QnVmZmVyO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIGFsbG9jVW5zYWZlID0gQnVmZmVyID8gQnVmZmVyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiAgYGJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIsIGlzRGVlcCkge1xuICBpZiAoaXNEZWVwKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgpO1xuICB9XG4gIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIGJ1ZmZlci5jb3B5KHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVCdWZmZXI7XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGRhdGFWaWV3YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFWaWV3IFRoZSBkYXRhIHZpZXcgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGRhdGEgdmlldy5cbiAqL1xuZnVuY3Rpb24gY2xvbmVEYXRhVmlldyhkYXRhVmlldywgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKGRhdGFWaWV3LmJ1ZmZlcikgOiBkYXRhVmlldy5idWZmZXI7XG4gIHJldHVybiBuZXcgZGF0YVZpZXcuY29uc3RydWN0b3IoYnVmZmVyLCBkYXRhVmlldy5ieXRlT2Zmc2V0LCBkYXRhVmlldy5ieXRlTGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZURhdGFWaWV3O1xuIiwiLyoqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVGbGFncyA9IC9cXHcqJC87XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGByZWdleHBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcmVnZXhwIFRoZSByZWdleHAgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgcmVnZXhwLlxuICovXG5mdW5jdGlvbiBjbG9uZVJlZ0V4cChyZWdleHApIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyByZWdleHAuY29uc3RydWN0b3IocmVnZXhwLnNvdXJjZSwgcmVGbGFncy5leGVjKHJlZ2V4cCkpO1xuICByZXN1bHQubGFzdEluZGV4ID0gcmVnZXhwLmxhc3RJbmRleDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVJlZ0V4cDtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBgc3ltYm9sYCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzeW1ib2wgVGhlIHN5bWJvbCBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgc3ltYm9sIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVTeW1ib2woc3ltYm9sKSB7XG4gIHJldHVybiBzeW1ib2xWYWx1ZU9mID8gT2JqZWN0KHN5bWJvbFZhbHVlT2YuY2FsbChzeW1ib2wpKSA6IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lU3ltYm9sO1xuIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVUeXBlZEFycmF5O1xuIiwiLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weUFycmF5O1xuIiwidmFyIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKTtcblxuLyoqXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGlzTmV3ID0gIW9iamVjdDtcbiAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXG4gICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSlcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5ld1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIGlmIChpc05ldykge1xuICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weU9iamVjdDtcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGdldFN5bWJvbHMgPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzJyk7XG5cbi8qKlxuICogQ29waWVzIG93biBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5U3ltYm9scyhzb3VyY2UsIG9iamVjdCkge1xuICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHMoc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5U3ltYm9scztcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGdldFN5bWJvbHNJbiA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHNJbicpO1xuXG4vKipcbiAqIENvcGllcyBvd24gYW5kIGluaGVyaXRlZCBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5U3ltYm9sc0luKHNvdXJjZSwgb2JqZWN0KSB7XG4gIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9sc0luKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weVN5bWJvbHNJbjtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVKc0RhdGE7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmluZVByb3BlcnR5O1xuIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmcmVlR2xvYmFsO1xuIiwidmFyIGJhc2VHZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUdldEFsbEtleXMnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBbGxLZXlzO1xuIiwidmFyIGJhc2VHZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUdldEFsbEtleXMnKSxcbiAgICBnZXRTeW1ib2xzSW4gPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzSW4nKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0luLCBnZXRTeW1ib2xzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFsbEtleXNJbjtcbiIsInZhciBpc0tleWFibGUgPSByZXF1aXJlKCcuL19pc0tleWFibGUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hcERhdGE7XG4iLCJ2YXIgYmFzZUlzTmF0aXZlID0gcmVxdWlyZSgnLi9fYmFzZUlzTmF0aXZlJyksXG4gICAgZ2V0VmFsdWUgPSByZXF1aXJlKCcuL19nZXRWYWx1ZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5hdGl2ZTtcbiIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRQcm90b3R5cGU7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRSYXdUYWc7XG4iLCJ2YXIgYXJyYXlGaWx0ZXIgPSByZXF1aXJlKCcuL19hcnJheUZpbHRlcicpLFxuICAgIHN0dWJBcnJheSA9IHJlcXVpcmUoJy4vc3R1YkFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRTeW1ib2xzO1xuIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGdldFN5bWJvbHMgPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzJyksXG4gICAgc3R1YkFycmF5ID0gcmVxdWlyZSgnLi9zdHViQXJyYXknKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9sc0luID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB3aGlsZSAob2JqZWN0KSB7XG4gICAgYXJyYXlQdXNoKHJlc3VsdCwgZ2V0U3ltYm9scyhvYmplY3QpKTtcbiAgICBvYmplY3QgPSBnZXRQcm90b3R5cGUob2JqZWN0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRTeW1ib2xzSW47XG4iLCJ2YXIgRGF0YVZpZXcgPSByZXF1aXJlKCcuL19EYXRhVmlldycpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpLFxuICAgIFByb21pc2UgPSByZXF1aXJlKCcuL19Qcm9taXNlJyksXG4gICAgU2V0ID0gcmVxdWlyZSgnLi9fU2V0JyksXG4gICAgV2Vha01hcCA9IHJlcXVpcmUoJy4vX1dlYWtNYXAnKSxcbiAgICBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRUYWc7XG4iLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRWYWx1ZTtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaENsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoRGVsZXRlO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEdldDtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hIYXM7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hTZXQ7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIGFycmF5IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVBcnJheShhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgLy8gQWRkIHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYC5cbiAgaWYgKGxlbmd0aCAmJiB0eXBlb2YgYXJyYXlbMF0gPT0gJ3N0cmluZycgJiYgaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgJ2luZGV4JykpIHtcbiAgICByZXN1bHQuaW5kZXggPSBhcnJheS5pbmRleDtcbiAgICByZXN1bHQuaW5wdXQgPSBhcnJheS5pbnB1dDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZUFycmF5O1xuIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyksXG4gICAgY2xvbmVEYXRhVmlldyA9IHJlcXVpcmUoJy4vX2Nsb25lRGF0YVZpZXcnKSxcbiAgICBjbG9uZVJlZ0V4cCA9IHJlcXVpcmUoJy4vX2Nsb25lUmVnRXhwJyksXG4gICAgY2xvbmVTeW1ib2wgPSByZXF1aXJlKCcuL19jbG9uZVN5bWJvbCcpLFxuICAgIGNsb25lVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vX2Nsb25lVHlwZWRBcnJheScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUgYmFzZWQgb24gaXRzIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjbG9uaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTWFwYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBgU2V0YCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQnlUYWcob2JqZWN0LCB0YWcsIGlzRGVlcCkge1xuICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgcmV0dXJuIGNsb25lQXJyYXlCdWZmZXIob2JqZWN0KTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3IoK29iamVjdCk7XG5cbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgcmV0dXJuIGNsb25lRGF0YVZpZXcob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBmbG9hdDMyVGFnOiBjYXNlIGZsb2F0NjRUYWc6XG4gICAgY2FzZSBpbnQ4VGFnOiBjYXNlIGludDE2VGFnOiBjYXNlIGludDMyVGFnOlxuICAgIGNhc2UgdWludDhUYWc6IGNhc2UgdWludDhDbGFtcGVkVGFnOiBjYXNlIHVpbnQxNlRhZzogY2FzZSB1aW50MzJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVUeXBlZEFycmF5KG9iamVjdCwgaXNEZWVwKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3Iob2JqZWN0KTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgcmV0dXJuIGNsb25lUmVnRXhwKG9iamVjdCk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcjtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgcmV0dXJuIGNsb25lU3ltYm9sKG9iamVjdCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0Q2xvbmVCeVRhZztcbiIsInZhciBiYXNlQ3JlYXRlID0gcmVxdWlyZSgnLi9fYmFzZUNyZWF0ZScpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpKVxuICAgID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSlcbiAgICA6IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZU9iamVjdDtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0luZGV4O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5YWJsZTtcbiIsInZhciBjb3JlSnNEYXRhID0gcmVxdWlyZSgnLi9fY29yZUpzRGF0YScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTWFza2VkO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUHJvdG90eXBlO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUNsZWFyO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlRGVsZXRlO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUdldDtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlSGFzO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlU2V0O1xuIiwidmFyIEhhc2ggPSByZXF1aXJlKCcuL19IYXNoJyksXG4gICAgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUNsZWFyO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlRGVsZXRlO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUdldDtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlSGFzO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZVNldDtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVDcmVhdGU7XG4iLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXM7XG4iLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVLZXlzSW47XG4iLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cbiAgICB2YXIgdHlwZXMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUucmVxdWlyZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUoJ3V0aWwnKS50eXBlcztcblxuICAgIGlmICh0eXBlcykge1xuICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cblxuICAgIC8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuXG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBub2RlVXRpbDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdFRvU3RyaW5nO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlckFyZztcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0NsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrRGVsZXRlO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrR2V0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0hhcztcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKSxcbiAgICBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrU2V0O1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU291cmNlO1xuIiwidmFyIGJhc2VDbG9uZSA9IHJlcXVpcmUoJy4vX2Jhc2VDbG9uZScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYHZhbHVlYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGVcbiAqIFtzdHJ1Y3R1cmVkIGNsb25lIGFsZ29yaXRobV0oaHR0cHM6Ly9tZG4uaW8vU3RydWN0dXJlZF9jbG9uZV9hbGdvcml0aG0pXG4gKiBhbmQgc3VwcG9ydHMgY2xvbmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLCBkYXRlIG9iamVjdHMsIG1hcHMsXG4gKiBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLCBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWRcbiAqIGFycmF5cy4gVGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYGFyZ3VtZW50c2Agb2JqZWN0cyBhcmUgY2xvbmVkXG4gKiBhcyBwbGFpbiBvYmplY3RzLiBBbiBlbXB0eSBvYmplY3QgaXMgcmV0dXJuZWQgZm9yIHVuY2xvbmVhYmxlIHZhbHVlcyBzdWNoXG4gKiBhcyBlcnJvciBvYmplY3RzLCBmdW5jdGlvbnMsIERPTSBub2RlcywgYW5kIFdlYWtNYXBzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKiBAc2VlIF8uY2xvbmVEZWVwXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICpcbiAqIHZhciBzaGFsbG93ID0gXy5jbG9uZShvYmplY3RzKTtcbiAqIGNvbnNvbGUubG9nKHNoYWxsb3dbMF0gPT09IG9iamVjdHNbMF0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjbG9uZSh2YWx1ZSkge1xuICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lO1xuIiwiLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXE7XG4iLCJ2YXIgYmFzZUlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9fYmFzZUlzQXJndW1lbnRzJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcmd1bWVudHM7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5O1xuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2U7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKSxcbiAgICBzdHViRmFsc2UgPSByZXF1aXJlKCcuL3N0dWJGYWxzZScpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNCdWZmZXI7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTGVuZ3RoO1xuIiwidmFyIGJhc2VJc01hcCA9IHJlcXVpcmUoJy4vX2Jhc2VJc01hcCcpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNNYXAgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc01hcDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYE1hcGAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNNYXAobmV3IE1hcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc01hcChuZXcgV2Vha01hcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNNYXAgPSBub2RlSXNNYXAgPyBiYXNlVW5hcnkobm9kZUlzTWFwKSA6IGJhc2VJc01hcDtcblxubW9kdWxlLmV4cG9ydHMgPSBpc01hcDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3RMaWtlO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xudmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuOC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fCBiYXNlR2V0VGFnKHZhbHVlKSAhPSBvYmplY3RUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiZcbiAgICBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUGxhaW5PYmplY3Q7XG4iLCJ2YXIgYmFzZUlzUmVnRXhwID0gcmVxdWlyZSgnLi9fYmFzZUlzUmVnRXhwJyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgbm9kZVV0aWwgPSByZXF1aXJlKCcuL19ub2RlVXRpbCcpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1JlZ0V4cCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzUmVnRXhwO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgUmVnRXhwYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSByZWdleHAsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1JlZ0V4cCgvYWJjLyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1JlZ0V4cCgnL2FiYy8nKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1JlZ0V4cCA9IG5vZGVJc1JlZ0V4cCA/IGJhc2VVbmFyeShub2RlSXNSZWdFeHApIDogYmFzZUlzUmVnRXhwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUmVnRXhwO1xuIiwidmFyIGJhc2VJc1NldCA9IHJlcXVpcmUoJy4vX2Jhc2VJc1NldCcpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNTZXQgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1NldDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFNldGAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2V0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTZXQobmV3IFNldCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1NldChuZXcgV2Vha1NldCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNTZXQgPSBub2RlSXNTZXQgPyBiYXNlVW5hcnkobm9kZUlzU2V0KSA6IGJhc2VJc1NldDtcblxubW9kdWxlLmV4cG9ydHMgPSBpc1NldDtcbiIsInZhciBiYXNlSXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fYmFzZUlzVHlwZWRBcnJheScpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUeXBlZEFycmF5O1xuIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXMgPSByZXF1aXJlKCcuL19iYXNlS2V5cycpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzO1xuIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzSW4nKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5c0luO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICogLy8gPT4gW1tdLCBbXV1cbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViQXJyYXk7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkZhbHNlO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8qXG4gKiBxVGlwMiAtIFByZXR0eSBwb3dlcmZ1bCB0b29sdGlwcyAtIHYzLjAuM1xuICogaHR0cDovL3F0aXAyLmNvbVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNiBcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZXNcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiBXZWQgTWF5IDExIDIwMTYgMTA6MzEgR01UKzAxMDArMDEwMFxuICogUGx1Z2luczogdGlwcyBtb2RhbCB2aWV3cG9ydCBzdmcgaW1hZ2VtYXAgaWU2XG4gKiBTdHlsZXM6IGNvcmUgYmFzaWMgY3NzM1xuICovXG4vKmdsb2JhbCB3aW5kb3c6IGZhbHNlLCBqUXVlcnk6IGZhbHNlLCBjb25zb2xlOiBmYWxzZSwgZGVmaW5lOiBmYWxzZSAqL1xuXG4vKiBDYWNoZSB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQgKi9cbihmdW5jdGlvbiggd2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkICkge1xuXG4vLyBVc2VzIEFNRCBvciBicm93c2VyIGdsb2JhbHMgdG8gY3JlYXRlIGEgalF1ZXJ5IHBsdWdpbi5cbihmdW5jdGlvbiggZmFjdG9yeSApIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuXHRcdGRlZmluZShbJ2pxdWVyeSddLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIGlmKGpRdWVyeSAmJiAhalF1ZXJ5LmZuLnF0aXApIHtcblx0XHRmYWN0b3J5KGpRdWVyeSk7XG5cdH1cbn1cbihmdW5jdGlvbigkKSB7XG5cdFwidXNlIHN0cmljdFwiOyAvLyBFbmFibGUgRUNNQVNjcmlwdCBcInN0cmljdFwiIG9wZXJhdGlvbiBmb3IgdGhpcyBmdW5jdGlvbi4gU2VlIG1vcmU6IGh0dHA6Ly9lam9obi5vcmcvYmxvZy9lY21hc2NyaXB0LTUtc3RyaWN0LW1vZGUtanNvbi1hbmQtbW9yZS9cbjsvLyBNdW5nZSB0aGUgcHJpbWl0aXZlcyAtIFBhdWwgSXJpc2ggdGlwXG52YXIgVFJVRSA9IHRydWUsXG5GQUxTRSA9IGZhbHNlLFxuTlVMTCA9IG51bGwsXG5cbi8vIENvbW1vbiB2YXJpYWJsZXNcblggPSAneCcsIFkgPSAneScsXG5XSURUSCA9ICd3aWR0aCcsXG5IRUlHSFQgPSAnaGVpZ2h0JyxcblxuLy8gUG9zaXRpb25pbmcgc2lkZXNcblRPUCA9ICd0b3AnLFxuTEVGVCA9ICdsZWZ0JyxcbkJPVFRPTSA9ICdib3R0b20nLFxuUklHSFQgPSAncmlnaHQnLFxuQ0VOVEVSID0gJ2NlbnRlcicsXG5cbi8vIFBvc2l0aW9uIGFkanVzdG1lbnQgdHlwZXNcbkZMSVAgPSAnZmxpcCcsXG5GTElQSU5WRVJUID0gJ2ZsaXBpbnZlcnQnLFxuU0hJRlQgPSAnc2hpZnQnLFxuXG4vLyBTaG9ydGN1dCB2YXJzXG5RVElQLCBQUk9UT1RZUEUsIENPUk5FUiwgQ0hFQ0tTLFxuUExVR0lOUyA9IHt9LFxuTkFNRVNQQUNFID0gJ3F0aXAnLFxuQVRUUl9IQVMgPSAnZGF0YS1oYXNxdGlwJyxcbkFUVFJfSUQgPSAnZGF0YS1xdGlwLWlkJyxcbldJREdFVCA9IFsndWktd2lkZ2V0JywgJ3VpLXRvb2x0aXAnXSxcblNFTEVDVE9SID0gJy4nK05BTUVTUEFDRSxcbklOQUNUSVZFX0VWRU5UUyA9ICdjbGljayBkYmxjbGljayBtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VsZWF2ZSBtb3VzZWVudGVyJy5zcGxpdCgnICcpLFxuXG5DTEFTU19GSVhFRCA9IE5BTUVTUEFDRSsnLWZpeGVkJyxcbkNMQVNTX0RFRkFVTFQgPSBOQU1FU1BBQ0UgKyAnLWRlZmF1bHQnLFxuQ0xBU1NfRk9DVVMgPSBOQU1FU1BBQ0UgKyAnLWZvY3VzJyxcbkNMQVNTX0hPVkVSID0gTkFNRVNQQUNFICsgJy1ob3ZlcicsXG5DTEFTU19ESVNBQkxFRCA9IE5BTUVTUEFDRSsnLWRpc2FibGVkJyxcblxucmVwbGFjZVN1ZmZpeCA9ICdfcmVwbGFjZWRCeXFUaXAnLFxub2xkdGl0bGUgPSAnb2xkdGl0bGUnLFxudHJhY2tpbmdCb3VuZCxcblxuLy8gQnJvd3NlciBkZXRlY3Rpb25cbkJST1dTRVIgPSB7XG5cdC8qXG5cdCAqIElFIHZlcnNpb24gZGV0ZWN0aW9uXG5cdCAqXG5cdCAqIEFkYXB0ZWQgZnJvbTogaHR0cDovL2FqYXhpYW4uY29tL2FyY2hpdmVzL2F0dGFjay1vZi10aGUtaWUtY29uZGl0aW9uYWwtY29tbWVudFxuXHQgKiBDcmVkaXQgdG8gSmFtZXMgUGFkb2xzZXkgZm9yIHRoZSBvcmlnaW5hbCBpbXBsZW1udGF0aW9uIVxuXHQgKi9cblx0aWU6IChmdW5jdGlvbigpIHtcblx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1lbXB0eSAqL1xuXHRcdHZhciB2LCBpO1xuXHRcdGZvciAoXG5cdFx0XHR2ID0gNCwgaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdFx0KGkuaW5uZXJIVE1MID0gJzwhLS1baWYgZ3QgSUUgJyArIHYgKyAnXT48aT48L2k+PCFbZW5kaWZdLS0+JykgJiYgaS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaScpWzBdO1xuXHRcdFx0dis9MVxuXHRcdCkge31cblx0XHRyZXR1cm4gdiA+IDQgPyB2IDogTmFOO1xuXHRcdC8qIGVzbGludC1lbmFibGUgbm8tZW1wdHkgKi9cblx0fSkoKSxcblxuXHQvKlxuXHQgKiBpT1MgdmVyc2lvbiBkZXRlY3Rpb25cblx0ICovXG5cdGlPUzogcGFyc2VGbG9hdChcblx0XHQoJycgKyAoL0NQVS4qT1MgKFswLTlfXXsxLDV9KXwoQ1BVIGxpa2UpLipBcHBsZVdlYktpdC4qTW9iaWxlL2kuZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KSB8fCBbMCwnJ10pWzFdKVxuXHRcdC5yZXBsYWNlKCd1bmRlZmluZWQnLCAnM18yJykucmVwbGFjZSgnXycsICcuJykucmVwbGFjZSgnXycsICcnKVxuXHQpIHx8IEZBTFNFXG59O1xuO2Z1bmN0aW9uIFFUaXAodGFyZ2V0LCBvcHRpb25zLCBpZCwgYXR0cikge1xuXHQvLyBFbGVtZW50cyBhbmQgSURcblx0dGhpcy5pZCA9IGlkO1xuXHR0aGlzLnRhcmdldCA9IHRhcmdldDtcblx0dGhpcy50b29sdGlwID0gTlVMTDtcblx0dGhpcy5lbGVtZW50cyA9IHsgdGFyZ2V0OiB0YXJnZXQgfTtcblxuXHQvLyBJbnRlcm5hbCBjb25zdHJ1Y3RzXG5cdHRoaXMuX2lkID0gTkFNRVNQQUNFICsgJy0nICsgaWQ7XG5cdHRoaXMudGltZXJzID0geyBpbWc6IHt9IH07XG5cdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdHRoaXMucGx1Z2lucyA9IHt9O1xuXG5cdC8vIENhY2hlIG9iamVjdFxuXHR0aGlzLmNhY2hlID0ge1xuXHRcdGV2ZW50OiB7fSxcblx0XHR0YXJnZXQ6ICQoKSxcblx0XHRkaXNhYmxlZDogRkFMU0UsXG5cdFx0YXR0cjogYXR0cixcblx0XHRvblRvb2x0aXA6IEZBTFNFLFxuXHRcdGxhc3RDbGFzczogJydcblx0fTtcblxuXHQvLyBTZXQgdGhlIGluaXRpYWwgZmxhZ3Ncblx0dGhpcy5yZW5kZXJlZCA9IHRoaXMuZGVzdHJveWVkID0gdGhpcy5kaXNhYmxlZCA9IHRoaXMud2FpdGluZyA9XG5cdFx0dGhpcy5oaWRkZW5EdXJpbmdXYWl0ID0gdGhpcy5wb3NpdGlvbmluZyA9IHRoaXMudHJpZ2dlcmluZyA9IEZBTFNFO1xufVxuUFJPVE9UWVBFID0gUVRpcC5wcm90b3R5cGU7XG5cblBST1RPVFlQRS5fd2hlbiA9IGZ1bmN0aW9uKGRlZmVycmVkcykge1xuXHRyZXR1cm4gJC53aGVuLmFwcGx5KCQsIGRlZmVycmVkcyk7XG59O1xuXG5QUk9UT1RZUEUucmVuZGVyID0gZnVuY3Rpb24oc2hvdykge1xuXHRpZih0aGlzLnJlbmRlcmVkIHx8IHRoaXMuZGVzdHJveWVkKSB7IHJldHVybiB0aGlzOyB9IC8vIElmIHRvb2x0aXAgaGFzIGFscmVhZHkgYmVlbiByZW5kZXJlZCwgZXhpdFxuXG5cdHZhciBzZWxmID0gdGhpcyxcblx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdGNhY2hlID0gdGhpcy5jYWNoZSxcblx0XHRlbGVtZW50cyA9IHRoaXMuZWxlbWVudHMsXG5cdFx0dGV4dCA9IG9wdGlvbnMuY29udGVudC50ZXh0LFxuXHRcdHRpdGxlID0gb3B0aW9ucy5jb250ZW50LnRpdGxlLFxuXHRcdGJ1dHRvbiA9IG9wdGlvbnMuY29udGVudC5idXR0b24sXG5cdFx0cG9zT3B0aW9ucyA9IG9wdGlvbnMucG9zaXRpb24sXG5cdFx0ZGVmZXJyZWRzID0gW107XG5cblx0Ly8gQWRkIEFSSUEgYXR0cmlidXRlcyB0byB0YXJnZXRcblx0JC5hdHRyKHRoaXMudGFyZ2V0WzBdLCAnYXJpYS1kZXNjcmliZWRieScsIHRoaXMuX2lkKTtcblxuXHQvLyBDcmVhdGUgcHVibGljIHBvc2l0aW9uIG9iamVjdCB0aGF0IHRyYWNrcyBjdXJyZW50IHBvc2l0aW9uIGNvcm5lcnNcblx0Y2FjaGUucG9zQ2xhc3MgPSB0aGlzLl9jcmVhdGVQb3NDbGFzcyhcblx0XHQodGhpcy5wb3NpdGlvbiA9IHsgbXk6IHBvc09wdGlvbnMubXksIGF0OiBwb3NPcHRpb25zLmF0IH0pLm15XG5cdCk7XG5cblx0Ly8gQ3JlYXRlIHRvb2x0aXAgZWxlbWVudFxuXHR0aGlzLnRvb2x0aXAgPSBlbGVtZW50cy50b29sdGlwID0gJCgnPGRpdi8+Jywge1xuXHRcdCdpZCc6IHRoaXMuX2lkLFxuXHRcdCdjbGFzcyc6IFsgTkFNRVNQQUNFLCBDTEFTU19ERUZBVUxULCBvcHRpb25zLnN0eWxlLmNsYXNzZXMsIGNhY2hlLnBvc0NsYXNzIF0uam9pbignICcpLFxuXHRcdCd3aWR0aCc6IG9wdGlvbnMuc3R5bGUud2lkdGggfHwgJycsXG5cdFx0J2hlaWdodCc6IG9wdGlvbnMuc3R5bGUuaGVpZ2h0IHx8ICcnLFxuXHRcdCd0cmFja2luZyc6IHBvc09wdGlvbnMudGFyZ2V0ID09PSAnbW91c2UnICYmIHBvc09wdGlvbnMuYWRqdXN0Lm1vdXNlLFxuXG5cdFx0LyogQVJJQSBzcGVjaWZpYyBhdHRyaWJ1dGVzICovXG5cdFx0J3JvbGUnOiAnYWxlcnQnLFxuXHRcdCdhcmlhLWxpdmUnOiAncG9saXRlJyxcblx0XHQnYXJpYS1hdG9taWMnOiBGQUxTRSxcblx0XHQnYXJpYS1kZXNjcmliZWRieSc6IHRoaXMuX2lkICsgJy1jb250ZW50Jyxcblx0XHQnYXJpYS1oaWRkZW4nOiBUUlVFXG5cdH0pXG5cdC50b2dnbGVDbGFzcyhDTEFTU19ESVNBQkxFRCwgdGhpcy5kaXNhYmxlZClcblx0LmF0dHIoQVRUUl9JRCwgdGhpcy5pZClcblx0LmRhdGEoTkFNRVNQQUNFLCB0aGlzKVxuXHQuYXBwZW5kVG8ocG9zT3B0aW9ucy5jb250YWluZXIpXG5cdC5hcHBlbmQoXG5cdFx0Ly8gQ3JlYXRlIGNvbnRlbnQgZWxlbWVudFxuXHRcdGVsZW1lbnRzLmNvbnRlbnQgPSAkKCc8ZGl2IC8+Jywge1xuXHRcdFx0J2NsYXNzJzogTkFNRVNQQUNFICsgJy1jb250ZW50Jyxcblx0XHRcdCdpZCc6IHRoaXMuX2lkICsgJy1jb250ZW50Jyxcblx0XHRcdCdhcmlhLWF0b21pYyc6IFRSVUVcblx0XHR9KVxuXHQpO1xuXG5cdC8vIFNldCByZW5kZXJlZCBmbGFnIGFuZCBwcmV2ZW50IHJlZHVuZGFudCByZXBvc2l0aW9uIGNhbGxzIGZvciBub3dcblx0dGhpcy5yZW5kZXJlZCA9IC0xO1xuXHR0aGlzLnBvc2l0aW9uaW5nID0gVFJVRTtcblxuXHQvLyBDcmVhdGUgdGl0bGUuLi5cblx0aWYodGl0bGUpIHtcblx0XHR0aGlzLl9jcmVhdGVUaXRsZSgpO1xuXG5cdFx0Ly8gVXBkYXRlIHRpdGxlIG9ubHkgaWYgaXRzIG5vdCBhIGNhbGxiYWNrIChjYWxsZWQgaW4gdG9nZ2xlIGlmIHNvKVxuXHRcdGlmKCEkLmlzRnVuY3Rpb24odGl0bGUpKSB7XG5cdFx0XHRkZWZlcnJlZHMucHVzaCggdGhpcy5fdXBkYXRlVGl0bGUodGl0bGUsIEZBTFNFKSApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENyZWF0ZSBidXR0b25cblx0aWYoYnV0dG9uKSB7IHRoaXMuX2NyZWF0ZUJ1dHRvbigpOyB9XG5cblx0Ly8gU2V0IHByb3BlciByZW5kZXJlZCBmbGFnIGFuZCB1cGRhdGUgY29udGVudCBpZiBub3QgYSBjYWxsYmFjayBmdW5jdGlvbiAoY2FsbGVkIGluIHRvZ2dsZSlcblx0aWYoISQuaXNGdW5jdGlvbih0ZXh0KSkge1xuXHRcdGRlZmVycmVkcy5wdXNoKCB0aGlzLl91cGRhdGVDb250ZW50KHRleHQsIEZBTFNFKSApO1xuXHR9XG5cdHRoaXMucmVuZGVyZWQgPSBUUlVFO1xuXG5cdC8vIFNldHVwIHdpZGdldCBjbGFzc2VzXG5cdHRoaXMuX3NldFdpZGdldCgpO1xuXG5cdC8vIEluaXRpYWxpemUgJ3JlbmRlcicgcGx1Z2luc1xuXHQkLmVhY2goUExVR0lOUywgZnVuY3Rpb24obmFtZSkge1xuXHRcdHZhciBpbnN0YW5jZTtcblx0XHRpZih0aGlzLmluaXRpYWxpemUgPT09ICdyZW5kZXInICYmIChpbnN0YW5jZSA9IHRoaXMoc2VsZikpKSB7XG5cdFx0XHRzZWxmLnBsdWdpbnNbbmFtZV0gPSBpbnN0YW5jZTtcblx0XHR9XG5cdH0pO1xuXG5cdC8vIFVuYXNzaWduIGluaXRpYWwgZXZlbnRzIGFuZCBhc3NpZ24gcHJvcGVyIGV2ZW50c1xuXHR0aGlzLl91bmFzc2lnbkV2ZW50cygpO1xuXHR0aGlzLl9hc3NpZ25FdmVudHMoKTtcblxuXHQvLyBXaGVuIGRlZmVycmVkcyBoYXZlIGNvbXBsZXRlZFxuXHR0aGlzLl93aGVuKGRlZmVycmVkcykudGhlbihmdW5jdGlvbigpIHtcblx0XHQvLyB0b29sdGlwcmVuZGVyIGV2ZW50XG5cdFx0c2VsZi5fdHJpZ2dlcigncmVuZGVyJyk7XG5cblx0XHQvLyBSZXNldCBmbGFnc1xuXHRcdHNlbGYucG9zaXRpb25pbmcgPSBGQUxTRTtcblxuXHRcdC8vIFNob3cgdG9vbHRpcCBpZiBub3QgaGlkZGVuIGR1cmluZyB3YWl0IHBlcmlvZFxuXHRcdGlmKCFzZWxmLmhpZGRlbkR1cmluZ1dhaXQgJiYgKG9wdGlvbnMuc2hvdy5yZWFkeSB8fCBzaG93KSkge1xuXHRcdFx0c2VsZi50b2dnbGUoVFJVRSwgY2FjaGUuZXZlbnQsIEZBTFNFKTtcblx0XHR9XG5cdFx0c2VsZi5oaWRkZW5EdXJpbmdXYWl0ID0gRkFMU0U7XG5cdH0pO1xuXG5cdC8vIEV4cG9zZSBBUElcblx0UVRJUC5hcGlbdGhpcy5pZF0gPSB0aGlzO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxuUFJPVE9UWVBFLmRlc3Ryb3kgPSBmdW5jdGlvbihpbW1lZGlhdGUpIHtcblx0Ly8gU2V0IGZsYWcgdGhlIHNpZ25pZnkgZGVzdHJveSBpcyB0YWtpbmcgcGxhY2UgdG8gcGx1Z2luc1xuXHQvLyBhbmQgZW5zdXJlIGl0IG9ubHkgZ2V0cyBkZXN0cm95ZWQgb25jZSFcblx0aWYodGhpcy5kZXN0cm95ZWQpIHsgcmV0dXJuIHRoaXMudGFyZ2V0OyB9XG5cblx0ZnVuY3Rpb24gcHJvY2VzcygpIHtcblx0XHRpZih0aGlzLmRlc3Ryb3llZCkgeyByZXR1cm47IH1cblx0XHR0aGlzLmRlc3Ryb3llZCA9IFRSVUU7XG5cblx0XHR2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXQsXG5cdFx0XHR0aXRsZSA9IHRhcmdldC5hdHRyKG9sZHRpdGxlKSxcblx0XHRcdHRpbWVyO1xuXG5cdFx0Ly8gRGVzdHJveSB0b29sdGlwIGlmIHJlbmRlcmVkXG5cdFx0aWYodGhpcy5yZW5kZXJlZCkge1xuXHRcdFx0dGhpcy50b29sdGlwLnN0b3AoMSwwKS5maW5kKCcqJykucmVtb3ZlKCkuZW5kKCkucmVtb3ZlKCk7XG5cdFx0fVxuXG5cdFx0Ly8gRGVzdHJveSBhbGwgcGx1Z2luc1xuXHRcdCQuZWFjaCh0aGlzLnBsdWdpbnMsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5kZXN0cm95ICYmIHRoaXMuZGVzdHJveSgpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gQ2xlYXIgdGltZXJzXG5cdFx0Zm9yICh0aW1lciBpbiB0aGlzLnRpbWVycykge1xuXHRcdFx0aWYgKHRoaXMudGltZXJzLmhhc093blByb3BlcnR5KHRpbWVyKSkge1xuXHRcdFx0XHRjbGVhclRpbWVvdXQodGhpcy50aW1lcnNbdGltZXJdKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgYXBpIG9iamVjdCBhbmQgQVJJQSBhdHRyaWJ1dGVzXG5cdFx0dGFyZ2V0LnJlbW92ZURhdGEoTkFNRVNQQUNFKVxuXHRcdFx0LnJlbW92ZUF0dHIoQVRUUl9JRClcblx0XHRcdC5yZW1vdmVBdHRyKEFUVFJfSEFTKVxuXHRcdFx0LnJlbW92ZUF0dHIoJ2FyaWEtZGVzY3JpYmVkYnknKTtcblxuXHRcdC8vIFJlc2V0IG9sZCB0aXRsZSBhdHRyaWJ1dGUgaWYgcmVtb3ZlZFxuXHRcdGlmKHRoaXMub3B0aW9ucy5zdXBwcmVzcyAmJiB0aXRsZSkge1xuXHRcdFx0dGFyZ2V0LmF0dHIoJ3RpdGxlJywgdGl0bGUpLnJlbW92ZUF0dHIob2xkdGl0bGUpO1xuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSBxVGlwIGV2ZW50cyBhc3NvY2lhdGVkIHdpdGggdGhpcyBBUElcblx0XHR0aGlzLl91bmFzc2lnbkV2ZW50cygpO1xuXG5cdFx0Ly8gUmVtb3ZlIElEIGZyb20gdXNlZCBpZCBvYmplY3RzLCBhbmQgZGVsZXRlIG9iamVjdCByZWZlcmVuY2VzXG5cdFx0Ly8gZm9yIGJldHRlciBnYXJiYWdlIGNvbGxlY3Rpb24gYW5kIGxlYWsgcHJvdGVjdGlvblxuXHRcdHRoaXMub3B0aW9ucyA9IHRoaXMuZWxlbWVudHMgPSB0aGlzLmNhY2hlID0gdGhpcy50aW1lcnMgPVxuXHRcdFx0dGhpcy5wbHVnaW5zID0gdGhpcy5tb3VzZSA9IE5VTEw7XG5cblx0XHQvLyBEZWxldGUgZXBveHNlZCBBUEkgb2JqZWN0XG5cdFx0ZGVsZXRlIFFUSVAuYXBpW3RoaXMuaWRdO1xuXHR9XG5cblx0Ly8gSWYgYW4gaW1tZWRpYXRlIGRlc3Ryb3kgaXMgbmVlZGVkXG5cdGlmKChpbW1lZGlhdGUgIT09IFRSVUUgfHwgdGhpcy50cmlnZ2VyaW5nID09PSAnaGlkZScpICYmIHRoaXMucmVuZGVyZWQpIHtcblx0XHR0aGlzLnRvb2x0aXAub25lKCd0b29sdGlwaGlkZGVuJywgJC5wcm94eShwcm9jZXNzLCB0aGlzKSk7XG5cdFx0IXRoaXMudHJpZ2dlcmluZyAmJiB0aGlzLmhpZGUoKTtcblx0fVxuXG5cdC8vIElmIHdlJ3JlIG5vdCBpbiB0aGUgcHJvY2VzcyBvZiBoaWRpbmcuLi4gcHJvY2Vzc1xuXHRlbHNlIHsgcHJvY2Vzcy5jYWxsKHRoaXMpOyB9XG5cblx0cmV0dXJuIHRoaXMudGFyZ2V0O1xufTtcbjtmdW5jdGlvbiBpbnZhbGlkT3B0KGEpIHtcblx0cmV0dXJuIGEgPT09IE5VTEwgfHwgJC50eXBlKGEpICE9PSAnb2JqZWN0Jztcbn1cblxuZnVuY3Rpb24gaW52YWxpZENvbnRlbnQoYykge1xuXHRyZXR1cm4gISgkLmlzRnVuY3Rpb24oYykgfHwgXG4gICAgICAgICAgICBjICYmIGMuYXR0ciB8fCBcbiAgICAgICAgICAgIGMubGVuZ3RoIHx8IFxuICAgICAgICAgICAgJC50eXBlKGMpID09PSAnb2JqZWN0JyAmJiAoYy5qcXVlcnkgfHwgYy50aGVuKSk7XG59XG5cbi8vIE9wdGlvbiBvYmplY3Qgc2FuaXRpemVyXG5mdW5jdGlvbiBzYW5pdGl6ZU9wdGlvbnMob3B0cykge1xuXHR2YXIgY29udGVudCwgdGV4dCwgYWpheCwgb25jZTtcblxuXHRpZihpbnZhbGlkT3B0KG9wdHMpKSB7IHJldHVybiBGQUxTRTsgfVxuXG5cdGlmKGludmFsaWRPcHQob3B0cy5tZXRhZGF0YSkpIHtcblx0XHRvcHRzLm1ldGFkYXRhID0geyB0eXBlOiBvcHRzLm1ldGFkYXRhIH07XG5cdH1cblxuXHRpZignY29udGVudCcgaW4gb3B0cykge1xuXHRcdGNvbnRlbnQgPSBvcHRzLmNvbnRlbnQ7XG5cblx0XHRpZihpbnZhbGlkT3B0KGNvbnRlbnQpIHx8IGNvbnRlbnQuanF1ZXJ5IHx8IGNvbnRlbnQuZG9uZSkge1xuXHRcdFx0dGV4dCA9IGludmFsaWRDb250ZW50KGNvbnRlbnQpID8gRkFMU0UgOiBjb250ZW50O1xuXHRcdFx0Y29udGVudCA9IG9wdHMuY29udGVudCA9IHtcblx0XHRcdFx0dGV4dDogdGV4dFxuXHRcdFx0fTtcblx0XHR9XG5cdFx0ZWxzZSB7IHRleHQgPSBjb250ZW50LnRleHQ7IH1cblxuXHRcdC8vIERFUFJFQ0FURUQgLSBPbGQgY29udGVudC5hamF4IHBsdWdpbiBmdW5jdGlvbmFsaXR5XG5cdFx0Ly8gQ29udmVydHMgaXQgaW50byB0aGUgcHJvcGVyIERlZmVycmVkIHN5bnRheFxuXHRcdGlmKCdhamF4JyBpbiBjb250ZW50KSB7XG5cdFx0XHRhamF4ID0gY29udGVudC5hamF4O1xuXHRcdFx0b25jZSA9IGFqYXggJiYgYWpheC5vbmNlICE9PSBGQUxTRTtcblx0XHRcdGRlbGV0ZSBjb250ZW50LmFqYXg7XG5cblx0XHRcdGNvbnRlbnQudGV4dCA9IGZ1bmN0aW9uKGV2ZW50LCBhcGkpIHtcblx0XHRcdFx0dmFyIGxvYWRpbmcgPSB0ZXh0IHx8ICQodGhpcykuYXR0cihhcGkub3B0aW9ucy5jb250ZW50LmF0dHIpIHx8ICdMb2FkaW5nLi4uJyxcblxuXHRcdFx0XHRkZWZlcnJlZCA9ICQuYWpheChcblx0XHRcdFx0XHQkLmV4dGVuZCh7fSwgYWpheCwgeyBjb250ZXh0OiBhcGkgfSlcblx0XHRcdFx0KVxuXHRcdFx0XHQudGhlbihhamF4LnN1Y2Nlc3MsIE5VTEwsIGFqYXguZXJyb3IpXG5cdFx0XHRcdC50aGVuKGZ1bmN0aW9uKG5ld0NvbnRlbnQpIHtcblx0XHRcdFx0XHRpZihuZXdDb250ZW50ICYmIG9uY2UpIHsgYXBpLnNldCgnY29udGVudC50ZXh0JywgbmV3Q29udGVudCk7IH1cblx0XHRcdFx0XHRyZXR1cm4gbmV3Q29udGVudDtcblx0XHRcdFx0fSxcblx0XHRcdFx0ZnVuY3Rpb24oeGhyLCBzdGF0dXMsIGVycm9yKSB7XG5cdFx0XHRcdFx0aWYoYXBpLmRlc3Ryb3llZCB8fCB4aHIuc3RhdHVzID09PSAwKSB7IHJldHVybjsgfVxuXHRcdFx0XHRcdGFwaS5zZXQoJ2NvbnRlbnQudGV4dCcsIHN0YXR1cyArICc6ICcgKyBlcnJvcik7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHJldHVybiAhb25jZSA/IChhcGkuc2V0KCdjb250ZW50LnRleHQnLCBsb2FkaW5nKSwgZGVmZXJyZWQpIDogbG9hZGluZztcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0aWYoJ3RpdGxlJyBpbiBjb250ZW50KSB7XG5cdFx0XHRpZigkLmlzUGxhaW5PYmplY3QoY29udGVudC50aXRsZSkpIHtcblx0XHRcdFx0Y29udGVudC5idXR0b24gPSBjb250ZW50LnRpdGxlLmJ1dHRvbjtcblx0XHRcdFx0Y29udGVudC50aXRsZSA9IGNvbnRlbnQudGl0bGUudGV4dDtcblx0XHRcdH1cblxuXHRcdFx0aWYoaW52YWxpZENvbnRlbnQoY29udGVudC50aXRsZSB8fCBGQUxTRSkpIHtcblx0XHRcdFx0Y29udGVudC50aXRsZSA9IEZBTFNFO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmKCdwb3NpdGlvbicgaW4gb3B0cyAmJiBpbnZhbGlkT3B0KG9wdHMucG9zaXRpb24pKSB7XG5cdFx0b3B0cy5wb3NpdGlvbiA9IHsgbXk6IG9wdHMucG9zaXRpb24sIGF0OiBvcHRzLnBvc2l0aW9uIH07XG5cdH1cblxuXHRpZignc2hvdycgaW4gb3B0cyAmJiBpbnZhbGlkT3B0KG9wdHMuc2hvdykpIHtcblx0XHRvcHRzLnNob3cgPSBvcHRzLnNob3cuanF1ZXJ5ID8geyB0YXJnZXQ6IG9wdHMuc2hvdyB9IDpcblx0XHRcdG9wdHMuc2hvdyA9PT0gVFJVRSA/IHsgcmVhZHk6IFRSVUUgfSA6IHsgZXZlbnQ6IG9wdHMuc2hvdyB9O1xuXHR9XG5cblx0aWYoJ2hpZGUnIGluIG9wdHMgJiYgaW52YWxpZE9wdChvcHRzLmhpZGUpKSB7XG5cdFx0b3B0cy5oaWRlID0gb3B0cy5oaWRlLmpxdWVyeSA/IHsgdGFyZ2V0OiBvcHRzLmhpZGUgfSA6IHsgZXZlbnQ6IG9wdHMuaGlkZSB9O1xuXHR9XG5cblx0aWYoJ3N0eWxlJyBpbiBvcHRzICYmIGludmFsaWRPcHQob3B0cy5zdHlsZSkpIHtcblx0XHRvcHRzLnN0eWxlID0geyBjbGFzc2VzOiBvcHRzLnN0eWxlIH07XG5cdH1cblxuXHQvLyBTYW5pdGl6ZSBwbHVnaW4gb3B0aW9uc1xuXHQkLmVhY2goUExVR0lOUywgZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5zYW5pdGl6ZSAmJiB0aGlzLnNhbml0aXplKG9wdHMpO1xuXHR9KTtcblxuXHRyZXR1cm4gb3B0cztcbn1cblxuLy8gU2V0dXAgYnVpbHRpbiAuc2V0KCkgb3B0aW9uIGNoZWNrc1xuQ0hFQ0tTID0gUFJPVE9UWVBFLmNoZWNrcyA9IHtcblx0YnVpbHRpbjoge1xuXHRcdC8vIENvcmUgY2hlY2tzXG5cdFx0J15pZCQnOiBmdW5jdGlvbihvYmosIG8sIHYsIHByZXYpIHtcblx0XHRcdHZhciBpZCA9IHYgPT09IFRSVUUgPyBRVElQLm5leHRpZCA6IHYsXG5cdFx0XHRcdG5ld0lkID0gTkFNRVNQQUNFICsgJy0nICsgaWQ7XG5cblx0XHRcdGlmKGlkICE9PSBGQUxTRSAmJiBpZC5sZW5ndGggPiAwICYmICEkKCcjJytuZXdJZCkubGVuZ3RoKSB7XG5cdFx0XHRcdHRoaXMuX2lkID0gbmV3SWQ7XG5cblx0XHRcdFx0aWYodGhpcy5yZW5kZXJlZCkge1xuXHRcdFx0XHRcdHRoaXMudG9vbHRpcFswXS5pZCA9IHRoaXMuX2lkO1xuXHRcdFx0XHRcdHRoaXMuZWxlbWVudHMuY29udGVudFswXS5pZCA9IHRoaXMuX2lkICsgJy1jb250ZW50Jztcblx0XHRcdFx0XHR0aGlzLmVsZW1lbnRzLnRpdGxlWzBdLmlkID0gdGhpcy5faWQgKyAnLXRpdGxlJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7IG9ialtvXSA9IHByZXY7IH1cblx0XHR9LFxuXHRcdCdecHJlcmVuZGVyJzogZnVuY3Rpb24ob2JqLCBvLCB2KSB7XG5cdFx0XHR2ICYmICF0aGlzLnJlbmRlcmVkICYmIHRoaXMucmVuZGVyKHRoaXMub3B0aW9ucy5zaG93LnJlYWR5KTtcblx0XHR9LFxuXG5cdFx0Ly8gQ29udGVudCBjaGVja3Ncblx0XHQnXmNvbnRlbnQudGV4dCQnOiBmdW5jdGlvbihvYmosIG8sIHYpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZUNvbnRlbnQodik7XG5cdFx0fSxcblx0XHQnXmNvbnRlbnQuYXR0ciQnOiBmdW5jdGlvbihvYmosIG8sIHYsIHByZXYpIHtcblx0XHRcdGlmKHRoaXMub3B0aW9ucy5jb250ZW50LnRleHQgPT09IHRoaXMudGFyZ2V0LmF0dHIocHJldikpIHtcblx0XHRcdFx0dGhpcy5fdXBkYXRlQ29udGVudCggdGhpcy50YXJnZXQuYXR0cih2KSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0J15jb250ZW50LnRpdGxlJCc6IGZ1bmN0aW9uKG9iaiwgbywgdikge1xuXHRcdFx0Ly8gUmVtb3ZlIHRpdGxlIGlmIGNvbnRlbnQgaXMgbnVsbFxuXHRcdFx0aWYoIXYpIHsgcmV0dXJuIHRoaXMuX3JlbW92ZVRpdGxlKCk7IH1cblxuXHRcdFx0Ly8gSWYgdGl0bGUgaXNuJ3QgYWxyZWFkeSBjcmVhdGVkLCBjcmVhdGUgaXQgbm93IGFuZCB1cGRhdGVcblx0XHRcdHYgJiYgIXRoaXMuZWxlbWVudHMudGl0bGUgJiYgdGhpcy5fY3JlYXRlVGl0bGUoKTtcblx0XHRcdHRoaXMuX3VwZGF0ZVRpdGxlKHYpO1xuXHRcdH0sXG5cdFx0J15jb250ZW50LmJ1dHRvbiQnOiBmdW5jdGlvbihvYmosIG8sIHYpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZUJ1dHRvbih2KTtcblx0XHR9LFxuXHRcdCdeY29udGVudC50aXRsZS4odGV4dHxidXR0b24pJCc6IGZ1bmN0aW9uKG9iaiwgbywgdikge1xuXHRcdFx0dGhpcy5zZXQoJ2NvbnRlbnQuJytvLCB2KTsgLy8gQmFja3dhcmRzIHRpdGxlLnRleHQvYnV0dG9uIGNvbXBhdFxuXHRcdH0sXG5cblx0XHQvLyBQb3NpdGlvbiBjaGVja3Ncblx0XHQnXnBvc2l0aW9uLihteXxhdCkkJzogZnVuY3Rpb24ob2JqLCBvLCB2KXtcblx0XHRcdGlmKCdzdHJpbmcnID09PSB0eXBlb2Ygdikge1xuXHRcdFx0XHR0aGlzLnBvc2l0aW9uW29dID0gb2JqW29dID0gbmV3IENPUk5FUih2LCBvID09PSAnYXQnKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdCdecG9zaXRpb24uY29udGFpbmVyJCc6IGZ1bmN0aW9uKG9iaiwgbywgdil7XG5cdFx0XHR0aGlzLnJlbmRlcmVkICYmIHRoaXMudG9vbHRpcC5hcHBlbmRUbyh2KTtcblx0XHR9LFxuXG5cdFx0Ly8gU2hvdyBjaGVja3Ncblx0XHQnXnNob3cucmVhZHkkJzogZnVuY3Rpb24ob2JqLCBvLCB2KSB7XG5cdFx0XHR2ICYmICghdGhpcy5yZW5kZXJlZCAmJiB0aGlzLnJlbmRlcihUUlVFKSB8fCB0aGlzLnRvZ2dsZShUUlVFKSk7XG5cdFx0fSxcblxuXHRcdC8vIFN0eWxlIGNoZWNrc1xuXHRcdCdec3R5bGUuY2xhc3NlcyQnOiBmdW5jdGlvbihvYmosIG8sIHYsIHApIHtcblx0XHRcdHRoaXMucmVuZGVyZWQgJiYgdGhpcy50b29sdGlwLnJlbW92ZUNsYXNzKHApLmFkZENsYXNzKHYpO1xuXHRcdH0sXG5cdFx0J15zdHlsZS4od2lkdGh8aGVpZ2h0KSc6IGZ1bmN0aW9uKG9iaiwgbywgdikge1xuXHRcdFx0dGhpcy5yZW5kZXJlZCAmJiB0aGlzLnRvb2x0aXAuY3NzKG8sIHYpO1xuXHRcdH0sXG5cdFx0J15zdHlsZS53aWRnZXR8Y29udGVudC50aXRsZSc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5yZW5kZXJlZCAmJiB0aGlzLl9zZXRXaWRnZXQoKTtcblx0XHR9LFxuXHRcdCdec3R5bGUuZGVmJzogZnVuY3Rpb24ob2JqLCBvLCB2KSB7XG5cdFx0XHR0aGlzLnJlbmRlcmVkICYmIHRoaXMudG9vbHRpcC50b2dnbGVDbGFzcyhDTEFTU19ERUZBVUxULCAhIXYpO1xuXHRcdH0sXG5cblx0XHQvLyBFdmVudHMgY2hlY2tcblx0XHQnXmV2ZW50cy4ocmVuZGVyfHNob3d8bW92ZXxoaWRlfGZvY3VzfGJsdXIpJCc6IGZ1bmN0aW9uKG9iaiwgbywgdikge1xuXHRcdFx0dGhpcy5yZW5kZXJlZCAmJiB0aGlzLnRvb2x0aXBbKCQuaXNGdW5jdGlvbih2KSA/ICcnIDogJ3VuJykgKyAnYmluZCddKCd0b29sdGlwJytvLCB2KTtcblx0XHR9LFxuXG5cdFx0Ly8gUHJvcGVydGllcyB3aGljaCByZXF1aXJlIGV2ZW50IHJlYXNzaWdubWVudFxuXHRcdCdeKHNob3d8aGlkZXxwb3NpdGlvbikuKGV2ZW50fHRhcmdldHxmaXhlZHxpbmFjdGl2ZXxsZWF2ZXxkaXN0YW5jZXx2aWV3cG9ydHxhZGp1c3QpJzogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZighdGhpcy5yZW5kZXJlZCkgeyByZXR1cm47IH1cblxuXHRcdFx0Ly8gU2V0IHRyYWNraW5nIGZsYWdcblx0XHRcdHZhciBwb3NPcHRpb25zID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xuXHRcdFx0dGhpcy50b29sdGlwLmF0dHIoJ3RyYWNraW5nJywgcG9zT3B0aW9ucy50YXJnZXQgPT09ICdtb3VzZScgJiYgcG9zT3B0aW9ucy5hZGp1c3QubW91c2UpO1xuXG5cdFx0XHQvLyBSZWFzc2lnbiBldmVudHNcblx0XHRcdHRoaXMuX3VuYXNzaWduRXZlbnRzKCk7XG5cdFx0XHR0aGlzLl9hc3NpZ25FdmVudHMoKTtcblx0XHR9XG5cdH1cbn07XG5cbi8vIERvdCBub3RhdGlvbiBjb252ZXJ0ZXJcbmZ1bmN0aW9uIGNvbnZlcnROb3RhdGlvbihvcHRpb25zLCBub3RhdGlvbikge1xuXHR2YXIgaSA9IDAsIG9iaiwgb3B0aW9uID0gb3B0aW9ucyxcblxuXHQvLyBTcGxpdCBub3RhdGlvbiBpbnRvIGFycmF5XG5cdGxldmVscyA9IG5vdGF0aW9uLnNwbGl0KCcuJyk7XG5cblx0Ly8gTG9vcCB0aHJvdWdoXG5cdHdoaWxlKG9wdGlvbiA9IG9wdGlvblsgbGV2ZWxzW2krK10gXSkge1xuXHRcdGlmKGkgPCBsZXZlbHMubGVuZ3RoKSB7IG9iaiA9IG9wdGlvbjsgfVxuXHR9XG5cblx0cmV0dXJuIFtvYmogfHwgb3B0aW9ucywgbGV2ZWxzLnBvcCgpXTtcbn1cblxuUFJPVE9UWVBFLmdldCA9IGZ1bmN0aW9uKG5vdGF0aW9uKSB7XG5cdGlmKHRoaXMuZGVzdHJveWVkKSB7IHJldHVybiB0aGlzOyB9XG5cblx0dmFyIG8gPSBjb252ZXJ0Tm90YXRpb24odGhpcy5vcHRpb25zLCBub3RhdGlvbi50b0xvd2VyQ2FzZSgpKSxcblx0XHRyZXN1bHQgPSBvWzBdWyBvWzFdIF07XG5cblx0cmV0dXJuIHJlc3VsdC5wcmVjZWRhbmNlID8gcmVzdWx0LnN0cmluZygpIDogcmVzdWx0O1xufTtcblxuZnVuY3Rpb24gc2V0Q2FsbGJhY2sobm90YXRpb24sIGFyZ3MpIHtcblx0dmFyIGNhdGVnb3J5LCBydWxlLCBtYXRjaDtcblxuXHRmb3IoY2F0ZWdvcnkgaW4gdGhpcy5jaGVja3MpIHtcblx0XHRpZiAoIXRoaXMuY2hlY2tzLmhhc093blByb3BlcnR5KGNhdGVnb3J5KSkgeyBjb250aW51ZTsgfVxuXG5cdFx0Zm9yKHJ1bGUgaW4gdGhpcy5jaGVja3NbY2F0ZWdvcnldKSB7XG5cdFx0XHRpZiAoIXRoaXMuY2hlY2tzW2NhdGVnb3J5XS5oYXNPd25Qcm9wZXJ0eShydWxlKSkgeyBjb250aW51ZTsgfVxuXG5cdFx0XHRpZihtYXRjaCA9IChuZXcgUmVnRXhwKHJ1bGUsICdpJykpLmV4ZWMobm90YXRpb24pKSB7XG5cdFx0XHRcdGFyZ3MucHVzaChtYXRjaCk7XG5cblx0XHRcdFx0aWYoY2F0ZWdvcnkgPT09ICdidWlsdGluJyB8fCB0aGlzLnBsdWdpbnNbY2F0ZWdvcnldKSB7XG5cdFx0XHRcdFx0dGhpcy5jaGVja3NbY2F0ZWdvcnldW3J1bGVdLmFwcGx5KFxuXHRcdFx0XHRcdFx0dGhpcy5wbHVnaW5zW2NhdGVnb3J5XSB8fCB0aGlzLCBhcmdzXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG52YXIgcm1vdmUgPSAvXnBvc2l0aW9uXFwuKG15fGF0fGFkanVzdHx0YXJnZXR8Y29udGFpbmVyfHZpZXdwb3J0KXxzdHlsZXxjb250ZW50fHNob3dcXC5yZWFkeS9pLFxuXHRycmVuZGVyID0gL15wcmVyZW5kZXJ8c2hvd1xcLnJlYWR5L2k7XG5cblBST1RPVFlQRS5zZXQgPSBmdW5jdGlvbihvcHRpb24sIHZhbHVlKSB7XG5cdGlmKHRoaXMuZGVzdHJveWVkKSB7IHJldHVybiB0aGlzOyB9XG5cblx0dmFyIHJlbmRlcmVkID0gdGhpcy5yZW5kZXJlZCxcblx0XHRyZXBvc2l0aW9uID0gRkFMU0UsXG5cdFx0b3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRuYW1lO1xuXG5cdC8vIENvbnZlcnQgc2luZ3VsYXIgb3B0aW9uL3ZhbHVlIHBhaXIgaW50byBvYmplY3QgZm9ybVxuXHRpZignc3RyaW5nJyA9PT0gdHlwZW9mIG9wdGlvbikge1xuXHRcdG5hbWUgPSBvcHRpb247IG9wdGlvbiA9IHt9OyBvcHRpb25bbmFtZV0gPSB2YWx1ZTtcblx0fVxuXHRlbHNlIHsgb3B0aW9uID0gJC5leHRlbmQoe30sIG9wdGlvbik7IH1cblxuXHQvLyBTZXQgYWxsIG9mIHRoZSBkZWZpbmVkIG9wdGlvbnMgdG8gdGhlaXIgbmV3IHZhbHVlc1xuXHQkLmVhY2gob3B0aW9uLCBmdW5jdGlvbihub3RhdGlvbiwgdmFsKSB7XG5cdFx0aWYocmVuZGVyZWQgJiYgcnJlbmRlci50ZXN0KG5vdGF0aW9uKSkge1xuXHRcdFx0ZGVsZXRlIG9wdGlvbltub3RhdGlvbl07IHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBTZXQgbmV3IG9iaiB2YWx1ZVxuXHRcdHZhciBvYmogPSBjb252ZXJ0Tm90YXRpb24ob3B0aW9ucywgbm90YXRpb24udG9Mb3dlckNhc2UoKSksIHByZXZpb3VzO1xuXHRcdHByZXZpb3VzID0gb2JqWzBdWyBvYmpbMV0gXTtcblx0XHRvYmpbMF1bIG9ialsxXSBdID0gdmFsICYmIHZhbC5ub2RlVHlwZSA/ICQodmFsKSA6IHZhbDtcblxuXHRcdC8vIEFsc28gY2hlY2sgaWYgd2UgbmVlZCB0byByZXBvc2l0aW9uXG5cdFx0cmVwb3NpdGlvbiA9IHJtb3ZlLnRlc3Qobm90YXRpb24pIHx8IHJlcG9zaXRpb247XG5cblx0XHQvLyBTZXQgdGhlIG5ldyBwYXJhbXMgZm9yIHRoZSBjYWxsYmFja1xuXHRcdG9wdGlvbltub3RhdGlvbl0gPSBbb2JqWzBdLCBvYmpbMV0sIHZhbCwgcHJldmlvdXNdO1xuXHR9KTtcblxuXHQvLyBSZS1zYW5pdGl6ZSBvcHRpb25zXG5cdHNhbml0aXplT3B0aW9ucyhvcHRpb25zKTtcblxuXHQvKlxuXHQgKiBFeGVjdXRlIGFueSB2YWxpZCBjYWxsYmFja3MgZm9yIHRoZSBzZXQgb3B0aW9uc1xuXHQgKiBBbHNvIHNldCBwb3NpdGlvbmluZyBmbGFnIHNvIHdlIGRvbid0IGdldCBsb2FkcyBvZiByZWR1bmRhbnQgcmVwb3NpdGlvbmluZyBjYWxscy5cblx0ICovXG5cdHRoaXMucG9zaXRpb25pbmcgPSBUUlVFO1xuXHQkLmVhY2gob3B0aW9uLCAkLnByb3h5KHNldENhbGxiYWNrLCB0aGlzKSk7XG5cdHRoaXMucG9zaXRpb25pbmcgPSBGQUxTRTtcblxuXHQvLyBVcGRhdGUgcG9zaXRpb24gaWYgbmVlZGVkXG5cdGlmKHRoaXMucmVuZGVyZWQgJiYgdGhpcy50b29sdGlwWzBdLm9mZnNldFdpZHRoID4gMCAmJiByZXBvc2l0aW9uKSB7XG5cdFx0dGhpcy5yZXBvc2l0aW9uKCBvcHRpb25zLnBvc2l0aW9uLnRhcmdldCA9PT0gJ21vdXNlJyA/IE5VTEwgOiB0aGlzLmNhY2hlLmV2ZW50ICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG47UFJPVE9UWVBFLl91cGRhdGUgPSBmdW5jdGlvbihjb250ZW50LCBlbGVtZW50KSB7XG5cdHZhciBzZWxmID0gdGhpcyxcblx0XHRjYWNoZSA9IHRoaXMuY2FjaGU7XG5cblx0Ly8gTWFrZSBzdXJlIHRvb2x0aXAgaXMgcmVuZGVyZWQgYW5kIGNvbnRlbnQgaXMgZGVmaW5lZC4gSWYgbm90IHJldHVyblxuXHRpZighdGhpcy5yZW5kZXJlZCB8fCAhY29udGVudCkgeyByZXR1cm4gRkFMU0U7IH1cblxuXHQvLyBVc2UgZnVuY3Rpb24gdG8gcGFyc2UgY29udGVudFxuXHRpZigkLmlzRnVuY3Rpb24oY29udGVudCkpIHtcblx0XHRjb250ZW50ID0gY29udGVudC5jYWxsKHRoaXMuZWxlbWVudHMudGFyZ2V0LCBjYWNoZS5ldmVudCwgdGhpcykgfHwgJyc7XG5cdH1cblxuXHQvLyBIYW5kbGUgZGVmZXJyZWQgY29udGVudFxuXHRpZigkLmlzRnVuY3Rpb24oY29udGVudC50aGVuKSkge1xuXHRcdGNhY2hlLndhaXRpbmcgPSBUUlVFO1xuXHRcdHJldHVybiBjb250ZW50LnRoZW4oZnVuY3Rpb24oYykge1xuXHRcdFx0Y2FjaGUud2FpdGluZyA9IEZBTFNFO1xuXHRcdFx0cmV0dXJuIHNlbGYuX3VwZGF0ZShjLCBlbGVtZW50KTtcblx0XHR9LCBOVUxMLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRyZXR1cm4gc2VsZi5fdXBkYXRlKGUsIGVsZW1lbnQpO1xuXHRcdH0pO1xuXHR9XG5cblx0Ly8gSWYgY29udGVudCBpcyBudWxsLi4uIHJldHVybiBmYWxzZVxuXHRpZihjb250ZW50ID09PSBGQUxTRSB8fCAhY29udGVudCAmJiBjb250ZW50ICE9PSAnJykgeyByZXR1cm4gRkFMU0U7IH1cblxuXHQvLyBBcHBlbmQgbmV3IGNvbnRlbnQgaWYgaXRzIGEgRE9NIGFycmF5IGFuZCBzaG93IGl0IGlmIGhpZGRlblxuXHRpZihjb250ZW50LmpxdWVyeSAmJiBjb250ZW50Lmxlbmd0aCA+IDApIHtcblx0XHRlbGVtZW50LmVtcHR5KCkuYXBwZW5kKFxuXHRcdFx0Y29udGVudC5jc3MoeyBkaXNwbGF5OiAnYmxvY2snLCB2aXNpYmlsaXR5OiAndmlzaWJsZScgfSlcblx0XHQpO1xuXHR9XG5cblx0Ly8gQ29udGVudCBpcyBhIHJlZ3VsYXIgc3RyaW5nLCBpbnNlcnQgdGhlIG5ldyBjb250ZW50XG5cdGVsc2UgeyBlbGVtZW50Lmh0bWwoY29udGVudCk7IH1cblxuXHQvLyBXYWl0IGZvciBjb250ZW50IHRvIGJlIGxvYWRlZCwgYW5kIHJlcG9zaXRpb25cblx0cmV0dXJuIHRoaXMuX3dhaXRGb3JDb250ZW50KGVsZW1lbnQpLnRoZW4oZnVuY3Rpb24oaW1hZ2VzKSB7XG5cdFx0aWYoc2VsZi5yZW5kZXJlZCAmJiBzZWxmLnRvb2x0aXBbMF0ub2Zmc2V0V2lkdGggPiAwKSB7XG5cdFx0XHRzZWxmLnJlcG9zaXRpb24oY2FjaGUuZXZlbnQsICFpbWFnZXMubGVuZ3RoKTtcblx0XHR9XG5cdH0pO1xufTtcblxuUFJPVE9UWVBFLl93YWl0Rm9yQ29udGVudCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0dmFyIGNhY2hlID0gdGhpcy5jYWNoZTtcblxuXHQvLyBTZXQgZmxhZ1xuXHRjYWNoZS53YWl0aW5nID0gVFJVRTtcblxuXHQvLyBJZiBpbWFnZXNMb2FkZWQgaXMgaW5jbHVkZWQsIGVuc3VyZSBpbWFnZXMgaGF2ZSBsb2FkZWQgYW5kIHJldHVybiBwcm9taXNlXG5cdHJldHVybiAoICQuZm4uaW1hZ2VzTG9hZGVkID8gZWxlbWVudC5pbWFnZXNMb2FkZWQoKSA6IG5ldyAkLkRlZmVycmVkKCkucmVzb2x2ZShbXSkgKVxuXHRcdC5kb25lKGZ1bmN0aW9uKCkgeyBjYWNoZS53YWl0aW5nID0gRkFMU0U7IH0pXG5cdFx0LnByb21pc2UoKTtcbn07XG5cblBST1RPVFlQRS5fdXBkYXRlQ29udGVudCA9IGZ1bmN0aW9uKGNvbnRlbnQsIHJlcG9zaXRpb24pIHtcblx0dGhpcy5fdXBkYXRlKGNvbnRlbnQsIHRoaXMuZWxlbWVudHMuY29udGVudCwgcmVwb3NpdGlvbik7XG59O1xuXG5QUk9UT1RZUEUuX3VwZGF0ZVRpdGxlID0gZnVuY3Rpb24oY29udGVudCwgcmVwb3NpdGlvbikge1xuXHRpZih0aGlzLl91cGRhdGUoY29udGVudCwgdGhpcy5lbGVtZW50cy50aXRsZSwgcmVwb3NpdGlvbikgPT09IEZBTFNFKSB7XG5cdFx0dGhpcy5fcmVtb3ZlVGl0bGUoRkFMU0UpO1xuXHR9XG59O1xuXG5QUk9UT1RZUEUuX2NyZWF0ZVRpdGxlID0gZnVuY3Rpb24oKVxue1xuXHR2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzLFxuXHRcdGlkID0gdGhpcy5faWQrJy10aXRsZSc7XG5cblx0Ly8gRGVzdHJveSBwcmV2aW91cyB0aXRsZSBlbGVtZW50LCBpZiBwcmVzZW50XG5cdGlmKGVsZW1lbnRzLnRpdGxlYmFyKSB7IHRoaXMuX3JlbW92ZVRpdGxlKCk7IH1cblxuXHQvLyBDcmVhdGUgdGl0bGUgYmFyIGFuZCB0aXRsZSBlbGVtZW50c1xuXHRlbGVtZW50cy50aXRsZWJhciA9ICQoJzxkaXYgLz4nLCB7XG5cdFx0J2NsYXNzJzogTkFNRVNQQUNFICsgJy10aXRsZWJhciAnICsgKHRoaXMub3B0aW9ucy5zdHlsZS53aWRnZXQgPyBjcmVhdGVXaWRnZXRDbGFzcygnaGVhZGVyJykgOiAnJylcblx0fSlcblx0LmFwcGVuZChcblx0XHRlbGVtZW50cy50aXRsZSA9ICQoJzxkaXYgLz4nLCB7XG5cdFx0XHQnaWQnOiBpZCxcblx0XHRcdCdjbGFzcyc6IE5BTUVTUEFDRSArICctdGl0bGUnLFxuXHRcdFx0J2FyaWEtYXRvbWljJzogVFJVRVxuXHRcdH0pXG5cdClcblx0Lmluc2VydEJlZm9yZShlbGVtZW50cy5jb250ZW50KVxuXG5cdC8vIEJ1dHRvbi1zcGVjaWZpYyBldmVudHNcblx0LmRlbGVnYXRlKCcucXRpcC1jbG9zZScsICdtb3VzZWRvd24ga2V5ZG93biBtb3VzZXVwIGtleXVwIG1vdXNlb3V0JywgZnVuY3Rpb24oZXZlbnQpIHtcblx0XHQkKHRoaXMpLnRvZ2dsZUNsYXNzKCd1aS1zdGF0ZS1hY3RpdmUgdWktc3RhdGUtZm9jdXMnLCBldmVudC50eXBlLnN1YnN0cigtNCkgPT09ICdkb3duJyk7XG5cdH0pXG5cdC5kZWxlZ2F0ZSgnLnF0aXAtY2xvc2UnLCAnbW91c2VvdmVyIG1vdXNlb3V0JywgZnVuY3Rpb24oZXZlbnQpe1xuXHRcdCQodGhpcykudG9nZ2xlQ2xhc3MoJ3VpLXN0YXRlLWhvdmVyJywgZXZlbnQudHlwZSA9PT0gJ21vdXNlb3ZlcicpO1xuXHR9KTtcblxuXHQvLyBDcmVhdGUgYnV0dG9uIGlmIGVuYWJsZWRcblx0aWYodGhpcy5vcHRpb25zLmNvbnRlbnQuYnV0dG9uKSB7IHRoaXMuX2NyZWF0ZUJ1dHRvbigpOyB9XG59O1xuXG5QUk9UT1RZUEUuX3JlbW92ZVRpdGxlID0gZnVuY3Rpb24ocmVwb3NpdGlvbilcbntcblx0dmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cztcblxuXHRpZihlbGVtZW50cy50aXRsZSkge1xuXHRcdGVsZW1lbnRzLnRpdGxlYmFyLnJlbW92ZSgpO1xuXHRcdGVsZW1lbnRzLnRpdGxlYmFyID0gZWxlbWVudHMudGl0bGUgPSBlbGVtZW50cy5idXR0b24gPSBOVUxMO1xuXG5cdFx0Ly8gUmVwb3NpdGlvbiBpZiBlbmFibGVkXG5cdFx0aWYocmVwb3NpdGlvbiAhPT0gRkFMU0UpIHsgdGhpcy5yZXBvc2l0aW9uKCk7IH1cblx0fVxufTtcbjtQUk9UT1RZUEUuX2NyZWF0ZVBvc0NsYXNzID0gZnVuY3Rpb24obXkpIHtcblx0cmV0dXJuIE5BTUVTUEFDRSArICctcG9zLScgKyAobXkgfHwgdGhpcy5vcHRpb25zLnBvc2l0aW9uLm15KS5hYmJyZXYoKTtcbn07XG5cblBST1RPVFlQRS5yZXBvc2l0aW9uID0gZnVuY3Rpb24oZXZlbnQsIGVmZmVjdCkge1xuXHRpZighdGhpcy5yZW5kZXJlZCB8fCB0aGlzLnBvc2l0aW9uaW5nIHx8IHRoaXMuZGVzdHJveWVkKSB7IHJldHVybiB0aGlzOyB9XG5cblx0Ly8gU2V0IHBvc2l0aW9uaW5nIGZsYWdcblx0dGhpcy5wb3NpdGlvbmluZyA9IFRSVUU7XG5cblx0dmFyIGNhY2hlID0gdGhpcy5jYWNoZSxcblx0XHR0b29sdGlwID0gdGhpcy50b29sdGlwLFxuXHRcdHBvc09wdGlvbnMgPSB0aGlzLm9wdGlvbnMucG9zaXRpb24sXG5cdFx0dGFyZ2V0ID0gcG9zT3B0aW9ucy50YXJnZXQsXG5cdFx0bXkgPSBwb3NPcHRpb25zLm15LFxuXHRcdGF0ID0gcG9zT3B0aW9ucy5hdCxcblx0XHR2aWV3cG9ydCA9IHBvc09wdGlvbnMudmlld3BvcnQsXG5cdFx0Y29udGFpbmVyID0gcG9zT3B0aW9ucy5jb250YWluZXIsXG5cdFx0YWRqdXN0ID0gcG9zT3B0aW9ucy5hZGp1c3QsXG5cdFx0bWV0aG9kID0gYWRqdXN0Lm1ldGhvZC5zcGxpdCgnICcpLFxuXHRcdHRvb2x0aXBXaWR0aCA9IHRvb2x0aXAub3V0ZXJXaWR0aChGQUxTRSksXG5cdFx0dG9vbHRpcEhlaWdodCA9IHRvb2x0aXAub3V0ZXJIZWlnaHQoRkFMU0UpLFxuXHRcdHRhcmdldFdpZHRoID0gMCxcblx0XHR0YXJnZXRIZWlnaHQgPSAwLFxuXHRcdHR5cGUgPSB0b29sdGlwLmNzcygncG9zaXRpb24nKSxcblx0XHRwb3NpdGlvbiA9IHsgbGVmdDogMCwgdG9wOiAwIH0sXG5cdFx0dmlzaWJsZSA9IHRvb2x0aXBbMF0ub2Zmc2V0V2lkdGggPiAwLFxuXHRcdGlzU2Nyb2xsID0gZXZlbnQgJiYgZXZlbnQudHlwZSA9PT0gJ3Njcm9sbCcsXG5cdFx0d2luID0gJCh3aW5kb3cpLFxuXHRcdGRvYyA9IGNvbnRhaW5lclswXS5vd25lckRvY3VtZW50LFxuXHRcdG1vdXNlID0gdGhpcy5tb3VzZSxcblx0XHRwbHVnaW5DYWxjdWxhdGlvbnMsIG9mZnNldCwgYWRqdXN0ZWQsIG5ld0NsYXNzO1xuXG5cdC8vIENoZWNrIGlmIGFic29sdXRlIHBvc2l0aW9uIHdhcyBwYXNzZWRcblx0aWYoJC5pc0FycmF5KHRhcmdldCkgJiYgdGFyZ2V0Lmxlbmd0aCA9PT0gMikge1xuXHRcdC8vIEZvcmNlIGxlZnQgdG9wIGFuZCBzZXQgcG9zaXRpb25cblx0XHRhdCA9IHsgeDogTEVGVCwgeTogVE9QIH07XG5cdFx0cG9zaXRpb24gPSB7IGxlZnQ6IHRhcmdldFswXSwgdG9wOiB0YXJnZXRbMV0gfTtcblx0fVxuXG5cdC8vIENoZWNrIGlmIG1vdXNlIHdhcyB0aGUgdGFyZ2V0XG5cdGVsc2UgaWYodGFyZ2V0ID09PSAnbW91c2UnKSB7XG5cdFx0Ly8gRm9yY2UgbGVmdCB0b3AgdG8gYWxsb3cgZmxpcHBpbmdcblx0XHRhdCA9IHsgeDogTEVGVCwgeTogVE9QIH07XG5cblx0XHQvLyBVc2UgdGhlIG1vdXNlIG9yaWdpbiB0aGF0IGNhdXNlZCB0aGUgc2hvdyBldmVudCwgaWYgZGlzdGFuY2UgaGlkaW5nIGlzIGVuYWJsZWRcblx0XHRpZigoIWFkanVzdC5tb3VzZSB8fCB0aGlzLm9wdGlvbnMuaGlkZS5kaXN0YW5jZSkgJiYgY2FjaGUub3JpZ2luICYmIGNhY2hlLm9yaWdpbi5wYWdlWCkge1xuXHRcdFx0ZXZlbnQgPSAgY2FjaGUub3JpZ2luO1xuXHRcdH1cblxuXHRcdC8vIFVzZSBjYWNoZWQgZXZlbnQgZm9yIHJlc2l6ZS9zY3JvbGwgZXZlbnRzXG5cdFx0ZWxzZSBpZighZXZlbnQgfHwgZXZlbnQgJiYgKGV2ZW50LnR5cGUgPT09ICdyZXNpemUnIHx8IGV2ZW50LnR5cGUgPT09ICdzY3JvbGwnKSkge1xuXHRcdFx0ZXZlbnQgPSBjYWNoZS5ldmVudDtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIHVzZSB0aGUgY2FjaGVkIG1vdXNlIGNvb3JkaW5hdGVzIGlmIGF2YWlsYWJsZVxuXHRcdGVsc2UgaWYobW91c2UgJiYgbW91c2UucGFnZVgpIHtcblx0XHRcdGV2ZW50ID0gbW91c2U7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIGJvZHkgYW5kIGNvbnRhaW5lciBvZmZzZXQgYW5kIHRha2UgdGhlbSBpbnRvIGFjY291bnQgYmVsb3dcblx0XHRpZih0eXBlICE9PSAnc3RhdGljJykgeyBwb3NpdGlvbiA9IGNvbnRhaW5lci5vZmZzZXQoKTsgfVxuXHRcdGlmKGRvYy5ib2R5Lm9mZnNldFdpZHRoICE9PSAod2luZG93LmlubmVyV2lkdGggfHwgZG9jLmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCkpIHtcblx0XHRcdG9mZnNldCA9ICQoZG9jdW1lbnQuYm9keSkub2Zmc2V0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gVXNlIGV2ZW50IGNvb3JkaW5hdGVzIGZvciBwb3NpdGlvblxuXHRcdHBvc2l0aW9uID0ge1xuXHRcdFx0bGVmdDogZXZlbnQucGFnZVggLSBwb3NpdGlvbi5sZWZ0ICsgKG9mZnNldCAmJiBvZmZzZXQubGVmdCB8fCAwKSxcblx0XHRcdHRvcDogZXZlbnQucGFnZVkgLSBwb3NpdGlvbi50b3AgKyAob2Zmc2V0ICYmIG9mZnNldC50b3AgfHwgMClcblx0XHR9O1xuXG5cdFx0Ly8gU2Nyb2xsIGV2ZW50cyBhcmUgYSBwYWluLCBzb21lIGJyb3dzZXJzXG5cdFx0aWYoYWRqdXN0Lm1vdXNlICYmIGlzU2Nyb2xsICYmIG1vdXNlKSB7XG5cdFx0XHRwb3NpdGlvbi5sZWZ0IC09IChtb3VzZS5zY3JvbGxYIHx8IDApIC0gd2luLnNjcm9sbExlZnQoKTtcblx0XHRcdHBvc2l0aW9uLnRvcCAtPSAobW91c2Uuc2Nyb2xsWSB8fCAwKSAtIHdpbi5zY3JvbGxUb3AoKTtcblx0XHR9XG5cdH1cblxuXHQvLyBUYXJnZXQgd2Fzbid0IG1vdXNlIG9yIGFic29sdXRlLi4uXG5cdGVsc2Uge1xuXHRcdC8vIENoZWNrIGlmIGV2ZW50IHRhcmdldHRpbmcgaXMgYmVpbmcgdXNlZFxuXHRcdGlmKHRhcmdldCA9PT0gJ2V2ZW50Jykge1xuXHRcdFx0aWYoZXZlbnQgJiYgZXZlbnQudGFyZ2V0ICYmIGV2ZW50LnR5cGUgIT09ICdzY3JvbGwnICYmIGV2ZW50LnR5cGUgIT09ICdyZXNpemUnKSB7XG5cdFx0XHRcdGNhY2hlLnRhcmdldCA9ICQoZXZlbnQudGFyZ2V0KTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYoIWV2ZW50LnRhcmdldCkge1xuXHRcdFx0XHRjYWNoZS50YXJnZXQgPSB0aGlzLmVsZW1lbnRzLnRhcmdldDtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZih0YXJnZXQgIT09ICdldmVudCcpe1xuXHRcdFx0Y2FjaGUudGFyZ2V0ID0gJCh0YXJnZXQuanF1ZXJ5ID8gdGFyZ2V0IDogdGhpcy5lbGVtZW50cy50YXJnZXQpO1xuXHRcdH1cblx0XHR0YXJnZXQgPSBjYWNoZS50YXJnZXQ7XG5cblx0XHQvLyBQYXJzZSB0aGUgdGFyZ2V0IGludG8gYSBqUXVlcnkgb2JqZWN0IGFuZCBtYWtlIHN1cmUgdGhlcmUncyBhbiBlbGVtZW50IHByZXNlbnRcblx0XHR0YXJnZXQgPSAkKHRhcmdldCkuZXEoMCk7XG5cdFx0aWYodGFyZ2V0Lmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gdGhpczsgfVxuXG5cdFx0Ly8gQ2hlY2sgaWYgd2luZG93IG9yIGRvY3VtZW50IGlzIHRoZSB0YXJnZXRcblx0XHRlbHNlIGlmKHRhcmdldFswXSA9PT0gZG9jdW1lbnQgfHwgdGFyZ2V0WzBdID09PSB3aW5kb3cpIHtcblx0XHRcdHRhcmdldFdpZHRoID0gQlJPV1NFUi5pT1MgPyB3aW5kb3cuaW5uZXJXaWR0aCA6IHRhcmdldC53aWR0aCgpO1xuXHRcdFx0dGFyZ2V0SGVpZ2h0ID0gQlJPV1NFUi5pT1MgPyB3aW5kb3cuaW5uZXJIZWlnaHQgOiB0YXJnZXQuaGVpZ2h0KCk7XG5cblx0XHRcdGlmKHRhcmdldFswXSA9PT0gd2luZG93KSB7XG5cdFx0XHRcdHBvc2l0aW9uID0ge1xuXHRcdFx0XHRcdHRvcDogKHZpZXdwb3J0IHx8IHRhcmdldCkuc2Nyb2xsVG9wKCksXG5cdFx0XHRcdFx0bGVmdDogKHZpZXdwb3J0IHx8IHRhcmdldCkuc2Nyb2xsTGVmdCgpXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgaWYgdGhlIHRhcmdldCBpcyBhbiA8QVJFQT4gZWxlbWVudFxuXHRcdGVsc2UgaWYoUExVR0lOUy5pbWFnZW1hcCAmJiB0YXJnZXQuaXMoJ2FyZWEnKSkge1xuXHRcdFx0cGx1Z2luQ2FsY3VsYXRpb25zID0gUExVR0lOUy5pbWFnZW1hcCh0aGlzLCB0YXJnZXQsIGF0LCBQTFVHSU5TLnZpZXdwb3J0ID8gbWV0aG9kIDogRkFMU0UpO1xuXHRcdH1cblxuXHRcdC8vIENoZWNrIGlmIHRoZSB0YXJnZXQgaXMgYW4gU1ZHIGVsZW1lbnRcblx0XHRlbHNlIGlmKFBMVUdJTlMuc3ZnICYmIHRhcmdldCAmJiB0YXJnZXRbMF0ub3duZXJTVkdFbGVtZW50KSB7XG5cdFx0XHRwbHVnaW5DYWxjdWxhdGlvbnMgPSBQTFVHSU5TLnN2Zyh0aGlzLCB0YXJnZXQsIGF0LCBQTFVHSU5TLnZpZXdwb3J0ID8gbWV0aG9kIDogRkFMU0UpO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSB1c2UgcmVndWxhciBqUXVlcnkgbWV0aG9kc1xuXHRcdGVsc2Uge1xuXHRcdFx0dGFyZ2V0V2lkdGggPSB0YXJnZXQub3V0ZXJXaWR0aChGQUxTRSk7XG5cdFx0XHR0YXJnZXRIZWlnaHQgPSB0YXJnZXQub3V0ZXJIZWlnaHQoRkFMU0UpO1xuXHRcdFx0cG9zaXRpb24gPSB0YXJnZXQub2Zmc2V0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gUGFyc2UgcmV0dXJuZWQgcGx1Z2luIHZhbHVlcyBpbnRvIHByb3BlciB2YXJpYWJsZXNcblx0XHRpZihwbHVnaW5DYWxjdWxhdGlvbnMpIHtcblx0XHRcdHRhcmdldFdpZHRoID0gcGx1Z2luQ2FsY3VsYXRpb25zLndpZHRoO1xuXHRcdFx0dGFyZ2V0SGVpZ2h0ID0gcGx1Z2luQ2FsY3VsYXRpb25zLmhlaWdodDtcblx0XHRcdG9mZnNldCA9IHBsdWdpbkNhbGN1bGF0aW9ucy5vZmZzZXQ7XG5cdFx0XHRwb3NpdGlvbiA9IHBsdWdpbkNhbGN1bGF0aW9ucy5wb3NpdGlvbjtcblx0XHR9XG5cblx0XHQvLyBBZGp1c3QgcG9zaXRpb24gdG8gdGFrZSBpbnRvIGFjY291bnQgb2Zmc2V0IHBhcmVudHNcblx0XHRwb3NpdGlvbiA9IHRoaXMucmVwb3NpdGlvbi5vZmZzZXQodGFyZ2V0LCBwb3NpdGlvbiwgY29udGFpbmVyKTtcblxuXHRcdC8vIEFkanVzdCBmb3IgcG9zaXRpb24uZml4ZWQgdG9vbHRpcHMgKGFuZCBhbHNvIGlPUyBzY3JvbGwgYnVnIGluIHYzLjItNC4wICYgdjQuMy00LjMuMilcblx0XHRpZihCUk9XU0VSLmlPUyA+IDMuMSAmJiBCUk9XU0VSLmlPUyA8IDQuMSB8fFxuXHRcdFx0QlJPV1NFUi5pT1MgPj0gNC4zICYmIEJST1dTRVIuaU9TIDwgNC4zMyB8fFxuXHRcdFx0IUJST1dTRVIuaU9TICYmIHR5cGUgPT09ICdmaXhlZCdcblx0XHQpe1xuXHRcdFx0cG9zaXRpb24ubGVmdCAtPSB3aW4uc2Nyb2xsTGVmdCgpO1xuXHRcdFx0cG9zaXRpb24udG9wIC09IHdpbi5zY3JvbGxUb3AoKTtcblx0XHR9XG5cblx0XHQvLyBBZGp1c3QgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGFyZ2V0XG5cdFx0aWYoIXBsdWdpbkNhbGN1bGF0aW9ucyB8fCBwbHVnaW5DYWxjdWxhdGlvbnMgJiYgcGx1Z2luQ2FsY3VsYXRpb25zLmFkanVzdGFibGUgIT09IEZBTFNFKSB7XG5cdFx0XHRwb3NpdGlvbi5sZWZ0ICs9IGF0LnggPT09IFJJR0hUID8gdGFyZ2V0V2lkdGggOiBhdC54ID09PSBDRU5URVIgPyB0YXJnZXRXaWR0aCAvIDIgOiAwO1xuXHRcdFx0cG9zaXRpb24udG9wICs9IGF0LnkgPT09IEJPVFRPTSA/IHRhcmdldEhlaWdodCA6IGF0LnkgPT09IENFTlRFUiA/IHRhcmdldEhlaWdodCAvIDIgOiAwO1xuXHRcdH1cblx0fVxuXG5cdC8vIEFkanVzdCBwb3NpdGlvbiByZWxhdGl2ZSB0byB0b29sdGlwXG5cdHBvc2l0aW9uLmxlZnQgKz0gYWRqdXN0LnggKyAobXkueCA9PT0gUklHSFQgPyAtdG9vbHRpcFdpZHRoIDogbXkueCA9PT0gQ0VOVEVSID8gLXRvb2x0aXBXaWR0aCAvIDIgOiAwKTtcblx0cG9zaXRpb24udG9wICs9IGFkanVzdC55ICsgKG15LnkgPT09IEJPVFRPTSA/IC10b29sdGlwSGVpZ2h0IDogbXkueSA9PT0gQ0VOVEVSID8gLXRvb2x0aXBIZWlnaHQgLyAyIDogMCk7XG5cblx0Ly8gVXNlIHZpZXdwb3J0IGFkanVzdG1lbnQgcGx1Z2luIGlmIGVuYWJsZWRcblx0aWYoUExVR0lOUy52aWV3cG9ydCkge1xuXHRcdGFkanVzdGVkID0gcG9zaXRpb24uYWRqdXN0ZWQgPSBQTFVHSU5TLnZpZXdwb3J0KFxuXHRcdFx0dGhpcywgcG9zaXRpb24sIHBvc09wdGlvbnMsIHRhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHQsIHRvb2x0aXBXaWR0aCwgdG9vbHRpcEhlaWdodFxuXHRcdCk7XG5cblx0XHQvLyBBcHBseSBvZmZzZXRzIHN1cHBsaWVkIGJ5IHBvc2l0aW9uaW5nIHBsdWdpbiAoaWYgdXNlZClcblx0XHRpZihvZmZzZXQgJiYgYWRqdXN0ZWQubGVmdCkgeyBwb3NpdGlvbi5sZWZ0ICs9IG9mZnNldC5sZWZ0OyB9XG5cdFx0aWYob2Zmc2V0ICYmIGFkanVzdGVkLnRvcCkgeyAgcG9zaXRpb24udG9wICs9IG9mZnNldC50b3A7IH1cblxuXHRcdC8vIEFwcGx5IGFueSBuZXcgJ215JyBwb3NpdGlvblxuXHRcdGlmKGFkanVzdGVkLm15KSB7IHRoaXMucG9zaXRpb24ubXkgPSBhZGp1c3RlZC5teTsgfVxuXHR9XG5cblx0Ly8gVmlld3BvcnQgYWRqdXN0bWVudCBpcyBkaXNhYmxlZCwgc2V0IHZhbHVlcyB0byB6ZXJvXG5cdGVsc2UgeyBwb3NpdGlvbi5hZGp1c3RlZCA9IHsgbGVmdDogMCwgdG9wOiAwIH07IH1cblxuXHQvLyBTZXQgdG9vbHRpcCBwb3NpdGlvbiBjbGFzcyBpZiBpdCdzIGNoYW5nZWRcblx0aWYoY2FjaGUucG9zQ2xhc3MgIT09IChuZXdDbGFzcyA9IHRoaXMuX2NyZWF0ZVBvc0NsYXNzKHRoaXMucG9zaXRpb24ubXkpKSkge1xuXHRcdGNhY2hlLnBvc0NsYXNzID0gbmV3Q2xhc3M7XG5cdFx0dG9vbHRpcC5yZW1vdmVDbGFzcyhjYWNoZS5wb3NDbGFzcykuYWRkQ2xhc3MobmV3Q2xhc3MpO1xuXHR9XG5cblx0Ly8gdG9vbHRpcG1vdmUgZXZlbnRcblx0aWYoIXRoaXMuX3RyaWdnZXIoJ21vdmUnLCBbcG9zaXRpb24sIHZpZXdwb3J0LmVsZW0gfHwgdmlld3BvcnRdLCBldmVudCkpIHsgcmV0dXJuIHRoaXM7IH1cblx0ZGVsZXRlIHBvc2l0aW9uLmFkanVzdGVkO1xuXG5cdC8vIElmIGVmZmVjdCBpcyBkaXNhYmxlZCwgdGFyZ2V0IGl0IG1vdXNlLCBubyBhbmltYXRpb24gaXMgZGVmaW5lZCBvciBwb3NpdGlvbmluZyBnaXZlcyBOYU4gb3V0LCBzZXQgQ1NTIGRpcmVjdGx5XG5cdGlmKGVmZmVjdCA9PT0gRkFMU0UgfHwgIXZpc2libGUgfHwgaXNOYU4ocG9zaXRpb24ubGVmdCkgfHwgaXNOYU4ocG9zaXRpb24udG9wKSB8fCB0YXJnZXQgPT09ICdtb3VzZScgfHwgISQuaXNGdW5jdGlvbihwb3NPcHRpb25zLmVmZmVjdCkpIHtcblx0XHR0b29sdGlwLmNzcyhwb3NpdGlvbik7XG5cdH1cblxuXHQvLyBVc2UgY3VzdG9tIGZ1bmN0aW9uIGlmIHByb3ZpZGVkXG5cdGVsc2UgaWYoJC5pc0Z1bmN0aW9uKHBvc09wdGlvbnMuZWZmZWN0KSkge1xuXHRcdHBvc09wdGlvbnMuZWZmZWN0LmNhbGwodG9vbHRpcCwgdGhpcywgJC5leHRlbmQoe30sIHBvc2l0aW9uKSk7XG5cdFx0dG9vbHRpcC5xdWV1ZShmdW5jdGlvbihuZXh0KSB7XG5cdFx0XHQvLyBSZXNldCBhdHRyaWJ1dGVzIHRvIGF2b2lkIGNyb3NzLWJyb3dzZXIgcmVuZGVyaW5nIGJ1Z3Ncblx0XHRcdCQodGhpcykuY3NzKHsgb3BhY2l0eTogJycsIGhlaWdodDogJycgfSk7XG5cdFx0XHRpZihCUk9XU0VSLmllKSB7IHRoaXMuc3R5bGUucmVtb3ZlQXR0cmlidXRlKCdmaWx0ZXInKTsgfVxuXG5cdFx0XHRuZXh0KCk7XG5cdFx0fSk7XG5cdH1cblxuXHQvLyBTZXQgcG9zaXRpb25pbmcgZmxhZ1xuXHR0aGlzLnBvc2l0aW9uaW5nID0gRkFMU0U7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vLyBDdXN0b20gKG1vcmUgY29ycmVjdCBmb3IgcVRpcCEpIG9mZnNldCBjYWxjdWxhdG9yXG5QUk9UT1RZUEUucmVwb3NpdGlvbi5vZmZzZXQgPSBmdW5jdGlvbihlbGVtLCBwb3MsIGNvbnRhaW5lcikge1xuXHRpZighY29udGFpbmVyWzBdKSB7IHJldHVybiBwb3M7IH1cblxuXHR2YXIgb3duZXJEb2N1bWVudCA9ICQoZWxlbVswXS5vd25lckRvY3VtZW50KSxcblx0XHRxdWlya3MgPSAhIUJST1dTRVIuaWUgJiYgZG9jdW1lbnQuY29tcGF0TW9kZSAhPT0gJ0NTUzFDb21wYXQnLFxuXHRcdHBhcmVudCA9IGNvbnRhaW5lclswXSxcblx0XHRzY3JvbGxlZCwgcG9zaXRpb24sIHBhcmVudE9mZnNldCwgb3ZlcmZsb3c7XG5cblx0ZnVuY3Rpb24gc2Nyb2xsKGUsIGkpIHtcblx0XHRwb3MubGVmdCArPSBpICogZS5zY3JvbGxMZWZ0KCk7XG5cdFx0cG9zLnRvcCArPSBpICogZS5zY3JvbGxUb3AoKTtcblx0fVxuXG5cdC8vIENvbXBlbnNhdGUgZm9yIG5vbi1zdGF0aWMgY29udGFpbmVycyBvZmZzZXRcblx0ZG8ge1xuXHRcdGlmKChwb3NpdGlvbiA9ICQuY3NzKHBhcmVudCwgJ3Bvc2l0aW9uJykpICE9PSAnc3RhdGljJykge1xuXHRcdFx0aWYocG9zaXRpb24gPT09ICdmaXhlZCcpIHtcblx0XHRcdFx0cGFyZW50T2Zmc2V0ID0gcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdFx0XHRzY3JvbGwob3duZXJEb2N1bWVudCwgLTEpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHBhcmVudE9mZnNldCA9ICQocGFyZW50KS5wb3NpdGlvbigpO1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQubGVmdCArPSBwYXJzZUZsb2F0KCQuY3NzKHBhcmVudCwgJ2JvcmRlckxlZnRXaWR0aCcpKSB8fCAwO1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQudG9wICs9IHBhcnNlRmxvYXQoJC5jc3MocGFyZW50LCAnYm9yZGVyVG9wV2lkdGgnKSkgfHwgMDtcblx0XHRcdH1cblxuXHRcdFx0cG9zLmxlZnQgLT0gcGFyZW50T2Zmc2V0LmxlZnQgKyAocGFyc2VGbG9hdCgkLmNzcyhwYXJlbnQsICdtYXJnaW5MZWZ0JykpIHx8IDApO1xuXHRcdFx0cG9zLnRvcCAtPSBwYXJlbnRPZmZzZXQudG9wICsgKHBhcnNlRmxvYXQoJC5jc3MocGFyZW50LCAnbWFyZ2luVG9wJykpIHx8IDApO1xuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBwYXJlbnQgZWxlbWVudCB3aXRoIGFuIG92ZXJmbG93IG9mIFwic2Nyb2xsXCIgb3IgXCJhdXRvXCIsIHN0b3JlIGl0XG5cdFx0XHRpZighc2Nyb2xsZWQgJiYgKG92ZXJmbG93ID0gJC5jc3MocGFyZW50LCAnb3ZlcmZsb3cnKSkgIT09ICdoaWRkZW4nICYmIG92ZXJmbG93ICE9PSAndmlzaWJsZScpIHsgc2Nyb2xsZWQgPSAkKHBhcmVudCk7IH1cblx0XHR9XG5cdH1cblx0d2hpbGUocGFyZW50ID0gcGFyZW50Lm9mZnNldFBhcmVudCk7XG5cblx0Ly8gQ29tcGVuc2F0ZSBmb3IgY29udGFpbmVycyBzY3JvbGwgaWYgaXQgYWxzbyBoYXMgYW4gb2Zmc2V0UGFyZW50IChvciBpbiBJRSBxdWlya3MgbW9kZSlcblx0aWYoc2Nyb2xsZWQgJiYgKHNjcm9sbGVkWzBdICE9PSBvd25lckRvY3VtZW50WzBdIHx8IHF1aXJrcykpIHtcblx0XHRzY3JvbGwoc2Nyb2xsZWQsIDEpO1xuXHR9XG5cblx0cmV0dXJuIHBvcztcbn07XG5cbi8vIENvcm5lciBjbGFzc1xudmFyIEMgPSAoQ09STkVSID0gUFJPVE9UWVBFLnJlcG9zaXRpb24uQ29ybmVyID0gZnVuY3Rpb24oY29ybmVyLCBmb3JjZVkpIHtcblx0Y29ybmVyID0gKCcnICsgY29ybmVyKS5yZXBsYWNlKC8oW0EtWl0pLywgJyAkMScpLnJlcGxhY2UoL21pZGRsZS9naSwgQ0VOVEVSKS50b0xvd2VyQ2FzZSgpO1xuXHR0aGlzLnggPSAoY29ybmVyLm1hdGNoKC9sZWZ0fHJpZ2h0L2kpIHx8IGNvcm5lci5tYXRjaCgvY2VudGVyLykgfHwgWydpbmhlcml0J10pWzBdLnRvTG93ZXJDYXNlKCk7XG5cdHRoaXMueSA9IChjb3JuZXIubWF0Y2goL3RvcHxib3R0b218Y2VudGVyL2kpIHx8IFsnaW5oZXJpdCddKVswXS50b0xvd2VyQ2FzZSgpO1xuXHR0aGlzLmZvcmNlWSA9ICEhZm9yY2VZO1xuXG5cdHZhciBmID0gY29ybmVyLmNoYXJBdCgwKTtcblx0dGhpcy5wcmVjZWRhbmNlID0gZiA9PT0gJ3QnIHx8IGYgPT09ICdiJyA/IFkgOiBYO1xufSkucHJvdG90eXBlO1xuXG5DLmludmVydCA9IGZ1bmN0aW9uKHosIGNlbnRlcikge1xuXHR0aGlzW3pdID0gdGhpc1t6XSA9PT0gTEVGVCA/IFJJR0hUIDogdGhpc1t6XSA9PT0gUklHSFQgPyBMRUZUIDogY2VudGVyIHx8IHRoaXNbel07XG59O1xuXG5DLnN0cmluZyA9IGZ1bmN0aW9uKGpvaW4pIHtcblx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnk7XG5cblx0dmFyIHJlc3VsdCA9IHggIT09IHkgP1xuXHRcdHggPT09ICdjZW50ZXInIHx8IHkgIT09ICdjZW50ZXInICYmICh0aGlzLnByZWNlZGFuY2UgPT09IFkgfHwgdGhpcy5mb3JjZVkpID8gXG5cdFx0XHRbeSx4XSA6IFxuXHRcdFx0W3gseV0gOlxuXHRcdFt4XTtcblxuXHRyZXR1cm4gam9pbiAhPT0gZmFsc2UgPyByZXN1bHQuam9pbignICcpIDogcmVzdWx0O1xufTtcblxuQy5hYmJyZXYgPSBmdW5jdGlvbigpIHtcblx0dmFyIHJlc3VsdCA9IHRoaXMuc3RyaW5nKGZhbHNlKTtcblx0cmV0dXJuIHJlc3VsdFswXS5jaGFyQXQoMCkgKyAocmVzdWx0WzFdICYmIHJlc3VsdFsxXS5jaGFyQXQoMCkgfHwgJycpO1xufTtcblxuQy5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gbmV3IENPUk5FUiggdGhpcy5zdHJpbmcoKSwgdGhpcy5mb3JjZVkgKTtcbn07XG5cbjtcblBST1RPVFlQRS50b2dnbGUgPSBmdW5jdGlvbihzdGF0ZSwgZXZlbnQpIHtcblx0dmFyIGNhY2hlID0gdGhpcy5jYWNoZSxcblx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdHRvb2x0aXAgPSB0aGlzLnRvb2x0aXA7XG5cblx0Ly8gVHJ5IHRvIHByZXZlbnQgZmxpY2tlcmluZyB3aGVuIHRvb2x0aXAgb3ZlcmxhcHMgc2hvdyBlbGVtZW50XG5cdGlmKGV2ZW50KSB7XG5cdFx0aWYoKC9vdmVyfGVudGVyLykudGVzdChldmVudC50eXBlKSAmJiBjYWNoZS5ldmVudCAmJiAoL291dHxsZWF2ZS8pLnRlc3QoY2FjaGUuZXZlbnQudHlwZSkgJiZcblx0XHRcdG9wdGlvbnMuc2hvdy50YXJnZXQuYWRkKGV2ZW50LnRhcmdldCkubGVuZ3RoID09PSBvcHRpb25zLnNob3cudGFyZ2V0Lmxlbmd0aCAmJlxuXHRcdFx0dG9vbHRpcC5oYXMoZXZlbnQucmVsYXRlZFRhcmdldCkubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvLyBDYWNoZSBldmVudFxuXHRcdGNhY2hlLmV2ZW50ID0gJC5ldmVudC5maXgoZXZlbnQpO1xuXHR9XG5cblx0Ly8gSWYgd2UncmUgY3VycmVudGx5IHdhaXRpbmcgYW5kIHdlJ3ZlIGp1c3QgaGlkZGVuLi4uIHN0b3AgaXRcblx0dGhpcy53YWl0aW5nICYmICFzdGF0ZSAmJiAodGhpcy5oaWRkZW5EdXJpbmdXYWl0ID0gVFJVRSk7XG5cblx0Ly8gUmVuZGVyIHRoZSB0b29sdGlwIGlmIHNob3dpbmcgYW5kIGl0IGlzbid0IGFscmVhZHlcblx0aWYoIXRoaXMucmVuZGVyZWQpIHsgcmV0dXJuIHN0YXRlID8gdGhpcy5yZW5kZXIoMSkgOiB0aGlzOyB9XG5cdGVsc2UgaWYodGhpcy5kZXN0cm95ZWQgfHwgdGhpcy5kaXNhYmxlZCkgeyByZXR1cm4gdGhpczsgfVxuXG5cdHZhciB0eXBlID0gc3RhdGUgPyAnc2hvdycgOiAnaGlkZScsXG5cdFx0b3B0cyA9IHRoaXMub3B0aW9uc1t0eXBlXSxcblx0XHRwb3NPcHRpb25zID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uLFxuXHRcdGNvbnRlbnRPcHRpb25zID0gdGhpcy5vcHRpb25zLmNvbnRlbnQsXG5cdFx0d2lkdGggPSB0aGlzLnRvb2x0aXAuY3NzKCd3aWR0aCcpLFxuXHRcdHZpc2libGUgPSB0aGlzLnRvb2x0aXAuaXMoJzp2aXNpYmxlJyksXG5cdFx0YW5pbWF0ZSA9IHN0YXRlIHx8IG9wdHMudGFyZ2V0Lmxlbmd0aCA9PT0gMSxcblx0XHRzYW1lVGFyZ2V0ID0gIWV2ZW50IHx8IG9wdHMudGFyZ2V0Lmxlbmd0aCA8IDIgfHwgY2FjaGUudGFyZ2V0WzBdID09PSBldmVudC50YXJnZXQsXG5cdFx0aWRlbnRpY2FsU3RhdGUsIGFsbG93LCBhZnRlcjtcblxuXHQvLyBEZXRlY3Qgc3RhdGUgaWYgdmFsaWQgb25lIGlzbid0IHByb3ZpZGVkXG5cdGlmKCh0eXBlb2Ygc3RhdGUpLnNlYXJjaCgnYm9vbGVhbnxudW1iZXInKSkgeyBzdGF0ZSA9ICF2aXNpYmxlOyB9XG5cblx0Ly8gQ2hlY2sgaWYgdGhlIHRvb2x0aXAgaXMgaW4gYW4gaWRlbnRpY2FsIHN0YXRlIHRvIHRoZSBuZXcgd291bGQtYmUgc3RhdGVcblx0aWRlbnRpY2FsU3RhdGUgPSAhdG9vbHRpcC5pcygnOmFuaW1hdGVkJykgJiYgdmlzaWJsZSA9PT0gc3RhdGUgJiYgc2FtZVRhcmdldDtcblxuXHQvLyBGaXJlIHRvb2x0aXAoc2hvdy9oaWRlKSBldmVudCBhbmQgY2hlY2sgaWYgZGVzdHJveWVkXG5cdGFsbG93ID0gIWlkZW50aWNhbFN0YXRlID8gISF0aGlzLl90cmlnZ2VyKHR5cGUsIFs5MF0pIDogTlVMTDtcblxuXHQvLyBDaGVjayB0byBtYWtlIHN1cmUgdGhlIHRvb2x0aXAgd2Fzbid0IGRlc3Ryb3llZCBpbiB0aGUgY2FsbGJhY2tcblx0aWYodGhpcy5kZXN0cm95ZWQpIHsgcmV0dXJuIHRoaXM7IH1cblxuXHQvLyBJZiB0aGUgdXNlciBkaWRuJ3Qgc3RvcCB0aGUgbWV0aG9kIHByZW1hdHVyZWx5IGFuZCB3ZSdyZSBzaG93aW5nIHRoZSB0b29sdGlwLCBmb2N1cyBpdFxuXHRpZihhbGxvdyAhPT0gRkFMU0UgJiYgc3RhdGUpIHsgdGhpcy5mb2N1cyhldmVudCk7IH1cblxuXHQvLyBJZiB0aGUgc3RhdGUgaGFzbid0IGNoYW5nZWQgb3IgdGhlIHVzZXIgc3RvcHBlZCBpdCwgcmV0dXJuIGVhcmx5XG5cdGlmKCFhbGxvdyB8fCBpZGVudGljYWxTdGF0ZSkgeyByZXR1cm4gdGhpczsgfVxuXG5cdC8vIFNldCBBUklBIGhpZGRlbiBhdHRyaWJ1dGVcblx0JC5hdHRyKHRvb2x0aXBbMF0sICdhcmlhLWhpZGRlbicsICEhIXN0YXRlKTtcblxuXHQvLyBFeGVjdXRlIHN0YXRlIHNwZWNpZmljIHByb3BlcnRpZXNcblx0aWYoc3RhdGUpIHtcblx0XHQvLyBTdG9yZSBzaG93IG9yaWdpbiBjb29yZGluYXRlc1xuXHRcdHRoaXMubW91c2UgJiYgKGNhY2hlLm9yaWdpbiA9ICQuZXZlbnQuZml4KHRoaXMubW91c2UpKTtcblxuXHRcdC8vIFVwZGF0ZSB0b29sdGlwIGNvbnRlbnQgJiB0aXRsZSBpZiBpdCdzIGEgZHluYW1pYyBmdW5jdGlvblxuXHRcdGlmKCQuaXNGdW5jdGlvbihjb250ZW50T3B0aW9ucy50ZXh0KSkgeyB0aGlzLl91cGRhdGVDb250ZW50KGNvbnRlbnRPcHRpb25zLnRleHQsIEZBTFNFKTsgfVxuXHRcdGlmKCQuaXNGdW5jdGlvbihjb250ZW50T3B0aW9ucy50aXRsZSkpIHsgdGhpcy5fdXBkYXRlVGl0bGUoY29udGVudE9wdGlvbnMudGl0bGUsIEZBTFNFKTsgfVxuXG5cdFx0Ly8gQ2FjaGUgbW91c2Vtb3ZlIGV2ZW50cyBmb3IgcG9zaXRpb25pbmcgcHVycG9zZXMgKGlmIG5vdCBhbHJlYWR5IHRyYWNraW5nKVxuXHRcdGlmKCF0cmFja2luZ0JvdW5kICYmIHBvc09wdGlvbnMudGFyZ2V0ID09PSAnbW91c2UnICYmIHBvc09wdGlvbnMuYWRqdXN0Lm1vdXNlKSB7XG5cdFx0XHQkKGRvY3VtZW50KS5iaW5kKCdtb3VzZW1vdmUuJytOQU1FU1BBQ0UsIHRoaXMuX3N0b3JlTW91c2UpO1xuXHRcdFx0dHJhY2tpbmdCb3VuZCA9IFRSVUU7XG5cdFx0fVxuXG5cdFx0Ly8gVXBkYXRlIHRoZSB0b29sdGlwIHBvc2l0aW9uIChzZXQgd2lkdGggZmlyc3QgdG8gcHJldmVudCB2aWV3cG9ydC9tYXgtd2lkdGggaXNzdWVzKVxuXHRcdGlmKCF3aWR0aCkgeyB0b29sdGlwLmNzcygnd2lkdGgnLCB0b29sdGlwLm91dGVyV2lkdGgoRkFMU0UpKTsgfVxuXHRcdHRoaXMucmVwb3NpdGlvbihldmVudCwgYXJndW1lbnRzWzJdKTtcblx0XHRpZighd2lkdGgpIHsgdG9vbHRpcC5jc3MoJ3dpZHRoJywgJycpOyB9XG5cblx0XHQvLyBIaWRlIG90aGVyIHRvb2x0aXBzIGlmIHRvb2x0aXAgaXMgc29sb1xuXHRcdGlmKCEhb3B0cy5zb2xvKSB7XG5cdFx0XHQodHlwZW9mIG9wdHMuc29sbyA9PT0gJ3N0cmluZycgPyAkKG9wdHMuc29sbykgOiAkKFNFTEVDVE9SLCBvcHRzLnNvbG8pKVxuXHRcdFx0XHQubm90KHRvb2x0aXApLm5vdChvcHRzLnRhcmdldCkucXRpcCgnaGlkZScsIG5ldyAkLkV2ZW50KCd0b29sdGlwc29sbycpKTtcblx0XHR9XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gQ2xlYXIgc2hvdyB0aW1lciBpZiB3ZSdyZSBoaWRpbmdcblx0XHRjbGVhclRpbWVvdXQodGhpcy50aW1lcnMuc2hvdyk7XG5cblx0XHQvLyBSZW1vdmUgY2FjaGVkIG9yaWdpbiBvbiBoaWRlXG5cdFx0ZGVsZXRlIGNhY2hlLm9yaWdpbjtcblxuXHRcdC8vIFJlbW92ZSBtb3VzZSB0cmFja2luZyBldmVudCBpZiBub3QgbmVlZGVkIChhbGwgdHJhY2tpbmcgcVRpcHMgYXJlIGhpZGRlbilcblx0XHRpZih0cmFja2luZ0JvdW5kICYmICEkKFNFTEVDVE9SKydbdHJhY2tpbmc9XCJ0cnVlXCJdOnZpc2libGUnLCBvcHRzLnNvbG8pLm5vdCh0b29sdGlwKS5sZW5ndGgpIHtcblx0XHRcdCQoZG9jdW1lbnQpLnVuYmluZCgnbW91c2Vtb3ZlLicrTkFNRVNQQUNFKTtcblx0XHRcdHRyYWNraW5nQm91bmQgPSBGQUxTRTtcblx0XHR9XG5cblx0XHQvLyBCbHVyIHRoZSB0b29sdGlwXG5cdFx0dGhpcy5ibHVyKGV2ZW50KTtcblx0fVxuXG5cdC8vIERlZmluZSBwb3N0LWFuaW1hdGlvbiwgc3RhdGUgc3BlY2lmaWMgcHJvcGVydGllc1xuXHRhZnRlciA9ICQucHJveHkoZnVuY3Rpb24oKSB7XG5cdFx0aWYoc3RhdGUpIHtcblx0XHRcdC8vIFByZXZlbnQgYW50aWFsaWFzIGZyb20gZGlzYXBwZWFyaW5nIGluIElFIGJ5IHJlbW92aW5nIGZpbHRlclxuXHRcdFx0aWYoQlJPV1NFUi5pZSkgeyB0b29sdGlwWzBdLnN0eWxlLnJlbW92ZUF0dHJpYnV0ZSgnZmlsdGVyJyk7IH1cblxuXHRcdFx0Ly8gUmVtb3ZlIG92ZXJmbG93IHNldHRpbmcgdG8gcHJldmVudCB0aXAgYnVnc1xuXHRcdFx0dG9vbHRpcC5jc3MoJ292ZXJmbG93JywgJycpO1xuXG5cdFx0XHQvLyBBdXRvZm9jdXMgZWxlbWVudHMgaWYgZW5hYmxlZFxuXHRcdFx0aWYoJ3N0cmluZycgPT09IHR5cGVvZiBvcHRzLmF1dG9mb2N1cykge1xuXHRcdFx0XHQkKHRoaXMub3B0aW9ucy5zaG93LmF1dG9mb2N1cywgdG9vbHRpcCkuZm9jdXMoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgc2V0LCBoaWRlIHRvb2x0aXAgd2hlbiBpbmFjdGl2ZSBmb3IgZGVsYXkgcGVyaW9kXG5cdFx0XHR0aGlzLm9wdGlvbnMuc2hvdy50YXJnZXQudHJpZ2dlcigncXRpcC0nK3RoaXMuaWQrJy1pbmFjdGl2ZScpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIFJlc2V0IENTUyBzdGF0ZXNcblx0XHRcdHRvb2x0aXAuY3NzKHtcblx0XHRcdFx0ZGlzcGxheTogJycsXG5cdFx0XHRcdHZpc2liaWxpdHk6ICcnLFxuXHRcdFx0XHRvcGFjaXR5OiAnJyxcblx0XHRcdFx0bGVmdDogJycsXG5cdFx0XHRcdHRvcDogJydcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8vIHRvb2x0aXB2aXNpYmxlL3Rvb2x0aXBoaWRkZW4gZXZlbnRzXG5cdFx0dGhpcy5fdHJpZ2dlcihzdGF0ZSA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nKTtcblx0fSwgdGhpcyk7XG5cblx0Ly8gSWYgbm8gZWZmZWN0IHR5cGUgaXMgc3VwcGxpZWQsIHVzZSBhIHNpbXBsZSB0b2dnbGVcblx0aWYob3B0cy5lZmZlY3QgPT09IEZBTFNFIHx8IGFuaW1hdGUgPT09IEZBTFNFKSB7XG5cdFx0dG9vbHRpcFsgdHlwZSBdKCk7XG5cdFx0YWZ0ZXIoKTtcblx0fVxuXG5cdC8vIFVzZSBjdXN0b20gZnVuY3Rpb24gaWYgcHJvdmlkZWRcblx0ZWxzZSBpZigkLmlzRnVuY3Rpb24ob3B0cy5lZmZlY3QpKSB7XG5cdFx0dG9vbHRpcC5zdG9wKDEsIDEpO1xuXHRcdG9wdHMuZWZmZWN0LmNhbGwodG9vbHRpcCwgdGhpcyk7XG5cdFx0dG9vbHRpcC5xdWV1ZSgnZngnLCBmdW5jdGlvbihuKSB7XG5cdFx0XHRhZnRlcigpOyBuKCk7XG5cdFx0fSk7XG5cdH1cblxuXHQvLyBVc2UgYmFzaWMgZmFkZSBmdW5jdGlvbiBieSBkZWZhdWx0XG5cdGVsc2UgeyB0b29sdGlwLmZhZGVUbyg5MCwgc3RhdGUgPyAxIDogMCwgYWZ0ZXIpOyB9XG5cblx0Ly8gSWYgaW5hY3RpdmUgaGlkZSBtZXRob2QgaXMgc2V0LCBhY3RpdmUgaXRcblx0aWYoc3RhdGUpIHsgb3B0cy50YXJnZXQudHJpZ2dlcigncXRpcC0nK3RoaXMuaWQrJy1pbmFjdGl2ZScpOyB9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5QUk9UT1RZUEUuc2hvdyA9IGZ1bmN0aW9uKGV2ZW50KSB7IHJldHVybiB0aGlzLnRvZ2dsZShUUlVFLCBldmVudCk7IH07XG5cblBST1RPVFlQRS5oaWRlID0gZnVuY3Rpb24oZXZlbnQpIHsgcmV0dXJuIHRoaXMudG9nZ2xlKEZBTFNFLCBldmVudCk7IH07XG47UFJPVE9UWVBFLmZvY3VzID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0aWYoIXRoaXMucmVuZGVyZWQgfHwgdGhpcy5kZXN0cm95ZWQpIHsgcmV0dXJuIHRoaXM7IH1cblxuXHR2YXIgcXRpcHMgPSAkKFNFTEVDVE9SKSxcblx0XHR0b29sdGlwID0gdGhpcy50b29sdGlwLFxuXHRcdGN1ckluZGV4ID0gcGFyc2VJbnQodG9vbHRpcFswXS5zdHlsZS56SW5kZXgsIDEwKSxcblx0XHRuZXdJbmRleCA9IFFUSVAuemluZGV4ICsgcXRpcHMubGVuZ3RoO1xuXG5cdC8vIE9ubHkgdXBkYXRlIHRoZSB6LWluZGV4IGlmIGl0IGhhcyBjaGFuZ2VkIGFuZCB0b29sdGlwIGlzIG5vdCBhbHJlYWR5IGZvY3VzZWRcblx0aWYoIXRvb2x0aXAuaGFzQ2xhc3MoQ0xBU1NfRk9DVVMpKSB7XG5cdFx0Ly8gdG9vbHRpcGZvY3VzIGV2ZW50XG5cdFx0aWYodGhpcy5fdHJpZ2dlcignZm9jdXMnLCBbbmV3SW5kZXhdLCBldmVudCkpIHtcblx0XHRcdC8vIE9ubHkgdXBkYXRlIHotaW5kZXgncyBpZiB0aGV5J3ZlIGNoYW5nZWRcblx0XHRcdGlmKGN1ckluZGV4ICE9PSBuZXdJbmRleCkge1xuXHRcdFx0XHQvLyBSZWR1Y2Ugb3VyIHotaW5kZXgncyBhbmQga2VlcCB0aGVtIHByb3Blcmx5IG9yZGVyZWRcblx0XHRcdFx0cXRpcHMuZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZih0aGlzLnN0eWxlLnpJbmRleCA+IGN1ckluZGV4KSB7XG5cdFx0XHRcdFx0XHR0aGlzLnN0eWxlLnpJbmRleCA9IHRoaXMuc3R5bGUuekluZGV4IC0gMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIEZpcmUgYmx1ciBldmVudCBmb3IgZm9jdXNlZCB0b29sdGlwXG5cdFx0XHRcdHF0aXBzLmZpbHRlcignLicgKyBDTEFTU19GT0NVUykucXRpcCgnYmx1cicsIGV2ZW50KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRoZSBuZXcgei1pbmRleFxuXHRcdFx0dG9vbHRpcC5hZGRDbGFzcyhDTEFTU19GT0NVUylbMF0uc3R5bGUuekluZGV4ID0gbmV3SW5kZXg7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5QUk9UT1RZUEUuYmx1ciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdGlmKCF0aGlzLnJlbmRlcmVkIHx8IHRoaXMuZGVzdHJveWVkKSB7IHJldHVybiB0aGlzOyB9XG5cblx0Ly8gU2V0IGZvY3VzZWQgc3RhdHVzIHRvIEZBTFNFXG5cdHRoaXMudG9vbHRpcC5yZW1vdmVDbGFzcyhDTEFTU19GT0NVUyk7XG5cblx0Ly8gdG9vbHRpcGJsdXIgZXZlbnRcblx0dGhpcy5fdHJpZ2dlcignYmx1cicsIFsgdGhpcy50b29sdGlwLmNzcygnekluZGV4JykgXSwgZXZlbnQpO1xuXG5cdHJldHVybiB0aGlzO1xufTtcbjtQUk9UT1RZUEUuZGlzYWJsZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG5cdGlmKHRoaXMuZGVzdHJveWVkKSB7IHJldHVybiB0aGlzOyB9XG5cblx0Ly8gSWYgJ3RvZ2dsZScgaXMgcGFzc2VkLCB0b2dnbGUgdGhlIGN1cnJlbnQgc3RhdGVcblx0aWYoc3RhdGUgPT09ICd0b2dnbGUnKSB7XG5cdFx0c3RhdGUgPSAhKHRoaXMucmVuZGVyZWQgPyB0aGlzLnRvb2x0aXAuaGFzQ2xhc3MoQ0xBU1NfRElTQUJMRUQpIDogdGhpcy5kaXNhYmxlZCk7XG5cdH1cblxuXHQvLyBEaXNhYmxlIGlmIG5vIHN0YXRlIHBhc3NlZFxuXHRlbHNlIGlmKCdib29sZWFuJyAhPT0gdHlwZW9mIHN0YXRlKSB7XG5cdFx0c3RhdGUgPSBUUlVFO1xuXHR9XG5cblx0aWYodGhpcy5yZW5kZXJlZCkge1xuXHRcdHRoaXMudG9vbHRpcC50b2dnbGVDbGFzcyhDTEFTU19ESVNBQkxFRCwgc3RhdGUpXG5cdFx0XHQuYXR0cignYXJpYS1kaXNhYmxlZCcsIHN0YXRlKTtcblx0fVxuXG5cdHRoaXMuZGlzYWJsZWQgPSAhIXN0YXRlO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxuUFJPVE9UWVBFLmVuYWJsZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5kaXNhYmxlKEZBTFNFKTsgfTtcbjtQUk9UT1RZUEUuX2NyZWF0ZUJ1dHRvbiA9IGZ1bmN0aW9uKClcbntcblx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cyxcblx0XHR0b29sdGlwID0gZWxlbWVudHMudG9vbHRpcCxcblx0XHRidXR0b24gPSB0aGlzLm9wdGlvbnMuY29udGVudC5idXR0b24sXG5cdFx0aXNTdHJpbmcgPSB0eXBlb2YgYnV0dG9uID09PSAnc3RyaW5nJyxcblx0XHRjbG9zZSA9IGlzU3RyaW5nID8gYnV0dG9uIDogJ0Nsb3NlIHRvb2x0aXAnO1xuXG5cdGlmKGVsZW1lbnRzLmJ1dHRvbikgeyBlbGVtZW50cy5idXR0b24ucmVtb3ZlKCk7IH1cblxuXHQvLyBVc2UgY3VzdG9tIGJ1dHRvbiBpZiBvbmUgd2FzIHN1cHBsaWVkIGJ5IHVzZXIsIGVsc2UgdXNlIGRlZmF1bHRcblx0aWYoYnV0dG9uLmpxdWVyeSkge1xuXHRcdGVsZW1lbnRzLmJ1dHRvbiA9IGJ1dHRvbjtcblx0fVxuXHRlbHNlIHtcblx0XHRlbGVtZW50cy5idXR0b24gPSAkKCc8YSAvPicsIHtcblx0XHRcdCdjbGFzcyc6ICdxdGlwLWNsb3NlICcgKyAodGhpcy5vcHRpb25zLnN0eWxlLndpZGdldCA/ICcnIDogTkFNRVNQQUNFKyctaWNvbicpLFxuXHRcdFx0J3RpdGxlJzogY2xvc2UsXG5cdFx0XHQnYXJpYS1sYWJlbCc6IGNsb3NlXG5cdFx0fSlcblx0XHQucHJlcGVuZChcblx0XHRcdCQoJzxzcGFuIC8+Jywge1xuXHRcdFx0XHQnY2xhc3MnOiAndWktaWNvbiB1aS1pY29uLWNsb3NlJyxcblx0XHRcdFx0J2h0bWwnOiAnJnRpbWVzOydcblx0XHRcdH0pXG5cdFx0KTtcblx0fVxuXG5cdC8vIENyZWF0ZSBidXR0b24gYW5kIHNldHVwIGF0dHJpYnV0ZXNcblx0ZWxlbWVudHMuYnV0dG9uLmFwcGVuZFRvKGVsZW1lbnRzLnRpdGxlYmFyIHx8IHRvb2x0aXApXG5cdFx0LmF0dHIoJ3JvbGUnLCAnYnV0dG9uJylcblx0XHQuY2xpY2soZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdGlmKCF0b29sdGlwLmhhc0NsYXNzKENMQVNTX0RJU0FCTEVEKSkgeyBzZWxmLmhpZGUoZXZlbnQpOyB9XG5cdFx0XHRyZXR1cm4gRkFMU0U7XG5cdFx0fSk7XG59O1xuXG5QUk9UT1RZUEUuX3VwZGF0ZUJ1dHRvbiA9IGZ1bmN0aW9uKGJ1dHRvbilcbntcblx0Ly8gTWFrZSBzdXJlIHRvb2x0aXAgaXMgcmVuZGVyZWQgYW5kIGlmIG5vdCwgcmV0dXJuXG5cdGlmKCF0aGlzLnJlbmRlcmVkKSB7IHJldHVybiBGQUxTRTsgfVxuXG5cdHZhciBlbGVtID0gdGhpcy5lbGVtZW50cy5idXR0b247XG5cdGlmKGJ1dHRvbikgeyB0aGlzLl9jcmVhdGVCdXR0b24oKTsgfVxuXHRlbHNlIHsgZWxlbS5yZW1vdmUoKTsgfVxufTtcbjsvLyBXaWRnZXQgY2xhc3MgY3JlYXRvclxuZnVuY3Rpb24gY3JlYXRlV2lkZ2V0Q2xhc3MoY2xzKSB7XG5cdHJldHVybiBXSURHRVQuY29uY2F0KCcnKS5qb2luKGNscyA/ICctJytjbHMrJyAnIDogJyAnKTtcbn1cblxuLy8gV2lkZ2V0IGNsYXNzIHNldHRlciBtZXRob2RcblBST1RPVFlQRS5fc2V0V2lkZ2V0ID0gZnVuY3Rpb24oKVxue1xuXHR2YXIgb24gPSB0aGlzLm9wdGlvbnMuc3R5bGUud2lkZ2V0LFxuXHRcdGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cyxcblx0XHR0b29sdGlwID0gZWxlbWVudHMudG9vbHRpcCxcblx0XHRkaXNhYmxlZCA9IHRvb2x0aXAuaGFzQ2xhc3MoQ0xBU1NfRElTQUJMRUQpO1xuXG5cdHRvb2x0aXAucmVtb3ZlQ2xhc3MoQ0xBU1NfRElTQUJMRUQpO1xuXHRDTEFTU19ESVNBQkxFRCA9IG9uID8gJ3VpLXN0YXRlLWRpc2FibGVkJyA6ICdxdGlwLWRpc2FibGVkJztcblx0dG9vbHRpcC50b2dnbGVDbGFzcyhDTEFTU19ESVNBQkxFRCwgZGlzYWJsZWQpO1xuXG5cdHRvb2x0aXAudG9nZ2xlQ2xhc3MoJ3VpLWhlbHBlci1yZXNldCAnK2NyZWF0ZVdpZGdldENsYXNzKCksIG9uKS50b2dnbGVDbGFzcyhDTEFTU19ERUZBVUxULCB0aGlzLm9wdGlvbnMuc3R5bGUuZGVmICYmICFvbik7XG5cblx0aWYoZWxlbWVudHMuY29udGVudCkge1xuXHRcdGVsZW1lbnRzLmNvbnRlbnQudG9nZ2xlQ2xhc3MoIGNyZWF0ZVdpZGdldENsYXNzKCdjb250ZW50JyksIG9uKTtcblx0fVxuXHRpZihlbGVtZW50cy50aXRsZWJhcikge1xuXHRcdGVsZW1lbnRzLnRpdGxlYmFyLnRvZ2dsZUNsYXNzKCBjcmVhdGVXaWRnZXRDbGFzcygnaGVhZGVyJyksIG9uKTtcblx0fVxuXHRpZihlbGVtZW50cy5idXR0b24pIHtcblx0XHRlbGVtZW50cy5idXR0b24udG9nZ2xlQ2xhc3MoTkFNRVNQQUNFKyctaWNvbicsICFvbik7XG5cdH1cbn07XG47ZnVuY3Rpb24gZGVsYXkoY2FsbGJhY2ssIGR1cmF0aW9uKSB7XG5cdC8vIElmIHRvb2x0aXAgaGFzIGRpc3BsYXllZCwgc3RhcnQgaGlkZSB0aW1lclxuXHRpZihkdXJhdGlvbiA+IDApIHtcblx0XHRyZXR1cm4gc2V0VGltZW91dChcblx0XHRcdCQucHJveHkoY2FsbGJhY2ssIHRoaXMpLCBkdXJhdGlvblxuXHRcdCk7XG5cdH1cblx0ZWxzZXsgY2FsbGJhY2suY2FsbCh0aGlzKTsgfVxufVxuXG5mdW5jdGlvbiBzaG93TWV0aG9kKGV2ZW50KSB7XG5cdGlmKHRoaXMudG9vbHRpcC5oYXNDbGFzcyhDTEFTU19ESVNBQkxFRCkpIHsgcmV0dXJuOyB9XG5cblx0Ly8gQ2xlYXIgaGlkZSB0aW1lcnNcblx0Y2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLnNob3cpO1xuXHRjbGVhclRpbWVvdXQodGhpcy50aW1lcnMuaGlkZSk7XG5cblx0Ly8gU3RhcnQgc2hvdyB0aW1lclxuXHR0aGlzLnRpbWVycy5zaG93ID0gZGVsYXkuY2FsbCh0aGlzLFxuXHRcdGZ1bmN0aW9uKCkgeyB0aGlzLnRvZ2dsZShUUlVFLCBldmVudCk7IH0sXG5cdFx0dGhpcy5vcHRpb25zLnNob3cuZGVsYXlcblx0KTtcbn1cblxuZnVuY3Rpb24gaGlkZU1ldGhvZChldmVudCkge1xuXHRpZih0aGlzLnRvb2x0aXAuaGFzQ2xhc3MoQ0xBU1NfRElTQUJMRUQpIHx8IHRoaXMuZGVzdHJveWVkKSB7IHJldHVybjsgfVxuXG5cdC8vIENoZWNrIGlmIG5ldyB0YXJnZXQgd2FzIGFjdHVhbGx5IHRoZSB0b29sdGlwIGVsZW1lbnRcblx0dmFyIHJlbGF0ZWRUYXJnZXQgPSAkKGV2ZW50LnJlbGF0ZWRUYXJnZXQpLFxuXHRcdG9udG9Ub29sdGlwID0gcmVsYXRlZFRhcmdldC5jbG9zZXN0KFNFTEVDVE9SKVswXSA9PT0gdGhpcy50b29sdGlwWzBdLFxuXHRcdG9udG9UYXJnZXQgPSByZWxhdGVkVGFyZ2V0WzBdID09PSB0aGlzLm9wdGlvbnMuc2hvdy50YXJnZXRbMF07XG5cblx0Ly8gQ2xlYXIgdGltZXJzIGFuZCBzdG9wIGFuaW1hdGlvbiBxdWV1ZVxuXHRjbGVhclRpbWVvdXQodGhpcy50aW1lcnMuc2hvdyk7XG5cdGNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5oaWRlKTtcblxuXHQvLyBQcmV2ZW50IGhpZGluZyBpZiB0b29sdGlwIGlzIGZpeGVkIGFuZCBldmVudCB0YXJnZXQgaXMgdGhlIHRvb2x0aXAuXG5cdC8vIE9yIGlmIG1vdXNlIHBvc2l0aW9uaW5nIGlzIGVuYWJsZWQgYW5kIGN1cnNvciBtb21lbnRhcmlseSBvdmVybGFwc1xuXHRpZih0aGlzICE9PSByZWxhdGVkVGFyZ2V0WzBdICYmXG5cdFx0KHRoaXMub3B0aW9ucy5wb3NpdGlvbi50YXJnZXQgPT09ICdtb3VzZScgJiYgb250b1Rvb2x0aXApIHx8XG5cdFx0dGhpcy5vcHRpb25zLmhpZGUuZml4ZWQgJiYgKFxuXHRcdFx0KC9tb3VzZShvdXR8bGVhdmV8bW92ZSkvKS50ZXN0KGV2ZW50LnR5cGUpICYmIChvbnRvVG9vbHRpcCB8fCBvbnRvVGFyZ2V0KSlcblx0XHQpXG5cdHtcblx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1lbXB0eSAqL1xuXHRcdHRyeSB7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0fSBjYXRjaChlKSB7fVxuXHRcdC8qIGVzbGludC1lbmFibGUgbm8tZW1wdHkgKi9cblxuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIElmIHRvb2x0aXAgaGFzIGRpc3BsYXllZCwgc3RhcnQgaGlkZSB0aW1lclxuXHR0aGlzLnRpbWVycy5oaWRlID0gZGVsYXkuY2FsbCh0aGlzLFxuXHRcdGZ1bmN0aW9uKCkgeyB0aGlzLnRvZ2dsZShGQUxTRSwgZXZlbnQpOyB9LFxuXHRcdHRoaXMub3B0aW9ucy5oaWRlLmRlbGF5LFxuXHRcdHRoaXNcblx0KTtcbn1cblxuZnVuY3Rpb24gaW5hY3RpdmVNZXRob2QoZXZlbnQpIHtcblx0aWYodGhpcy50b29sdGlwLmhhc0NsYXNzKENMQVNTX0RJU0FCTEVEKSB8fCAhdGhpcy5vcHRpb25zLmhpZGUuaW5hY3RpdmUpIHsgcmV0dXJuOyB9XG5cblx0Ly8gQ2xlYXIgdGltZXJcblx0Y2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLmluYWN0aXZlKTtcblxuXHR0aGlzLnRpbWVycy5pbmFjdGl2ZSA9IGRlbGF5LmNhbGwodGhpcyxcblx0XHRmdW5jdGlvbigpeyB0aGlzLmhpZGUoZXZlbnQpOyB9LFxuXHRcdHRoaXMub3B0aW9ucy5oaWRlLmluYWN0aXZlXG5cdCk7XG59XG5cbmZ1bmN0aW9uIHJlcG9zaXRpb25NZXRob2QoZXZlbnQpIHtcblx0aWYodGhpcy5yZW5kZXJlZCAmJiB0aGlzLnRvb2x0aXBbMF0ub2Zmc2V0V2lkdGggPiAwKSB7IHRoaXMucmVwb3NpdGlvbihldmVudCk7IH1cbn1cblxuLy8gU3RvcmUgbW91c2UgY29vcmRpbmF0ZXNcblBST1RPVFlQRS5fc3RvcmVNb3VzZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdCh0aGlzLm1vdXNlID0gJC5ldmVudC5maXgoZXZlbnQpKS50eXBlID0gJ21vdXNlbW92ZSc7XG5cdHJldHVybiB0aGlzO1xufTtcblxuLy8gQmluZCBldmVudHNcblBST1RPVFlQRS5fYmluZCA9IGZ1bmN0aW9uKHRhcmdldHMsIGV2ZW50cywgbWV0aG9kLCBzdWZmaXgsIGNvbnRleHQpIHtcblx0aWYoIXRhcmdldHMgfHwgIW1ldGhvZCB8fCAhZXZlbnRzLmxlbmd0aCkgeyByZXR1cm47IH1cblx0dmFyIG5zID0gJy4nICsgdGhpcy5faWQgKyAoc3VmZml4ID8gJy0nK3N1ZmZpeCA6ICcnKTtcblx0JCh0YXJnZXRzKS5iaW5kKFxuXHRcdChldmVudHMuc3BsaXQgPyBldmVudHMgOiBldmVudHMuam9pbihucyArICcgJykpICsgbnMsXG5cdFx0JC5wcm94eShtZXRob2QsIGNvbnRleHQgfHwgdGhpcylcblx0KTtcblx0cmV0dXJuIHRoaXM7XG59O1xuUFJPVE9UWVBFLl91bmJpbmQgPSBmdW5jdGlvbih0YXJnZXRzLCBzdWZmaXgpIHtcblx0dGFyZ2V0cyAmJiAkKHRhcmdldHMpLnVuYmluZCgnLicgKyB0aGlzLl9pZCArIChzdWZmaXggPyAnLScrc3VmZml4IDogJycpKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vLyBHbG9iYWwgZGVsZWdhdGlvbiBoZWxwZXJcbmZ1bmN0aW9uIGRlbGVnYXRlKHNlbGVjdG9yLCBldmVudHMsIG1ldGhvZCkge1xuXHQkKGRvY3VtZW50LmJvZHkpLmRlbGVnYXRlKHNlbGVjdG9yLFxuXHRcdChldmVudHMuc3BsaXQgPyBldmVudHMgOiBldmVudHMuam9pbignLicrTkFNRVNQQUNFICsgJyAnKSkgKyAnLicrTkFNRVNQQUNFLFxuXHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGFwaSA9IFFUSVAuYXBpWyAkLmF0dHIodGhpcywgQVRUUl9JRCkgXTtcblx0XHRcdGFwaSAmJiAhYXBpLmRpc2FibGVkICYmIG1ldGhvZC5hcHBseShhcGksIGFyZ3VtZW50cyk7XG5cdFx0fVxuXHQpO1xufVxuLy8gRXZlbnQgdHJpZ2dlclxuUFJPVE9UWVBFLl90cmlnZ2VyID0gZnVuY3Rpb24odHlwZSwgYXJncywgZXZlbnQpIHtcblx0dmFyIGNhbGxiYWNrID0gbmV3ICQuRXZlbnQoJ3Rvb2x0aXAnK3R5cGUpO1xuXHRjYWxsYmFjay5vcmlnaW5hbEV2ZW50ID0gZXZlbnQgJiYgJC5leHRlbmQoe30sIGV2ZW50KSB8fCB0aGlzLmNhY2hlLmV2ZW50IHx8IE5VTEw7XG5cblx0dGhpcy50cmlnZ2VyaW5nID0gdHlwZTtcblx0dGhpcy50b29sdGlwLnRyaWdnZXIoY2FsbGJhY2ssIFt0aGlzXS5jb25jYXQoYXJncyB8fCBbXSkpO1xuXHR0aGlzLnRyaWdnZXJpbmcgPSBGQUxTRTtcblxuXHRyZXR1cm4gIWNhbGxiYWNrLmlzRGVmYXVsdFByZXZlbnRlZCgpO1xufTtcblxuUFJPVE9UWVBFLl9iaW5kRXZlbnRzID0gZnVuY3Rpb24oc2hvd0V2ZW50cywgaGlkZUV2ZW50cywgc2hvd1RhcmdldHMsIGhpZGVUYXJnZXRzLCBzaG93Q2FsbGJhY2ssIGhpZGVDYWxsYmFjaykge1xuXHQvLyBHZXQgdGFzcmdldHMgdGhhdCBseWUgd2l0aGluIGJvdGhcblx0dmFyIHNpbWlsYXJUYXJnZXRzID0gc2hvd1RhcmdldHMuZmlsdGVyKCBoaWRlVGFyZ2V0cyApLmFkZCggaGlkZVRhcmdldHMuZmlsdGVyKHNob3dUYXJnZXRzKSApLFxuXHRcdHRvZ2dsZUV2ZW50cyA9IFtdO1xuXG5cdC8vIElmIGhpZGUgYW5kIHNob3cgdGFyZ2V0cyBhcmUgdGhlIHNhbWUuLi5cblx0aWYoc2ltaWxhclRhcmdldHMubGVuZ3RoKSB7XG5cblx0XHQvLyBGaWx0ZXIgaWRlbnRpY2FsIHNob3cvaGlkZSBldmVudHNcblx0XHQkLmVhY2goaGlkZUV2ZW50cywgZnVuY3Rpb24oaSwgdHlwZSkge1xuXHRcdFx0dmFyIHNob3dJbmRleCA9ICQuaW5BcnJheSh0eXBlLCBzaG93RXZlbnRzKTtcblxuXHRcdFx0Ly8gQm90aCBldmVudHMgYXJlIGlkZW50aWNhbCwgcmVtb3ZlIGZyb20gYm90aCBoaWRlIGFuZCBzaG93IGV2ZW50c1xuXHRcdFx0Ly8gYW5kIGFwcGVuZCB0byB0b2dnbGVFdmVudHNcblx0XHRcdHNob3dJbmRleCA+IC0xICYmIHRvZ2dsZUV2ZW50cy5wdXNoKCBzaG93RXZlbnRzLnNwbGljZSggc2hvd0luZGV4LCAxIClbMF0gKTtcblx0XHR9KTtcblxuXHRcdC8vIFRvZ2dsZSBldmVudHMgYXJlIHNwZWNpYWwgY2FzZSBvZiBpZGVudGljYWwgc2hvdy9oaWRlIGV2ZW50cywgd2hpY2ggaGFwcGVuIGluIHNlcXVlbmNlXG5cdFx0aWYodG9nZ2xlRXZlbnRzLmxlbmd0aCkge1xuXHRcdFx0Ly8gQmluZCB0b2dnbGUgZXZlbnRzIHRvIHRoZSBzaW1pbGFyIHRhcmdldHNcblx0XHRcdHRoaXMuX2JpbmQoc2ltaWxhclRhcmdldHMsIHRvZ2dsZUV2ZW50cywgZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0dmFyIHN0YXRlID0gdGhpcy5yZW5kZXJlZCA/IHRoaXMudG9vbHRpcFswXS5vZmZzZXRXaWR0aCA+IDAgOiBmYWxzZTtcblx0XHRcdFx0KHN0YXRlID8gaGlkZUNhbGxiYWNrIDogc2hvd0NhbGxiYWNrKS5jYWxsKHRoaXMsIGV2ZW50KTtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBSZW1vdmUgdGhlIHNpbWlsYXIgdGFyZ2V0cyBmcm9tIHRoZSByZWd1bGFyIHNob3cvaGlkZSBiaW5kaW5nc1xuXHRcdFx0c2hvd1RhcmdldHMgPSBzaG93VGFyZ2V0cy5ub3Qoc2ltaWxhclRhcmdldHMpO1xuXHRcdFx0aGlkZVRhcmdldHMgPSBoaWRlVGFyZ2V0cy5ub3Qoc2ltaWxhclRhcmdldHMpO1xuXHRcdH1cblx0fVxuXG5cdC8vIEFwcGx5IHNob3cvaGlkZS90b2dnbGUgZXZlbnRzXG5cdHRoaXMuX2JpbmQoc2hvd1RhcmdldHMsIHNob3dFdmVudHMsIHNob3dDYWxsYmFjayk7XG5cdHRoaXMuX2JpbmQoaGlkZVRhcmdldHMsIGhpZGVFdmVudHMsIGhpZGVDYWxsYmFjayk7XG59O1xuXG5QUk9UT1RZUEUuX2Fzc2lnbkluaXRpYWxFdmVudHMgPSBmdW5jdGlvbihldmVudCkge1xuXHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRzaG93VGFyZ2V0ID0gb3B0aW9ucy5zaG93LnRhcmdldCxcblx0XHRoaWRlVGFyZ2V0ID0gb3B0aW9ucy5oaWRlLnRhcmdldCxcblx0XHRzaG93RXZlbnRzID0gb3B0aW9ucy5zaG93LmV2ZW50ID8gJC50cmltKCcnICsgb3B0aW9ucy5zaG93LmV2ZW50KS5zcGxpdCgnICcpIDogW10sXG5cdFx0aGlkZUV2ZW50cyA9IG9wdGlvbnMuaGlkZS5ldmVudCA/ICQudHJpbSgnJyArIG9wdGlvbnMuaGlkZS5ldmVudCkuc3BsaXQoJyAnKSA6IFtdO1xuXG5cdC8vIENhdGNoIHJlbW92ZS9yZW1vdmVxdGlwIGV2ZW50cyBvbiB0YXJnZXQgZWxlbWVudCB0byBkZXN0cm95IHJlZHVuZGFudCB0b29sdGlwc1xuXHR0aGlzLl9iaW5kKHRoaXMuZWxlbWVudHMudGFyZ2V0LCBbJ3JlbW92ZScsICdyZW1vdmVxdGlwJ10sIGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZGVzdHJveSh0cnVlKTtcblx0fSwgJ2Rlc3Ryb3knKTtcblxuXHQvKlxuXHQgKiBNYWtlIHN1cmUgaG92ZXJJbnRlbnQgZnVuY3Rpb25zIHByb3Blcmx5IGJ5IHVzaW5nIG1vdXNlbGVhdmUgYXMgYSBoaWRlIGV2ZW50IGlmXG5cdCAqIG1vdXNlZW50ZXIvbW91c2VvdXQgaXMgdXNlZCBmb3Igc2hvdy5ldmVudCwgZXZlbiBpZiBpdCBpc24ndCBpbiB0aGUgdXNlcnMgb3B0aW9ucy5cblx0ICovXG5cdGlmKC9tb3VzZShvdmVyfGVudGVyKS9pLnRlc3Qob3B0aW9ucy5zaG93LmV2ZW50KSAmJiAhL21vdXNlKG91dHxsZWF2ZSkvaS50ZXN0KG9wdGlvbnMuaGlkZS5ldmVudCkpIHtcblx0XHRoaWRlRXZlbnRzLnB1c2goJ21vdXNlbGVhdmUnKTtcblx0fVxuXG5cdC8qXG5cdCAqIEFsc28gbWFrZSBzdXJlIGluaXRpYWwgbW91c2UgdGFyZ2V0dGluZyB3b3JrcyBjb3JyZWN0bHkgYnkgY2FjaGluZyBtb3VzZW1vdmUgY29vcmRzXG5cdCAqIG9uIHNob3cgdGFyZ2V0cyBiZWZvcmUgdGhlIHRvb2x0aXAgaGFzIHJlbmRlcmVkLiBBbHNvIHNldCBvblRhcmdldCB3aGVuIHRyaWdnZXJlZCB0b1xuXHQgKiBrZWVwIG1vdXNlIHRyYWNraW5nIHdvcmtpbmcuXG5cdCAqL1xuXHR0aGlzLl9iaW5kKHNob3dUYXJnZXQsICdtb3VzZW1vdmUnLCBmdW5jdGlvbihtb3ZlRXZlbnQpIHtcblx0XHR0aGlzLl9zdG9yZU1vdXNlKG1vdmVFdmVudCk7XG5cdFx0dGhpcy5jYWNoZS5vblRhcmdldCA9IFRSVUU7XG5cdH0pO1xuXG5cdC8vIERlZmluZSBob3ZlckludGVudCBmdW5jdGlvblxuXHRmdW5jdGlvbiBob3ZlckludGVudChob3ZlckV2ZW50KSB7XG5cdFx0Ly8gT25seSBjb250aW51ZSBpZiB0b29sdGlwIGlzbid0IGRpc2FibGVkXG5cdFx0aWYodGhpcy5kaXNhYmxlZCB8fCB0aGlzLmRlc3Ryb3llZCkgeyByZXR1cm4gRkFMU0U7IH1cblxuXHRcdC8vIENhY2hlIHRoZSBldmVudCBkYXRhXG5cdFx0dGhpcy5jYWNoZS5ldmVudCA9IGhvdmVyRXZlbnQgJiYgJC5ldmVudC5maXgoaG92ZXJFdmVudCk7XG5cdFx0dGhpcy5jYWNoZS50YXJnZXQgPSBob3ZlckV2ZW50ICYmICQoaG92ZXJFdmVudC50YXJnZXQpO1xuXG5cdFx0Ly8gU3RhcnQgdGhlIGV2ZW50IHNlcXVlbmNlXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLnNob3cpO1xuXHRcdHRoaXMudGltZXJzLnNob3cgPSBkZWxheS5jYWxsKHRoaXMsXG5cdFx0XHRmdW5jdGlvbigpIHsgdGhpcy5yZW5kZXIodHlwZW9mIGhvdmVyRXZlbnQgPT09ICdvYmplY3QnIHx8IG9wdGlvbnMuc2hvdy5yZWFkeSk7IH0sXG5cdFx0XHRvcHRpb25zLnByZXJlbmRlciA/IDAgOiBvcHRpb25zLnNob3cuZGVsYXlcblx0XHQpO1xuXHR9XG5cblx0Ly8gRmlsdGVyIGFuZCBiaW5kIGV2ZW50c1xuXHR0aGlzLl9iaW5kRXZlbnRzKHNob3dFdmVudHMsIGhpZGVFdmVudHMsIHNob3dUYXJnZXQsIGhpZGVUYXJnZXQsIGhvdmVySW50ZW50LCBmdW5jdGlvbigpIHtcblx0XHRpZighdGhpcy50aW1lcnMpIHsgcmV0dXJuIEZBTFNFOyB9XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLnNob3cpO1xuXHR9KTtcblxuXHQvLyBQcmVyZW5kZXJpbmcgaXMgZW5hYmxlZCwgY3JlYXRlIHRvb2x0aXAgbm93XG5cdGlmKG9wdGlvbnMuc2hvdy5yZWFkeSB8fCBvcHRpb25zLnByZXJlbmRlcikgeyBob3ZlckludGVudC5jYWxsKHRoaXMsIGV2ZW50KTsgfVxufTtcblxuLy8gRXZlbnQgYXNzaWdubWVudCBtZXRob2RcblBST1RPVFlQRS5fYXNzaWduRXZlbnRzID0gZnVuY3Rpb24oKSB7XG5cdHZhciBzZWxmID0gdGhpcyxcblx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdHBvc09wdGlvbnMgPSBvcHRpb25zLnBvc2l0aW9uLFxuXG5cdFx0dG9vbHRpcCA9IHRoaXMudG9vbHRpcCxcblx0XHRzaG93VGFyZ2V0ID0gb3B0aW9ucy5zaG93LnRhcmdldCxcblx0XHRoaWRlVGFyZ2V0ID0gb3B0aW9ucy5oaWRlLnRhcmdldCxcblx0XHRjb250YWluZXJUYXJnZXQgPSBwb3NPcHRpb25zLmNvbnRhaW5lcixcblx0XHR2aWV3cG9ydFRhcmdldCA9IHBvc09wdGlvbnMudmlld3BvcnQsXG5cdFx0ZG9jdW1lbnRUYXJnZXQgPSAkKGRvY3VtZW50KSxcblx0XHR3aW5kb3dUYXJnZXQgPSAkKHdpbmRvdyksXG5cblx0XHRzaG93RXZlbnRzID0gb3B0aW9ucy5zaG93LmV2ZW50ID8gJC50cmltKCcnICsgb3B0aW9ucy5zaG93LmV2ZW50KS5zcGxpdCgnICcpIDogW10sXG5cdFx0aGlkZUV2ZW50cyA9IG9wdGlvbnMuaGlkZS5ldmVudCA/ICQudHJpbSgnJyArIG9wdGlvbnMuaGlkZS5ldmVudCkuc3BsaXQoJyAnKSA6IFtdO1xuXG5cblx0Ly8gQXNzaWduIHBhc3NlZCBldmVudCBjYWxsYmFja3Ncblx0JC5lYWNoKG9wdGlvbnMuZXZlbnRzLCBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaykge1xuXHRcdHNlbGYuX2JpbmQodG9vbHRpcCwgbmFtZSA9PT0gJ3RvZ2dsZScgPyBbJ3Rvb2x0aXBzaG93JywndG9vbHRpcGhpZGUnXSA6IFsndG9vbHRpcCcrbmFtZV0sIGNhbGxiYWNrLCBudWxsLCB0b29sdGlwKTtcblx0fSk7XG5cblx0Ly8gSGlkZSB0b29sdGlwcyB3aGVuIGxlYXZpbmcgY3VycmVudCB3aW5kb3cvZnJhbWUgKGJ1dCBub3Qgc2VsZWN0L29wdGlvbiBlbGVtZW50cylcblx0aWYoL21vdXNlKG91dHxsZWF2ZSkvaS50ZXN0KG9wdGlvbnMuaGlkZS5ldmVudCkgJiYgb3B0aW9ucy5oaWRlLmxlYXZlID09PSAnd2luZG93Jykge1xuXHRcdHRoaXMuX2JpbmQoZG9jdW1lbnRUYXJnZXQsIFsnbW91c2VvdXQnLCAnYmx1ciddLCBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0aWYoIS9zZWxlY3R8b3B0aW9uLy50ZXN0KGV2ZW50LnRhcmdldC5ub2RlTmFtZSkgJiYgIWV2ZW50LnJlbGF0ZWRUYXJnZXQpIHtcblx0XHRcdFx0dGhpcy5oaWRlKGV2ZW50KTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdC8vIEVuYWJsZSBoaWRlLmZpeGVkIGJ5IGFkZGluZyBhcHByb3ByaWF0ZSBjbGFzc1xuXHRpZihvcHRpb25zLmhpZGUuZml4ZWQpIHtcblx0XHRoaWRlVGFyZ2V0ID0gaGlkZVRhcmdldC5hZGQoIHRvb2x0aXAuYWRkQ2xhc3MoQ0xBU1NfRklYRUQpICk7XG5cdH1cblxuXHQvKlxuXHQgKiBNYWtlIHN1cmUgaG92ZXJJbnRlbnQgZnVuY3Rpb25zIHByb3Blcmx5IGJ5IHVzaW5nIG1vdXNlbGVhdmUgdG8gY2xlYXIgc2hvdyB0aW1lciBpZlxuXHQgKiBtb3VzZWVudGVyL21vdXNlb3V0IGlzIHVzZWQgZm9yIHNob3cuZXZlbnQsIGV2ZW4gaWYgaXQgaXNuJ3QgaW4gdGhlIHVzZXJzIG9wdGlvbnMuXG5cdCAqL1xuXHRlbHNlIGlmKC9tb3VzZShvdmVyfGVudGVyKS9pLnRlc3Qob3B0aW9ucy5zaG93LmV2ZW50KSkge1xuXHRcdHRoaXMuX2JpbmQoaGlkZVRhcmdldCwgJ21vdXNlbGVhdmUnLCBmdW5jdGlvbigpIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5zaG93KTtcblx0XHR9KTtcblx0fVxuXG5cdC8vIEhpZGUgdG9vbHRpcCBvbiBkb2N1bWVudCBtb3VzZWRvd24gaWYgdW5mb2N1cyBldmVudHMgYXJlIGVuYWJsZWRcblx0aWYoKCcnICsgb3B0aW9ucy5oaWRlLmV2ZW50KS5pbmRleE9mKCd1bmZvY3VzJykgPiAtMSkge1xuXHRcdHRoaXMuX2JpbmQoY29udGFpbmVyVGFyZ2V0LmNsb3Nlc3QoJ2h0bWwnKSwgWydtb3VzZWRvd24nLCAndG91Y2hzdGFydCddLCBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0dmFyIGVsZW0gPSAkKGV2ZW50LnRhcmdldCksXG5cdFx0XHRcdGVuYWJsZWQgPSB0aGlzLnJlbmRlcmVkICYmICF0aGlzLnRvb2x0aXAuaGFzQ2xhc3MoQ0xBU1NfRElTQUJMRUQpICYmIHRoaXMudG9vbHRpcFswXS5vZmZzZXRXaWR0aCA+IDAsXG5cdFx0XHRcdGlzQW5jZXN0b3IgPSBlbGVtLnBhcmVudHMoU0VMRUNUT1IpLmZpbHRlcih0aGlzLnRvb2x0aXBbMF0pLmxlbmd0aCA+IDA7XG5cblx0XHRcdGlmKGVsZW1bMF0gIT09IHRoaXMudGFyZ2V0WzBdICYmIGVsZW1bMF0gIT09IHRoaXMudG9vbHRpcFswXSAmJiAhaXNBbmNlc3RvciAmJlxuXHRcdFx0XHQhdGhpcy50YXJnZXQuaGFzKGVsZW1bMF0pLmxlbmd0aCAmJiBlbmFibGVkXG5cdFx0XHQpIHtcblx0XHRcdFx0dGhpcy5oaWRlKGV2ZW50KTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdC8vIENoZWNrIGlmIHRoZSB0b29sdGlwIGhpZGVzIHdoZW4gaW5hY3RpdmVcblx0aWYoJ251bWJlcicgPT09IHR5cGVvZiBvcHRpb25zLmhpZGUuaW5hY3RpdmUpIHtcblx0XHQvLyBCaW5kIGluYWN0aXZlIG1ldGhvZCB0byBzaG93IHRhcmdldChzKSBhcyBhIGN1c3RvbSBldmVudFxuXHRcdHRoaXMuX2JpbmQoc2hvd1RhcmdldCwgJ3F0aXAtJyt0aGlzLmlkKyctaW5hY3RpdmUnLCBpbmFjdGl2ZU1ldGhvZCwgJ2luYWN0aXZlJyk7XG5cblx0XHQvLyBEZWZpbmUgZXZlbnRzIHdoaWNoIHJlc2V0IHRoZSAnaW5hY3RpdmUnIGV2ZW50IGhhbmRsZXJcblx0XHR0aGlzLl9iaW5kKGhpZGVUYXJnZXQuYWRkKHRvb2x0aXApLCBRVElQLmluYWN0aXZlRXZlbnRzLCBpbmFjdGl2ZU1ldGhvZCk7XG5cdH1cblxuXHQvLyBGaWx0ZXIgYW5kIGJpbmQgZXZlbnRzXG5cdHRoaXMuX2JpbmRFdmVudHMoc2hvd0V2ZW50cywgaGlkZUV2ZW50cywgc2hvd1RhcmdldCwgaGlkZVRhcmdldCwgc2hvd01ldGhvZCwgaGlkZU1ldGhvZCk7XG5cblx0Ly8gTW91c2UgbW92ZW1lbnQgYmluZGluZ3Ncblx0dGhpcy5fYmluZChzaG93VGFyZ2V0LmFkZCh0b29sdGlwKSwgJ21vdXNlbW92ZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0Ly8gQ2hlY2sgaWYgdGhlIHRvb2x0aXAgaGlkZXMgd2hlbiBtb3VzZSBpcyBtb3ZlZCBhIGNlcnRhaW4gZGlzdGFuY2Vcblx0XHRpZignbnVtYmVyJyA9PT0gdHlwZW9mIG9wdGlvbnMuaGlkZS5kaXN0YW5jZSkge1xuXHRcdFx0dmFyIG9yaWdpbiA9IHRoaXMuY2FjaGUub3JpZ2luIHx8IHt9LFxuXHRcdFx0XHRsaW1pdCA9IHRoaXMub3B0aW9ucy5oaWRlLmRpc3RhbmNlLFxuXHRcdFx0XHRhYnMgPSBNYXRoLmFicztcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgdGhlIG1vdmVtZW50IGhhcyBnb25lIGJleW9uZCB0aGUgbGltaXQsIGFuZCBoaWRlIGl0IGlmIHNvXG5cdFx0XHRpZihhYnMoZXZlbnQucGFnZVggLSBvcmlnaW4ucGFnZVgpID49IGxpbWl0IHx8IGFicyhldmVudC5wYWdlWSAtIG9yaWdpbi5wYWdlWSkgPj0gbGltaXQpIHtcblx0XHRcdFx0dGhpcy5oaWRlKGV2ZW50KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSBtb3VzZW1vdmUgY29vcmRzIG9uIHNob3cgdGFyZ2V0c1xuXHRcdHRoaXMuX3N0b3JlTW91c2UoZXZlbnQpO1xuXHR9KTtcblxuXHQvLyBNb3VzZSBwb3NpdGlvbmluZyBldmVudHNcblx0aWYocG9zT3B0aW9ucy50YXJnZXQgPT09ICdtb3VzZScpIHtcblx0XHQvLyBJZiBtb3VzZSBhZGp1c3RtZW50IGlzIG9uLi4uXG5cdFx0aWYocG9zT3B0aW9ucy5hZGp1c3QubW91c2UpIHtcblx0XHRcdC8vIEFwcGx5IGEgbW91c2VsZWF2ZSBldmVudCBzbyB3ZSBkb24ndCBnZXQgcHJvYmxlbXMgd2l0aCBvdmVybGFwcGluZ1xuXHRcdFx0aWYob3B0aW9ucy5oaWRlLmV2ZW50KSB7XG5cdFx0XHRcdC8vIFRyYWNrIGlmIHdlJ3JlIG9uIHRoZSB0YXJnZXQgb3Igbm90XG5cdFx0XHRcdHRoaXMuX2JpbmQoc2hvd1RhcmdldCwgWydtb3VzZWVudGVyJywgJ21vdXNlbGVhdmUnXSwgZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0XHRpZighdGhpcy5jYWNoZSkge3JldHVybiBGQUxTRTsgfVxuXHRcdFx0XHRcdHRoaXMuY2FjaGUub25UYXJnZXQgPSBldmVudC50eXBlID09PSAnbW91c2VlbnRlcic7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBVcGRhdGUgdG9vbHRpcCBwb3NpdGlvbiBvbiBtb3VzZW1vdmVcblx0XHRcdHRoaXMuX2JpbmQoZG9jdW1lbnRUYXJnZXQsICdtb3VzZW1vdmUnLCBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHQvLyBVcGRhdGUgdGhlIHRvb2x0aXAgcG9zaXRpb24gb25seSBpZiB0aGUgdG9vbHRpcCBpcyB2aXNpYmxlIGFuZCBhZGp1c3RtZW50IGlzIGVuYWJsZWRcblx0XHRcdFx0aWYodGhpcy5yZW5kZXJlZCAmJiB0aGlzLmNhY2hlLm9uVGFyZ2V0ICYmICF0aGlzLnRvb2x0aXAuaGFzQ2xhc3MoQ0xBU1NfRElTQUJMRUQpICYmIHRoaXMudG9vbHRpcFswXS5vZmZzZXRXaWR0aCA+IDApIHtcblx0XHRcdFx0XHR0aGlzLnJlcG9zaXRpb24oZXZlbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHQvLyBBZGp1c3QgcG9zaXRpb25zIG9mIHRoZSB0b29sdGlwIG9uIHdpbmRvdyByZXNpemUgaWYgZW5hYmxlZFxuXHRpZihwb3NPcHRpb25zLmFkanVzdC5yZXNpemUgfHwgdmlld3BvcnRUYXJnZXQubGVuZ3RoKSB7XG5cdFx0dGhpcy5fYmluZCggJC5ldmVudC5zcGVjaWFsLnJlc2l6ZSA/IHZpZXdwb3J0VGFyZ2V0IDogd2luZG93VGFyZ2V0LCAncmVzaXplJywgcmVwb3NpdGlvbk1ldGhvZCApO1xuXHR9XG5cblx0Ly8gQWRqdXN0IHRvb2x0aXAgcG9zaXRpb24gb24gc2Nyb2xsIG9mIHRoZSB3aW5kb3cgb3Igdmlld3BvcnQgZWxlbWVudCBpZiBwcmVzZW50XG5cdGlmKHBvc09wdGlvbnMuYWRqdXN0LnNjcm9sbCkge1xuXHRcdHRoaXMuX2JpbmQoIHdpbmRvd1RhcmdldC5hZGQocG9zT3B0aW9ucy5jb250YWluZXIpLCAnc2Nyb2xsJywgcmVwb3NpdGlvbk1ldGhvZCApO1xuXHR9XG59O1xuXG4vLyBVbi1hc3NpZ25tZW50IG1ldGhvZFxuUFJPVE9UWVBFLl91bmFzc2lnbkV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcblx0XHRzaG93VGFyZ2V0cyA9IG9wdGlvbnMuc2hvdy50YXJnZXQsXG5cdFx0aGlkZVRhcmdldHMgPSBvcHRpb25zLmhpZGUudGFyZ2V0LFxuXHRcdHRhcmdldHMgPSAkLmdyZXAoW1xuXHRcdFx0dGhpcy5lbGVtZW50cy50YXJnZXRbMF0sXG5cdFx0XHR0aGlzLnJlbmRlcmVkICYmIHRoaXMudG9vbHRpcFswXSxcblx0XHRcdG9wdGlvbnMucG9zaXRpb24uY29udGFpbmVyWzBdLFxuXHRcdFx0b3B0aW9ucy5wb3NpdGlvbi52aWV3cG9ydFswXSxcblx0XHRcdG9wdGlvbnMucG9zaXRpb24uY29udGFpbmVyLmNsb3Nlc3QoJ2h0bWwnKVswXSwgLy8gdW5mb2N1c1xuXHRcdFx0d2luZG93LFxuXHRcdFx0ZG9jdW1lbnRcblx0XHRdLCBmdW5jdGlvbihpKSB7XG5cdFx0XHRyZXR1cm4gdHlwZW9mIGkgPT09ICdvYmplY3QnO1xuXHRcdH0pO1xuXG5cdC8vIEFkZCBzaG93IGFuZCBoaWRlIHRhcmdldHMgaWYgdGhleSdyZSB2YWxpZFxuXHRpZihzaG93VGFyZ2V0cyAmJiBzaG93VGFyZ2V0cy50b0FycmF5KSB7XG5cdFx0dGFyZ2V0cyA9IHRhcmdldHMuY29uY2F0KHNob3dUYXJnZXRzLnRvQXJyYXkoKSk7XG5cdH1cblx0aWYoaGlkZVRhcmdldHMgJiYgaGlkZVRhcmdldHMudG9BcnJheSkge1xuXHRcdHRhcmdldHMgPSB0YXJnZXRzLmNvbmNhdChoaWRlVGFyZ2V0cy50b0FycmF5KCkpO1xuXHR9XG5cblx0Ly8gVW5iaW5kIHRoZSBldmVudHNcblx0dGhpcy5fdW5iaW5kKHRhcmdldHMpXG5cdFx0Ll91bmJpbmQodGFyZ2V0cywgJ2Rlc3Ryb3knKVxuXHRcdC5fdW5iaW5kKHRhcmdldHMsICdpbmFjdGl2ZScpO1xufTtcblxuLy8gQXBwbHkgY29tbW9uIGV2ZW50IGhhbmRsZXJzIHVzaW5nIGRlbGVnYXRlIChhdm9pZHMgZXhjZXNzaXZlIC5iaW5kIGNhbGxzISlcbiQoZnVuY3Rpb24oKSB7XG5cdGRlbGVnYXRlKFNFTEVDVE9SLCBbJ21vdXNlZW50ZXInLCAnbW91c2VsZWF2ZSddLCBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBzdGF0ZSA9IGV2ZW50LnR5cGUgPT09ICdtb3VzZWVudGVyJyxcblx0XHRcdHRvb2x0aXAgPSAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLFxuXHRcdFx0dGFyZ2V0ID0gJChldmVudC5yZWxhdGVkVGFyZ2V0IHx8IGV2ZW50LnRhcmdldCksXG5cdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG5cdFx0Ly8gT24gbW91c2VlbnRlci4uLlxuXHRcdGlmKHN0YXRlKSB7XG5cdFx0XHQvLyBGb2N1cyB0aGUgdG9vbHRpcCBvbiBtb3VzZWVudGVyICh6LWluZGV4IHN0YWNraW5nKVxuXHRcdFx0dGhpcy5mb2N1cyhldmVudCk7XG5cblx0XHRcdC8vIENsZWFyIGhpZGUgdGltZXIgb24gdG9vbHRpcCBob3ZlciB0byBwcmV2ZW50IGl0IGZyb20gY2xvc2luZ1xuXHRcdFx0dG9vbHRpcC5oYXNDbGFzcyhDTEFTU19GSVhFRCkgJiYgIXRvb2x0aXAuaGFzQ2xhc3MoQ0xBU1NfRElTQUJMRUQpICYmIGNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5oaWRlKTtcblx0XHR9XG5cblx0XHQvLyBPbiBtb3VzZWxlYXZlLi4uXG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBXaGVuIG1vdXNlIHRyYWNraW5nIGlzIGVuYWJsZWQsIGhpZGUgd2hlbiB3ZSBsZWF2ZSB0aGUgdG9vbHRpcCBhbmQgbm90IG9udG8gdGhlIHNob3cgdGFyZ2V0IChpZiBhIGhpZGUgZXZlbnQgaXMgc2V0KVxuXHRcdFx0aWYob3B0aW9ucy5wb3NpdGlvbi50YXJnZXQgPT09ICdtb3VzZScgJiYgb3B0aW9ucy5wb3NpdGlvbi5hZGp1c3QubW91c2UgJiZcblx0XHRcdFx0b3B0aW9ucy5oaWRlLmV2ZW50ICYmIG9wdGlvbnMuc2hvdy50YXJnZXQgJiYgIXRhcmdldC5jbG9zZXN0KG9wdGlvbnMuc2hvdy50YXJnZXRbMF0pLmxlbmd0aCkge1xuXHRcdFx0XHR0aGlzLmhpZGUoZXZlbnQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCBob3ZlciBjbGFzc1xuXHRcdHRvb2x0aXAudG9nZ2xlQ2xhc3MoQ0xBU1NfSE9WRVIsIHN0YXRlKTtcblx0fSk7XG5cblx0Ly8gRGVmaW5lIGV2ZW50cyB3aGljaCByZXNldCB0aGUgJ2luYWN0aXZlJyBldmVudCBoYW5kbGVyXG5cdGRlbGVnYXRlKCdbJytBVFRSX0lEKyddJywgSU5BQ1RJVkVfRVZFTlRTLCBpbmFjdGl2ZU1ldGhvZCk7XG59KTtcbjsvLyBJbml0aWFsaXphdGlvbiBtZXRob2RcbmZ1bmN0aW9uIGluaXQoZWxlbSwgaWQsIG9wdHMpIHtcblx0dmFyIG9iaiwgcG9zT3B0aW9ucywgYXR0ciwgY29uZmlnLCB0aXRsZSxcblxuXHQvLyBTZXR1cCBlbGVtZW50IHJlZmVyZW5jZXNcblx0ZG9jQm9keSA9ICQoZG9jdW1lbnQuYm9keSksXG5cblx0Ly8gVXNlIGRvY3VtZW50IGJvZHkgaW5zdGVhZCBvZiBkb2N1bWVudCBlbGVtZW50IGlmIG5lZWRlZFxuXHRuZXdUYXJnZXQgPSBlbGVtWzBdID09PSBkb2N1bWVudCA/IGRvY0JvZHkgOiBlbGVtLFxuXG5cdC8vIEdyYWIgbWV0YWRhdGEgZnJvbSBlbGVtZW50IGlmIHBsdWdpbiBpcyBwcmVzZW50XG5cdG1ldGFkYXRhID0gZWxlbS5tZXRhZGF0YSA/IGVsZW0ubWV0YWRhdGEob3B0cy5tZXRhZGF0YSkgOiBOVUxMLFxuXG5cdC8vIElmIG1ldGFkYXRhIHR5cGUgaWYgSFRNTDUsIGdyYWIgJ25hbWUnIGZyb20gdGhlIG9iamVjdCBpbnN0ZWFkLCBvciB1c2UgdGhlIHJlZ3VsYXIgZGF0YSBvYmplY3Qgb3RoZXJ3aXNlXG5cdG1ldGFkYXRhNSA9IG9wdHMubWV0YWRhdGEudHlwZSA9PT0gJ2h0bWw1JyAmJiBtZXRhZGF0YSA/IG1ldGFkYXRhW29wdHMubWV0YWRhdGEubmFtZV0gOiBOVUxMLFxuXG5cdC8vIEdyYWIgZGF0YSBmcm9tIG1ldGFkYXRhLm5hbWUgKG9yIGRhdGEtcXRpcG9wdHMgYXMgZmFsbGJhY2spIHVzaW5nIC5kYXRhKCkgbWV0aG9kLFxuXHRodG1sNSA9IGVsZW0uZGF0YShvcHRzLm1ldGFkYXRhLm5hbWUgfHwgJ3F0aXBvcHRzJyk7XG5cblx0Ly8gSWYgd2UgZG9uJ3QgZ2V0IGFuIG9iamVjdCByZXR1cm5lZCBhdHRlbXB0IHRvIHBhcnNlIGl0IG1hbnVhbHlsIHdpdGhvdXQgcGFyc2VKU09OXG5cdC8qIGVzbGludC1kaXNhYmxlIG5vLWVtcHR5ICovXG5cdHRyeSB7IGh0bWw1ID0gdHlwZW9mIGh0bWw1ID09PSAnc3RyaW5nJyA/ICQucGFyc2VKU09OKGh0bWw1KSA6IGh0bWw1OyB9XG5cdGNhdGNoKGUpIHt9XG5cdC8qIGVzbGludC1lbmFibGUgbm8tZW1wdHkgKi9cblxuXHQvLyBNZXJnZSBpbiBhbmQgc2FuaXRpemUgbWV0YWRhdGFcblx0Y29uZmlnID0gJC5leHRlbmQoVFJVRSwge30sIFFUSVAuZGVmYXVsdHMsIG9wdHMsXG5cdFx0dHlwZW9mIGh0bWw1ID09PSAnb2JqZWN0JyA/IHNhbml0aXplT3B0aW9ucyhodG1sNSkgOiBOVUxMLFxuXHRcdHNhbml0aXplT3B0aW9ucyhtZXRhZGF0YTUgfHwgbWV0YWRhdGEpKTtcblxuXHQvLyBSZS1ncmFiIG91ciBwb3NpdGlvbmluZyBvcHRpb25zIG5vdyB3ZSd2ZSBtZXJnZWQgb3VyIG1ldGFkYXRhIGFuZCBzZXQgaWQgdG8gcGFzc2VkIHZhbHVlXG5cdHBvc09wdGlvbnMgPSBjb25maWcucG9zaXRpb247XG5cdGNvbmZpZy5pZCA9IGlkO1xuXG5cdC8vIFNldHVwIG1pc3NpbmcgY29udGVudCBpZiBub25lIGlzIGRldGVjdGVkXG5cdGlmKCdib29sZWFuJyA9PT0gdHlwZW9mIGNvbmZpZy5jb250ZW50LnRleHQpIHtcblx0XHRhdHRyID0gZWxlbS5hdHRyKGNvbmZpZy5jb250ZW50LmF0dHIpO1xuXG5cdFx0Ly8gR3JhYiBmcm9tIHN1cHBsaWVkIGF0dHJpYnV0ZSBpZiBhdmFpbGFibGVcblx0XHRpZihjb25maWcuY29udGVudC5hdHRyICE9PSBGQUxTRSAmJiBhdHRyKSB7IGNvbmZpZy5jb250ZW50LnRleHQgPSBhdHRyOyB9XG5cblx0XHQvLyBObyB2YWxpZCBjb250ZW50IHdhcyBmb3VuZCwgYWJvcnQgcmVuZGVyXG5cdFx0ZWxzZSB7IHJldHVybiBGQUxTRTsgfVxuXHR9XG5cblx0Ly8gU2V0dXAgdGFyZ2V0IG9wdGlvbnNcblx0aWYoIXBvc09wdGlvbnMuY29udGFpbmVyLmxlbmd0aCkgeyBwb3NPcHRpb25zLmNvbnRhaW5lciA9IGRvY0JvZHk7IH1cblx0aWYocG9zT3B0aW9ucy50YXJnZXQgPT09IEZBTFNFKSB7IHBvc09wdGlvbnMudGFyZ2V0ID0gbmV3VGFyZ2V0OyB9XG5cdGlmKGNvbmZpZy5zaG93LnRhcmdldCA9PT0gRkFMU0UpIHsgY29uZmlnLnNob3cudGFyZ2V0ID0gbmV3VGFyZ2V0OyB9XG5cdGlmKGNvbmZpZy5zaG93LnNvbG8gPT09IFRSVUUpIHsgY29uZmlnLnNob3cuc29sbyA9IHBvc09wdGlvbnMuY29udGFpbmVyLmNsb3Nlc3QoJ2JvZHknKTsgfVxuXHRpZihjb25maWcuaGlkZS50YXJnZXQgPT09IEZBTFNFKSB7IGNvbmZpZy5oaWRlLnRhcmdldCA9IG5ld1RhcmdldDsgfVxuXHRpZihjb25maWcucG9zaXRpb24udmlld3BvcnQgPT09IFRSVUUpIHsgY29uZmlnLnBvc2l0aW9uLnZpZXdwb3J0ID0gcG9zT3B0aW9ucy5jb250YWluZXI7IH1cblxuXHQvLyBFbnN1cmUgd2Ugb25seSB1c2UgYSBzaW5nbGUgY29udGFpbmVyXG5cdHBvc09wdGlvbnMuY29udGFpbmVyID0gcG9zT3B0aW9ucy5jb250YWluZXIuZXEoMCk7XG5cblx0Ly8gQ29udmVydCBwb3NpdGlvbiBjb3JuZXIgdmFsdWVzIGludG8geCBhbmQgeSBzdHJpbmdzXG5cdHBvc09wdGlvbnMuYXQgPSBuZXcgQ09STkVSKHBvc09wdGlvbnMuYXQsIFRSVUUpO1xuXHRwb3NPcHRpb25zLm15ID0gbmV3IENPUk5FUihwb3NPcHRpb25zLm15KTtcblxuXHQvLyBEZXN0cm95IHByZXZpb3VzIHRvb2x0aXAgaWYgb3ZlcndyaXRlIGlzIGVuYWJsZWQsIG9yIHNraXAgZWxlbWVudCBpZiBub3Rcblx0aWYoZWxlbS5kYXRhKE5BTUVTUEFDRSkpIHtcblx0XHRpZihjb25maWcub3ZlcndyaXRlKSB7XG5cdFx0XHRlbGVtLnF0aXAoJ2Rlc3Ryb3knLCB0cnVlKTtcblx0XHR9XG5cdFx0ZWxzZSBpZihjb25maWcub3ZlcndyaXRlID09PSBGQUxTRSkge1xuXHRcdFx0cmV0dXJuIEZBTFNFO1xuXHRcdH1cblx0fVxuXG5cdC8vIEFkZCBoYXMtcXRpcCBhdHRyaWJ1dGVcblx0ZWxlbS5hdHRyKEFUVFJfSEFTLCBpZCk7XG5cblx0Ly8gUmVtb3ZlIHRpdGxlIGF0dHJpYnV0ZSBhbmQgc3RvcmUgaXQgaWYgcHJlc2VudFxuXHRpZihjb25maWcuc3VwcHJlc3MgJiYgKHRpdGxlID0gZWxlbS5hdHRyKCd0aXRsZScpKSkge1xuXHRcdC8vIEZpbmFsIGF0dHIgY2FsbCBmaXhlcyBldmVudCBkZWxlZ2F0aW9tIGFuZCBJRSBkZWZhdWx0IHRvb2x0aXAgc2hvd2luZyBwcm9ibGVtXG5cdFx0ZWxlbS5yZW1vdmVBdHRyKCd0aXRsZScpLmF0dHIob2xkdGl0bGUsIHRpdGxlKS5hdHRyKCd0aXRsZScsICcnKTtcblx0fVxuXG5cdC8vIEluaXRpYWxpemUgdGhlIHRvb2x0aXAgYW5kIGFkZCBBUEkgcmVmZXJlbmNlXG5cdG9iaiA9IG5ldyBRVGlwKGVsZW0sIGNvbmZpZywgaWQsICEhYXR0cik7XG5cdGVsZW0uZGF0YShOQU1FU1BBQ0UsIG9iaik7XG5cblx0cmV0dXJuIG9iajtcbn1cblxuLy8galF1ZXJ5ICQuZm4gZXh0ZW5zaW9uIG1ldGhvZFxuUVRJUCA9ICQuZm4ucXRpcCA9IGZ1bmN0aW9uKG9wdGlvbnMsIG5vdGF0aW9uLCBuZXdWYWx1ZSlcbntcblx0dmFyIGNvbW1hbmQgPSAoJycgKyBvcHRpb25zKS50b0xvd2VyQ2FzZSgpLCAvLyBQYXJzZSBjb21tYW5kXG5cdFx0cmV0dXJuZWQgPSBOVUxMLFxuXHRcdGFyZ3MgPSAkLm1ha2VBcnJheShhcmd1bWVudHMpLnNsaWNlKDEpLFxuXHRcdGV2ZW50ID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdLFxuXHRcdG9wdHMgPSB0aGlzWzBdID8gJC5kYXRhKHRoaXNbMF0sIE5BTUVTUEFDRSkgOiBOVUxMO1xuXG5cdC8vIENoZWNrIGZvciBBUEkgcmVxdWVzdFxuXHRpZighYXJndW1lbnRzLmxlbmd0aCAmJiBvcHRzIHx8IGNvbW1hbmQgPT09ICdhcGknKSB7XG5cdFx0cmV0dXJuIG9wdHM7XG5cdH1cblxuXHQvLyBFeGVjdXRlIEFQSSBjb21tYW5kIGlmIHByZXNlbnRcblx0ZWxzZSBpZignc3RyaW5nJyA9PT0gdHlwZW9mIG9wdGlvbnMpIHtcblx0XHR0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgYXBpID0gJC5kYXRhKHRoaXMsIE5BTUVTUEFDRSk7XG5cdFx0XHRpZighYXBpKSB7IHJldHVybiBUUlVFOyB9XG5cblx0XHRcdC8vIENhY2hlIHRoZSBldmVudCBpZiBwb3NzaWJsZVxuXHRcdFx0aWYoZXZlbnQgJiYgZXZlbnQudGltZVN0YW1wKSB7IGFwaS5jYWNoZS5ldmVudCA9IGV2ZW50OyB9XG5cblx0XHRcdC8vIENoZWNrIGZvciBzcGVjaWZpYyBBUEkgY29tbWFuZHNcblx0XHRcdGlmKG5vdGF0aW9uICYmIChjb21tYW5kID09PSAnb3B0aW9uJyB8fCBjb21tYW5kID09PSAnb3B0aW9ucycpKSB7XG5cdFx0XHRcdGlmKG5ld1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgJC5pc1BsYWluT2JqZWN0KG5vdGF0aW9uKSkge1xuXHRcdFx0XHRcdGFwaS5zZXQobm90YXRpb24sIG5ld1ZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm5lZCA9IGFwaS5nZXQobm90YXRpb24pO1xuXHRcdFx0XHRcdHJldHVybiBGQUxTRTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBFeGVjdXRlIEFQSSBjb21tYW5kXG5cdFx0XHRlbHNlIGlmKGFwaVtjb21tYW5kXSkge1xuXHRcdFx0XHRhcGlbY29tbWFuZF0uYXBwbHkoYXBpLCBhcmdzKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiByZXR1cm5lZCAhPT0gTlVMTCA/IHJldHVybmVkIDogdGhpcztcblx0fVxuXG5cdC8vIE5vIEFQSSBjb21tYW5kcy4gdmFsaWRhdGUgcHJvdmlkZWQgb3B0aW9ucyBhbmQgc2V0dXAgcVRpcHNcblx0ZWxzZSBpZignb2JqZWN0JyA9PT0gdHlwZW9mIG9wdGlvbnMgfHwgIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHQvLyBTYW5pdGl6ZSBvcHRpb25zIGZpcnN0XG5cdFx0b3B0cyA9IHNhbml0aXplT3B0aW9ucygkLmV4dGVuZChUUlVFLCB7fSwgb3B0aW9ucykpO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpKSB7XG5cdFx0XHR2YXIgYXBpLCBpZDtcblxuXHRcdFx0Ly8gRmluZCBuZXh0IGF2YWlsYWJsZSBJRCwgb3IgdXNlIGN1c3RvbSBJRCBpZiBwcm92aWRlZFxuXHRcdFx0aWQgPSAkLmlzQXJyYXkob3B0cy5pZCkgPyBvcHRzLmlkW2ldIDogb3B0cy5pZDtcblx0XHRcdGlkID0gIWlkIHx8IGlkID09PSBGQUxTRSB8fCBpZC5sZW5ndGggPCAxIHx8IFFUSVAuYXBpW2lkXSA/IFFUSVAubmV4dGlkKysgOiBpZDtcblxuXHRcdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgcVRpcCBhbmQgcmUtZ3JhYiBuZXdseSBzYW5pdGl6ZWQgb3B0aW9uc1xuXHRcdFx0YXBpID0gaW5pdCgkKHRoaXMpLCBpZCwgb3B0cyk7XG5cdFx0XHRpZihhcGkgPT09IEZBTFNFKSB7IHJldHVybiBUUlVFOyB9XG5cdFx0XHRlbHNlIHsgUVRJUC5hcGlbaWRdID0gYXBpOyB9XG5cblx0XHRcdC8vIEluaXRpYWxpemUgcGx1Z2luc1xuXHRcdFx0JC5lYWNoKFBMVUdJTlMsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZih0aGlzLmluaXRpYWxpemUgPT09ICdpbml0aWFsaXplJykgeyB0aGlzKGFwaSk7IH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBBc3NpZ24gaW5pdGlhbCBwcmUtcmVuZGVyIGV2ZW50c1xuXHRcdFx0YXBpLl9hc3NpZ25Jbml0aWFsRXZlbnRzKGV2ZW50KTtcblx0XHR9KTtcblx0fVxufTtcblxuLy8gRXhwb3NlIGNsYXNzXG4kLnF0aXAgPSBRVGlwO1xuXG4vLyBQb3B1bGF0ZWQgaW4gcmVuZGVyIG1ldGhvZFxuUVRJUC5hcGkgPSB7fTtcbjskLmVhY2goe1xuXHQvKiBBbGxvdyBvdGhlciBwbHVnaW5zIHRvIHN1Y2Nlc3NmdWxseSByZXRyaWV2ZSB0aGUgdGl0bGUgb2YgYW4gZWxlbWVudCB3aXRoIGEgcVRpcCBhcHBsaWVkICovXG5cdGF0dHI6IGZ1bmN0aW9uKGF0dHIsIHZhbCkge1xuXHRcdGlmKHRoaXMubGVuZ3RoKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXNbMF0sXG5cdFx0XHRcdHRpdGxlID0gJ3RpdGxlJyxcblx0XHRcdFx0YXBpID0gJC5kYXRhKHNlbGYsICdxdGlwJyk7XG5cblx0XHRcdGlmKGF0dHIgPT09IHRpdGxlICYmIGFwaSAmJiBhcGkub3B0aW9ucyAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIGFwaSAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIGFwaS5vcHRpb25zICYmIGFwaS5vcHRpb25zLnN1cHByZXNzKSB7XG5cdFx0XHRcdGlmKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG5cdFx0XHRcdFx0cmV0dXJuICQuYXR0cihzZWxmLCBvbGR0aXRsZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiBxVGlwIGlzIHJlbmRlcmVkIGFuZCB0aXRsZSB3YXMgb3JpZ2luYWxseSB1c2VkIGFzIGNvbnRlbnQsIHVwZGF0ZSBpdFxuXHRcdFx0XHRpZihhcGkgJiYgYXBpLm9wdGlvbnMuY29udGVudC5hdHRyID09PSB0aXRsZSAmJiBhcGkuY2FjaGUuYXR0cikge1xuXHRcdFx0XHRcdGFwaS5zZXQoJ2NvbnRlbnQudGV4dCcsIHZhbCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBVc2UgdGhlIHJlZ3VsYXIgYXR0ciBtZXRob2QgdG8gc2V0LCB0aGVuIGNhY2hlIHRoZSByZXN1bHRcblx0XHRcdFx0cmV0dXJuIHRoaXMuYXR0cihvbGR0aXRsZSwgdmFsKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gJC5mblsnYXR0cicrcmVwbGFjZVN1ZmZpeF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fSxcblxuXHQvKiBBbGxvdyBjbG9uZSB0byBjb3JyZWN0bHkgcmV0cmlldmUgY2FjaGVkIHRpdGxlIGF0dHJpYnV0ZXMgKi9cblx0Y2xvbmU6IGZ1bmN0aW9uKGtlZXBEYXRhKSB7XG5cdFx0Ly8gQ2xvbmUgb3VyIGVsZW1lbnQgdXNpbmcgdGhlIHJlYWwgY2xvbmUgbWV0aG9kXG5cdFx0dmFyIGVsZW1zID0gJC5mblsnY2xvbmUnK3JlcGxhY2VTdWZmaXhdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cblx0XHQvLyBHcmFiIGFsbCBlbGVtZW50cyB3aXRoIGFuIG9sZHRpdGxlIHNldCwgYW5kIGNoYW5nZSBpdCB0byByZWd1bGFyIHRpdGxlIGF0dHJpYnV0ZSwgaWYga2VlcERhdGEgaXMgZmFsc2Vcblx0XHRpZigha2VlcERhdGEpIHtcblx0XHRcdGVsZW1zLmZpbHRlcignWycrb2xkdGl0bGUrJ10nKS5hdHRyKCd0aXRsZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gJC5hdHRyKHRoaXMsIG9sZHRpdGxlKTtcblx0XHRcdH0pXG5cdFx0XHQucmVtb3ZlQXR0cihvbGR0aXRsZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVsZW1zO1xuXHR9XG59LCBmdW5jdGlvbihuYW1lLCBmdW5jKSB7XG5cdGlmKCFmdW5jIHx8ICQuZm5bbmFtZStyZXBsYWNlU3VmZml4XSkgeyByZXR1cm4gVFJVRTsgfVxuXG5cdHZhciBvbGQgPSAkLmZuW25hbWUrcmVwbGFjZVN1ZmZpeF0gPSAkLmZuW25hbWVdO1xuXHQkLmZuW25hbWVdID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCBvbGQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fTtcbn0pO1xuXG4vKiBGaXJlIG9mZiAncmVtb3ZlcXRpcCcgaGFuZGxlciBpbiAkLmNsZWFuRGF0YSBpZiBqUXVlcnkgVUkgbm90IHByZXNlbnQgKGl0IGFscmVhZHkgZG9lcyBzaW1pbGFyKS5cbiAqIFRoaXMgc25pcHBldCBpcyB0YWtlbiBkaXJlY3RseSBmcm9tIGpRdWVyeSBVSSBzb3VyY2UgY29kZSBmb3VuZCBoZXJlOlxuICogICAgIGh0dHA6Ly9jb2RlLmpxdWVyeS5jb20vdWkvanF1ZXJ5LXVpLWdpdC5qc1xuICovXG5pZighJC51aSkge1xuXHQkWydjbGVhbkRhdGEnK3JlcGxhY2VTdWZmaXhdID0gJC5jbGVhbkRhdGE7XG5cdCQuY2xlYW5EYXRhID0gZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdGZvcih2YXIgaSA9IDAsIGVsZW07IChlbGVtID0gJCggZWxlbXNbaV0gKSkubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmKGVsZW0uYXR0cihBVFRSX0hBUykpIHtcblx0XHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tZW1wdHkgKi9cblx0XHRcdFx0dHJ5IHsgZWxlbS50cmlnZ2VySGFuZGxlcigncmVtb3ZlcXRpcCcpOyB9XG5cdFx0XHRcdGNhdGNoKCBlICkge31cblx0XHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1lbXB0eSAqL1xuXHRcdFx0fVxuXHRcdH1cblx0XHQkWydjbGVhbkRhdGEnK3JlcGxhY2VTdWZmaXhdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH07XG59XG47Ly8gcVRpcCB2ZXJzaW9uXG5RVElQLnZlcnNpb24gPSAnMy4wLjMnO1xuXG4vLyBCYXNlIElEIGZvciBhbGwgcVRpcHNcblFUSVAubmV4dGlkID0gMDtcblxuLy8gSW5hY3RpdmUgZXZlbnRzIGFycmF5XG5RVElQLmluYWN0aXZlRXZlbnRzID0gSU5BQ1RJVkVfRVZFTlRTO1xuXG4vLyBCYXNlIHotaW5kZXggZm9yIGFsbCBxVGlwc1xuUVRJUC56aW5kZXggPSAxNTAwMDtcblxuLy8gRGVmaW5lIGNvbmZpZ3VyYXRpb24gZGVmYXVsdHNcblFUSVAuZGVmYXVsdHMgPSB7XG5cdHByZXJlbmRlcjogRkFMU0UsXG5cdGlkOiBGQUxTRSxcblx0b3ZlcndyaXRlOiBUUlVFLFxuXHRzdXBwcmVzczogVFJVRSxcblx0Y29udGVudDoge1xuXHRcdHRleHQ6IFRSVUUsXG5cdFx0YXR0cjogJ3RpdGxlJyxcblx0XHR0aXRsZTogRkFMU0UsXG5cdFx0YnV0dG9uOiBGQUxTRVxuXHR9LFxuXHRwb3NpdGlvbjoge1xuXHRcdG15OiAndG9wIGxlZnQnLFxuXHRcdGF0OiAnYm90dG9tIHJpZ2h0Jyxcblx0XHR0YXJnZXQ6IEZBTFNFLFxuXHRcdGNvbnRhaW5lcjogRkFMU0UsXG5cdFx0dmlld3BvcnQ6IEZBTFNFLFxuXHRcdGFkanVzdDoge1xuXHRcdFx0eDogMCwgeTogMCxcblx0XHRcdG1vdXNlOiBUUlVFLFxuXHRcdFx0c2Nyb2xsOiBUUlVFLFxuXHRcdFx0cmVzaXplOiBUUlVFLFxuXHRcdFx0bWV0aG9kOiAnZmxpcGludmVydCBmbGlwaW52ZXJ0J1xuXHRcdH0sXG5cdFx0ZWZmZWN0OiBmdW5jdGlvbihhcGksIHBvcykge1xuXHRcdFx0JCh0aGlzKS5hbmltYXRlKHBvcywge1xuXHRcdFx0XHRkdXJhdGlvbjogMjAwLFxuXHRcdFx0XHRxdWV1ZTogRkFMU0Vcblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblx0c2hvdzoge1xuXHRcdHRhcmdldDogRkFMU0UsXG5cdFx0ZXZlbnQ6ICdtb3VzZWVudGVyJyxcblx0XHRlZmZlY3Q6IFRSVUUsXG5cdFx0ZGVsYXk6IDkwLFxuXHRcdHNvbG86IEZBTFNFLFxuXHRcdHJlYWR5OiBGQUxTRSxcblx0XHRhdXRvZm9jdXM6IEZBTFNFXG5cdH0sXG5cdGhpZGU6IHtcblx0XHR0YXJnZXQ6IEZBTFNFLFxuXHRcdGV2ZW50OiAnbW91c2VsZWF2ZScsXG5cdFx0ZWZmZWN0OiBUUlVFLFxuXHRcdGRlbGF5OiAwLFxuXHRcdGZpeGVkOiBGQUxTRSxcblx0XHRpbmFjdGl2ZTogRkFMU0UsXG5cdFx0bGVhdmU6ICd3aW5kb3cnLFxuXHRcdGRpc3RhbmNlOiBGQUxTRVxuXHR9LFxuXHRzdHlsZToge1xuXHRcdGNsYXNzZXM6ICcnLFxuXHRcdHdpZGdldDogRkFMU0UsXG5cdFx0d2lkdGg6IEZBTFNFLFxuXHRcdGhlaWdodDogRkFMU0UsXG5cdFx0ZGVmOiBUUlVFXG5cdH0sXG5cdGV2ZW50czoge1xuXHRcdHJlbmRlcjogTlVMTCxcblx0XHRtb3ZlOiBOVUxMLFxuXHRcdHNob3c6IE5VTEwsXG5cdFx0aGlkZTogTlVMTCxcblx0XHR0b2dnbGU6IE5VTEwsXG5cdFx0dmlzaWJsZTogTlVMTCxcblx0XHRoaWRkZW46IE5VTEwsXG5cdFx0Zm9jdXM6IE5VTEwsXG5cdFx0Ymx1cjogTlVMTFxuXHR9XG59O1xuO3ZhciBUSVAsXG5jcmVhdGVWTUwsXG5TQ0FMRSxcblBJWEVMX1JBVElPLFxuQkFDS0lOR19TVE9SRV9SQVRJTyxcblxuLy8gQ29tbW9uIENTUyBzdHJpbmdzXG5NQVJHSU4gPSAnbWFyZ2luJyxcbkJPUkRFUiA9ICdib3JkZXInLFxuQ09MT1IgPSAnY29sb3InLFxuQkdfQ09MT1IgPSAnYmFja2dyb3VuZC1jb2xvcicsXG5UUkFOU1BBUkVOVCA9ICd0cmFuc3BhcmVudCcsXG5JTVBPUlRBTlQgPSAnICFpbXBvcnRhbnQnLFxuXG4vLyBDaGVjayBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyA8Y2FudmFzLz4gZWxlbWVudHNcbkhBU0NBTlZBUyA9ICEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCxcblxuLy8gSW52YWxpZCBjb2xvdXIgdmFsdWVzIHVzZWQgaW4gcGFyc2VDb2xvdXJzKClcbklOVkFMSUQgPSAvcmdiYT9cXCgwLCAwLCAwKCwgMCk/XFwpfHRyYW5zcGFyZW50fCMxMjM0NTYvaTtcblxuLy8gQ2FtZWwtY2FzZSBtZXRob2QsIHRha2VuIGZyb20galF1ZXJ5IHNvdXJjZVxuLy8gaHR0cDovL2NvZGUuanF1ZXJ5LmNvbS9qcXVlcnktMS44LjAuanNcbmZ1bmN0aW9uIGNhbWVsKHMpIHsgcmV0dXJuIHMuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzLnNsaWNlKDEpOyB9XG5cbi8qXG4gKiBNb2RpZmllZCBmcm9tIE1vZGVybml6cidzIHRlc3RQcm9wc0FsbCgpXG4gKiBodHRwOi8vbW9kZXJuaXpyLmNvbS9kb3dubG9hZHMvbW9kZXJuaXpyLWxhdGVzdC5qc1xuICovXG52YXIgY3NzUHJvcHMgPSB7fSwgY3NzUHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdPJywgJ01veicsICdtcyddO1xuZnVuY3Rpb24gdmVuZG9yQ3NzKGVsZW0sIHByb3ApIHtcblx0dmFyIHVjUHJvcCA9IHByb3AuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnNsaWNlKDEpLFxuXHRcdHByb3BzID0gKHByb3AgKyAnICcgKyBjc3NQcmVmaXhlcy5qb2luKHVjUHJvcCArICcgJykgKyB1Y1Byb3ApLnNwbGl0KCcgJyksXG5cdFx0Y3VyLCB2YWwsIGkgPSAwO1xuXG5cdC8vIElmIHRoZSBwcm9wZXJ0eSBoYXMgYWxyZWFkeSBiZWVuIG1hcHBlZC4uLlxuXHRpZihjc3NQcm9wc1twcm9wXSkgeyByZXR1cm4gZWxlbS5jc3MoY3NzUHJvcHNbcHJvcF0pOyB9XG5cblx0d2hpbGUoY3VyID0gcHJvcHNbaSsrXSkge1xuXHRcdGlmKCh2YWwgPSBlbGVtLmNzcyhjdXIpKSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjc3NQcm9wc1twcm9wXSA9IGN1cjtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXHR9XG59XG5cbi8vIFBhcnNlIGEgZ2l2ZW4gZWxlbWVudHMgQ1NTIHByb3BlcnR5IGludG8gYW4gaW50XG5mdW5jdGlvbiBpbnRDc3MoZWxlbSwgcHJvcCkge1xuXHRyZXR1cm4gTWF0aC5jZWlsKHBhcnNlRmxvYXQodmVuZG9yQ3NzKGVsZW0sIHByb3ApKSk7XG59XG5cblxuLy8gVk1MIGNyZWF0aW9uIChmb3IgSUUgb25seSlcbmlmKCFIQVNDQU5WQVMpIHtcblx0Y3JlYXRlVk1MID0gZnVuY3Rpb24odGFnLCBwcm9wcywgc3R5bGUpIHtcblx0XHRyZXR1cm4gJzxxdGlwdm1sOicrdGFnKycgeG1sbnM9XCJ1cm46c2NoZW1hcy1taWNyb3NvZnQuY29tOnZtbFwiIGNsYXNzPVwicXRpcC12bWxcIiAnKyhwcm9wc3x8JycpK1xuXHRcdFx0JyBzdHlsZT1cImJlaGF2aW9yOiB1cmwoI2RlZmF1bHQjVk1MKTsgJysoc3R5bGV8fCcnKSsgJ1wiIC8+Jztcblx0fTtcbn1cblxuLy8gQ2FudmFzIG9ubHkgZGVmaW5pdGlvbnNcbmVsc2Uge1xuXHRQSVhFTF9SQVRJTyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG5cdEJBQ0tJTkdfU1RPUkVfUkFUSU8gPSAoZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNvbnRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0KCcyZCcpO1xuXHRcdHJldHVybiBjb250ZXh0LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY29udGV4dC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGNvbnRleHQubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuXHRcdFx0XHRjb250ZXh0Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjb250ZXh0Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDE7XG5cdH0pKCk7XG5cdFNDQUxFID0gUElYRUxfUkFUSU8gLyBCQUNLSU5HX1NUT1JFX1JBVElPO1xufVxuXG5cbmZ1bmN0aW9uIFRpcChxdGlwLCBvcHRpb25zKSB7XG5cdHRoaXMuX25zID0gJ3RpcCc7XG5cdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdHRoaXMub2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQ7XG5cdHRoaXMuc2l6ZSA9IFsgb3B0aW9ucy53aWR0aCwgb3B0aW9ucy5oZWlnaHQgXTtcblxuXHQvLyBJbml0aWFsaXplXG5cdHRoaXMucXRpcCA9IHF0aXA7XG5cdHRoaXMuaW5pdChxdGlwKTtcbn1cblxuJC5leHRlbmQoVGlwLnByb3RvdHlwZSwge1xuXHRpbml0OiBmdW5jdGlvbihxdGlwKSB7XG5cdFx0dmFyIGNvbnRleHQsIHRpcDtcblxuXHRcdC8vIENyZWF0ZSB0aXAgZWxlbWVudCBhbmQgcHJlcGVuZCB0byB0aGUgdG9vbHRpcFxuXHRcdHRpcCA9IHRoaXMuZWxlbWVudCA9IHF0aXAuZWxlbWVudHMudGlwID0gJCgnPGRpdiAvPicsIHsgJ2NsYXNzJzogTkFNRVNQQUNFKyctdGlwJyB9KS5wcmVwZW5kVG8ocXRpcC50b29sdGlwKTtcblxuXHRcdC8vIENyZWF0ZSB0aXAgZHJhd2luZyBlbGVtZW50KHMpXG5cdFx0aWYoSEFTQ0FOVkFTKSB7XG5cdFx0XHQvLyBzYXZlKCkgYXMgc29vbiBhcyB3ZSBjcmVhdGUgdGhlIGNhbnZhcyBlbGVtZW50IHNvIEZGMiBkb2Vzbid0IGJvcmsgb24gb3VyIGZpcnN0IHJlc3RvcmUoKSFcblx0XHRcdGNvbnRleHQgPSAkKCc8Y2FudmFzIC8+JykuYXBwZW5kVG8odGhpcy5lbGVtZW50KVswXS5nZXRDb250ZXh0KCcyZCcpO1xuXG5cdFx0XHQvLyBTZXR1cCBjb25zdGFudCBwYXJhbWV0ZXJzXG5cdFx0XHRjb250ZXh0LmxpbmVKb2luID0gJ21pdGVyJztcblx0XHRcdGNvbnRleHQubWl0ZXJMaW1pdCA9IDEwMDAwMDtcblx0XHRcdGNvbnRleHQuc2F2ZSgpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGNvbnRleHQgPSBjcmVhdGVWTUwoJ3NoYXBlJywgJ2Nvb3Jkb3JpZ2luPVwiMCwwXCInLCAncG9zaXRpb246YWJzb2x1dGU7Jyk7XG5cdFx0XHR0aGlzLmVsZW1lbnQuaHRtbChjb250ZXh0ICsgY29udGV4dCk7XG5cblx0XHRcdC8vIFByZXZlbnQgbW91c2luZyBkb3duIG9uIHRoZSB0aXAgc2luY2UgaXQgY2F1c2VzIHByb2JsZW1zIHdpdGggLmxpdmUoKSBoYW5kbGluZyBpbiBJRSBkdWUgdG8gVk1MXG5cdFx0XHRxdGlwLl9iaW5kKCAkKCcqJywgdGlwKS5hZGQodGlwKSwgWydjbGljaycsICdtb3VzZWRvd24nXSwgZnVuY3Rpb24oZXZlbnQpIHsgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7IH0sIHRoaXMuX25zKTtcblx0XHR9XG5cblx0XHQvLyBCaW5kIHVwZGF0ZSBldmVudHNcblx0XHRxdGlwLl9iaW5kKHF0aXAudG9vbHRpcCwgJ3Rvb2x0aXBtb3ZlJywgdGhpcy5yZXBvc2l0aW9uLCB0aGlzLl9ucywgdGhpcyk7XG5cblx0XHQvLyBDcmVhdGUgaXRcblx0XHR0aGlzLmNyZWF0ZSgpO1xuXHR9LFxuXG5cdF9zd2FwRGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5zaXplWzBdID0gdGhpcy5vcHRpb25zLmhlaWdodDtcblx0XHR0aGlzLnNpemVbMV0gPSB0aGlzLm9wdGlvbnMud2lkdGg7XG5cdH0sXG5cdF9yZXNldERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuc2l6ZVswXSA9IHRoaXMub3B0aW9ucy53aWR0aDtcblx0XHR0aGlzLnNpemVbMV0gPSB0aGlzLm9wdGlvbnMuaGVpZ2h0O1xuXHR9LFxuXG5cdF91c2VUaXRsZTogZnVuY3Rpb24oY29ybmVyKSB7XG5cdFx0dmFyIHRpdGxlYmFyID0gdGhpcy5xdGlwLmVsZW1lbnRzLnRpdGxlYmFyO1xuXHRcdHJldHVybiB0aXRsZWJhciAmJiAoXG5cdFx0XHRjb3JuZXIueSA9PT0gVE9QIHx8IGNvcm5lci55ID09PSBDRU5URVIgJiYgdGhpcy5lbGVtZW50LnBvc2l0aW9uKCkudG9wICsgdGhpcy5zaXplWzFdIC8gMiArIHRoaXMub3B0aW9ucy5vZmZzZXQgPCB0aXRsZWJhci5vdXRlckhlaWdodChUUlVFKVxuXHRcdCk7XG5cdH0sXG5cblx0X3BhcnNlQ29ybmVyOiBmdW5jdGlvbihjb3JuZXIpIHtcblx0XHR2YXIgbXkgPSB0aGlzLnF0aXAub3B0aW9ucy5wb3NpdGlvbi5teTtcblxuXHRcdC8vIERldGVjdCBjb3JuZXIgYW5kIG1pbWljIHByb3BlcnRpZXNcblx0XHRpZihjb3JuZXIgPT09IEZBTFNFIHx8IG15ID09PSBGQUxTRSkge1xuXHRcdFx0Y29ybmVyID0gRkFMU0U7XG5cdFx0fVxuXHRcdGVsc2UgaWYoY29ybmVyID09PSBUUlVFKSB7XG5cdFx0XHRjb3JuZXIgPSBuZXcgQ09STkVSKCBteS5zdHJpbmcoKSApO1xuXHRcdH1cblx0XHRlbHNlIGlmKCFjb3JuZXIuc3RyaW5nKSB7XG5cdFx0XHRjb3JuZXIgPSBuZXcgQ09STkVSKGNvcm5lcik7XG5cdFx0XHRjb3JuZXIuZml4ZWQgPSBUUlVFO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb3JuZXI7XG5cdH0sXG5cblx0X3BhcnNlV2lkdGg6IGZ1bmN0aW9uKGNvcm5lciwgc2lkZSwgdXNlKSB7XG5cdFx0dmFyIGVsZW1lbnRzID0gdGhpcy5xdGlwLmVsZW1lbnRzLFxuXHRcdFx0cHJvcCA9IEJPUkRFUiArIGNhbWVsKHNpZGUpICsgJ1dpZHRoJztcblxuXHRcdHJldHVybiAodXNlID8gaW50Q3NzKHVzZSwgcHJvcCkgOiBcblx0XHRcdGludENzcyhlbGVtZW50cy5jb250ZW50LCBwcm9wKSB8fFxuXHRcdFx0aW50Q3NzKHRoaXMuX3VzZVRpdGxlKGNvcm5lcikgJiYgZWxlbWVudHMudGl0bGViYXIgfHwgZWxlbWVudHMuY29udGVudCwgcHJvcCkgfHxcblx0XHRcdGludENzcyhlbGVtZW50cy50b29sdGlwLCBwcm9wKVxuXHRcdCkgfHwgMDtcblx0fSxcblxuXHRfcGFyc2VSYWRpdXM6IGZ1bmN0aW9uKGNvcm5lcikge1xuXHRcdHZhciBlbGVtZW50cyA9IHRoaXMucXRpcC5lbGVtZW50cyxcblx0XHRcdHByb3AgPSBCT1JERVIgKyBjYW1lbChjb3JuZXIueSkgKyBjYW1lbChjb3JuZXIueCkgKyAnUmFkaXVzJztcblxuXHRcdHJldHVybiBCUk9XU0VSLmllIDwgOSA/IDAgOlxuXHRcdFx0aW50Q3NzKHRoaXMuX3VzZVRpdGxlKGNvcm5lcikgJiYgZWxlbWVudHMudGl0bGViYXIgfHwgZWxlbWVudHMuY29udGVudCwgcHJvcCkgfHxcblx0XHRcdGludENzcyhlbGVtZW50cy50b29sdGlwLCBwcm9wKSB8fCAwO1xuXHR9LFxuXG5cdF9pbnZhbGlkQ29sb3VyOiBmdW5jdGlvbihlbGVtLCBwcm9wLCBjb21wYXJlKSB7XG5cdFx0dmFyIHZhbCA9IGVsZW0uY3NzKHByb3ApO1xuXHRcdHJldHVybiAhdmFsIHx8IGNvbXBhcmUgJiYgdmFsID09PSBlbGVtLmNzcyhjb21wYXJlKSB8fCBJTlZBTElELnRlc3QodmFsKSA/IEZBTFNFIDogdmFsO1xuXHR9LFxuXG5cdF9wYXJzZUNvbG91cnM6IGZ1bmN0aW9uKGNvcm5lcikge1xuXHRcdHZhciBlbGVtZW50cyA9IHRoaXMucXRpcC5lbGVtZW50cyxcblx0XHRcdHRpcCA9IHRoaXMuZWxlbWVudC5jc3MoJ2Nzc1RleHQnLCAnJyksXG5cdFx0XHRib3JkZXJTaWRlID0gQk9SREVSICsgY2FtZWwoY29ybmVyWyBjb3JuZXIucHJlY2VkYW5jZSBdKSArIGNhbWVsKENPTE9SKSxcblx0XHRcdGNvbG9yRWxlbSA9IHRoaXMuX3VzZVRpdGxlKGNvcm5lcikgJiYgZWxlbWVudHMudGl0bGViYXIgfHwgZWxlbWVudHMuY29udGVudCxcblx0XHRcdGNzcyA9IHRoaXMuX2ludmFsaWRDb2xvdXIsIGNvbG9yID0gW107XG5cblx0XHQvLyBBdHRlbXB0IHRvIGRldGVjdCB0aGUgYmFja2dyb3VuZCBjb2xvdXIgZnJvbSB2YXJpb3VzIGVsZW1lbnRzLCBsZWZ0LXRvLXJpZ2h0IHByZWNlZGFuY2Vcblx0XHRjb2xvclswXSA9IGNzcyh0aXAsIEJHX0NPTE9SKSB8fCBjc3MoY29sb3JFbGVtLCBCR19DT0xPUikgfHwgY3NzKGVsZW1lbnRzLmNvbnRlbnQsIEJHX0NPTE9SKSB8fFxuXHRcdFx0Y3NzKGVsZW1lbnRzLnRvb2x0aXAsIEJHX0NPTE9SKSB8fCB0aXAuY3NzKEJHX0NPTE9SKTtcblxuXHRcdC8vIEF0dGVtcHQgdG8gZGV0ZWN0IHRoZSBjb3JyZWN0IGJvcmRlciBzaWRlIGNvbG91ciBmcm9tIHZhcmlvdXMgZWxlbWVudHMsIGxlZnQtdG8tcmlnaHQgcHJlY2VkYW5jZVxuXHRcdGNvbG9yWzFdID0gY3NzKHRpcCwgYm9yZGVyU2lkZSwgQ09MT1IpIHx8IGNzcyhjb2xvckVsZW0sIGJvcmRlclNpZGUsIENPTE9SKSB8fFxuXHRcdFx0Y3NzKGVsZW1lbnRzLmNvbnRlbnQsIGJvcmRlclNpZGUsIENPTE9SKSB8fCBjc3MoZWxlbWVudHMudG9vbHRpcCwgYm9yZGVyU2lkZSwgQ09MT1IpIHx8IGVsZW1lbnRzLnRvb2x0aXAuY3NzKGJvcmRlclNpZGUpO1xuXG5cdFx0Ly8gUmVzZXQgYmFja2dyb3VuZCBhbmQgYm9yZGVyIGNvbG91cnNcblx0XHQkKCcqJywgdGlwKS5hZGQodGlwKS5jc3MoJ2Nzc1RleHQnLCBCR19DT0xPUisnOicrVFJBTlNQQVJFTlQrSU1QT1JUQU5UKyc7JytCT1JERVIrJzowJytJTVBPUlRBTlQrJzsnKTtcblxuXHRcdHJldHVybiBjb2xvcjtcblx0fSxcblxuXHRfY2FsY3VsYXRlU2l6ZTogZnVuY3Rpb24oY29ybmVyKSB7XG5cdFx0dmFyIHkgPSBjb3JuZXIucHJlY2VkYW5jZSA9PT0gWSxcblx0XHRcdHdpZHRoID0gdGhpcy5vcHRpb25zLndpZHRoLFxuXHRcdFx0aGVpZ2h0ID0gdGhpcy5vcHRpb25zLmhlaWdodCxcblx0XHRcdGlzQ2VudGVyID0gY29ybmVyLmFiYnJldigpID09PSAnYycsXG5cdFx0XHRiYXNlID0gKHkgPyB3aWR0aDogaGVpZ2h0KSAqIChpc0NlbnRlciA/IDAuNSA6IDEpLFxuXHRcdFx0cG93ID0gTWF0aC5wb3csXG5cdFx0XHRyb3VuZCA9IE1hdGgucm91bmQsXG5cdFx0XHRiaWdIeXAsIHJhdGlvLCByZXN1bHQsXG5cblx0XHRzbWFsbEh5cCA9IE1hdGguc3FydCggcG93KGJhc2UsIDIpICsgcG93KGhlaWdodCwgMikgKSxcblx0XHRoeXAgPSBbXG5cdFx0XHR0aGlzLmJvcmRlciAvIGJhc2UgKiBzbWFsbEh5cCxcblx0XHRcdHRoaXMuYm9yZGVyIC8gaGVpZ2h0ICogc21hbGxIeXBcblx0XHRdO1xuXG5cdFx0aHlwWzJdID0gTWF0aC5zcXJ0KCBwb3coaHlwWzBdLCAyKSAtIHBvdyh0aGlzLmJvcmRlciwgMikgKTtcblx0XHRoeXBbM10gPSBNYXRoLnNxcnQoIHBvdyhoeXBbMV0sIDIpIC0gcG93KHRoaXMuYm9yZGVyLCAyKSApO1xuXG5cdFx0YmlnSHlwID0gc21hbGxIeXAgKyBoeXBbMl0gKyBoeXBbM10gKyAoaXNDZW50ZXIgPyAwIDogaHlwWzBdKTtcblx0XHRyYXRpbyA9IGJpZ0h5cCAvIHNtYWxsSHlwO1xuXG5cdFx0cmVzdWx0ID0gWyByb3VuZChyYXRpbyAqIHdpZHRoKSwgcm91bmQocmF0aW8gKiBoZWlnaHQpIF07XG5cdFx0cmV0dXJuIHkgPyByZXN1bHQgOiByZXN1bHQucmV2ZXJzZSgpO1xuXHR9LFxuXG5cdC8vIFRpcCBjb29yZGluYXRlcyBjYWxjdWxhdG9yXG5cdF9jYWxjdWxhdGVUaXA6IGZ1bmN0aW9uKGNvcm5lciwgc2l6ZSwgc2NhbGUpIHtcblx0XHRzY2FsZSA9IHNjYWxlIHx8IDE7XG5cdFx0c2l6ZSA9IHNpemUgfHwgdGhpcy5zaXplO1xuXG5cdFx0dmFyIHdpZHRoID0gc2l6ZVswXSAqIHNjYWxlLFxuXHRcdFx0aGVpZ2h0ID0gc2l6ZVsxXSAqIHNjYWxlLFxuXHRcdFx0d2lkdGgyID0gTWF0aC5jZWlsKHdpZHRoIC8gMiksIGhlaWdodDIgPSBNYXRoLmNlaWwoaGVpZ2h0IC8gMiksXG5cblx0XHQvLyBEZWZpbmUgdGlwIGNvb3JkaW5hdGVzIGluIHRlcm1zIG9mIGhlaWdodCBhbmQgd2lkdGggdmFsdWVzXG5cdFx0dGlwcyA9IHtcblx0XHRcdGJyOlx0WzAsMCxcdFx0d2lkdGgsaGVpZ2h0LFx0d2lkdGgsMF0sXG5cdFx0XHRibDpcdFswLDAsXHRcdHdpZHRoLDAsXHRcdDAsaGVpZ2h0XSxcblx0XHRcdHRyOlx0WzAsaGVpZ2h0LFx0d2lkdGgsMCxcdFx0d2lkdGgsaGVpZ2h0XSxcblx0XHRcdHRsOlx0WzAsMCxcdFx0MCxoZWlnaHQsXHRcdHdpZHRoLGhlaWdodF0sXG5cdFx0XHR0YzpcdFswLGhlaWdodCxcdHdpZHRoMiwwLFx0XHR3aWR0aCxoZWlnaHRdLFxuXHRcdFx0YmM6XHRbMCwwLFx0XHR3aWR0aCwwLFx0XHR3aWR0aDIsaGVpZ2h0XSxcblx0XHRcdHJjOlx0WzAsMCxcdFx0d2lkdGgsaGVpZ2h0MixcdDAsaGVpZ2h0XSxcblx0XHRcdGxjOlx0W3dpZHRoLDAsXHR3aWR0aCxoZWlnaHQsXHQwLGhlaWdodDJdXG5cdFx0fTtcblxuXHRcdC8vIFNldCBjb21tb24gc2lkZSBzaGFwZXNcblx0XHR0aXBzLmx0ID0gdGlwcy5icjsgdGlwcy5ydCA9IHRpcHMuYmw7XG5cdFx0dGlwcy5sYiA9IHRpcHMudHI7IHRpcHMucmIgPSB0aXBzLnRsO1xuXG5cdFx0cmV0dXJuIHRpcHNbIGNvcm5lci5hYmJyZXYoKSBdO1xuXHR9LFxuXG5cdC8vIFRpcCBjb29yZGluYXRlcyBkcmF3ZXIgKGNhbnZhcylcblx0X2RyYXdDb29yZHM6IGZ1bmN0aW9uKGNvbnRleHQsIGNvb3Jkcykge1xuXHRcdGNvbnRleHQuYmVnaW5QYXRoKCk7XG5cdFx0Y29udGV4dC5tb3ZlVG8oY29vcmRzWzBdLCBjb29yZHNbMV0pO1xuXHRcdGNvbnRleHQubGluZVRvKGNvb3Jkc1syXSwgY29vcmRzWzNdKTtcblx0XHRjb250ZXh0LmxpbmVUbyhjb29yZHNbNF0sIGNvb3Jkc1s1XSk7XG5cdFx0Y29udGV4dC5jbG9zZVBhdGgoKTtcblx0fSxcblxuXHRjcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIERldGVybWluZSB0aXAgY29ybmVyXG5cdFx0dmFyIGMgPSB0aGlzLmNvcm5lciA9IChIQVNDQU5WQVMgfHwgQlJPV1NFUi5pZSkgJiYgdGhpcy5fcGFyc2VDb3JuZXIodGhpcy5vcHRpb25zLmNvcm5lcik7XG5cblx0XHQvLyBJZiB3ZSBoYXZlIGEgdGlwIGNvcm5lci4uLlxuXHRcdHRoaXMuZW5hYmxlZCA9ICEhdGhpcy5jb3JuZXIgJiYgdGhpcy5jb3JuZXIuYWJicmV2KCkgIT09ICdjJztcblx0XHRpZih0aGlzLmVuYWJsZWQpIHtcblx0XHRcdC8vIENhY2hlIGl0XG5cdFx0XHR0aGlzLnF0aXAuY2FjaGUuY29ybmVyID0gYy5jbG9uZSgpO1xuXG5cdFx0XHQvLyBDcmVhdGUgaXRcblx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0fVxuXG5cdFx0Ly8gVG9nZ2xlIHRpcCBlbGVtZW50XG5cdFx0dGhpcy5lbGVtZW50LnRvZ2dsZSh0aGlzLmVuYWJsZWQpO1xuXG5cdFx0cmV0dXJuIHRoaXMuY29ybmVyO1xuXHR9LFxuXG5cdHVwZGF0ZTogZnVuY3Rpb24oY29ybmVyLCBwb3NpdGlvbikge1xuXHRcdGlmKCF0aGlzLmVuYWJsZWQpIHsgcmV0dXJuIHRoaXM7IH1cblxuXHRcdHZhciBlbGVtZW50cyA9IHRoaXMucXRpcC5lbGVtZW50cyxcblx0XHRcdHRpcCA9IHRoaXMuZWxlbWVudCxcblx0XHRcdGlubmVyID0gdGlwLmNoaWxkcmVuKCksXG5cdFx0XHRvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0Y3VyU2l6ZSA9IHRoaXMuc2l6ZSxcblx0XHRcdG1pbWljID0gb3B0aW9ucy5taW1pYyxcblx0XHRcdHJvdW5kID0gTWF0aC5yb3VuZCxcblx0XHRcdGNvbG9yLCBwcmVjZWRhbmNlLCBjb250ZXh0LFxuXHRcdFx0Y29vcmRzLCBiaWdDb29yZHMsIHRyYW5zbGF0ZSwgbmV3U2l6ZSwgYm9yZGVyO1xuXG5cdFx0Ly8gUmUtZGV0ZXJtaW5lIHRpcCBpZiBub3QgYWxyZWFkeSBzZXRcblx0XHRpZighY29ybmVyKSB7IGNvcm5lciA9IHRoaXMucXRpcC5jYWNoZS5jb3JuZXIgfHwgdGhpcy5jb3JuZXI7IH1cblxuXHRcdC8vIFVzZSBjb3JuZXIgcHJvcGVydHkgaWYgd2UgZGV0ZWN0IGFuIGludmFsaWQgbWltaWMgdmFsdWVcblx0XHRpZihtaW1pYyA9PT0gRkFMU0UpIHsgbWltaWMgPSBjb3JuZXI7IH1cblxuXHRcdC8vIE90aGVyd2lzZSBpbmhlcml0IG1pbWljIHByb3BlcnRpZXMgZnJvbSB0aGUgY29ybmVyIG9iamVjdCBhcyBuZWNlc3Nhcnlcblx0XHRlbHNlIHtcblx0XHRcdG1pbWljID0gbmV3IENPUk5FUihtaW1pYyk7XG5cdFx0XHRtaW1pYy5wcmVjZWRhbmNlID0gY29ybmVyLnByZWNlZGFuY2U7XG5cblx0XHRcdGlmKG1pbWljLnggPT09ICdpbmhlcml0JykgeyBtaW1pYy54ID0gY29ybmVyLng7IH1cblx0XHRcdGVsc2UgaWYobWltaWMueSA9PT0gJ2luaGVyaXQnKSB7IG1pbWljLnkgPSBjb3JuZXIueTsgfVxuXHRcdFx0ZWxzZSBpZihtaW1pYy54ID09PSBtaW1pYy55KSB7XG5cdFx0XHRcdG1pbWljWyBjb3JuZXIucHJlY2VkYW5jZSBdID0gY29ybmVyWyBjb3JuZXIucHJlY2VkYW5jZSBdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRwcmVjZWRhbmNlID0gbWltaWMucHJlY2VkYW5jZTtcblxuXHRcdC8vIEVuc3VyZSB0aGUgdGlwIHdpZHRoLmhlaWdodCBhcmUgcmVsYXRpdmUgdG8gdGhlIHRpcCBwb3NpdGlvblxuXHRcdGlmKGNvcm5lci5wcmVjZWRhbmNlID09PSBYKSB7IHRoaXMuX3N3YXBEaW1lbnNpb25zKCk7IH1cblx0XHRlbHNlIHsgdGhpcy5fcmVzZXREaW1lbnNpb25zKCk7IH1cblxuXHRcdC8vIFVwZGF0ZSBvdXIgY29sb3Vyc1xuXHRcdGNvbG9yID0gdGhpcy5jb2xvciA9IHRoaXMuX3BhcnNlQ29sb3Vycyhjb3JuZXIpO1xuXG5cdFx0Ly8gRGV0ZWN0IGJvcmRlciB3aWR0aCwgdGFraW5nIGludG8gYWNjb3VudCBjb2xvdXJzXG5cdFx0aWYoY29sb3JbMV0gIT09IFRSQU5TUEFSRU5UKSB7XG5cdFx0XHQvLyBHcmFiIGJvcmRlciB3aWR0aFxuXHRcdFx0Ym9yZGVyID0gdGhpcy5ib3JkZXIgPSB0aGlzLl9wYXJzZVdpZHRoKGNvcm5lciwgY29ybmVyW2Nvcm5lci5wcmVjZWRhbmNlXSk7XG5cblx0XHRcdC8vIElmIGJvcmRlciB3aWR0aCBpc24ndCB6ZXJvLCB1c2UgYm9yZGVyIGNvbG9yIGFzIGZpbGwgaWYgaXQncyBub3QgaW52YWxpZCAoMS4wIHN0eWxlIHRpcHMpXG5cdFx0XHRpZihvcHRpb25zLmJvcmRlciAmJiBib3JkZXIgPCAxICYmICFJTlZBTElELnRlc3QoY29sb3JbMV0pKSB7IGNvbG9yWzBdID0gY29sb3JbMV07IH1cblxuXHRcdFx0Ly8gU2V0IGJvcmRlciB3aWR0aCAodXNlIGRldGVjdGVkIGJvcmRlciB3aWR0aCBpZiBvcHRpb25zLmJvcmRlciBpcyB0cnVlKVxuXHRcdFx0dGhpcy5ib3JkZXIgPSBib3JkZXIgPSBvcHRpb25zLmJvcmRlciAhPT0gVFJVRSA/IG9wdGlvbnMuYm9yZGVyIDogYm9yZGVyO1xuXHRcdH1cblxuXHRcdC8vIEJvcmRlciBjb2xvdXIgd2FzIGludmFsaWQsIHNldCBib3JkZXIgdG8gemVyb1xuXHRcdGVsc2UgeyB0aGlzLmJvcmRlciA9IGJvcmRlciA9IDA7IH1cblxuXHRcdC8vIERldGVybWluZSB0aXAgc2l6ZVxuXHRcdG5ld1NpemUgPSB0aGlzLnNpemUgPSB0aGlzLl9jYWxjdWxhdGVTaXplKGNvcm5lcik7XG5cdFx0dGlwLmNzcyh7XG5cdFx0XHR3aWR0aDogbmV3U2l6ZVswXSxcblx0XHRcdGhlaWdodDogbmV3U2l6ZVsxXSxcblx0XHRcdGxpbmVIZWlnaHQ6IG5ld1NpemVbMV0rJ3B4J1xuXHRcdH0pO1xuXG5cdFx0Ly8gQ2FsY3VsYXRlIHRpcCB0cmFuc2xhdGlvblxuXHRcdGlmKGNvcm5lci5wcmVjZWRhbmNlID09PSBZKSB7XG5cdFx0XHR0cmFuc2xhdGUgPSBbXG5cdFx0XHRcdHJvdW5kKG1pbWljLnggPT09IExFRlQgPyBib3JkZXIgOiBtaW1pYy54ID09PSBSSUdIVCA/IG5ld1NpemVbMF0gLSBjdXJTaXplWzBdIC0gYm9yZGVyIDogKG5ld1NpemVbMF0gLSBjdXJTaXplWzBdKSAvIDIpLFxuXHRcdFx0XHRyb3VuZChtaW1pYy55ID09PSBUT1AgPyBuZXdTaXplWzFdIC0gY3VyU2l6ZVsxXSA6IDApXG5cdFx0XHRdO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHRyYW5zbGF0ZSA9IFtcblx0XHRcdFx0cm91bmQobWltaWMueCA9PT0gTEVGVCA/IG5ld1NpemVbMF0gLSBjdXJTaXplWzBdIDogMCksXG5cdFx0XHRcdHJvdW5kKG1pbWljLnkgPT09IFRPUCA/IGJvcmRlciA6IG1pbWljLnkgPT09IEJPVFRPTSA/IG5ld1NpemVbMV0gLSBjdXJTaXplWzFdIC0gYm9yZGVyIDogKG5ld1NpemVbMV0gLSBjdXJTaXplWzFdKSAvIDIpXG5cdFx0XHRdO1xuXHRcdH1cblxuXHRcdC8vIENhbnZhcyBkcmF3aW5nIGltcGxlbWVudGF0aW9uXG5cdFx0aWYoSEFTQ0FOVkFTKSB7XG5cdFx0XHQvLyBHcmFiIGNhbnZhcyBjb250ZXh0IGFuZCBjbGVhci9zYXZlIGl0XG5cdFx0XHRjb250ZXh0ID0gaW5uZXJbMF0uZ2V0Q29udGV4dCgnMmQnKTtcblx0XHRcdGNvbnRleHQucmVzdG9yZSgpOyBjb250ZXh0LnNhdmUoKTtcblx0XHRcdGNvbnRleHQuY2xlYXJSZWN0KDAsMCw2MDAwLDYwMDApO1xuXG5cdFx0XHQvLyBDYWxjdWxhdGUgY29vcmRpbmF0ZXNcblx0XHRcdGNvb3JkcyA9IHRoaXMuX2NhbGN1bGF0ZVRpcChtaW1pYywgY3VyU2l6ZSwgU0NBTEUpO1xuXHRcdFx0YmlnQ29vcmRzID0gdGhpcy5fY2FsY3VsYXRlVGlwKG1pbWljLCB0aGlzLnNpemUsIFNDQUxFKTtcblxuXHRcdFx0Ly8gU2V0IHRoZSBjYW52YXMgc2l6ZSB1c2luZyBjYWxjdWxhdGVkIHNpemVcblx0XHRcdGlubmVyLmF0dHIoV0lEVEgsIG5ld1NpemVbMF0gKiBTQ0FMRSkuYXR0cihIRUlHSFQsIG5ld1NpemVbMV0gKiBTQ0FMRSk7XG5cdFx0XHRpbm5lci5jc3MoV0lEVEgsIG5ld1NpemVbMF0pLmNzcyhIRUlHSFQsIG5ld1NpemVbMV0pO1xuXG5cdFx0XHQvLyBEcmF3IHRoZSBvdXRlci1zdHJva2UgdGlwXG5cdFx0XHR0aGlzLl9kcmF3Q29vcmRzKGNvbnRleHQsIGJpZ0Nvb3Jkcyk7XG5cdFx0XHRjb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yWzFdO1xuXHRcdFx0Y29udGV4dC5maWxsKCk7XG5cblx0XHRcdC8vIERyYXcgdGhlIGFjdHVhbCB0aXBcblx0XHRcdGNvbnRleHQudHJhbnNsYXRlKHRyYW5zbGF0ZVswXSAqIFNDQUxFLCB0cmFuc2xhdGVbMV0gKiBTQ0FMRSk7XG5cdFx0XHR0aGlzLl9kcmF3Q29vcmRzKGNvbnRleHQsIGNvb3Jkcyk7XG5cdFx0XHRjb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yWzBdO1xuXHRcdFx0Y29udGV4dC5maWxsKCk7XG5cdFx0fVxuXG5cdFx0Ly8gVk1MIChJRSBQcm9wcmlldGFyeSBpbXBsZW1lbnRhdGlvbilcblx0XHRlbHNlIHtcblx0XHRcdC8vIENhbGN1bGF0ZSBjb29yZGluYXRlc1xuXHRcdFx0Y29vcmRzID0gdGhpcy5fY2FsY3VsYXRlVGlwKG1pbWljKTtcblxuXHRcdFx0Ly8gU2V0dXAgY29vcmRpbmF0ZXMgc3RyaW5nXG5cdFx0XHRjb29yZHMgPSAnbScgKyBjb29yZHNbMF0gKyAnLCcgKyBjb29yZHNbMV0gKyAnIGwnICsgY29vcmRzWzJdICtcblx0XHRcdFx0JywnICsgY29vcmRzWzNdICsgJyAnICsgY29vcmRzWzRdICsgJywnICsgY29vcmRzWzVdICsgJyB4ZSc7XG5cblx0XHRcdC8vIFNldHVwIFZNTC1zcGVjaWZpYyBvZmZzZXQgZm9yIHBpeGVsLXBlcmZlY3Rpb25cblx0XHRcdHRyYW5zbGF0ZVsyXSA9IGJvcmRlciAmJiAvXihyfGIpL2kudGVzdChjb3JuZXIuc3RyaW5nKCkpID9cblx0XHRcdFx0QlJPV1NFUi5pZSA9PT0gOCA/IDIgOiAxIDogMDtcblxuXHRcdFx0Ly8gU2V0IGluaXRpYWwgQ1NTXG5cdFx0XHRpbm5lci5jc3Moe1xuXHRcdFx0XHRjb29yZHNpemU6IG5ld1NpemVbMF0rYm9yZGVyICsgJyAnICsgbmV3U2l6ZVsxXStib3JkZXIsXG5cdFx0XHRcdGFudGlhbGlhczogJycrKG1pbWljLnN0cmluZygpLmluZGV4T2YoQ0VOVEVSKSA+IC0xKSxcblx0XHRcdFx0bGVmdDogdHJhbnNsYXRlWzBdIC0gdHJhbnNsYXRlWzJdICogTnVtYmVyKHByZWNlZGFuY2UgPT09IFgpLFxuXHRcdFx0XHR0b3A6IHRyYW5zbGF0ZVsxXSAtIHRyYW5zbGF0ZVsyXSAqIE51bWJlcihwcmVjZWRhbmNlID09PSBZKSxcblx0XHRcdFx0d2lkdGg6IG5ld1NpemVbMF0gKyBib3JkZXIsXG5cdFx0XHRcdGhlaWdodDogbmV3U2l6ZVsxXSArIGJvcmRlclxuXHRcdFx0fSlcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGkpIHtcblx0XHRcdFx0dmFyICR0aGlzID0gJCh0aGlzKTtcblxuXHRcdFx0XHQvLyBTZXQgc2hhcGUgc3BlY2lmaWMgYXR0cmlidXRlc1xuXHRcdFx0XHQkdGhpc1sgJHRoaXMucHJvcCA/ICdwcm9wJyA6ICdhdHRyJyBdKHtcblx0XHRcdFx0XHRjb29yZHNpemU6IG5ld1NpemVbMF0rYm9yZGVyICsgJyAnICsgbmV3U2l6ZVsxXStib3JkZXIsXG5cdFx0XHRcdFx0cGF0aDogY29vcmRzLFxuXHRcdFx0XHRcdGZpbGxjb2xvcjogY29sb3JbMF0sXG5cdFx0XHRcdFx0ZmlsbGVkOiAhIWksXG5cdFx0XHRcdFx0c3Ryb2tlZDogIWlcblx0XHRcdFx0fSlcblx0XHRcdFx0LnRvZ2dsZSghIShib3JkZXIgfHwgaSkpO1xuXG5cdFx0XHRcdC8vIENoZWNrIGlmIGJvcmRlciBpcyBlbmFibGVkIGFuZCBhZGQgc3Ryb2tlIGVsZW1lbnRcblx0XHRcdFx0IWkgJiYgJHRoaXMuaHRtbCggY3JlYXRlVk1MKFxuXHRcdFx0XHRcdCdzdHJva2UnLCAnd2VpZ2h0PVwiJytib3JkZXIqMisncHhcIiBjb2xvcj1cIicrY29sb3JbMV0rJ1wiIG1pdGVybGltaXQ9XCIxMDAwXCIgam9pbnN0eWxlPVwibWl0ZXJcIidcblx0XHRcdFx0KSApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Ly8gT3BlcmEgYnVnICMzNTcgLSBJbmNvcnJlY3QgdGlwIHBvc2l0aW9uXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL0NyYWdhODkvcVRpcDIvaXNzdWVzLzM2N1xuXHRcdHdpbmRvdy5vcGVyYSAmJiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0ZWxlbWVudHMudGlwLmNzcyh7XG5cdFx0XHRcdGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuXHRcdFx0XHR2aXNpYmlsaXR5OiAndmlzaWJsZSdcblx0XHRcdH0pO1xuXHRcdH0sIDEpO1xuXG5cdFx0Ly8gUG9zaXRpb24gaWYgbmVlZGVkXG5cdFx0aWYocG9zaXRpb24gIT09IEZBTFNFKSB7IHRoaXMuY2FsY3VsYXRlKGNvcm5lciwgbmV3U2l6ZSk7IH1cblx0fSxcblxuXHRjYWxjdWxhdGU6IGZ1bmN0aW9uKGNvcm5lciwgc2l6ZSkge1xuXHRcdGlmKCF0aGlzLmVuYWJsZWQpIHsgcmV0dXJuIEZBTFNFOyB9XG5cblx0XHR2YXIgc2VsZiA9IHRoaXMsXG5cdFx0XHRlbGVtZW50cyA9IHRoaXMucXRpcC5lbGVtZW50cyxcblx0XHRcdHRpcCA9IHRoaXMuZWxlbWVudCxcblx0XHRcdHVzZXJPZmZzZXQgPSB0aGlzLm9wdGlvbnMub2Zmc2V0LFxuXHRcdFx0cG9zaXRpb24gPSB7fSxcblx0XHRcdHByZWNlZGFuY2UsIGNvcm5lcnM7XG5cblx0XHQvLyBJbmhlcml0IGNvcm5lciBpZiBub3QgcHJvdmlkZWRcblx0XHRjb3JuZXIgPSBjb3JuZXIgfHwgdGhpcy5jb3JuZXI7XG5cdFx0cHJlY2VkYW5jZSA9IGNvcm5lci5wcmVjZWRhbmNlO1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIHdoaWNoIHRpcCBkaW1lbnNpb24gdG8gdXNlIGZvciBhZGp1c3RtZW50XG5cdFx0c2l6ZSA9IHNpemUgfHwgdGhpcy5fY2FsY3VsYXRlU2l6ZShjb3JuZXIpO1xuXG5cdFx0Ly8gU2V0dXAgY29ybmVycyBhbmQgb2Zmc2V0IGFycmF5XG5cdFx0Y29ybmVycyA9IFsgY29ybmVyLngsIGNvcm5lci55IF07XG5cdFx0aWYocHJlY2VkYW5jZSA9PT0gWCkgeyBjb3JuZXJzLnJldmVyc2UoKTsgfVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHRpcCBwb3NpdGlvblxuXHRcdCQuZWFjaChjb3JuZXJzLCBmdW5jdGlvbihpLCBzaWRlKSB7XG5cdFx0XHR2YXIgYiwgYmMsIGJyO1xuXG5cdFx0XHRpZihzaWRlID09PSBDRU5URVIpIHtcblx0XHRcdFx0YiA9IHByZWNlZGFuY2UgPT09IFkgPyBMRUZUIDogVE9QO1xuXHRcdFx0XHRwb3NpdGlvblsgYiBdID0gJzUwJSc7XG5cdFx0XHRcdHBvc2l0aW9uW01BUkdJTisnLScgKyBiXSA9IC1NYXRoLnJvdW5kKHNpemVbIHByZWNlZGFuY2UgPT09IFkgPyAwIDogMSBdIC8gMikgKyB1c2VyT2Zmc2V0O1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGIgPSBzZWxmLl9wYXJzZVdpZHRoKGNvcm5lciwgc2lkZSwgZWxlbWVudHMudG9vbHRpcCk7XG5cdFx0XHRcdGJjID0gc2VsZi5fcGFyc2VXaWR0aChjb3JuZXIsIHNpZGUsIGVsZW1lbnRzLmNvbnRlbnQpO1xuXHRcdFx0XHRiciA9IHNlbGYuX3BhcnNlUmFkaXVzKGNvcm5lcik7XG5cblx0XHRcdFx0cG9zaXRpb25bIHNpZGUgXSA9IE1hdGgubWF4KC1zZWxmLmJvcmRlciwgaSA/IGJjIDogdXNlck9mZnNldCArIChiciA+IGIgPyBiciA6IC1iKSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBBZGp1c3QgZm9yIHRpcCBzaXplXG5cdFx0cG9zaXRpb25bIGNvcm5lcltwcmVjZWRhbmNlXSBdIC09IHNpemVbIHByZWNlZGFuY2UgPT09IFggPyAwIDogMSBdO1xuXG5cdFx0Ly8gU2V0IGFuZCByZXR1cm4gbmV3IHBvc2l0aW9uXG5cdFx0dGlwLmNzcyh7IG1hcmdpbjogJycsIHRvcDogJycsIGJvdHRvbTogJycsIGxlZnQ6ICcnLCByaWdodDogJycgfSkuY3NzKHBvc2l0aW9uKTtcblx0XHRyZXR1cm4gcG9zaXRpb247XG5cdH0sXG5cblx0cmVwb3NpdGlvbjogZnVuY3Rpb24oZXZlbnQsIGFwaSwgcG9zKSB7XG5cdFx0aWYoIXRoaXMuZW5hYmxlZCkgeyByZXR1cm47IH1cblxuXHRcdHZhciBjYWNoZSA9IGFwaS5jYWNoZSxcblx0XHRcdG5ld0Nvcm5lciA9IHRoaXMuY29ybmVyLmNsb25lKCksXG5cdFx0XHRhZGp1c3QgPSBwb3MuYWRqdXN0ZWQsXG5cdFx0XHRtZXRob2QgPSBhcGkub3B0aW9ucy5wb3NpdGlvbi5hZGp1c3QubWV0aG9kLnNwbGl0KCcgJyksXG5cdFx0XHRob3Jpem9udGFsID0gbWV0aG9kWzBdLFxuXHRcdFx0dmVydGljYWwgPSBtZXRob2RbMV0gfHwgbWV0aG9kWzBdLFxuXHRcdFx0c2hpZnQgPSB7IGxlZnQ6IEZBTFNFLCB0b3A6IEZBTFNFLCB4OiAwLCB5OiAwIH0sXG5cdFx0XHRvZmZzZXQsIGNzcyA9IHt9LCBwcm9wcztcblxuXHRcdGZ1bmN0aW9uIHNoaWZ0ZmxpcChkaXJlY3Rpb24sIHByZWNlZGFuY2UsIHBvcHBvc2l0ZSwgc2lkZSwgb3Bwb3NpdGUpIHtcblx0XHRcdC8vIEhvcml6b250YWwgLSBTaGlmdCBvciBmbGlwIG1ldGhvZFxuXHRcdFx0aWYoZGlyZWN0aW9uID09PSBTSElGVCAmJiBuZXdDb3JuZXIucHJlY2VkYW5jZSA9PT0gcHJlY2VkYW5jZSAmJiBhZGp1c3Rbc2lkZV0gJiYgbmV3Q29ybmVyW3BvcHBvc2l0ZV0gIT09IENFTlRFUikge1xuXHRcdFx0XHRuZXdDb3JuZXIucHJlY2VkYW5jZSA9IG5ld0Nvcm5lci5wcmVjZWRhbmNlID09PSBYID8gWSA6IFg7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmKGRpcmVjdGlvbiAhPT0gU0hJRlQgJiYgYWRqdXN0W3NpZGVdKXtcblx0XHRcdFx0bmV3Q29ybmVyW3ByZWNlZGFuY2VdID0gbmV3Q29ybmVyW3ByZWNlZGFuY2VdID09PSBDRU5URVIgP1xuXHRcdFx0XHRcdGFkanVzdFtzaWRlXSA+IDAgPyBzaWRlIDogb3Bwb3NpdGUgOlxuXHRcdFx0XHRcdG5ld0Nvcm5lcltwcmVjZWRhbmNlXSA9PT0gc2lkZSA/IG9wcG9zaXRlIDogc2lkZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzaGlmdG9ubHkoeHksIHNpZGUsIG9wcG9zaXRlKSB7XG5cdFx0XHRpZihuZXdDb3JuZXJbeHldID09PSBDRU5URVIpIHtcblx0XHRcdFx0Y3NzW01BUkdJTisnLScrc2lkZV0gPSBzaGlmdFt4eV0gPSBvZmZzZXRbTUFSR0lOKyctJytzaWRlXSAtIGFkanVzdFtzaWRlXTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRwcm9wcyA9IG9mZnNldFtvcHBvc2l0ZV0gIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdFx0WyBhZGp1c3Rbc2lkZV0sIC1vZmZzZXRbc2lkZV0gXSA6IFsgLWFkanVzdFtzaWRlXSwgb2Zmc2V0W3NpZGVdIF07XG5cblx0XHRcdFx0aWYoIChzaGlmdFt4eV0gPSBNYXRoLm1heChwcm9wc1swXSwgcHJvcHNbMV0pKSA+IHByb3BzWzBdICkge1xuXHRcdFx0XHRcdHBvc1tzaWRlXSAtPSBhZGp1c3Rbc2lkZV07XG5cdFx0XHRcdFx0c2hpZnRbc2lkZV0gPSBGQUxTRTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNzc1sgb2Zmc2V0W29wcG9zaXRlXSAhPT0gdW5kZWZpbmVkID8gb3Bwb3NpdGUgOiBzaWRlIF0gPSBzaGlmdFt4eV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gSWYgb3VyIHRpcCBwb3NpdGlvbiBpc24ndCBmaXhlZCBlLmcuIGRvZXNuJ3QgYWRqdXN0IHdpdGggdmlld3BvcnQuLi5cblx0XHRpZih0aGlzLmNvcm5lci5maXhlZCAhPT0gVFJVRSkge1xuXHRcdFx0Ly8gUGVyZm9ybSBzaGlmdC9mbGlwIGFkanVzdG1lbnRzXG5cdFx0XHRzaGlmdGZsaXAoaG9yaXpvbnRhbCwgWCwgWSwgTEVGVCwgUklHSFQpO1xuXHRcdFx0c2hpZnRmbGlwKHZlcnRpY2FsLCBZLCBYLCBUT1AsIEJPVFRPTSk7XG5cblx0XHRcdC8vIFVwZGF0ZSBhbmQgcmVkcmF3IHRoZSB0aXAgaWYgbmVlZGVkIChjaGVjayBjYWNoZWQgZGV0YWlscyBvZiBsYXN0IGRyYXduIHRpcClcblx0XHRcdGlmKG5ld0Nvcm5lci5zdHJpbmcoKSAhPT0gY2FjaGUuY29ybmVyLnN0cmluZygpIHx8IGNhY2hlLmNvcm5lclRvcCAhPT0gYWRqdXN0LnRvcCB8fCBjYWNoZS5jb3JuZXJMZWZ0ICE9PSBhZGp1c3QubGVmdCkge1xuXHRcdFx0XHR0aGlzLnVwZGF0ZShuZXdDb3JuZXIsIEZBTFNFKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXR1cCB0aXAgb2Zmc2V0IHByb3BlcnRpZXNcblx0XHRvZmZzZXQgPSB0aGlzLmNhbGN1bGF0ZShuZXdDb3JuZXIpO1xuXG5cdFx0Ly8gUmVhZGp1c3Qgb2Zmc2V0IG9iamVjdCB0byBtYWtlIGl0IGxlZnQvdG9wXG5cdFx0aWYob2Zmc2V0LnJpZ2h0ICE9PSB1bmRlZmluZWQpIHsgb2Zmc2V0LmxlZnQgPSAtb2Zmc2V0LnJpZ2h0OyB9XG5cdFx0aWYob2Zmc2V0LmJvdHRvbSAhPT0gdW5kZWZpbmVkKSB7IG9mZnNldC50b3AgPSAtb2Zmc2V0LmJvdHRvbTsgfVxuXHRcdG9mZnNldC51c2VyID0gdGhpcy5vZmZzZXQ7XG5cblx0XHQvLyBQZXJmb3JtIHNoaWZ0IGFkanVzdG1lbnRzXG5cdFx0c2hpZnQubGVmdCA9IGhvcml6b250YWwgPT09IFNISUZUICYmICEhYWRqdXN0LmxlZnQ7XG5cdFx0aWYoc2hpZnQubGVmdCkge1xuXHRcdFx0c2hpZnRvbmx5KFgsIExFRlQsIFJJR0hUKTtcblx0XHR9XG5cdFx0c2hpZnQudG9wID0gdmVydGljYWwgPT09IFNISUZUICYmICEhYWRqdXN0LnRvcDtcblx0XHRpZihzaGlmdC50b3ApIHtcblx0XHRcdHNoaWZ0b25seShZLCBUT1AsIEJPVFRPTSk7XG5cdFx0fVxuXG5cdFx0Lypcblx0XHQqIElmIHRoZSB0aXAgaXMgYWRqdXN0ZWQgaW4gYm90aCBkaW1lbnNpb25zLCBvciBpbiBhXG5cdFx0KiBkaXJlY3Rpb24gdGhhdCB3b3VsZCBjYXVzZSBpdCB0byBiZSBhbnl3aGVyZSBidXQgdGhlXG5cdFx0KiBvdXRlciBib3JkZXIsIGhpZGUgaXQhXG5cdFx0Ki9cblx0XHR0aGlzLmVsZW1lbnQuY3NzKGNzcykudG9nZ2xlKFxuXHRcdFx0IShzaGlmdC54ICYmIHNoaWZ0LnkgfHwgbmV3Q29ybmVyLnggPT09IENFTlRFUiAmJiBzaGlmdC55IHx8IG5ld0Nvcm5lci55ID09PSBDRU5URVIgJiYgc2hpZnQueClcblx0XHQpO1xuXG5cdFx0Ly8gQWRqdXN0IHBvc2l0aW9uIHRvIGFjY29tb2RhdGUgdGlwIGRpbWVuc2lvbnNcblx0XHRwb3MubGVmdCAtPSBvZmZzZXQubGVmdC5jaGFyQXQgPyBvZmZzZXQudXNlciA6XG5cdFx0XHRob3Jpem9udGFsICE9PSBTSElGVCB8fCBzaGlmdC50b3AgfHwgIXNoaWZ0LmxlZnQgJiYgIXNoaWZ0LnRvcCA/IG9mZnNldC5sZWZ0ICsgdGhpcy5ib3JkZXIgOiAwO1xuXHRcdHBvcy50b3AgLT0gb2Zmc2V0LnRvcC5jaGFyQXQgPyBvZmZzZXQudXNlciA6XG5cdFx0XHR2ZXJ0aWNhbCAhPT0gU0hJRlQgfHwgc2hpZnQubGVmdCB8fCAhc2hpZnQubGVmdCAmJiAhc2hpZnQudG9wID8gb2Zmc2V0LnRvcCArIHRoaXMuYm9yZGVyIDogMDtcblxuXHRcdC8vIENhY2hlIGRldGFpbHNcblx0XHRjYWNoZS5jb3JuZXJMZWZ0ID0gYWRqdXN0LmxlZnQ7IGNhY2hlLmNvcm5lclRvcCA9IGFkanVzdC50b3A7XG5cdFx0Y2FjaGUuY29ybmVyID0gbmV3Q29ybmVyLmNsb25lKCk7XG5cdH0sXG5cblx0ZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gVW5iaW5kIGV2ZW50c1xuXHRcdHRoaXMucXRpcC5fdW5iaW5kKHRoaXMucXRpcC50b29sdGlwLCB0aGlzLl9ucyk7XG5cblx0XHQvLyBSZW1vdmUgdGhlIHRpcCBlbGVtZW50KHMpXG5cdFx0aWYodGhpcy5xdGlwLmVsZW1lbnRzLnRpcCkge1xuXHRcdFx0dGhpcy5xdGlwLmVsZW1lbnRzLnRpcC5maW5kKCcqJylcblx0XHRcdFx0LnJlbW92ZSgpLmVuZCgpLnJlbW92ZSgpO1xuXHRcdH1cblx0fVxufSk7XG5cblRJUCA9IFBMVUdJTlMudGlwID0gZnVuY3Rpb24oYXBpKSB7XG5cdHJldHVybiBuZXcgVGlwKGFwaSwgYXBpLm9wdGlvbnMuc3R5bGUudGlwKTtcbn07XG5cbi8vIEluaXRpYWxpemUgdGlwIG9uIHJlbmRlclxuVElQLmluaXRpYWxpemUgPSAncmVuZGVyJztcblxuLy8gU2V0dXAgcGx1Z2luIHNhbml0aXphdGlvbiBvcHRpb25zXG5USVAuc2FuaXRpemUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cdGlmKG9wdGlvbnMuc3R5bGUgJiYgJ3RpcCcgaW4gb3B0aW9ucy5zdHlsZSkge1xuXHRcdHZhciBvcHRzID0gb3B0aW9ucy5zdHlsZS50aXA7XG5cdFx0aWYodHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7IG9wdHMgPSBvcHRpb25zLnN0eWxlLnRpcCA9IHsgY29ybmVyOiBvcHRzIH07IH1cblx0XHRpZighKC9zdHJpbmd8Ym9vbGVhbi9pKS50ZXN0KHR5cGVvZiBvcHRzLmNvcm5lcikpIHsgb3B0cy5jb3JuZXIgPSBUUlVFOyB9XG5cdH1cbn07XG5cbi8vIEFkZCBuZXcgb3B0aW9uIGNoZWNrcyBmb3IgdGhlIHBsdWdpblxuQ0hFQ0tTLnRpcCA9IHtcblx0J15wb3NpdGlvbi5teXxzdHlsZS50aXAuKGNvcm5lcnxtaW1pY3xib3JkZXIpJCc6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIE1ha2Ugc3VyZSBhIHRpcCBjYW4gYmUgZHJhd25cblx0XHR0aGlzLmNyZWF0ZSgpO1xuXG5cdFx0Ly8gUmVwb3NpdGlvbiB0aGUgdG9vbHRpcFxuXHRcdHRoaXMucXRpcC5yZXBvc2l0aW9uKCk7XG5cdH0sXG5cdCdec3R5bGUudGlwLihoZWlnaHR8d2lkdGgpJCc6IGZ1bmN0aW9uKG9iaikge1xuXHRcdC8vIFJlLXNldCBkaW1lbnNpb25zIGFuZCByZWRyYXcgdGhlIHRpcFxuXHRcdHRoaXMuc2l6ZSA9IFsgb2JqLndpZHRoLCBvYmouaGVpZ2h0IF07XG5cdFx0dGhpcy51cGRhdGUoKTtcblxuXHRcdC8vIFJlcG9zaXRpb24gdGhlIHRvb2x0aXBcblx0XHR0aGlzLnF0aXAucmVwb3NpdGlvbigpO1xuXHR9LFxuXHQnXmNvbnRlbnQudGl0bGV8c3R5bGUuKGNsYXNzZXN8d2lkZ2V0KSQnOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnVwZGF0ZSgpO1xuXHR9XG59O1xuXG4vLyBFeHRlbmQgb3JpZ2luYWwgcVRpcCBkZWZhdWx0c1xuJC5leHRlbmQoVFJVRSwgUVRJUC5kZWZhdWx0cywge1xuXHRzdHlsZToge1xuXHRcdHRpcDoge1xuXHRcdFx0Y29ybmVyOiBUUlVFLFxuXHRcdFx0bWltaWM6IEZBTFNFLFxuXHRcdFx0d2lkdGg6IDYsXG5cdFx0XHRoZWlnaHQ6IDYsXG5cdFx0XHRib3JkZXI6IFRSVUUsXG5cdFx0XHRvZmZzZXQ6IDBcblx0XHR9XG5cdH1cbn0pO1xuO3ZhciBNT0RBTCwgT1ZFUkxBWSxcblx0TU9EQUxDTEFTUyA9ICdxdGlwLW1vZGFsJyxcblx0TU9EQUxTRUxFQ1RPUiA9ICcuJytNT0RBTENMQVNTO1xuXG5PVkVSTEFZID0gZnVuY3Rpb24oKVxue1xuXHR2YXIgc2VsZiA9IHRoaXMsXG5cdFx0Zm9jdXNhYmxlRWxlbXMgPSB7fSxcblx0XHRjdXJyZW50LFxuXHRcdHByZXZTdGF0ZSxcblx0XHRlbGVtO1xuXG5cdC8vIE1vZGlmaWVkIGNvZGUgZnJvbSBqUXVlcnkgVUkgMS4xMC4wIHNvdXJjZVxuXHQvLyBodHRwOi8vY29kZS5qcXVlcnkuY29tL3VpLzEuMTAuMC9qcXVlcnktdWkuanNcblx0ZnVuY3Rpb24gZm9jdXNhYmxlKGVsZW1lbnQpIHtcblx0XHQvLyBVc2UgdGhlIGRlZmluZWQgZm9jdXNhYmxlIGNoZWNrZXIgd2hlbiBwb3NzaWJsZVxuXHRcdGlmKCQuZXhwclsnOiddLmZvY3VzYWJsZSkgeyByZXR1cm4gJC5leHByWyc6J10uZm9jdXNhYmxlOyB9XG5cblx0XHR2YXIgaXNUYWJJbmRleE5vdE5hTiA9ICFpc05hTigkLmF0dHIoZWxlbWVudCwgJ3RhYmluZGV4JykpLFxuXHRcdFx0bm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lICYmIGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdG1hcCwgbWFwTmFtZSwgaW1nO1xuXG5cdFx0aWYoJ2FyZWEnID09PSBub2RlTmFtZSkge1xuXHRcdFx0bWFwID0gZWxlbWVudC5wYXJlbnROb2RlO1xuXHRcdFx0bWFwTmFtZSA9IG1hcC5uYW1lO1xuXHRcdFx0aWYoIWVsZW1lbnQuaHJlZiB8fCAhbWFwTmFtZSB8fCBtYXAubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ21hcCcpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aW1nID0gJCgnaW1nW3VzZW1hcD0jJyArIG1hcE5hbWUgKyAnXScpWzBdO1xuXHRcdFx0cmV0dXJuICEhaW1nICYmIGltZy5pcygnOnZpc2libGUnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gL2lucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b258b2JqZWN0Ly50ZXN0KCBub2RlTmFtZSApID9cblx0XHRcdCFlbGVtZW50LmRpc2FibGVkIDpcblx0XHRcdCdhJyA9PT0gbm9kZU5hbWUgP1xuXHRcdFx0XHRlbGVtZW50LmhyZWYgfHwgaXNUYWJJbmRleE5vdE5hTiA6XG5cdFx0XHRcdGlzVGFiSW5kZXhOb3ROYU5cblx0XHQ7XG5cdH1cblxuXHQvLyBGb2N1cyBpbnB1dHMgdXNpbmcgY2FjaGVkIGZvY3VzYWJsZSBlbGVtZW50cyAoc2VlIHVwZGF0ZSgpKVxuXHRmdW5jdGlvbiBmb2N1c0lucHV0cyhibHVyRWxlbXMpIHtcblx0XHQvLyBCbHVycmluZyBib2R5IGVsZW1lbnQgaW4gSUUgY2F1c2VzIHdpbmRvdy5vcGVuIHdpbmRvd3MgdG8gdW5mb2N1cyFcblx0XHRpZihmb2N1c2FibGVFbGVtcy5sZW5ndGggPCAxICYmIGJsdXJFbGVtcy5sZW5ndGgpIHsgYmx1ckVsZW1zLm5vdCgnYm9keScpLmJsdXIoKTsgfVxuXG5cdFx0Ly8gRm9jdXMgdGhlIGlucHV0c1xuXHRcdGVsc2UgeyBmb2N1c2FibGVFbGVtcy5maXJzdCgpLmZvY3VzKCk7IH1cblx0fVxuXG5cdC8vIFN0ZWFsIGZvY3VzIGZyb20gZWxlbWVudHMgb3V0c2lkZSB0b29sdGlwXG5cdGZ1bmN0aW9uIHN0ZWFsRm9jdXMoZXZlbnQpIHtcblx0XHRpZighZWxlbS5pcygnOnZpc2libGUnKSkgeyByZXR1cm47IH1cblxuXHRcdHZhciB0YXJnZXQgPSAkKGV2ZW50LnRhcmdldCksXG5cdFx0XHR0b29sdGlwID0gY3VycmVudC50b29sdGlwLFxuXHRcdFx0Y29udGFpbmVyID0gdGFyZ2V0LmNsb3Nlc3QoU0VMRUNUT1IpLFxuXHRcdFx0dGFyZ2V0T25Ub3A7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgaW5wdXQgY29udGFpbmVyIHRhcmdldCBpcyBhYm92ZSB0aGlzXG5cdFx0dGFyZ2V0T25Ub3AgPSBjb250YWluZXIubGVuZ3RoIDwgMSA/IEZBTFNFIDpcblx0XHRcdHBhcnNlSW50KGNvbnRhaW5lclswXS5zdHlsZS56SW5kZXgsIDEwKSA+IHBhcnNlSW50KHRvb2x0aXBbMF0uc3R5bGUuekluZGV4LCAxMCk7XG5cblx0XHQvLyBJZiB3ZSdyZSBzaG93aW5nIGEgbW9kYWwsIGJ1dCBmb2N1cyBoYXMgbGFuZGVkIG9uIGFuIGlucHV0IGJlbG93XG5cdFx0Ly8gdGhpcyBtb2RhbCwgZGl2ZXJ0IGZvY3VzIHRvIHRoZSBmaXJzdCB2aXNpYmxlIGlucHV0IGluIHRoaXMgbW9kYWxcblx0XHQvLyBvciBpZiB3ZSBjYW4ndCBmaW5kIG9uZS4uLiB0aGUgdG9vbHRpcCBpdHNlbGZcblx0XHRpZighdGFyZ2V0T25Ub3AgJiYgdGFyZ2V0LmNsb3Nlc3QoU0VMRUNUT1IpWzBdICE9PSB0b29sdGlwWzBdKSB7XG5cdFx0XHRmb2N1c0lucHV0cyh0YXJnZXQpO1xuXHRcdH1cblx0fVxuXG5cdCQuZXh0ZW5kKHNlbGYsIHtcblx0XHRpbml0OiBmdW5jdGlvbigpIHtcblx0XHRcdC8vIENyZWF0ZSBkb2N1bWVudCBvdmVybGF5XG5cdFx0XHRlbGVtID0gc2VsZi5lbGVtID0gJCgnPGRpdiAvPicsIHtcblx0XHRcdFx0aWQ6ICdxdGlwLW92ZXJsYXknLFxuXHRcdFx0XHRodG1sOiAnPGRpdj48L2Rpdj4nLFxuXHRcdFx0XHRtb3VzZWRvd246IGZ1bmN0aW9uKCkgeyByZXR1cm4gRkFMU0U7IH1cblx0XHRcdH0pXG5cdFx0XHQuaGlkZSgpO1xuXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2UgY2FuJ3QgZm9jdXMgYW55dGhpbmcgb3V0c2lkZSB0aGUgdG9vbHRpcFxuXHRcdFx0JChkb2N1bWVudC5ib2R5KS5iaW5kKCdmb2N1c2luJytNT0RBTFNFTEVDVE9SLCBzdGVhbEZvY3VzKTtcblxuXHRcdFx0Ly8gQXBwbHkga2V5Ym9hcmQgXCJFc2NhcGUga2V5XCIgY2xvc2UgaGFuZGxlclxuXHRcdFx0JChkb2N1bWVudCkuYmluZCgna2V5ZG93bicrTU9EQUxTRUxFQ1RPUiwgZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0aWYoY3VycmVudCAmJiBjdXJyZW50Lm9wdGlvbnMuc2hvdy5tb2RhbC5lc2NhcGUgJiYgZXZlbnQua2V5Q29kZSA9PT0gMjcpIHtcblx0XHRcdFx0XHRjdXJyZW50LmhpZGUoZXZlbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQXBwbHkgY2xpY2sgaGFuZGxlciBmb3IgYmx1ciBvcHRpb25cblx0XHRcdGVsZW0uYmluZCgnY2xpY2snK01PREFMU0VMRUNUT1IsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdGlmKGN1cnJlbnQgJiYgY3VycmVudC5vcHRpb25zLnNob3cubW9kYWwuYmx1cikge1xuXHRcdFx0XHRcdGN1cnJlbnQuaGlkZShldmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm4gc2VsZjtcblx0XHR9LFxuXG5cdFx0dXBkYXRlOiBmdW5jdGlvbihhcGkpIHtcblx0XHRcdC8vIFVwZGF0ZSBjdXJyZW50IEFQSSByZWZlcmVuY2Vcblx0XHRcdGN1cnJlbnQgPSBhcGk7XG5cblx0XHRcdC8vIFVwZGF0ZSBmb2N1c2FibGUgZWxlbWVudHMgaWYgZW5hYmxlZFxuXHRcdFx0aWYoYXBpLm9wdGlvbnMuc2hvdy5tb2RhbC5zdGVhbGZvY3VzICE9PSBGQUxTRSkge1xuXHRcdFx0XHRmb2N1c2FibGVFbGVtcyA9IGFwaS50b29sdGlwLmZpbmQoJyonKS5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZvY3VzYWJsZSh0aGlzKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHsgZm9jdXNhYmxlRWxlbXMgPSBbXTsgfVxuXHRcdH0sXG5cblx0XHR0b2dnbGU6IGZ1bmN0aW9uKGFwaSwgc3RhdGUsIGR1cmF0aW9uKSB7XG5cdFx0XHR2YXIgdG9vbHRpcCA9IGFwaS50b29sdGlwLFxuXHRcdFx0XHRvcHRpb25zID0gYXBpLm9wdGlvbnMuc2hvdy5tb2RhbCxcblx0XHRcdFx0ZWZmZWN0ID0gb3B0aW9ucy5lZmZlY3QsXG5cdFx0XHRcdHR5cGUgPSBzdGF0ZSA/ICdzaG93JzogJ2hpZGUnLFxuXHRcdFx0XHR2aXNpYmxlID0gZWxlbS5pcygnOnZpc2libGUnKSxcblx0XHRcdFx0dmlzaWJsZU1vZGFscyA9ICQoTU9EQUxTRUxFQ1RPUikuZmlsdGVyKCc6dmlzaWJsZTpub3QoOmFuaW1hdGVkKScpLm5vdCh0b29sdGlwKTtcblxuXHRcdFx0Ly8gU2V0IGFjdGl2ZSB0b29sdGlwIEFQSSByZWZlcmVuY2Vcblx0XHRcdHNlbGYudXBkYXRlKGFwaSk7XG5cblx0XHRcdC8vIElmIHRoZSBtb2RhbCBjYW4gc3RlYWwgdGhlIGZvY3VzLi4uXG5cdFx0XHQvLyBCbHVyIHRoZSBjdXJyZW50IGl0ZW0gYW5kIGZvY3VzIGFueXRoaW5nIGluIHRoZSBtb2RhbCB3ZSBhblxuXHRcdFx0aWYoc3RhdGUgJiYgb3B0aW9ucy5zdGVhbGZvY3VzICE9PSBGQUxTRSkge1xuXHRcdFx0XHRmb2N1c0lucHV0cyggJCgnOmZvY3VzJykgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVG9nZ2xlIGJhY2tkcm9wIGN1cnNvciBzdHlsZSBvbiBzaG93XG5cdFx0XHRlbGVtLnRvZ2dsZUNsYXNzKCdibHVycycsIG9wdGlvbnMuYmx1cik7XG5cblx0XHRcdC8vIEFwcGVuZCB0byBib2R5IG9uIHNob3dcblx0XHRcdGlmKHN0YXRlKSB7XG5cdFx0XHRcdGVsZW0uYXBwZW5kVG8oZG9jdW1lbnQuYm9keSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFByZXZlbnQgbW9kYWwgZnJvbSBjb25mbGljdGluZyB3aXRoIHNob3cuc29sbywgYW5kIGRvbid0IGhpZGUgYmFja2Ryb3AgaXMgb3RoZXIgbW9kYWxzIGFyZSB2aXNpYmxlXG5cdFx0XHRpZihlbGVtLmlzKCc6YW5pbWF0ZWQnKSAmJiB2aXNpYmxlID09PSBzdGF0ZSAmJiBwcmV2U3RhdGUgIT09IEZBTFNFIHx8ICFzdGF0ZSAmJiB2aXNpYmxlTW9kYWxzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gc2VsZjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RvcCBhbGwgYW5pbWF0aW9uc1xuXHRcdFx0ZWxlbS5zdG9wKFRSVUUsIEZBTFNFKTtcblxuXHRcdFx0Ly8gVXNlIGN1c3RvbSBmdW5jdGlvbiBpZiBwcm92aWRlZFxuXHRcdFx0aWYoJC5pc0Z1bmN0aW9uKGVmZmVjdCkpIHtcblx0XHRcdFx0ZWZmZWN0LmNhbGwoZWxlbSwgc3RhdGUpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBubyBlZmZlY3QgdHlwZSBpcyBzdXBwbGllZCwgdXNlIGEgc2ltcGxlIHRvZ2dsZVxuXHRcdFx0ZWxzZSBpZihlZmZlY3QgPT09IEZBTFNFKSB7XG5cdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBVc2UgYmFzaWMgZmFkZSBmdW5jdGlvblxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGVsZW0uZmFkZVRvKCBwYXJzZUludChkdXJhdGlvbiwgMTApIHx8IDkwLCBzdGF0ZSA/IDEgOiAwLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZighc3RhdGUpIHsgZWxlbS5oaWRlKCk7IH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlc2V0IHBvc2l0aW9uIGFuZCBkZXRhY2ggZnJvbSBib2R5IG9uIGhpZGVcblx0XHRcdGlmKCFzdGF0ZSkge1xuXHRcdFx0XHRlbGVtLnF1ZXVlKGZ1bmN0aW9uKG5leHQpIHtcblx0XHRcdFx0XHRlbGVtLmNzcyh7IGxlZnQ6ICcnLCB0b3A6ICcnIH0pO1xuXHRcdFx0XHRcdGlmKCEkKE1PREFMU0VMRUNUT1IpLmxlbmd0aCkgeyBlbGVtLmRldGFjaCgpOyB9XG5cdFx0XHRcdFx0bmV4dCgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FjaGUgdGhlIHN0YXRlXG5cdFx0XHRwcmV2U3RhdGUgPSBzdGF0ZTtcblxuXHRcdFx0Ly8gSWYgdGhlIHRvb2x0aXAgaXMgZGVzdHJveWVkLCBzZXQgcmVmZXJlbmNlIHRvIG51bGxcblx0XHRcdGlmKGN1cnJlbnQuZGVzdHJveWVkKSB7IGN1cnJlbnQgPSBOVUxMOyB9XG5cblx0XHRcdHJldHVybiBzZWxmO1xuXHRcdH1cblx0fSk7XG5cblx0c2VsZi5pbml0KCk7XG59O1xuT1ZFUkxBWSA9IG5ldyBPVkVSTEFZKCk7XG5cbmZ1bmN0aW9uIE1vZGFsKGFwaSwgb3B0aW9ucykge1xuXHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHR0aGlzLl9ucyA9ICctbW9kYWwnO1xuXG5cdHRoaXMucXRpcCA9IGFwaTtcblx0dGhpcy5pbml0KGFwaSk7XG59XG5cbiQuZXh0ZW5kKE1vZGFsLnByb3RvdHlwZSwge1xuXHRpbml0OiBmdW5jdGlvbihxdGlwKSB7XG5cdFx0dmFyIHRvb2x0aXAgPSBxdGlwLnRvb2x0aXA7XG5cblx0XHQvLyBJZiBtb2RhbCBpcyBkaXNhYmxlZC4uLiByZXR1cm5cblx0XHRpZighdGhpcy5vcHRpb25zLm9uKSB7IHJldHVybiB0aGlzOyB9XG5cblx0XHQvLyBTZXQgb3ZlcmxheSByZWZlcmVuY2Vcblx0XHRxdGlwLmVsZW1lbnRzLm92ZXJsYXkgPSBPVkVSTEFZLmVsZW07XG5cblx0XHQvLyBBZGQgdW5pcXVlIGF0dHJpYnV0ZSBzbyB3ZSBjYW4gZ3JhYiBtb2RhbCB0b29sdGlwcyBlYXNpbHkgdmlhIGEgU0VMRUNUT1IsIGFuZCBzZXQgei1pbmRleFxuXHRcdHRvb2x0aXAuYWRkQ2xhc3MoTU9EQUxDTEFTUykuY3NzKCd6LWluZGV4JywgUVRJUC5tb2RhbF96aW5kZXggKyAkKE1PREFMU0VMRUNUT1IpLmxlbmd0aCk7XG5cblx0XHQvLyBBcHBseSBvdXIgc2hvdy9oaWRlL2ZvY3VzIG1vZGFsIGV2ZW50c1xuXHRcdHF0aXAuX2JpbmQodG9vbHRpcCwgWyd0b29sdGlwc2hvdycsICd0b29sdGlwaGlkZSddLCBmdW5jdGlvbihldmVudCwgYXBpLCBkdXJhdGlvbikge1xuXHRcdFx0dmFyIG9FdmVudCA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQ7XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSBtb3VzZW91dCBkb2Vzbid0IHRyaWdnZXIgYSBoaWRlIHdoZW4gc2hvd2luZyB0aGUgbW9kYWwgYW5kIG1vdXNpbmcgb250byBiYWNrZHJvcFxuXHRcdFx0aWYoZXZlbnQudGFyZ2V0ID09PSB0b29sdGlwWzBdKSB7XG5cdFx0XHRcdGlmKG9FdmVudCAmJiBldmVudC50eXBlID09PSAndG9vbHRpcGhpZGUnICYmIC9tb3VzZShsZWF2ZXxlbnRlcikvLnRlc3Qob0V2ZW50LnR5cGUpICYmICQob0V2ZW50LnJlbGF0ZWRUYXJnZXQpLmNsb3Nlc3QoT1ZFUkxBWS5lbGVtWzBdKS5sZW5ndGgpIHtcblx0XHRcdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1lbXB0eSAqL1xuXHRcdFx0XHRcdHRyeSB7IGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IH1cblx0XHRcdFx0XHRjYXRjaChlKSB7fVxuXHRcdFx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tZW1wdHkgKi9cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmKCFvRXZlbnQgfHwgb0V2ZW50ICYmIG9FdmVudC50eXBlICE9PSAndG9vbHRpcHNvbG8nKSB7XG5cdFx0XHRcdFx0dGhpcy50b2dnbGUoZXZlbnQsIGV2ZW50LnR5cGUgPT09ICd0b29sdGlwc2hvdycsIGR1cmF0aW9uKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sIHRoaXMuX25zLCB0aGlzKTtcblxuXHRcdC8vIEFkanVzdCBtb2RhbCB6LWluZGV4IG9uIHRvb2x0aXAgZm9jdXNcblx0XHRxdGlwLl9iaW5kKHRvb2x0aXAsICd0b29sdGlwZm9jdXMnLCBmdW5jdGlvbihldmVudCwgYXBpKSB7XG5cdFx0XHQvLyBJZiBmb2N1cyB3YXMgY2FuY2VsbGVkIGJlZm9yZSBpdCByZWFjaGVkIHVzLCBkb24ndCBkbyBhbnl0aGluZ1xuXHRcdFx0aWYoZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgZXZlbnQudGFyZ2V0ICE9PSB0b29sdGlwWzBdKSB7IHJldHVybjsgfVxuXG5cdFx0XHR2YXIgcXRpcHMgPSAkKE1PREFMU0VMRUNUT1IpLFxuXG5cdFx0XHQvLyBLZWVwIHRoZSBtb2RhbCdzIGxvd2VyIHRoYW4gb3RoZXIsIHJlZ3VsYXIgcXRpcHNcblx0XHRcdG5ld0luZGV4ID0gUVRJUC5tb2RhbF96aW5kZXggKyBxdGlwcy5sZW5ndGgsXG5cdFx0XHRjdXJJbmRleCA9IHBhcnNlSW50KHRvb2x0aXBbMF0uc3R5bGUuekluZGV4LCAxMCk7XG5cblx0XHRcdC8vIFNldCBvdmVybGF5IHotaW5kZXhcblx0XHRcdE9WRVJMQVkuZWxlbVswXS5zdHlsZS56SW5kZXggPSBuZXdJbmRleCAtIDE7XG5cblx0XHRcdC8vIFJlZHVjZSBtb2RhbCB6LWluZGV4J3MgYW5kIGtlZXAgdGhlbSBwcm9wZXJseSBvcmRlcmVkXG5cdFx0XHRxdGlwcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZih0aGlzLnN0eWxlLnpJbmRleCA+IGN1ckluZGV4KSB7XG5cdFx0XHRcdFx0dGhpcy5zdHlsZS56SW5kZXggLT0gMTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEZpcmUgYmx1ciBldmVudCBmb3IgZm9jdXNlZCB0b29sdGlwXG5cdFx0XHRxdGlwcy5maWx0ZXIoJy4nICsgQ0xBU1NfRk9DVVMpLnF0aXAoJ2JsdXInLCBldmVudC5vcmlnaW5hbEV2ZW50KTtcblxuXHRcdFx0Ly8gU2V0IHRoZSBuZXcgei1pbmRleFxuXHRcdFx0dG9vbHRpcC5hZGRDbGFzcyhDTEFTU19GT0NVUylbMF0uc3R5bGUuekluZGV4ID0gbmV3SW5kZXg7XG5cblx0XHRcdC8vIFNldCBjdXJyZW50XG5cdFx0XHRPVkVSTEFZLnVwZGF0ZShhcGkpO1xuXG5cdFx0XHQvLyBQcmV2ZW50IGRlZmF1bHQgaGFuZGxpbmdcblx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWVtcHR5ICovXG5cdFx0XHR0cnkgeyBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyB9XG5cdFx0XHRjYXRjaChlKSB7fVxuXHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1lbXB0eSAqL1xuXHRcdH0sIHRoaXMuX25zLCB0aGlzKTtcblxuXHRcdC8vIEZvY3VzIGFueSBvdGhlciB2aXNpYmxlIG1vZGFscyB3aGVuIHRoaXMgb25lIGhpZGVzXG5cdFx0cXRpcC5fYmluZCh0b29sdGlwLCAndG9vbHRpcGhpZGUnLCBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0aWYoZXZlbnQudGFyZ2V0ID09PSB0b29sdGlwWzBdKSB7XG5cdFx0XHRcdCQoTU9EQUxTRUxFQ1RPUikuZmlsdGVyKCc6dmlzaWJsZScpLm5vdCh0b29sdGlwKS5sYXN0KCkucXRpcCgnZm9jdXMnLCBldmVudCk7XG5cdFx0XHR9XG5cdFx0fSwgdGhpcy5fbnMsIHRoaXMpO1xuXHR9LFxuXG5cdHRvZ2dsZTogZnVuY3Rpb24oZXZlbnQsIHN0YXRlLCBkdXJhdGlvbikge1xuXHRcdC8vIE1ha2Ugc3VyZSBkZWZhdWx0IGV2ZW50IGhhc24ndCBiZWVuIHByZXZlbnRlZFxuXHRcdGlmKGV2ZW50ICYmIGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7IHJldHVybiB0aGlzOyB9XG5cblx0XHQvLyBUb2dnbGUgaXRcblx0XHRPVkVSTEFZLnRvZ2dsZSh0aGlzLnF0aXAsICEhc3RhdGUsIGR1cmF0aW9uKTtcblx0fSxcblxuXHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHQvLyBSZW1vdmUgbW9kYWwgY2xhc3Ncblx0XHR0aGlzLnF0aXAudG9vbHRpcC5yZW1vdmVDbGFzcyhNT0RBTENMQVNTKTtcblxuXHRcdC8vIFJlbW92ZSBib3VuZCBldmVudHNcblx0XHR0aGlzLnF0aXAuX3VuYmluZCh0aGlzLnF0aXAudG9vbHRpcCwgdGhpcy5fbnMpO1xuXG5cdFx0Ly8gRGVsZXRlIGVsZW1lbnQgcmVmZXJlbmNlXG5cdFx0T1ZFUkxBWS50b2dnbGUodGhpcy5xdGlwLCBGQUxTRSk7XG5cdFx0ZGVsZXRlIHRoaXMucXRpcC5lbGVtZW50cy5vdmVybGF5O1xuXHR9XG59KTtcblxuXG5NT0RBTCA9IFBMVUdJTlMubW9kYWwgPSBmdW5jdGlvbihhcGkpIHtcblx0cmV0dXJuIG5ldyBNb2RhbChhcGksIGFwaS5vcHRpb25zLnNob3cubW9kYWwpO1xufTtcblxuLy8gU2V0dXAgc2FuaXRpenRpb24gcnVsZXNcbk1PREFMLnNhbml0aXplID0gZnVuY3Rpb24ob3B0cykge1xuXHRpZihvcHRzLnNob3cpIHtcblx0XHRpZih0eXBlb2Ygb3B0cy5zaG93Lm1vZGFsICE9PSAnb2JqZWN0JykgeyBvcHRzLnNob3cubW9kYWwgPSB7IG9uOiAhIW9wdHMuc2hvdy5tb2RhbCB9OyB9XG5cdFx0ZWxzZSBpZih0eXBlb2Ygb3B0cy5zaG93Lm1vZGFsLm9uID09PSAndW5kZWZpbmVkJykgeyBvcHRzLnNob3cubW9kYWwub24gPSBUUlVFOyB9XG5cdH1cbn07XG5cbi8vIEJhc2Ugei1pbmRleCBmb3IgYWxsIG1vZGFsIHRvb2x0aXBzICh1c2UgcVRpcCBjb3JlIHotaW5kZXggYXMgYSBiYXNlKVxuLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG5RVElQLm1vZGFsX3ppbmRleCA9IFFUSVAuemluZGV4IC0gMjAwO1xuLyogZXNsaW50LWVuYWJsZSBjYW1lbGNhc2UgKi9cblxuLy8gUGx1Z2luIG5lZWRzIHRvIGJlIGluaXRpYWxpemVkIG9uIHJlbmRlclxuTU9EQUwuaW5pdGlhbGl6ZSA9ICdyZW5kZXInO1xuXG4vLyBTZXR1cCBvcHRpb24gc2V0IGNoZWNrc1xuQ0hFQ0tTLm1vZGFsID0ge1xuXHQnXnNob3cubW9kYWwuKG9ufGJsdXIpJCc6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIEluaXRpYWxpc2Vcblx0XHR0aGlzLmRlc3Ryb3koKTtcblx0XHR0aGlzLmluaXQoKTtcblxuXHRcdC8vIFNob3cgdGhlIG1vZGFsIGlmIG5vdCB2aXNpYmxlIGFscmVhZHkgYW5kIHRvb2x0aXAgaXMgdmlzaWJsZVxuXHRcdHRoaXMucXRpcC5lbGVtcy5vdmVybGF5LnRvZ2dsZShcblx0XHRcdHRoaXMucXRpcC50b29sdGlwWzBdLm9mZnNldFdpZHRoID4gMFxuXHRcdCk7XG5cdH1cbn07XG5cbi8vIEV4dGVuZCBvcmlnaW5hbCBhcGkgZGVmYXVsdHNcbiQuZXh0ZW5kKFRSVUUsIFFUSVAuZGVmYXVsdHMsIHtcblx0c2hvdzoge1xuXHRcdG1vZGFsOiB7XG5cdFx0XHRvbjogRkFMU0UsXG5cdFx0XHRlZmZlY3Q6IFRSVUUsXG5cdFx0XHRibHVyOiBUUlVFLFxuXHRcdFx0c3RlYWxmb2N1czogVFJVRSxcblx0XHRcdGVzY2FwZTogVFJVRVxuXHRcdH1cblx0fVxufSk7XG47UExVR0lOUy52aWV3cG9ydCA9IGZ1bmN0aW9uKGFwaSwgcG9zaXRpb24sIHBvc09wdGlvbnMsIHRhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHQsIGVsZW1XaWR0aCwgZWxlbUhlaWdodClcbntcblx0dmFyIHRhcmdldCA9IHBvc09wdGlvbnMudGFyZ2V0LFxuXHRcdHRvb2x0aXAgPSBhcGkuZWxlbWVudHMudG9vbHRpcCxcblx0XHRteSA9IHBvc09wdGlvbnMubXksXG5cdFx0YXQgPSBwb3NPcHRpb25zLmF0LFxuXHRcdGFkanVzdCA9IHBvc09wdGlvbnMuYWRqdXN0LFxuXHRcdG1ldGhvZCA9IGFkanVzdC5tZXRob2Quc3BsaXQoJyAnKSxcblx0XHRtZXRob2RYID0gbWV0aG9kWzBdLFxuXHRcdG1ldGhvZFkgPSBtZXRob2RbMV0gfHwgbWV0aG9kWzBdLFxuXHRcdHZpZXdwb3J0ID0gcG9zT3B0aW9ucy52aWV3cG9ydCxcblx0XHRjb250YWluZXIgPSBwb3NPcHRpb25zLmNvbnRhaW5lcixcblx0XHRhZGp1c3RlZCA9IHsgbGVmdDogMCwgdG9wOiAwIH0sXG5cdFx0Zml4ZWQsIG5ld015LCBjb250YWluZXJPZmZzZXQsIGNvbnRhaW5lclN0YXRpYyxcblx0XHR2aWV3cG9ydFdpZHRoLCB2aWV3cG9ydEhlaWdodCwgdmlld3BvcnRTY3JvbGwsIHZpZXdwb3J0T2Zmc2V0O1xuXG5cdC8vIElmIHZpZXdwb3J0IGlzIG5vdCBhIGpRdWVyeSBlbGVtZW50LCBvciBpdCdzIHRoZSB3aW5kb3cvZG9jdW1lbnQsIG9yIG5vIGFkanVzdG1lbnQgbWV0aG9kIGlzIHVzZWQuLi4gcmV0dXJuXG5cdGlmKCF2aWV3cG9ydC5qcXVlcnkgfHwgdGFyZ2V0WzBdID09PSB3aW5kb3cgfHwgdGFyZ2V0WzBdID09PSBkb2N1bWVudC5ib2R5IHx8IGFkanVzdC5tZXRob2QgPT09ICdub25lJykge1xuXHRcdHJldHVybiBhZGp1c3RlZDtcblx0fVxuXG5cdC8vIENhY2ggY29udGFpbmVyIGRldGFpbHNcblx0Y29udGFpbmVyT2Zmc2V0ID0gY29udGFpbmVyLm9mZnNldCgpIHx8IGFkanVzdGVkO1xuXHRjb250YWluZXJTdGF0aWMgPSBjb250YWluZXIuY3NzKCdwb3NpdGlvbicpID09PSAnc3RhdGljJztcblxuXHQvLyBDYWNoZSBvdXIgdmlld3BvcnQgZGV0YWlsc1xuXHRmaXhlZCA9IHRvb2x0aXAuY3NzKCdwb3NpdGlvbicpID09PSAnZml4ZWQnO1xuXHR2aWV3cG9ydFdpZHRoID0gdmlld3BvcnRbMF0gPT09IHdpbmRvdyA/IHZpZXdwb3J0LndpZHRoKCkgOiB2aWV3cG9ydC5vdXRlcldpZHRoKEZBTFNFKTtcblx0dmlld3BvcnRIZWlnaHQgPSB2aWV3cG9ydFswXSA9PT0gd2luZG93ID8gdmlld3BvcnQuaGVpZ2h0KCkgOiB2aWV3cG9ydC5vdXRlckhlaWdodChGQUxTRSk7XG5cdHZpZXdwb3J0U2Nyb2xsID0geyBsZWZ0OiBmaXhlZCA/IDAgOiB2aWV3cG9ydC5zY3JvbGxMZWZ0KCksIHRvcDogZml4ZWQgPyAwIDogdmlld3BvcnQuc2Nyb2xsVG9wKCkgfTtcblx0dmlld3BvcnRPZmZzZXQgPSB2aWV3cG9ydC5vZmZzZXQoKSB8fCBhZGp1c3RlZDtcblxuXHQvLyBHZW5lcmljIGNhbGN1bGF0aW9uIG1ldGhvZFxuXHRmdW5jdGlvbiBjYWxjdWxhdGUoc2lkZSwgb3RoZXJTaWRlLCB0eXBlLCBhZGp1c3RtZW50LCBzaWRlMSwgc2lkZTIsIGxlbmd0aE5hbWUsIHRhcmdldExlbmd0aCwgZWxlbUxlbmd0aCkge1xuXHRcdHZhciBpbml0aWFsUG9zID0gcG9zaXRpb25bc2lkZTFdLFxuXHRcdFx0bXlTaWRlID0gbXlbc2lkZV0sXG5cdFx0XHRhdFNpZGUgPSBhdFtzaWRlXSxcblx0XHRcdGlzU2hpZnQgPSB0eXBlID09PSBTSElGVCxcblx0XHRcdG15TGVuZ3RoID0gbXlTaWRlID09PSBzaWRlMSA/IGVsZW1MZW5ndGggOiBteVNpZGUgPT09IHNpZGUyID8gLWVsZW1MZW5ndGggOiAtZWxlbUxlbmd0aCAvIDIsXG5cdFx0XHRhdExlbmd0aCA9IGF0U2lkZSA9PT0gc2lkZTEgPyB0YXJnZXRMZW5ndGggOiBhdFNpZGUgPT09IHNpZGUyID8gLXRhcmdldExlbmd0aCA6IC10YXJnZXRMZW5ndGggLyAyLFxuXHRcdFx0c2lkZU9mZnNldCA9IHZpZXdwb3J0U2Nyb2xsW3NpZGUxXSArIHZpZXdwb3J0T2Zmc2V0W3NpZGUxXSAtIChjb250YWluZXJTdGF0aWMgPyAwIDogY29udGFpbmVyT2Zmc2V0W3NpZGUxXSksXG5cdFx0XHRvdmVyZmxvdzEgPSBzaWRlT2Zmc2V0IC0gaW5pdGlhbFBvcyxcblx0XHRcdG92ZXJmbG93MiA9IGluaXRpYWxQb3MgKyBlbGVtTGVuZ3RoIC0gKGxlbmd0aE5hbWUgPT09IFdJRFRIID8gdmlld3BvcnRXaWR0aCA6IHZpZXdwb3J0SGVpZ2h0KSAtIHNpZGVPZmZzZXQsXG5cdFx0XHRvZmZzZXQgPSBteUxlbmd0aCAtIChteS5wcmVjZWRhbmNlID09PSBzaWRlIHx8IG15U2lkZSA9PT0gbXlbb3RoZXJTaWRlXSA/IGF0TGVuZ3RoIDogMCkgLSAoYXRTaWRlID09PSBDRU5URVIgPyB0YXJnZXRMZW5ndGggLyAyIDogMCk7XG5cblx0XHQvLyBzaGlmdFxuXHRcdGlmKGlzU2hpZnQpIHtcblx0XHRcdG9mZnNldCA9IChteVNpZGUgPT09IHNpZGUxID8gMSA6IC0xKSAqIG15TGVuZ3RoO1xuXG5cdFx0XHQvLyBBZGp1c3QgcG9zaXRpb24gYnV0IGtlZXAgaXQgd2l0aGluIHZpZXdwb3J0IGRpbWVuc2lvbnNcblx0XHRcdHBvc2l0aW9uW3NpZGUxXSArPSBvdmVyZmxvdzEgPiAwID8gb3ZlcmZsb3cxIDogb3ZlcmZsb3cyID4gMCA/IC1vdmVyZmxvdzIgOiAwO1xuXHRcdFx0cG9zaXRpb25bc2lkZTFdID0gTWF0aC5tYXgoXG5cdFx0XHRcdC1jb250YWluZXJPZmZzZXRbc2lkZTFdICsgdmlld3BvcnRPZmZzZXRbc2lkZTFdLFxuXHRcdFx0XHRpbml0aWFsUG9zIC0gb2Zmc2V0LFxuXHRcdFx0XHRNYXRoLm1pbihcblx0XHRcdFx0XHRNYXRoLm1heChcblx0XHRcdFx0XHRcdC1jb250YWluZXJPZmZzZXRbc2lkZTFdICsgdmlld3BvcnRPZmZzZXRbc2lkZTFdICsgKGxlbmd0aE5hbWUgPT09IFdJRFRIID8gdmlld3BvcnRXaWR0aCA6IHZpZXdwb3J0SGVpZ2h0KSxcblx0XHRcdFx0XHRcdGluaXRpYWxQb3MgKyBvZmZzZXRcblx0XHRcdFx0XHQpLFxuXHRcdFx0XHRcdHBvc2l0aW9uW3NpZGUxXSxcblxuXHRcdFx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCBhZGp1c3QgY29tcGxldGUgb2ZmIHRoZSBlbGVtZW50IHdoZW4gdXNpbmcgJ2NlbnRlcidcblx0XHRcdFx0XHRteVNpZGUgPT09ICdjZW50ZXInID8gaW5pdGlhbFBvcyAtIG15TGVuZ3RoIDogMUU5XG5cdFx0XHRcdClcblx0XHRcdCk7XG5cblx0XHR9XG5cblx0XHQvLyBmbGlwL2ZsaXBpbnZlcnRcblx0XHRlbHNlIHtcblx0XHRcdC8vIFVwZGF0ZSBhZGp1c3RtZW50IGFtb3VudCBkZXBlbmRpbmcgb24gaWYgdXNpbmcgZmxpcGludmVydCBvciBmbGlwXG5cdFx0XHRhZGp1c3RtZW50ICo9IHR5cGUgPT09IEZMSVBJTlZFUlQgPyAyIDogMDtcblxuXHRcdFx0Ly8gQ2hlY2sgZm9yIG92ZXJmbG93IG9uIHRoZSBsZWZ0L3RvcFxuXHRcdFx0aWYob3ZlcmZsb3cxID4gMCAmJiAobXlTaWRlICE9PSBzaWRlMSB8fCBvdmVyZmxvdzIgPiAwKSkge1xuXHRcdFx0XHRwb3NpdGlvbltzaWRlMV0gLT0gb2Zmc2V0ICsgYWRqdXN0bWVudDtcblx0XHRcdFx0bmV3TXkuaW52ZXJ0KHNpZGUsIHNpZGUxKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2hlY2sgZm9yIG92ZXJmbG93IG9uIHRoZSBib3R0b20vcmlnaHRcblx0XHRcdGVsc2UgaWYob3ZlcmZsb3cyID4gMCAmJiAobXlTaWRlICE9PSBzaWRlMiB8fCBvdmVyZmxvdzEgPiAwKSAgKSB7XG5cdFx0XHRcdHBvc2l0aW9uW3NpZGUxXSAtPSAobXlTaWRlID09PSBDRU5URVIgPyAtb2Zmc2V0IDogb2Zmc2V0KSArIGFkanVzdG1lbnQ7XG5cdFx0XHRcdG5ld015LmludmVydChzaWRlLCBzaWRlMik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBoYXZlbid0IG1hZGUgdGhpbmdzIHdvcnNlIHdpdGggdGhlIGFkanVzdG1lbnQgYW5kIHJlc2V0IGlmIHNvXG5cdFx0XHRpZihwb3NpdGlvbltzaWRlMV0gPCB2aWV3cG9ydFNjcm9sbFtzaWRlMV0gJiYgLXBvc2l0aW9uW3NpZGUxXSA+IG92ZXJmbG93Mikge1xuXHRcdFx0XHRwb3NpdGlvbltzaWRlMV0gPSBpbml0aWFsUG9zOyBuZXdNeSA9IG15LmNsb25lKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBvc2l0aW9uW3NpZGUxXSAtIGluaXRpYWxQb3M7XG5cdH1cblxuXHQvLyBTZXQgbmV3TXkgaWYgdXNpbmcgZmxpcCBvciBmbGlwaW52ZXJ0IG1ldGhvZHNcblx0aWYobWV0aG9kWCAhPT0gJ3NoaWZ0JyB8fCBtZXRob2RZICE9PSAnc2hpZnQnKSB7IG5ld015ID0gbXkuY2xvbmUoKTsgfVxuXG5cdC8vIEFkanVzdCBwb3NpdGlvbiBiYXNlZCBvbnZpZXdwb3J0IGFuZCBhZGp1c3RtZW50IG9wdGlvbnNcblx0YWRqdXN0ZWQgPSB7XG5cdFx0bGVmdDogbWV0aG9kWCAhPT0gJ25vbmUnID8gY2FsY3VsYXRlKCBYLCBZLCBtZXRob2RYLCBhZGp1c3QueCwgTEVGVCwgUklHSFQsIFdJRFRILCB0YXJnZXRXaWR0aCwgZWxlbVdpZHRoICkgOiAwLFxuXHRcdHRvcDogbWV0aG9kWSAhPT0gJ25vbmUnID8gY2FsY3VsYXRlKCBZLCBYLCBtZXRob2RZLCBhZGp1c3QueSwgVE9QLCBCT1RUT00sIEhFSUdIVCwgdGFyZ2V0SGVpZ2h0LCBlbGVtSGVpZ2h0ICkgOiAwLFxuXHRcdG15OiBuZXdNeVxuXHR9O1xuXG5cdHJldHVybiBhZGp1c3RlZDtcbn07XG47UExVR0lOUy5wb2x5cyA9IHtcblx0Ly8gUE9MWSBhcmVhIGNvb3JkaW5hdGUgY2FsY3VsYXRvclxuXHQvL1x0U3BlY2lhbCB0aGFua3MgdG8gRWQgQ3JhZG9jayBmb3IgaGVscGluZyBvdXQgd2l0aCB0aGlzLlxuXHQvL1x0VXNlcyBhIGJpbmFyeSBzZWFyY2ggYWxnb3JpdGhtIHRvIGZpbmQgc3VpdGFibGUgY29vcmRpbmF0ZXMuXG5cdHBvbHlnb246IGZ1bmN0aW9uKGJhc2VDb29yZHMsIGNvcm5lcikge1xuXHRcdHZhciByZXN1bHQgPSB7XG5cdFx0XHR3aWR0aDogMCwgaGVpZ2h0OiAwLFxuXHRcdFx0cG9zaXRpb246IHtcblx0XHRcdFx0dG9wOiAxZTEwLCByaWdodDogMCxcblx0XHRcdFx0Ym90dG9tOiAwLCBsZWZ0OiAxZTEwXG5cdFx0XHR9LFxuXHRcdFx0YWRqdXN0YWJsZTogRkFMU0Vcblx0XHR9LFxuXHRcdGkgPSAwLCBuZXh0LFxuXHRcdGNvb3JkcyA9IFtdLFxuXHRcdGNvbXBhcmVYID0gMSwgY29tcGFyZVkgPSAxLFxuXHRcdHJlYWxYID0gMCwgcmVhbFkgPSAwLFxuXHRcdG5ld1dpZHRoLCBuZXdIZWlnaHQ7XG5cblx0XHQvLyBGaXJzdCBwYXNzLCBzYW5pdGl6ZSBjb29yZHMgYW5kIGRldGVybWluZSBvdXRlciBlZGdlc1xuXHRcdGkgPSBiYXNlQ29vcmRzLmxlbmd0aDsgXG5cdFx0d2hpbGUoaS0tKSB7XG5cdFx0XHRuZXh0ID0gWyBwYXJzZUludChiYXNlQ29vcmRzWy0taV0sIDEwKSwgcGFyc2VJbnQoYmFzZUNvb3Jkc1tpKzFdLCAxMCkgXTtcblxuXHRcdFx0aWYobmV4dFswXSA+IHJlc3VsdC5wb3NpdGlvbi5yaWdodCl7IHJlc3VsdC5wb3NpdGlvbi5yaWdodCA9IG5leHRbMF07IH1cblx0XHRcdGlmKG5leHRbMF0gPCByZXN1bHQucG9zaXRpb24ubGVmdCl7IHJlc3VsdC5wb3NpdGlvbi5sZWZ0ID0gbmV4dFswXTsgfVxuXHRcdFx0aWYobmV4dFsxXSA+IHJlc3VsdC5wb3NpdGlvbi5ib3R0b20peyByZXN1bHQucG9zaXRpb24uYm90dG9tID0gbmV4dFsxXTsgfVxuXHRcdFx0aWYobmV4dFsxXSA8IHJlc3VsdC5wb3NpdGlvbi50b3ApeyByZXN1bHQucG9zaXRpb24udG9wID0gbmV4dFsxXTsgfVxuXG5cdFx0XHRjb29yZHMucHVzaChuZXh0KTtcblx0XHR9XG5cblx0XHQvLyBDYWxjdWxhdGUgaGVpZ2h0IGFuZCB3aWR0aCBmcm9tIG91dGVyIGVkZ2VzXG5cdFx0bmV3V2lkdGggPSByZXN1bHQud2lkdGggPSBNYXRoLmFicyhyZXN1bHQucG9zaXRpb24ucmlnaHQgLSByZXN1bHQucG9zaXRpb24ubGVmdCk7XG5cdFx0bmV3SGVpZ2h0ID0gcmVzdWx0LmhlaWdodCA9IE1hdGguYWJzKHJlc3VsdC5wb3NpdGlvbi5ib3R0b20gLSByZXN1bHQucG9zaXRpb24udG9wKTtcblxuXHRcdC8vIElmIGl0J3MgdGhlIGNlbnRlciBjb3JuZXIuLi5cblx0XHRpZihjb3JuZXIuYWJicmV2KCkgPT09ICdjJykge1xuXHRcdFx0cmVzdWx0LnBvc2l0aW9uID0ge1xuXHRcdFx0XHRsZWZ0OiByZXN1bHQucG9zaXRpb24ubGVmdCArIHJlc3VsdC53aWR0aCAvIDIsXG5cdFx0XHRcdHRvcDogcmVzdWx0LnBvc2l0aW9uLnRvcCArIHJlc3VsdC5oZWlnaHQgLyAyXG5cdFx0XHR9O1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIFNlY29uZCBwYXNzLCB1c2UgYSBiaW5hcnkgc2VhcmNoIGFsZ29yaXRobSB0byBsb2NhdGUgbW9zdCBzdWl0YWJsZSBjb29yZGluYXRlXG5cdFx0XHR3aGlsZShuZXdXaWR0aCA+IDAgJiYgbmV3SGVpZ2h0ID4gMCAmJiBjb21wYXJlWCA+IDAgJiYgY29tcGFyZVkgPiAwKVxuXHRcdFx0e1xuXHRcdFx0XHRuZXdXaWR0aCA9IE1hdGguZmxvb3IobmV3V2lkdGggLyAyKTtcblx0XHRcdFx0bmV3SGVpZ2h0ID0gTWF0aC5mbG9vcihuZXdIZWlnaHQgLyAyKTtcblxuXHRcdFx0XHRpZihjb3JuZXIueCA9PT0gTEVGVCl7IGNvbXBhcmVYID0gbmV3V2lkdGg7IH1cblx0XHRcdFx0ZWxzZSBpZihjb3JuZXIueCA9PT0gUklHSFQpeyBjb21wYXJlWCA9IHJlc3VsdC53aWR0aCAtIG5ld1dpZHRoOyB9XG5cdFx0XHRcdGVsc2V7IGNvbXBhcmVYICs9IE1hdGguZmxvb3IobmV3V2lkdGggLyAyKTsgfVxuXG5cdFx0XHRcdGlmKGNvcm5lci55ID09PSBUT1ApeyBjb21wYXJlWSA9IG5ld0hlaWdodDsgfVxuXHRcdFx0XHRlbHNlIGlmKGNvcm5lci55ID09PSBCT1RUT00peyBjb21wYXJlWSA9IHJlc3VsdC5oZWlnaHQgLSBuZXdIZWlnaHQ7IH1cblx0XHRcdFx0ZWxzZXsgY29tcGFyZVkgKz0gTWF0aC5mbG9vcihuZXdIZWlnaHQgLyAyKTsgfVxuXG5cdFx0XHRcdGkgPSBjb29yZHMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZShpLS0pXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZihjb29yZHMubGVuZ3RoIDwgMil7IGJyZWFrOyB9XG5cblx0XHRcdFx0XHRyZWFsWCA9IGNvb3Jkc1tpXVswXSAtIHJlc3VsdC5wb3NpdGlvbi5sZWZ0O1xuXHRcdFx0XHRcdHJlYWxZID0gY29vcmRzW2ldWzFdIC0gcmVzdWx0LnBvc2l0aW9uLnRvcDtcblxuXHRcdFx0XHRcdGlmKFxuXHRcdFx0XHRcdFx0Y29ybmVyLnggPT09IExFRlQgJiYgcmVhbFggPj0gY29tcGFyZVggfHxcblx0XHRcdFx0XHRcdGNvcm5lci54ID09PSBSSUdIVCAmJiByZWFsWCA8PSBjb21wYXJlWCB8fFxuXHRcdFx0XHRcdFx0Y29ybmVyLnggPT09IENFTlRFUiAmJiAocmVhbFggPCBjb21wYXJlWCB8fCByZWFsWCA+IHJlc3VsdC53aWR0aCAtIGNvbXBhcmVYKSB8fFxuXHRcdFx0XHRcdFx0Y29ybmVyLnkgPT09IFRPUCAmJiByZWFsWSA+PSBjb21wYXJlWSB8fFxuXHRcdFx0XHRcdFx0Y29ybmVyLnkgPT09IEJPVFRPTSAmJiByZWFsWSA8PSBjb21wYXJlWSB8fFxuXHRcdFx0XHRcdFx0Y29ybmVyLnkgPT09IENFTlRFUiAmJiAocmVhbFkgPCBjb21wYXJlWSB8fCByZWFsWSA+IHJlc3VsdC5oZWlnaHQgLSBjb21wYXJlWSkpIHtcblx0XHRcdFx0XHRcdGNvb3Jkcy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXN1bHQucG9zaXRpb24gPSB7IGxlZnQ6IGNvb3Jkc1swXVswXSwgdG9wOiBjb29yZHNbMF1bMV0gfTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdHJlY3Q6IGZ1bmN0aW9uKGF4LCBheSwgYngsIGJ5KSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHdpZHRoOiBNYXRoLmFicyhieCAtIGF4KSxcblx0XHRcdGhlaWdodDogTWF0aC5hYnMoYnkgLSBheSksXG5cdFx0XHRwb3NpdGlvbjoge1xuXHRcdFx0XHRsZWZ0OiBNYXRoLm1pbihheCwgYngpLFxuXHRcdFx0XHR0b3A6IE1hdGgubWluKGF5LCBieSlcblx0XHRcdH1cblx0XHR9O1xuXHR9LFxuXG5cdF9hbmdsZXM6IHtcblx0XHR0YzogMyAvIDIsIHRyOiA3IC8gNCwgdGw6IDUgLyA0LFxuXHRcdGJjOiAxIC8gMiwgYnI6IDEgLyA0LCBibDogMyAvIDQsXG5cdFx0cmM6IDIsIGxjOiAxLCBjOiAwXG5cdH0sXG5cdGVsbGlwc2U6IGZ1bmN0aW9uKGN4LCBjeSwgcngsIHJ5LCBjb3JuZXIpIHtcblx0XHR2YXIgYyA9IFBMVUdJTlMucG9seXMuX2FuZ2xlc1sgY29ybmVyLmFiYnJldigpIF0sXG5cdFx0XHRyeGMgPSBjID09PSAwID8gMCA6IHJ4ICogTWF0aC5jb3MoIGMgKiBNYXRoLlBJICksXG5cdFx0XHRyeXMgPSByeSAqIE1hdGguc2luKCBjICogTWF0aC5QSSApO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHdpZHRoOiByeCAqIDIgLSBNYXRoLmFicyhyeGMpLFxuXHRcdFx0aGVpZ2h0OiByeSAqIDIgLSBNYXRoLmFicyhyeXMpLFxuXHRcdFx0cG9zaXRpb246IHtcblx0XHRcdFx0bGVmdDogY3ggKyByeGMsXG5cdFx0XHRcdHRvcDogY3kgKyByeXNcblx0XHRcdH0sXG5cdFx0XHRhZGp1c3RhYmxlOiBGQUxTRVxuXHRcdH07XG5cdH0sXG5cdGNpcmNsZTogZnVuY3Rpb24oY3gsIGN5LCByLCBjb3JuZXIpIHtcblx0XHRyZXR1cm4gUExVR0lOUy5wb2x5cy5lbGxpcHNlKGN4LCBjeSwgciwgciwgY29ybmVyKTtcblx0fVxufTtcbjtQTFVHSU5TLnN2ZyA9IGZ1bmN0aW9uKGFwaSwgc3ZnLCBjb3JuZXIpXG57XG5cdHZhciBlbGVtID0gc3ZnWzBdLFxuXHRcdHJvb3QgPSAkKGVsZW0ub3duZXJTVkdFbGVtZW50KSxcblx0XHRvd25lckRvY3VtZW50ID0gZWxlbS5vd25lckRvY3VtZW50LFxuXHRcdHN0cm9rZVdpZHRoMiA9IChwYXJzZUludChzdmcuY3NzKCdzdHJva2Utd2lkdGgnKSwgMTApIHx8IDApIC8gMixcblx0XHRmcmFtZU9mZnNldCwgbXR4LCB0cmFuc2Zvcm1lZCxcblx0XHRsZW4sIG5leHQsIGksIHBvaW50cyxcblx0XHRyZXN1bHQsIHBvc2l0aW9uO1xuXG5cdC8vIEFzY2VuZCB0aGUgcGFyZW50Tm9kZSBjaGFpbiB1bnRpbCB3ZSBmaW5kIGFuIGVsZW1lbnQgd2l0aCBnZXRCQm94KClcblx0d2hpbGUoIWVsZW0uZ2V0QkJveCkgeyBlbGVtID0gZWxlbS5wYXJlbnROb2RlOyB9XG5cdGlmKCFlbGVtLmdldEJCb3ggfHwgIWVsZW0ucGFyZW50Tm9kZSkgeyByZXR1cm4gRkFMU0U7IH1cblxuXHQvLyBEZXRlcm1pbmUgd2hpY2ggc2hhcGUgY2FsY3VsYXRpb24gdG8gdXNlXG5cdHN3aXRjaChlbGVtLm5vZGVOYW1lKSB7XG5cdFx0Y2FzZSAnZWxsaXBzZSc6XG5cdFx0Y2FzZSAnY2lyY2xlJzpcblx0XHRcdHJlc3VsdCA9IFBMVUdJTlMucG9seXMuZWxsaXBzZShcblx0XHRcdFx0ZWxlbS5jeC5iYXNlVmFsLnZhbHVlLFxuXHRcdFx0XHRlbGVtLmN5LmJhc2VWYWwudmFsdWUsXG5cdFx0XHRcdChlbGVtLnJ4IHx8IGVsZW0ucikuYmFzZVZhbC52YWx1ZSArIHN0cm9rZVdpZHRoMixcblx0XHRcdFx0KGVsZW0ucnkgfHwgZWxlbS5yKS5iYXNlVmFsLnZhbHVlICsgc3Ryb2tlV2lkdGgyLFxuXHRcdFx0XHRjb3JuZXJcblx0XHRcdCk7XG5cdFx0YnJlYWs7XG5cblx0XHRjYXNlICdsaW5lJzpcblx0XHRjYXNlICdwb2x5Z29uJzpcblx0XHRjYXNlICdwb2x5bGluZSc6XG5cdFx0XHQvLyBEZXRlcm1pbmUgcG9pbnRzIG9iamVjdCAobGluZSBoYXMgbm9uZSwgc28gbWltaWMgdXNpbmcgYXJyYXkpXG5cdFx0XHRwb2ludHMgPSBlbGVtLnBvaW50cyB8fCBbXG5cdFx0XHRcdHsgeDogZWxlbS54MS5iYXNlVmFsLnZhbHVlLCB5OiBlbGVtLnkxLmJhc2VWYWwudmFsdWUgfSxcblx0XHRcdFx0eyB4OiBlbGVtLngyLmJhc2VWYWwudmFsdWUsIHk6IGVsZW0ueTIuYmFzZVZhbC52YWx1ZSB9XG5cdFx0XHRdO1xuXG5cdFx0XHRmb3IocmVzdWx0ID0gW10sIGkgPSAtMSwgbGVuID0gcG9pbnRzLm51bWJlck9mSXRlbXMgfHwgcG9pbnRzLmxlbmd0aDsgKytpIDwgbGVuOykge1xuXHRcdFx0XHRuZXh0ID0gcG9pbnRzLmdldEl0ZW0gPyBwb2ludHMuZ2V0SXRlbShpKSA6IHBvaW50c1tpXTtcblx0XHRcdFx0cmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBbbmV4dC54LCBuZXh0LnldKTtcblx0XHRcdH1cblxuXHRcdFx0cmVzdWx0ID0gUExVR0lOUy5wb2x5cy5wb2x5Z29uKHJlc3VsdCwgY29ybmVyKTtcblx0XHRicmVhaztcblxuXHRcdC8vIFVua25vd24gc2hhcGUgb3IgcmVjdGFuZ2xlPyBVc2UgYm91bmRpbmcgYm94XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJlc3VsdCA9IGVsZW0uZ2V0QkJveCgpO1xuXHRcdFx0cmVzdWx0ID0ge1xuXHRcdFx0XHR3aWR0aDogcmVzdWx0LndpZHRoLFxuXHRcdFx0XHRoZWlnaHQ6IHJlc3VsdC5oZWlnaHQsXG5cdFx0XHRcdHBvc2l0aW9uOiB7XG5cdFx0XHRcdFx0bGVmdDogcmVzdWx0LngsXG5cdFx0XHRcdFx0dG9wOiByZXN1bHQueVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdGJyZWFrO1xuXHR9XG5cblx0Ly8gU2hvcnRjdXQgYXNzaWdubWVudHNcblx0cG9zaXRpb24gPSByZXN1bHQucG9zaXRpb247XG5cdHJvb3QgPSByb290WzBdO1xuXG5cdC8vIENvbnZlcnQgcG9zaXRpb24gaW50byBhIHBpeGVsIHZhbHVlXG5cdGlmKHJvb3QuY3JlYXRlU1ZHUG9pbnQpIHtcblx0XHRtdHggPSBlbGVtLmdldFNjcmVlbkNUTSgpO1xuXHRcdHBvaW50cyA9IHJvb3QuY3JlYXRlU1ZHUG9pbnQoKTtcblxuXHRcdHBvaW50cy54ID0gcG9zaXRpb24ubGVmdDtcblx0XHRwb2ludHMueSA9IHBvc2l0aW9uLnRvcDtcblx0XHR0cmFuc2Zvcm1lZCA9IHBvaW50cy5tYXRyaXhUcmFuc2Zvcm0oIG10eCApO1xuXHRcdHBvc2l0aW9uLmxlZnQgPSB0cmFuc2Zvcm1lZC54O1xuXHRcdHBvc2l0aW9uLnRvcCA9IHRyYW5zZm9ybWVkLnk7XG5cdH1cblxuXHQvLyBDaGVjayB0aGUgZWxlbWVudCBpcyBub3QgaW4gYSBjaGlsZCBkb2N1bWVudCwgYW5kIGlmIHNvLCBhZGp1c3QgZm9yIGZyYW1lIGVsZW1lbnRzIG9mZnNldFxuXHRpZihvd25lckRvY3VtZW50ICE9PSBkb2N1bWVudCAmJiBhcGkucG9zaXRpb24udGFyZ2V0ICE9PSAnbW91c2UnKSB7XG5cdFx0ZnJhbWVPZmZzZXQgPSAkKChvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IG93bmVyRG9jdW1lbnQucGFyZW50V2luZG93KS5mcmFtZUVsZW1lbnQpLm9mZnNldCgpO1xuXHRcdGlmKGZyYW1lT2Zmc2V0KSB7XG5cdFx0XHRwb3NpdGlvbi5sZWZ0ICs9IGZyYW1lT2Zmc2V0LmxlZnQ7XG5cdFx0XHRwb3NpdGlvbi50b3AgKz0gZnJhbWVPZmZzZXQudG9wO1xuXHRcdH1cblx0fVxuXG5cdC8vIEFkanVzdCBieSBzY3JvbGwgb2Zmc2V0IG9mIG93bmVyIGRvY3VtZW50XG5cdG93bmVyRG9jdW1lbnQgPSAkKG93bmVyRG9jdW1lbnQpO1xuXHRwb3NpdGlvbi5sZWZ0ICs9IG93bmVyRG9jdW1lbnQuc2Nyb2xsTGVmdCgpO1xuXHRwb3NpdGlvbi50b3AgKz0gb3duZXJEb2N1bWVudC5zY3JvbGxUb3AoKTtcblxuXHRyZXR1cm4gcmVzdWx0O1xufTtcbjtQTFVHSU5TLmltYWdlbWFwID0gZnVuY3Rpb24oYXBpLCBhcmVhLCBjb3JuZXIpXG57XG5cdGlmKCFhcmVhLmpxdWVyeSkgeyBhcmVhID0gJChhcmVhKTsgfVxuXG5cdHZhciBzaGFwZSA9IChhcmVhLmF0dHIoJ3NoYXBlJykgfHwgJ3JlY3QnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ3BvbHknLCAncG9seWdvbicpLFxuXHRcdGltYWdlID0gJCgnaW1nW3VzZW1hcD1cIiMnK2FyZWEucGFyZW50KCdtYXAnKS5hdHRyKCduYW1lJykrJ1wiXScpLFxuXHRcdGNvb3Jkc1N0cmluZyA9ICQudHJpbShhcmVhLmF0dHIoJ2Nvb3JkcycpKSxcblx0XHRjb29yZHNBcnJheSA9IGNvb3Jkc1N0cmluZy5yZXBsYWNlKC8sJC8sICcnKS5zcGxpdCgnLCcpLFxuXHRcdGltYWdlT2Zmc2V0LCBjb29yZHMsIGksIHJlc3VsdCwgbGVuO1xuXG5cdC8vIElmIHdlIGNhbid0IGZpbmQgdGhlIGltYWdlIHVzaW5nIHRoZSBtYXAuLi5cblx0aWYoIWltYWdlLmxlbmd0aCkgeyByZXR1cm4gRkFMU0U7IH1cblxuXHQvLyBQYXNzIGNvb3JkaW5hdGVzIHN0cmluZyBpZiBwb2x5Z29uXG5cdGlmKHNoYXBlID09PSAncG9seWdvbicpIHtcblx0XHRyZXN1bHQgPSBQTFVHSU5TLnBvbHlzLnBvbHlnb24oY29vcmRzQXJyYXksIGNvcm5lcik7XG5cdH1cblxuXHQvLyBPdGhlcndpc2UgcGFyc2UgdGhlIGNvb3JkaW5hdGVzIGFuZCBwYXNzIHRoZW0gYXMgYXJndW1lbnRzXG5cdGVsc2UgaWYoUExVR0lOUy5wb2x5c1tzaGFwZV0pIHtcblx0XHRmb3IoaSA9IC0xLCBsZW4gPSBjb29yZHNBcnJheS5sZW5ndGgsIGNvb3JkcyA9IFtdOyArK2kgPCBsZW47KSB7XG5cdFx0XHRjb29yZHMucHVzaCggcGFyc2VJbnQoY29vcmRzQXJyYXlbaV0sIDEwKSApO1xuXHRcdH1cblxuXHRcdHJlc3VsdCA9IFBMVUdJTlMucG9seXNbc2hhcGVdLmFwcGx5KFxuXHRcdFx0dGhpcywgY29vcmRzLmNvbmNhdChjb3JuZXIpXG5cdFx0KTtcblx0fVxuXG5cdC8vIElmIG5vIHNoYXByZSBjYWxjdWxhdGlvbiBtZXRob2Qgd2FzIGZvdW5kLCByZXR1cm4gZmFsc2Vcblx0ZWxzZSB7IHJldHVybiBGQUxTRTsgfVxuXG5cdC8vIE1ha2Ugc3VyZSB3ZSBhY2NvdW50IGZvciBwYWRkaW5nIGFuZCBib3JkZXJzIG9uIHRoZSBpbWFnZVxuXHRpbWFnZU9mZnNldCA9IGltYWdlLm9mZnNldCgpO1xuXHRpbWFnZU9mZnNldC5sZWZ0ICs9IE1hdGguY2VpbCgoaW1hZ2Uub3V0ZXJXaWR0aChGQUxTRSkgLSBpbWFnZS53aWR0aCgpKSAvIDIpO1xuXHRpbWFnZU9mZnNldC50b3AgKz0gTWF0aC5jZWlsKChpbWFnZS5vdXRlckhlaWdodChGQUxTRSkgLSBpbWFnZS5oZWlnaHQoKSkgLyAyKTtcblxuXHQvLyBBZGQgaW1hZ2UgcG9zaXRpb24gdG8gb2Zmc2V0IGNvb3JkaW5hdGVzXG5cdHJlc3VsdC5wb3NpdGlvbi5sZWZ0ICs9IGltYWdlT2Zmc2V0LmxlZnQ7XG5cdHJlc3VsdC5wb3NpdGlvbi50b3AgKz0gaW1hZ2VPZmZzZXQudG9wO1xuXG5cdHJldHVybiByZXN1bHQ7XG59O1xuO3ZhciBJRTYsXG5cbi8qXG4gKiBCR0lGcmFtZSBhZGFwdGlvbiAoaHR0cDovL3BsdWdpbnMuanF1ZXJ5LmNvbS9wcm9qZWN0L2JnaWZyYW1lKVxuICogU3BlY2lhbCB0aGFua3MgdG8gQnJhbmRvbiBBYXJvblxuICovXG5CR0lGUkFNRSA9ICc8aWZyYW1lIGNsYXNzPVwicXRpcC1iZ2lmcmFtZVwiIGZyYW1lYm9yZGVyPVwiMFwiIHRhYmluZGV4PVwiLTFcIiBzcmM9XCJqYXZhc2NyaXB0OlxcJ1xcJztcIiAnICtcblx0JyBzdHlsZT1cImRpc3BsYXk6YmxvY2s7IHBvc2l0aW9uOmFic29sdXRlOyB6LWluZGV4Oi0xOyBmaWx0ZXI6YWxwaGEob3BhY2l0eT0wKTsgJyArXG5cdFx0Jy1tcy1maWx0ZXI6XCJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQWxwaGEoT3BhY2l0eT0wKVwiO1wiPjwvaWZyYW1lPic7XG5cbmZ1bmN0aW9uIEllNihhcGkpIHtcblx0dGhpcy5fbnMgPSAnaWU2JztcblxuXHR0aGlzLnF0aXAgPSBhcGk7XG5cdHRoaXMuaW5pdChhcGkpO1xufVxuXG4kLmV4dGVuZChJZTYucHJvdG90eXBlLCB7XG5cdF9zY3JvbGwgOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb3ZlcmxheSA9IHRoaXMucXRpcC5lbGVtZW50cy5vdmVybGF5O1xuXHRcdG92ZXJsYXkgJiYgKG92ZXJsYXlbMF0uc3R5bGUudG9wID0gJCh3aW5kb3cpLnNjcm9sbFRvcCgpICsgJ3B4Jyk7XG5cdH0sXG5cblx0aW5pdDogZnVuY3Rpb24ocXRpcCkge1xuXHRcdHZhciB0b29sdGlwID0gcXRpcC50b29sdGlwO1xuXG5cdFx0Ly8gQ3JlYXRlIHRoZSBCR0lGcmFtZSBlbGVtZW50IGlmIG5lZWRlZFxuXHRcdGlmKCQoJ3NlbGVjdCwgb2JqZWN0JykubGVuZ3RoIDwgMSkge1xuXHRcdFx0dGhpcy5iZ2lmcmFtZSA9IHF0aXAuZWxlbWVudHMuYmdpZnJhbWUgPSAkKEJHSUZSQU1FKS5hcHBlbmRUbyh0b29sdGlwKTtcblxuXHRcdFx0Ly8gVXBkYXRlIEJHSUZyYW1lIG9uIHRvb2x0aXAgbW92ZVxuXHRcdFx0cXRpcC5fYmluZCh0b29sdGlwLCAndG9vbHRpcG1vdmUnLCB0aGlzLmFkanVzdEJHSUZyYW1lLCB0aGlzLl9ucywgdGhpcyk7XG5cdFx0fVxuXG5cdFx0Ly8gcmVkcmF3KCkgY29udGFpbmVyIGZvciB3aWR0aC9oZWlnaHQgY2FsY3VsYXRpb25zXG5cdFx0dGhpcy5yZWRyYXdDb250YWluZXIgPSAkKCc8ZGl2Lz4nLCB7IGlkOiBOQU1FU1BBQ0UrJy1yY29udGFpbmVyJyB9KVxuXHRcdFx0LmFwcGVuZFRvKGRvY3VtZW50LmJvZHkpO1xuXG5cdFx0Ly8gRml4dXAgbW9kYWwgcGx1Z2luIGlmIHByZXNlbnQgdG9vXG5cdFx0aWYoIHF0aXAuZWxlbWVudHMub3ZlcmxheSAmJiBxdGlwLmVsZW1lbnRzLm92ZXJsYXkuYWRkQ2xhc3MoJ3F0aXBtb2RhbC1pZTZmaXgnKSApIHtcblx0XHRcdHF0aXAuX2JpbmQod2luZG93LCBbJ3Njcm9sbCcsICdyZXNpemUnXSwgdGhpcy5fc2Nyb2xsLCB0aGlzLl9ucywgdGhpcyk7XG5cdFx0XHRxdGlwLl9iaW5kKHRvb2x0aXAsIFsndG9vbHRpcHNob3cnXSwgdGhpcy5fc2Nyb2xsLCB0aGlzLl9ucywgdGhpcyk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IGRpbWVuc2lvbnNcblx0XHR0aGlzLnJlZHJhdygpO1xuXHR9LFxuXG5cdGFkanVzdEJHSUZyYW1lOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdG9vbHRpcCA9IHRoaXMucXRpcC50b29sdGlwLFxuXHRcdFx0ZGltZW5zaW9ucyA9IHtcblx0XHRcdFx0aGVpZ2h0OiB0b29sdGlwLm91dGVySGVpZ2h0KEZBTFNFKSxcblx0XHRcdFx0d2lkdGg6IHRvb2x0aXAub3V0ZXJXaWR0aChGQUxTRSlcblx0XHRcdH0sXG5cdFx0XHRwbHVnaW4gPSB0aGlzLnF0aXAucGx1Z2lucy50aXAsXG5cdFx0XHR0aXAgPSB0aGlzLnF0aXAuZWxlbWVudHMudGlwLFxuXHRcdFx0dGlwQWRqdXN0LCBvZmZzZXQ7XG5cblx0XHQvLyBBZGp1c3QgYm9yZGVyIG9mZnNldFxuXHRcdG9mZnNldCA9IHBhcnNlSW50KHRvb2x0aXAuY3NzKCdib3JkZXJMZWZ0V2lkdGgnKSwgMTApIHx8IDA7XG5cdFx0b2Zmc2V0ID0geyBsZWZ0OiAtb2Zmc2V0LCB0b3A6IC1vZmZzZXQgfTtcblxuXHRcdC8vIEFkanVzdCBmb3IgdGlwcyBwbHVnaW5cblx0XHRpZihwbHVnaW4gJiYgdGlwKSB7XG5cdFx0XHR0aXBBZGp1c3QgPSBwbHVnaW4uY29ybmVyLnByZWNlZGFuY2UgPT09ICd4JyA/IFtXSURUSCwgTEVGVF0gOiBbSEVJR0hULCBUT1BdO1xuXHRcdFx0b2Zmc2V0WyB0aXBBZGp1c3RbMV0gXSAtPSB0aXBbIHRpcEFkanVzdFswXSBdKCk7XG5cdFx0fVxuXG5cdFx0Ly8gVXBkYXRlIGJnaWZyYW1lXG5cdFx0dGhpcy5iZ2lmcmFtZS5jc3Mob2Zmc2V0KS5jc3MoZGltZW5zaW9ucyk7XG5cdH0sXG5cblx0Ly8gTWF4L21pbiB3aWR0aCBzaW11bGF0b3IgZnVuY3Rpb25cblx0cmVkcmF3OiBmdW5jdGlvbigpIHtcblx0XHRpZih0aGlzLnF0aXAucmVuZGVyZWQgPCAxIHx8IHRoaXMuZHJhd2luZykgeyByZXR1cm4gdGhpczsgfVxuXG5cdFx0dmFyIHRvb2x0aXAgPSB0aGlzLnF0aXAudG9vbHRpcCxcblx0XHRcdHN0eWxlID0gdGhpcy5xdGlwLm9wdGlvbnMuc3R5bGUsXG5cdFx0XHRjb250YWluZXIgPSB0aGlzLnF0aXAub3B0aW9ucy5wb3NpdGlvbi5jb250YWluZXIsXG5cdFx0XHRwZXJjLCB3aWR0aCwgbWF4LCBtaW47XG5cblx0XHQvLyBTZXQgZHJhd2luZyBmbGFnXG5cdFx0dGhpcy5xdGlwLmRyYXdpbmcgPSAxO1xuXG5cdFx0Ly8gSWYgdG9vbHRpcCBoYXMgYSBzZXQgaGVpZ2h0L3dpZHRoLCBqdXN0IHNldCBpdC4uLiBsaWtlIGEgYm9zcyFcblx0XHRpZihzdHlsZS5oZWlnaHQpIHsgdG9vbHRpcC5jc3MoSEVJR0hULCBzdHlsZS5oZWlnaHQpOyB9XG5cdFx0aWYoc3R5bGUud2lkdGgpIHsgdG9vbHRpcC5jc3MoV0lEVEgsIHN0eWxlLndpZHRoKTsgfVxuXG5cdFx0Ly8gU2ltdWxhdGUgbWF4L21pbiB3aWR0aCBpZiBub3Qgc2V0IHdpZHRoIHByZXNlbnQuLi5cblx0XHRlbHNlIHtcblx0XHRcdC8vIFJlc2V0IHdpZHRoIGFuZCBhZGQgZmx1aWQgY2xhc3Ncblx0XHRcdHRvb2x0aXAuY3NzKFdJRFRILCAnJykuYXBwZW5kVG8odGhpcy5yZWRyYXdDb250YWluZXIpO1xuXG5cdFx0XHQvLyBHcmFiIG91ciB0b29sdGlwIHdpZHRoIChhZGQgMSBpZiBvZGQgc28gd2UgZG9uJ3QgZ2V0IHdyYXBwaW5nIHByb2JsZW1zLi4gaHV6emFoISlcblx0XHRcdHdpZHRoID0gdG9vbHRpcC53aWR0aCgpO1xuXHRcdFx0aWYod2lkdGggJSAyIDwgMSkgeyB3aWR0aCArPSAxOyB9XG5cblx0XHRcdC8vIEdyYWIgb3VyIG1heC9taW4gcHJvcGVydGllc1xuXHRcdFx0bWF4ID0gdG9vbHRpcC5jc3MoJ21heFdpZHRoJykgfHwgJyc7XG5cdFx0XHRtaW4gPSB0b29sdGlwLmNzcygnbWluV2lkdGgnKSB8fCAnJztcblxuXHRcdFx0Ly8gUGFyc2UgaW50byBwcm9wZXIgcGl4ZWwgdmFsdWVzXG5cdFx0XHRwZXJjID0gKG1heCArIG1pbikuaW5kZXhPZignJScpID4gLTEgPyBjb250YWluZXIud2lkdGgoKSAvIDEwMCA6IDA7XG5cdFx0XHRtYXggPSAobWF4LmluZGV4T2YoJyUnKSA+IC0xID8gcGVyYyA6IDEgKiBwYXJzZUludChtYXgsIDEwKSkgfHwgd2lkdGg7XG5cdFx0XHRtaW4gPSAobWluLmluZGV4T2YoJyUnKSA+IC0xID8gcGVyYyA6IDEgKiBwYXJzZUludChtaW4sIDEwKSkgfHwgMDtcblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIG5ldyBkaW1lbnNpb24gc2l6ZSBiYXNlZCBvbiBtYXgvbWluL2N1cnJlbnQgdmFsdWVzXG5cdFx0XHR3aWR0aCA9IG1heCArIG1pbiA/IE1hdGgubWluKE1hdGgubWF4KHdpZHRoLCBtaW4pLCBtYXgpIDogd2lkdGg7XG5cblx0XHRcdC8vIFNldCB0aGUgbmV3bHkgY2FsY3VsYXRlZCB3aWR0aCBhbmQgcmVtdm9lIGZsdWlkIGNsYXNzXG5cdFx0XHR0b29sdGlwLmNzcyhXSURUSCwgTWF0aC5yb3VuZCh3aWR0aCkpLmFwcGVuZFRvKGNvbnRhaW5lcik7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IGRyYXdpbmcgZmxhZ1xuXHRcdHRoaXMuZHJhd2luZyA9IDA7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHQvLyBSZW1vdmUgaWZyYW1lXG5cdFx0dGhpcy5iZ2lmcmFtZSAmJiB0aGlzLmJnaWZyYW1lLnJlbW92ZSgpO1xuXG5cdFx0Ly8gUmVtb3ZlIGJvdW5kIGV2ZW50c1xuXHRcdHRoaXMucXRpcC5fdW5iaW5kKFt3aW5kb3csIHRoaXMucXRpcC50b29sdGlwXSwgdGhpcy5fbnMpO1xuXHR9XG59KTtcblxuSUU2ID0gUExVR0lOUy5pZTYgPSBmdW5jdGlvbihhcGkpIHtcblx0Ly8gUHJvY2VlZCBvbmx5IGlmIHRoZSBicm93c2VyIGlzIElFNlxuXHRyZXR1cm4gQlJPV1NFUi5pZSA9PT0gNiA/IG5ldyBJZTYoYXBpKSA6IEZBTFNFO1xufTtcblxuSUU2LmluaXRpYWxpemUgPSAncmVuZGVyJztcblxuQ0hFQ0tTLmllNiA9IHtcblx0J15jb250ZW50fHN0eWxlJCc6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucmVkcmF3KCk7XG5cdH1cbn07XG47fSkpO1xufSggd2luZG93LCBkb2N1bWVudCApKTtcbiIsIi8qIVxuKiBzY3JlZW5mdWxsXG4qIHY1LjAuMiAtIDIwMjAtMDItMTNcbiogKGMpIFNpbmRyZSBTb3JodXM7IE1JVCBMaWNlbnNlXG4qL1xuKGZ1bmN0aW9uICgpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBkb2N1bWVudCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gd2luZG93LmRvY3VtZW50IDoge307XG5cdHZhciBpc0NvbW1vbmpzID0gdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHM7XG5cblx0dmFyIGZuID0gKGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdmFsO1xuXG5cdFx0dmFyIGZuTWFwID0gW1xuXHRcdFx0W1xuXHRcdFx0XHQncmVxdWVzdEZ1bGxzY3JlZW4nLFxuXHRcdFx0XHQnZXhpdEZ1bGxzY3JlZW4nLFxuXHRcdFx0XHQnZnVsbHNjcmVlbkVsZW1lbnQnLFxuXHRcdFx0XHQnZnVsbHNjcmVlbkVuYWJsZWQnLFxuXHRcdFx0XHQnZnVsbHNjcmVlbmNoYW5nZScsXG5cdFx0XHRcdCdmdWxsc2NyZWVuZXJyb3InXG5cdFx0XHRdLFxuXHRcdFx0Ly8gTmV3IFdlYktpdFxuXHRcdFx0W1xuXHRcdFx0XHQnd2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4nLFxuXHRcdFx0XHQnd2Via2l0RXhpdEZ1bGxzY3JlZW4nLFxuXHRcdFx0XHQnd2Via2l0RnVsbHNjcmVlbkVsZW1lbnQnLFxuXHRcdFx0XHQnd2Via2l0RnVsbHNjcmVlbkVuYWJsZWQnLFxuXHRcdFx0XHQnd2Via2l0ZnVsbHNjcmVlbmNoYW5nZScsXG5cdFx0XHRcdCd3ZWJraXRmdWxsc2NyZWVuZXJyb3InXG5cblx0XHRcdF0sXG5cdFx0XHQvLyBPbGQgV2ViS2l0XG5cdFx0XHRbXG5cdFx0XHRcdCd3ZWJraXRSZXF1ZXN0RnVsbFNjcmVlbicsXG5cdFx0XHRcdCd3ZWJraXRDYW5jZWxGdWxsU2NyZWVuJyxcblx0XHRcdFx0J3dlYmtpdEN1cnJlbnRGdWxsU2NyZWVuRWxlbWVudCcsXG5cdFx0XHRcdCd3ZWJraXRDYW5jZWxGdWxsU2NyZWVuJyxcblx0XHRcdFx0J3dlYmtpdGZ1bGxzY3JlZW5jaGFuZ2UnLFxuXHRcdFx0XHQnd2Via2l0ZnVsbHNjcmVlbmVycm9yJ1xuXG5cdFx0XHRdLFxuXHRcdFx0W1xuXHRcdFx0XHQnbW96UmVxdWVzdEZ1bGxTY3JlZW4nLFxuXHRcdFx0XHQnbW96Q2FuY2VsRnVsbFNjcmVlbicsXG5cdFx0XHRcdCdtb3pGdWxsU2NyZWVuRWxlbWVudCcsXG5cdFx0XHRcdCdtb3pGdWxsU2NyZWVuRW5hYmxlZCcsXG5cdFx0XHRcdCdtb3pmdWxsc2NyZWVuY2hhbmdlJyxcblx0XHRcdFx0J21vemZ1bGxzY3JlZW5lcnJvcidcblx0XHRcdF0sXG5cdFx0XHRbXG5cdFx0XHRcdCdtc1JlcXVlc3RGdWxsc2NyZWVuJyxcblx0XHRcdFx0J21zRXhpdEZ1bGxzY3JlZW4nLFxuXHRcdFx0XHQnbXNGdWxsc2NyZWVuRWxlbWVudCcsXG5cdFx0XHRcdCdtc0Z1bGxzY3JlZW5FbmFibGVkJyxcblx0XHRcdFx0J01TRnVsbHNjcmVlbkNoYW5nZScsXG5cdFx0XHRcdCdNU0Z1bGxzY3JlZW5FcnJvcidcblx0XHRcdF1cblx0XHRdO1xuXG5cdFx0dmFyIGkgPSAwO1xuXHRcdHZhciBsID0gZm5NYXAubGVuZ3RoO1xuXHRcdHZhciByZXQgPSB7fTtcblxuXHRcdGZvciAoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YWwgPSBmbk1hcFtpXTtcblx0XHRcdGlmICh2YWwgJiYgdmFsWzFdIGluIGRvY3VtZW50KSB7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRyZXRbZm5NYXBbMF1baV1dID0gdmFsW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9KSgpO1xuXG5cdHZhciBldmVudE5hbWVNYXAgPSB7XG5cdFx0Y2hhbmdlOiBmbi5mdWxsc2NyZWVuY2hhbmdlLFxuXHRcdGVycm9yOiBmbi5mdWxsc2NyZWVuZXJyb3Jcblx0fTtcblxuXHR2YXIgc2NyZWVuZnVsbCA9IHtcblx0XHRyZXF1ZXN0OiBmdW5jdGlvbiAoZWxlbWVudCkge1xuXHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdFx0dmFyIG9uRnVsbFNjcmVlbkVudGVyZWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dGhpcy5vZmYoJ2NoYW5nZScsIG9uRnVsbFNjcmVlbkVudGVyZWQpO1xuXHRcdFx0XHRcdHJlc29sdmUoKTtcblx0XHRcdFx0fS5iaW5kKHRoaXMpO1xuXG5cdFx0XHRcdHRoaXMub24oJ2NoYW5nZScsIG9uRnVsbFNjcmVlbkVudGVyZWQpO1xuXG5cdFx0XHRcdGVsZW1lbnQgPSBlbGVtZW50IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXHRcdFx0XHR2YXIgcmV0dXJuUHJvbWlzZSA9IGVsZW1lbnRbZm4ucmVxdWVzdEZ1bGxzY3JlZW5dKCk7XG5cblx0XHRcdFx0aWYgKHJldHVyblByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG5cdFx0XHRcdFx0cmV0dXJuUHJvbWlzZS50aGVuKG9uRnVsbFNjcmVlbkVudGVyZWQpLmNhdGNoKHJlamVjdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0uYmluZCh0aGlzKSk7XG5cdFx0fSxcblx0XHRleGl0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdFx0XHRpZiAoIXRoaXMuaXNGdWxsc2NyZWVuKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZSgpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBvbkZ1bGxTY3JlZW5FeGl0ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHRoaXMub2ZmKCdjaGFuZ2UnLCBvbkZ1bGxTY3JlZW5FeGl0KTtcblx0XHRcdFx0XHRyZXNvbHZlKCk7XG5cdFx0XHRcdH0uYmluZCh0aGlzKTtcblxuXHRcdFx0XHR0aGlzLm9uKCdjaGFuZ2UnLCBvbkZ1bGxTY3JlZW5FeGl0KTtcblxuXHRcdFx0XHR2YXIgcmV0dXJuUHJvbWlzZSA9IGRvY3VtZW50W2ZuLmV4aXRGdWxsc2NyZWVuXSgpO1xuXG5cdFx0XHRcdGlmIChyZXR1cm5Qcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuXHRcdFx0XHRcdHJldHVyblByb21pc2UudGhlbihvbkZ1bGxTY3JlZW5FeGl0KS5jYXRjaChyZWplY3QpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LmJpbmQodGhpcykpO1xuXHRcdH0sXG5cdFx0dG9nZ2xlOiBmdW5jdGlvbiAoZWxlbWVudCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaXNGdWxsc2NyZWVuID8gdGhpcy5leGl0KCkgOiB0aGlzLnJlcXVlc3QoZWxlbWVudCk7XG5cdFx0fSxcblx0XHRvbmNoYW5nZTogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdFx0XHR0aGlzLm9uKCdjaGFuZ2UnLCBjYWxsYmFjayk7XG5cdFx0fSxcblx0XHRvbmVycm9yOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0XHRcdHRoaXMub24oJ2Vycm9yJywgY2FsbGJhY2spO1xuXHRcdH0sXG5cdFx0b246IGZ1bmN0aW9uIChldmVudCwgY2FsbGJhY2spIHtcblx0XHRcdHZhciBldmVudE5hbWUgPSBldmVudE5hbWVNYXBbZXZlbnRdO1xuXHRcdFx0aWYgKGV2ZW50TmFtZSkge1xuXHRcdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgY2FsbGJhY2ssIGZhbHNlKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdG9mZjogZnVuY3Rpb24gKGV2ZW50LCBjYWxsYmFjaykge1xuXHRcdFx0dmFyIGV2ZW50TmFtZSA9IGV2ZW50TmFtZU1hcFtldmVudF07XG5cdFx0XHRpZiAoZXZlbnROYW1lKSB7XG5cdFx0XHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBjYWxsYmFjaywgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0cmF3OiBmblxuXHR9O1xuXG5cdGlmICghZm4pIHtcblx0XHRpZiAoaXNDb21tb25qcykge1xuXHRcdFx0bW9kdWxlLmV4cG9ydHMgPSB7aXNFbmFibGVkOiBmYWxzZX07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHdpbmRvdy5zY3JlZW5mdWxsID0ge2lzRW5hYmxlZDogZmFsc2V9O1xuXHRcdH1cblxuXHRcdHJldHVybjtcblx0fVxuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHNjcmVlbmZ1bGwsIHtcblx0XHRpc0Z1bGxzY3JlZW46IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gQm9vbGVhbihkb2N1bWVudFtmbi5mdWxsc2NyZWVuRWxlbWVudF0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZWxlbWVudDoge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gZG9jdW1lbnRbZm4uZnVsbHNjcmVlbkVsZW1lbnRdO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0aXNFbmFibGVkOiB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdC8vIENvZXJjZSB0byBib29sZWFuIGluIGNhc2Ugb2Ygb2xkIFdlYktpdFxuXHRcdFx0XHRyZXR1cm4gQm9vbGVhbihkb2N1bWVudFtmbi5mdWxsc2NyZWVuRW5hYmxlZF0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0aWYgKGlzQ29tbW9uanMpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IHNjcmVlbmZ1bGw7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LnNjcmVlbmZ1bGwgPSBzY3JlZW5mdWxsO1xuXHR9XG59KSgpO1xuIiwiKGZ1bmN0aW9uKCkge1xuICB2YXIgY3J5cHQgPSByZXF1aXJlKCdjcnlwdCcpLFxuICAgICAgdXRmOCA9IHJlcXVpcmUoJ2NoYXJlbmMnKS51dGY4LFxuICAgICAgYmluID0gcmVxdWlyZSgnY2hhcmVuYycpLmJpbixcblxuICAvLyBUaGUgY29yZVxuICBzaGExID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAvLyBDb252ZXJ0IHRvIGJ5dGUgYXJyYXlcbiAgICBpZiAobWVzc2FnZS5jb25zdHJ1Y3RvciA9PSBTdHJpbmcpXG4gICAgICBtZXNzYWdlID0gdXRmOC5zdHJpbmdUb0J5dGVzKG1lc3NhZ2UpO1xuICAgIGVsc2UgaWYgKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBCdWZmZXIuaXNCdWZmZXIgPT0gJ2Z1bmN0aW9uJyAmJiBCdWZmZXIuaXNCdWZmZXIobWVzc2FnZSkpXG4gICAgICBtZXNzYWdlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobWVzc2FnZSwgMCk7XG4gICAgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZSkpXG4gICAgICBtZXNzYWdlID0gbWVzc2FnZS50b1N0cmluZygpO1xuXG4gICAgLy8gb3RoZXJ3aXNlIGFzc3VtZSBieXRlIGFycmF5XG5cbiAgICB2YXIgbSAgPSBjcnlwdC5ieXRlc1RvV29yZHMobWVzc2FnZSksXG4gICAgICAgIGwgID0gbWVzc2FnZS5sZW5ndGggKiA4LFxuICAgICAgICB3ICA9IFtdLFxuICAgICAgICBIMCA9ICAxNzMyNTg0MTkzLFxuICAgICAgICBIMSA9IC0yNzE3MzM4NzksXG4gICAgICAgIEgyID0gLTE3MzI1ODQxOTQsXG4gICAgICAgIEgzID0gIDI3MTczMzg3OCxcbiAgICAgICAgSDQgPSAtMTAwOTU4OTc3NjtcblxuICAgIC8vIFBhZGRpbmdcbiAgICBtW2wgPj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBsICUgMzIpO1xuICAgIG1bKChsICsgNjQgPj4+IDkpIDw8IDQpICsgMTVdID0gbDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbS5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICAgIHZhciBhID0gSDAsXG4gICAgICAgICAgYiA9IEgxLFxuICAgICAgICAgIGMgPSBIMixcbiAgICAgICAgICBkID0gSDMsXG4gICAgICAgICAgZSA9IEg0O1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDgwOyBqKyspIHtcblxuICAgICAgICBpZiAoaiA8IDE2KVxuICAgICAgICAgIHdbal0gPSBtW2kgKyBqXTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIG4gPSB3W2ogLSAzXSBeIHdbaiAtIDhdIF4gd1tqIC0gMTRdIF4gd1tqIC0gMTZdO1xuICAgICAgICAgIHdbal0gPSAobiA8PCAxKSB8IChuID4+PiAzMSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdCA9ICgoSDAgPDwgNSkgfCAoSDAgPj4+IDI3KSkgKyBINCArICh3W2pdID4+PiAwKSArIChcbiAgICAgICAgICAgICAgICBqIDwgMjAgPyAoSDEgJiBIMiB8IH5IMSAmIEgzKSArIDE1MTg1MDAyNDkgOlxuICAgICAgICAgICAgICAgIGogPCA0MCA/IChIMSBeIEgyIF4gSDMpICsgMTg1OTc3NTM5MyA6XG4gICAgICAgICAgICAgICAgaiA8IDYwID8gKEgxICYgSDIgfCBIMSAmIEgzIHwgSDIgJiBIMykgLSAxODk0MDA3NTg4IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAoSDEgXiBIMiBeIEgzKSAtIDg5OTQ5NzUxNCk7XG5cbiAgICAgICAgSDQgPSBIMztcbiAgICAgICAgSDMgPSBIMjtcbiAgICAgICAgSDIgPSAoSDEgPDwgMzApIHwgKEgxID4+PiAyKTtcbiAgICAgICAgSDEgPSBIMDtcbiAgICAgICAgSDAgPSB0O1xuICAgICAgfVxuXG4gICAgICBIMCArPSBhO1xuICAgICAgSDEgKz0gYjtcbiAgICAgIEgyICs9IGM7XG4gICAgICBIMyArPSBkO1xuICAgICAgSDQgKz0gZTtcbiAgICB9XG5cbiAgICByZXR1cm4gW0gwLCBIMSwgSDIsIEgzLCBINF07XG4gIH0sXG5cbiAgLy8gUHVibGljIEFQSVxuICBhcGkgPSBmdW5jdGlvbiAobWVzc2FnZSwgb3B0aW9ucykge1xuICAgIHZhciBkaWdlc3RieXRlcyA9IGNyeXB0LndvcmRzVG9CeXRlcyhzaGExKG1lc3NhZ2UpKTtcbiAgICByZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLmFzQnl0ZXMgPyBkaWdlc3RieXRlcyA6XG4gICAgICAgIG9wdGlvbnMgJiYgb3B0aW9ucy5hc1N0cmluZyA/IGJpbi5ieXRlc1RvU3RyaW5nKGRpZ2VzdGJ5dGVzKSA6XG4gICAgICAgIGNyeXB0LmJ5dGVzVG9IZXgoZGlnZXN0Ynl0ZXMpO1xuICB9O1xuXG4gIGFwaS5fYmxvY2tzaXplID0gMTY7XG4gIGFwaS5fZGlnZXN0c2l6ZSA9IDIwO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gYXBpO1xufSkoKTtcbiIsIid1c2Ugc3RyaWN0JztcblxubGV0IGZhc3RQcm90byA9IG51bGw7XG5cbi8vIENyZWF0ZXMgYW4gb2JqZWN0IHdpdGggcGVybWFuZW50bHkgZmFzdCBwcm9wZXJ0aWVzIGluIFY4LiBTZWUgVG9vbiBWZXJ3YWVzdCdzXG4vLyBwb3N0IGh0dHBzOi8vbWVkaXVtLmNvbS9AdHZlcndhZXMvc2V0dGluZy11cC1wcm90b3R5cGVzLWluLXY4LWVjOWM5NDkxZGZlMiM1ZjYyXG4vLyBmb3IgbW9yZSBkZXRhaWxzLiBVc2UgJUhhc0Zhc3RQcm9wZXJ0aWVzKG9iamVjdCkgYW5kIHRoZSBOb2RlLmpzIGZsYWdcbi8vIC0tYWxsb3ctbmF0aXZlcy1zeW50YXggdG8gY2hlY2sgd2hldGhlciBhbiBvYmplY3QgaGFzIGZhc3QgcHJvcGVydGllcy5cbmZ1bmN0aW9uIEZhc3RPYmplY3Qobykge1xuXHQvLyBBIHByb3RvdHlwZSBvYmplY3Qgd2lsbCBoYXZlIFwiZmFzdCBwcm9wZXJ0aWVzXCIgZW5hYmxlZCBvbmNlIGl0IGlzIGNoZWNrZWRcblx0Ly8gYWdhaW5zdCB0aGUgaW5saW5lIHByb3BlcnR5IGNhY2hlIG9mIGEgZnVuY3Rpb24sIGUuZy4gZmFzdFByb3RvLnByb3BlcnR5OlxuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vdjgvdjgvYmxvYi82LjAuMTIyL3Rlc3QvbWpzdW5pdC9mYXN0LXByb3RvdHlwZS5qcyNMNDgtTDYzXG5cdGlmIChmYXN0UHJvdG8gIT09IG51bGwgJiYgdHlwZW9mIGZhc3RQcm90by5wcm9wZXJ0eSkge1xuXHRcdGNvbnN0IHJlc3VsdCA9IGZhc3RQcm90bztcblx0XHRmYXN0UHJvdG8gPSBGYXN0T2JqZWN0LnByb3RvdHlwZSA9IG51bGw7XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXHRmYXN0UHJvdG8gPSBGYXN0T2JqZWN0LnByb3RvdHlwZSA9IG8gPT0gbnVsbCA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiBvO1xuXHRyZXR1cm4gbmV3IEZhc3RPYmplY3Q7XG59XG5cbi8vIEluaXRpYWxpemUgdGhlIGlubGluZSBwcm9wZXJ0eSBjYWNoZSBvZiBGYXN0T2JqZWN0XG5GYXN0T2JqZWN0KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdG9GYXN0cHJvcGVydGllcyhvKSB7XG5cdHJldHVybiBGYXN0T2JqZWN0KG8pO1xufTtcbiJdfQ==
